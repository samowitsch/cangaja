/**
 * @description
 *
 * CG is the base class of the cangaja framework.
 * This file includes a requestAnimationFrame polyfill. It uses the simple javascript inheritance from John Resig.
 @example
     //Class example, how to start from scratch with simple inheritance
     CG.Class.extend("Entity",{
            init: function(){
                this.myprop = 'set from constructor'
            }
         });

     CG.Entity.extend("Point",{
            init: function(x, y){
                this._super()
                this.x = x
                this.y = y
            }
         });

     CG.Point.extend("Rectangle",{
            init: function(x, y, w, h){
                this._super(x, y)
                this.w = w
                this.h = h
            },
            move: function(){

            }
     });
 * @module CG
 * @main CG
 */
var CG = CG || {
    VERSION: 1,

    //canvas if needed, remember director mode slide!
    canvas: {},
    ctx: {},

    //constants
    Const_PI_180: Math.PI / 180,
    Const_180_PI: 180 / Math.PI,
    LEFT: 1,
    RIGHT: 2,
    UP: 3,
    DOWN: 4,

    //input related
    mousedown: false,
    mouse: {x: 0, y: 0},
    //touch start
    start: {x: 0, y: 0},
    //touch end
    end: {x: 0, y: 0}
};

/**
 Extends a destination object with a source object (modifies destination object)

 @method CG._extend
 @param {Object} dest - destination object
 @param {Object} source - source object
 @return {Object} returns the dest object
 @for Cangaja
 */
CG._extend = function(dest,source) {
    if(!source) { return dest; }
    for (var prop in source) {
        dest[prop] = source[prop];
    }
    return dest;
};

/**
 Return a shallow copy of an object. Sub-objects (and sub-arrays) are not cloned. (uses extend internally)

 @method CG._clone
 @param {Object} obj - object to clone
 @return {Object} cloned object
 @for Cangaja
 */
CG._clone = function(obj) {
    return Q._extend({},obj);
};

// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

// requestAnimationFrame polyfill by Erik M??ller
// fixes from Paul Irish and Tino Zijdel

(function () {
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame']
            || window[vendors[x] + 'CancelRequestAnimationFrame'];
    }

    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function (callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function () {
                    callback(currTime + timeToCall);
                },
                timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };

    if (!window.cancelAnimationFrame)
        window.cancelAnimationFrame = function (id) {
            clearTimeout(id);
        };
}());


/* Simple JavaScript Inheritance
 * By John Resig http://ejohn.org/
 * MIT Licensed.
 *
 * Inspired by base2 and Prototype
 */
(function () {
    var initializing = false,
        fnTest = /xyz/.test(function () {
            var xyz;
        }) ? /\b_super\b/ : /.*/;
    /* The base Class implementation (does nothing) */
    CG.Class = function () {
    };

    // See if a object is a specific class
    CG.Class.prototype.isA = function (className) {
        return this.className === className;
    };

    /* Create a new Class that inherits from this class */
    CG.Class.extend = function (className, prop, classMethods) {
        /* No name, don't add onto CG */
        if (!typeof className === "string") {
            classMethods = prop;
            prop = className;
            className = null;
        }
        var _super = this.prototype,
            ThisClass = this;

        /* Instantiate a base class (but only create the instance, */
        /* don't run the init constructor) */
        initializing = true;
        var prototype = new ThisClass();
        initializing = false;

        function _superFactory(name, fn) {
            return function () {
                var tmp = this._super;

                /* Add a new ._super() method that is the same method */
                /* but on the super-class */
                this._super = _super[name];

                /* The method only need to be bound temporarily, so we */
                /* remove it when we're done executing */
                var ret = fn.apply(this, arguments);
                this._super = tmp;

                return ret;
            };
        }

        /* Copy the properties over onto the new prototype */
        for (var name in prop) {
            /* Check if we're overwriting an existing function */
            prototype[name] = typeof prop[name] === "function" &&
                typeof _super[name] === "function" &&
                fnTest.test(prop[name]) ?
                _superFactory(name, prop[name]) :
                prop[name];
        }

        /* The dummy class constructor */
        function Class() {
            /* All construction is actually done in the init method */
            if (!initializing && this.init) {
                this.init.apply(this, arguments);
            }
        }

        /* Populate our constructed prototype object */
        Class.prototype = prototype;

        /* Enforce the constructor to be what we expect */
        Class.prototype.constructor = Class;
        /* And make this class extendable */
        Class.extend = CG.Class.extend;

        /* If there are class-level Methods, add them to the class */
        if (classMethods) {
            CG._extend(Class, classMethods);
        }

        if (className) {
            /* Save the class onto CG */
            CG[className] = Class;

            /* Let the class know its name */
            Class.prototype.className = className;
            Class.className = className;
        }

        return Class;
    };
}())


/**
 * @description
 *
 * CG.Game - this class is the starting point for a cangaja game. The default object name of the instantiated object has to be 'Game'!
 * @class CG.Game
 * @extends Class
 */

CG.Class.extend('Game', {
    /**
     * @method init
     * @constructor
     * @param canvas
     * @param options
     */
    init: function (canvas, options) {
        /**
         @property canvas {object}
         */
        switch (typeof canvas) {
            case 'object':
                this.canvas = canvas
                break
            case 'string':
                this.canvas = document.getElementById(canvas)
                break
            default:
                throw 'no canvas element defined'
                break
        }
        /**
         @property ctx {Object}
         */
        this.ctx = this.canvas.getContext('2d')
        /**
         @property fps {Number}
         */
        this.fps = 60
        /**
         @property width {Number}
         */
        this.width = this.canvas.width
        /**
         @property height {Number}
         */
        this.height = this.canvas.height
        /**
         @property width2 {Number}
         */
        this.width2 = this.width / 2
        /**
         @property height2 {Number}
         */
        this.height2 = this.height / 2
        /**
         @property b_canvas {Object}
         */
        this.b_canvas = document.createElement('canvas')
        this.b_canvas.width = this.width
        this.b_canvas.height = this.height
        /**
         @property b_ctx {Object}
         */
        this.b_ctx = this.b_canvas.getContext('2d')
        /**
         @property asset {CG.MediaAsset}
         */
        this.asset = new CG.MediaAsset(this)
        /**
         @property director {CG.Director}
         */
        this.director = new CG.Director()
        /**
         @property renderer {CG.CanvasRenderer}
         */
        this.renderer = new CG.CanvasRenderer()
        /**
         @property delta {CG.Delta}
         */
        this.delta = new CG.Delta(this.fps)
        /**
         @property bound {CG.Bound}
         */
        this.bound = new CG.Bound({
            x: 0,
            y: 0,
            width: this.width,
            height: this.height
        })

        this.preload()
    },
    /**
     * @description child classes that extends CG.Game defines here all needed stuff to preload with CG.MediaAsset.
     * @method preload
     */
    preload: function () {
    },
    /**
     * @description child classes that extends CG.Game could use this method to create all needed stuff.
     * @method create
     */
    create: function () {
        this.loop()
    },
    /**
     * @description this is the central (game) loop
     * @method loop
     */
    loop: function () {
        requestAnimationFrame(this.loop.bind(this))
        this.beforeUpdate()
        this.update()
        this.beforeDraw()
        this.draw()
        this.afterDraw()
    },
    /**
     * @description in this method all CG.Director elements are updated.
     * @method beforeUpdate
     */
    beforeUpdate: function(){
        this.director.update()
    },
    /**
     * @method update
     */
    update: function () {
    },
    /**
     * @description in this method all CG.Director elements are rendered to the canvas. after that the draw method is executed and some custom drawing is possible.
     * @method beforeDraw
     */
    beforeDraw: function () {
        this.director.draw()
    },
    /**
     * @description
     * @method draw
     */
    draw: function () {

    },
    /**
     * @description this is the final draw method. it draws the b_canvas buffer to the canvas
     * @method afterDraw
     */
    afterDraw: function () {
        this.ctx.clearRect(0, 0, this.bound.width, this.bound.height)

        // draw buffer b_canvas to the canvas
        this.ctx.drawImage(this.b_canvas, 0, 0)

        // clear the b_canvas
        this.b_ctx.clearRect(0, 0, this.bound.width, this.bound.height)
    }
})// Last updated November 2011
// By Simon Sarris
// www.simonsarris.com
// sarris@acm.org
//
// Free to use and distribute at will
// So long as you are nice to people, etc

// Simple class for keeping track of the current transformation matrix

// For instance:
//    var t = new Transform();
//    t.rotate(5);
//    var m = t.m;
//    ctx.setTransform(m[0], m[1], m[2], m[3], m[4], m[5]);

// Is equivalent to:
//    ctx.rotate(5);

// But now you can retrieve it :)

// Remember that this does not account for any CSS transforms applied to the canvas

function Transform() {
  this.reset();
}

Transform.prototype.reset = function() {
  this.m = [1,0,0,1,0,0];
};

Transform.prototype.multiply = function(matrix) {
  var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1];
  var m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1];

  var m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3];
  var m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];

  var dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4];
  var dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];

  this.m[0] = m11;
  this.m[1] = m12;
  this.m[2] = m21;
  this.m[3] = m22;
  this.m[4] = dx;
  this.m[5] = dy;
};

Transform.prototype.invert = function() {
  var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
  var m0 = this.m[3] * d;
  var m1 = -this.m[1] * d;
  var m2 = -this.m[2] * d;
  var m3 = this.m[0] * d;
  var m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
  var m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
  this.m[0] = m0;
  this.m[1] = m1;
  this.m[2] = m2;
  this.m[3] = m3;
  this.m[4] = m4;
  this.m[5] = m5;
};

Transform.prototype.rotate = function(rad) {
  var c = Math.cos(rad);
  var s = Math.sin(rad);
  var m11 = this.m[0] * c + this.m[2] * s;
  var m12 = this.m[1] * c + this.m[3] * s;
  var m21 = this.m[0] * -s + this.m[2] * c;
  var m22 = this.m[1] * -s + this.m[3] * c;
  this.m[0] = m11;
  this.m[1] = m12;
  this.m[2] = m21;
  this.m[3] = m22;
};

Transform.prototype.translate = function(x, y) {
  this.m[4] += this.m[0] * x + this.m[2] * y;
  this.m[5] += this.m[1] * x + this.m[3] * y;
};

Transform.prototype.scale = function(sx, sy) {
  this.m[0] *= sx;
  this.m[1] *= sx;
  this.m[2] *= sy;
  this.m[3] *= sy;
};

Transform.prototype.transformPoint = function(px, py) {
  var x = px;
  var y = py;
  px = x * this.m[0] + y * this.m[2] + this.m[4];
  py = x * this.m[1] + y * this.m[3] + this.m[5];
  return [px, py];
};//     keymaster.js
//     (c) 2011-2012 Thomas Fuchs
//     keymaster.js may be freely distributed under the MIT license.

;(function(global){
  var k,
    _handlers = {},
    _mods = { 16: false, 18: false, 17: false, 91: false },
    _scope = 'all',
    // modifier keys
    _MODIFIERS = {
      '⇧': 16, shift: 16,
      '⌥': 18, alt: 18, option: 18,
      '⌃': 17, ctrl: 17, control: 17,
      '⌘': 91, command: 91
    },
    // special keys
    _MAP = {
      backspace: 8, tab: 9, clear: 12,
      enter: 13, 'return': 13,
      esc: 27, escape: 27, space: 32,
      left: 37, up: 38,
      right: 39, down: 40,
      del: 46, 'delete': 46,
      home: 36, end: 35,
      pageup: 33, pagedown: 34,
      ',': 188, '.': 190, '/': 191,
      '`': 192, '-': 189, '=': 187,
      ';': 186, '\'': 222,
      '[': 219, ']': 221, '\\': 220
    },
    code = function(x){
      return _MAP[x] || x.toUpperCase().charCodeAt(0);
    },
    _downKeys = [];

  for(k=1;k<20;k++) _MAP['f'+k] = 111+k;

  // IE doesn't support Array#indexOf, so have a simple replacement
  function index(array, item){
    var i = array.length;
    while(i--) if(array[i]===item) return i;
    return -1;
  }

  // for comparing mods before unassignment
  function compareArray(a1, a2) {
    if (a1.length != a2.length) return false;
    for (var i = 0; i < a1.length; i++) {
        if (a1[i] !== a2[i]) return false;
    }
    return true;
  }

  var modifierMap = {
      16:'shiftKey',
      18:'altKey',
      17:'ctrlKey',
      91:'metaKey'
  };
  function updateModifierKey(event) {
      for(k in _mods) _mods[k] = event[modifierMap[k]];
  };

  // handle keydown event
  function dispatch(event) {
    var key, handler, k, i, modifiersMatch, scope;
    key = event.keyCode;

    if (index(_downKeys, key) == -1) {
        _downKeys.push(key);
    }

    // if a modifier key, set the key.<modifierkeyname> property to true and return
    if(key == 93 || key == 224) key = 91; // right command on webkit, command on Gecko
    if(key in _mods) {
      _mods[key] = true;
      // 'assignKey' from inside this closure is exported to window.key
      for(k in _MODIFIERS) if(_MODIFIERS[k] == key) assignKey[k] = true;
      return;
    }
    updateModifierKey(event);

    // see if we need to ignore the keypress (filter() can can be overridden)
    // by default ignore key presses if a select, textarea, or input is focused
    if(!assignKey.filter.call(this, event)) return;

    // abort if no potentially matching shortcuts found
    if (!(key in _handlers)) return;

    scope = getScope();

    // for each potential shortcut
    for (i = 0; i < _handlers[key].length; i++) {
      handler = _handlers[key][i];

      // see if it's in the current scope
      if(handler.scope == scope || handler.scope == 'all'){
        // check if modifiers match if any
        modifiersMatch = handler.mods.length > 0;
        for(k in _mods)
          if((!_mods[k] && index(handler.mods, +k) > -1) ||
            (_mods[k] && index(handler.mods, +k) == -1)) modifiersMatch = false;
        // call the handler and stop the event if neccessary
        if((handler.mods.length == 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91]) || modifiersMatch){
          if(handler.method(event, handler)===false){
            if(event.preventDefault) event.preventDefault();
              else event.returnValue = false;
            if(event.stopPropagation) event.stopPropagation();
            if(event.cancelBubble) event.cancelBubble = true;
          }
        }
      }
    }
  };

  // unset modifier keys on keyup
  function clearModifier(event){
    var key = event.keyCode, k,
        i = index(_downKeys, key);

    // remove key from _downKeys
    if (i >= 0) {
        _downKeys.splice(i, 1);
    }

    if(key == 93 || key == 224) key = 91;
    if(key in _mods) {
      _mods[key] = false;
      for(k in _MODIFIERS) if(_MODIFIERS[k] == key) assignKey[k] = false;
    }
  };

  function resetModifiers() {
    for(k in _mods) _mods[k] = false;
    for(k in _MODIFIERS) assignKey[k] = false;
  };

  // parse and assign shortcut
  function assignKey(key, scope, method){
    var keys, mods;
    keys = getKeys(key);
    if (method === undefined) {
      method = scope;
      scope = 'all';
    }

    // for each shortcut
    for (var i = 0; i < keys.length; i++) {
      // set modifier keys if any
      mods = [];
      key = keys[i].split('+');
      if (key.length > 1){
        mods = getMods(key);
        key = [key[key.length-1]];
      }
      // convert to keycode and...
      key = key[0]
      key = code(key);
      // ...store handler
      if (!(key in _handlers)) _handlers[key] = [];
      _handlers[key].push({ shortcut: keys[i], scope: scope, method: method, key: keys[i], mods: mods });
    }
  };

  // unbind all handlers for given key in current scope
  function unbindKey(key, scope) {
    var multipleKeys, keys,
      mods = [],
      i, j, obj;

    multipleKeys = getKeys(key);

    for (j = 0; j < multipleKeys.length; j++) {
      keys = multipleKeys[j].split('+');

      if (keys.length > 1) {
        mods = getMods(keys);
        key = keys[keys.length - 1];
      }

      key = code(key);

      if (scope === undefined) {
        scope = getScope();
      }
      if (!_handlers[key]) {
        return;
      }
      for (i in _handlers[key]) {
        obj = _handlers[key][i];
        // only clear handlers if correct scope and mods match
        if (obj.scope === scope && compareArray(obj.mods, mods)) {
          _handlers[key][i] = {};
        }
      }
    }
  };

  // Returns true if the key with code 'keyCode' is currently down
  // Converts strings into key codes.
  function isPressed(keyCode) {
      if (typeof(keyCode)=='string') {
        keyCode = code(keyCode);
      }
      return index(_downKeys, keyCode) != -1;
  }

  function getPressedKeyCodes() {
      return _downKeys.slice(0);
  }

  function filter(event){
    var tagName = (event.target || event.srcElement).tagName;
    // ignore keypressed in any elements that support keyboard data input
    return !(tagName == 'INPUT' || tagName == 'SELECT' || tagName == 'TEXTAREA');
  }

  // initialize key.<modifier> to false
  for(k in _MODIFIERS) assignKey[k] = false;

  // set current scope (default 'all')
  function setScope(scope){ _scope = scope || 'all' };
  function getScope(){ return _scope || 'all' };

  // delete all handlers for a given scope
  function deleteScope(scope){
    var key, handlers, i;

    for (key in _handlers) {
      handlers = _handlers[key];
      for (i = 0; i < handlers.length; ) {
        if (handlers[i].scope === scope) handlers.splice(i, 1);
        else i++;
      }
    }
  };

  // abstract key logic for assign and unassign
  function getKeys(key) {
    var keys;
    key = key.replace(/\s/g, '');
    keys = key.split(',');
    if ((keys[keys.length - 1]) == '') {
      keys[keys.length - 2] += ',';
    }
    return keys;
  }

  // abstract mods logic for assign and unassign
  function getMods(key) {
    var mods = key.slice(0, key.length - 1);
    for (var mi = 0; mi < mods.length; mi++)
    mods[mi] = _MODIFIERS[mods[mi]];
    return mods;
  }

  // cross-browser events
  function addEvent(object, event, method) {
    if (object.addEventListener)
      object.addEventListener(event, method, false);
    else if(object.attachEvent)
      object.attachEvent('on'+event, function(){ method(window.event) });
  };

  // set the handlers globally on document
  addEvent(document, 'keydown', function(event) { dispatch(event) }); // Passing _scope to a callback to ensure it remains the same by execution. Fixes #48
  addEvent(document, 'keyup', clearModifier);

  // reset modifiers to false whenever the window is (re)focused.
  addEvent(window, 'focus', resetModifiers);

  // store previously defined key
  var previousKey = global.key;

  // restore previously defined key and return reference to our key object
  function noConflict() {
    var k = global.key;
    global.key = previousKey;
    return k;
  }

  // set window.key and window.key.set/get/deleteScope, and the default filter
  global.key = assignKey;
  global.key.setScope = setScope;
  global.key.getScope = getScope;
  global.key.deleteScope = deleteScope;
  global.key.filter = filter;
  global.key.isPressed = isPressed;
  global.key.getPressedKeyCodes = getPressedKeyCodes;
  global.key.noConflict = noConflict;
  global.key.unbind = unbindKey;

  if(typeof module !== 'undefined') module.exports = key;

})(this);
!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.poly2tri=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
module.exports={"version": "1.3.3"}
},{}],2:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2013, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2013, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint maxcomplexity:11 */

"use strict";


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */


// -------------------------------------------------------------------------Node

/**
 * Advancing front node
 * @param {Point} p any "Point like" object with {x,y} (duck typing)
 * @param {Triangle} t triangle (optionnal)
 */
var Node = function(p, t) {
    this.point = p;
    this.triangle = t || null;

    this.next = null; // Node
    this.prev = null; // Node

    this.value = p.x;
};

// ---------------------------------------------------------------AdvancingFront
var AdvancingFront = function(head, tail) {
    this.head_ = head; // Node
    this.tail_ = tail; // Node
    this.search_node_ = head; // Node
};

AdvancingFront.prototype.head = function() {
    return this.head_;
};

AdvancingFront.prototype.setHead = function(node) {
    this.head_ = node;
};

AdvancingFront.prototype.tail = function() {
    return this.tail_;
};

AdvancingFront.prototype.setTail = function(node) {
    this.tail_ = node;
};

AdvancingFront.prototype.search = function() {
    return this.search_node_;
};

AdvancingFront.prototype.setSearch = function(node) {
    this.search_node_ = node;
};

AdvancingFront.prototype.findSearchNode = function(/*x*/) {
    // TODO: implement BST index
    return this.search_node_;
};

AdvancingFront.prototype.locateNode = function(x) {
    var node = this.search_node_;

    /* jshint boss:true */
    if (x < node.value) {
        while (node = node.prev) {
            if (x >= node.value) {
                this.search_node_ = node;
                return node;
            }
        }
    } else {
        while (node = node.next) {
            if (x < node.value) {
                this.search_node_ = node.prev;
                return node.prev;
            }
        }
    }
    return null;
};

AdvancingFront.prototype.locatePoint = function(point) {
    var px = point.x;
    var node = this.findSearchNode(px);
    var nx = node.point.x;

    if (px === nx) {
        // Here we are comparing point references, not values
        if (point !== node.point) {
            // We might have two nodes with same x value for a short time
            if (point === node.prev.point) {
                node = node.prev;
            } else if (point === node.next.point) {
                node = node.next;
            } else {
                throw new Error('poly2tri Invalid AdvancingFront.locatePoint() call');
            }
        }
    } else if (px < nx) {
        /* jshint boss:true */
        while (node = node.prev) {
            if (point === node.point) {
                break;
            }
        }
    } else {
        while (node = node.next) {
            if (point === node.point) {
                break;
            }
        }
    }

    if (node) {
        this.search_node_ = node;
    }
    return node;
};


// ----------------------------------------------------------------------Exports

module.exports = AdvancingFront;
module.exports.Node = Node;


},{}],3:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2013, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2013, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var xy = _dereq_('./xy');

// ------------------------------------------------------------------------Point
/**
 * Construct a point
 * @param {Number} x    coordinate (0 if undefined)
 * @param {Number} y    coordinate (0 if undefined)
 */
var Point = function(x, y) {
    this.x = +x || 0;
    this.y = +y || 0;

    // All extra fields added to Point are prefixed with _p2t_
    // to avoid collisions if custom Point class is used.

    // The edges this point constitutes an upper ending point
    this._p2t_edge_list = null;
};

/**
 * For pretty printing ex. <i>"(5;42)"</i>)
 */
Point.prototype.toString = function() {
    return xy.toStringBase(this);
};

/**
 * Creates a copy of this Point object.
 * @returns Point
 */
Point.prototype.clone = function() {
    return new Point(this.x, this.y);
};

/**
 * Set this Point instance to the origo. <code>(0; 0)</code>
 */
Point.prototype.set_zero = function() {
    this.x = 0.0;
    this.y = 0.0;
    return this; // for chaining
};

/**
 * Set the coordinates of this instance.
 * @param   x   number.
 * @param   y   number;
 */
Point.prototype.set = function(x, y) {
    this.x = +x || 0;
    this.y = +y || 0;
    return this; // for chaining
};

/**
 * Negate this Point instance. (component-wise)
 */
Point.prototype.negate = function() {
    this.x = -this.x;
    this.y = -this.y;
    return this; // for chaining
};

/**
 * Add another Point object to this instance. (component-wise)
 * @param   n   Point object.
 */
Point.prototype.add = function(n) {
    this.x += n.x;
    this.y += n.y;
    return this; // for chaining
};

/**
 * Subtract this Point instance with another point given. (component-wise)
 * @param   n   Point object.
 */
Point.prototype.sub = function(n) {
    this.x -= n.x;
    this.y -= n.y;
    return this; // for chaining
};

/**
 * Multiply this Point instance by a scalar. (component-wise)
 * @param   s   scalar.
 */
Point.prototype.mul = function(s) {
    this.x *= s;
    this.y *= s;
    return this; // for chaining
};

/**
 * Return the distance of this Point instance from the origo.
 */
Point.prototype.length = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
};

/**
 * Normalize this Point instance (as a vector).
 * @return The original distance of this instance from the origo.
 */
Point.prototype.normalize = function() {
    var len = this.length();
    this.x /= len;
    this.y /= len;
    return len;
};

/**
 * Test this Point object with another for equality.
 * @param   p   any "Point like" object with {x,y} (duck typing)
 * @return <code>True</code> if <code>this == p</code>, <code>false</code> otherwise.
 */
Point.prototype.equals = function(p) {
    return this.x === p.x && this.y === p.y;
};


// -----------------------------------------------------Point ("static" methods)

/**
 * Negate a point component-wise and return the result as a new Point object.
 * @param   p   Point object.
 * @return the resulting Point object.
 */
Point.negate = function(p) {
    return new Point(-p.x, -p.y);
};

/**
 * Add two points component-wise and return the result as a new Point object.
 * @param   a   Point object.
 * @param   b   Point object.
 * @return the resulting Point object.
 */
Point.add = function(a, b) {
    return new Point(a.x + b.x, a.y + b.y);
};

/**
 * Subtract two points component-wise and return the result as a new Point object.
 * @param   a   Point object.
 * @param   b   Point object.
 * @return the resulting Point object.
 */
Point.sub = function(a, b) {
    return new Point(a.x - b.x, a.y - b.y);
};

/**
 * Multiply a point by a scalar and return the result as a new Point object.
 * @param   s   the scalar (a number).
 * @param   p   Point object.
 * @return the resulting Point object.
 */
Point.mul = function(s, p) {
    return new Point(s * p.x, s * p.y);
};

/**
 * Perform the cross product on either two points (this produces a scalar)
 * or a point and a scalar (this produces a point).
 * This function requires two parameters, either may be a Point object or a
 * number.
 * @param   a   Point object or scalar.
 * @param   b   Point object or scalar.
 * @return  a   Point object or a number, depending on the parameters.
 */
Point.cross = function(a, b) {
    if (typeof(a) === 'number') {
        if (typeof(b) === 'number') {
            return a * b;
        } else {
            return new Point(-a * b.y, a * b.x);
        }
    } else {
        if (typeof(b) === 'number') {
            return new Point(b * a.y, -b * a.x);
        } else {
            return a.x * b.y - a.y * b.x;
        }
    }
};


// -----------------------------------------------------------------"Point-Like"
/*
 * The following functions operate on "Point" or any "Point like" object 
 * with {x,y} (duck typing).
 */

Point.toString = xy.toString;
Point.compare = xy.compare;
Point.cmp = xy.compare; // backward compatibility
Point.equals = xy.equals;

/**
 * Peform the dot product on two vectors.
 * @param   a,b   any "Point like" objects with {x,y} 
 * @return The dot product (as a number).
 */
Point.dot = function(a, b) {
    return a.x * b.x + a.y * b.y;
};


// ---------------------------------------------------------Exports (public API)

module.exports = Point;

},{"./xy":10}],4:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2013, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2013, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";

/*
 * Class added in the JavaScript version (was not present in the c++ version)
 */

var xy = _dereq_('./xy');

/**
 * Custom exception class to indicate invalid Point values
 * @param {String} message          error message
 * @param {array<Point>} points     invalid points
 */
var PointError = function(message, points) {
    this.name = "PointError";
    this.points = points = points || [];
    this.message = message || "Invalid Points!";
    for (var i = 0; i < points.length; i++) {
        this.message += " " + xy.toString(points[i]);
    }
};
PointError.prototype = new Error();
PointError.prototype.constructor = PointError;


module.exports = PointError;

},{"./xy":10}],5:[function(_dereq_,module,exports){
var global=typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};/*
 * Poly2Tri Copyright (c) 2009-2013, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2013, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * * Neither the name of Poly2Tri nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without specific
 *   prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

"use strict";

/*
 * Public API for poly2tri.js
 * ==========================
 */


/*
 * for Browser + <script> : 
 * return the poly2tri global variable to its previous value. 
 * (this feature is not automatically provided by browserify).
 */
var previousPoly2tri = global.poly2tri;
exports.noConflict = function() {
    global.poly2tri = previousPoly2tri;
    return exports;
};

exports.VERSION = _dereq_('../dist/version.json').version;

exports.PointError = _dereq_('./pointerror');
exports.Point = _dereq_('./point');
exports.Triangle = _dereq_('./triangle');
exports.SweepContext = _dereq_('./sweepcontext');


// Backward compatibility
var sweep = _dereq_('./sweep');
exports.triangulate = sweep.triangulate;
exports.sweep = {Triangulate: sweep.triangulate};

},{"../dist/version.json":1,"./point":3,"./pointerror":4,"./sweep":6,"./sweepcontext":7,"./triangle":8}],6:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2013, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2013, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint latedef:nofunc, maxcomplexity:9 */

"use strict";


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 *
 * This 'Sweep' module is present in order to keep this JavaScript version 
 * as close as possible to the reference C++ version, even though almost all
 * functions could be declared as methods on the SweepContext object.
 */

var PointError = _dereq_('./pointerror');
var Triangle = _dereq_('./triangle');
var Node = _dereq_('./advancingfront').Node;


// ------------------------------------------------------------------------utils

var utils = _dereq_('./utils');

var PI_3div4 = 3 * Math.PI / 4;
var PI_div2 = Math.PI / 2;
var EPSILON = utils.EPSILON;

var Orientation = utils.Orientation;
var orient2d = utils.orient2d;
var inScanArea = utils.inScanArea;


// ------------------------------------------------------------------------Sweep

/**
 * Triangulate the polygon with holes and Steiner points.
 * Do this AFTER you've added the polyline, holes, and Steiner points
 * @param   tcx SweepContext object.
 */
function triangulate(tcx) {
    tcx.initTriangulation();
    tcx.createAdvancingFront();
    // Sweep points; build mesh
    sweepPoints(tcx);
    // Clean up
    finalizationPolygon(tcx);
}

/**
 * Start sweeping the Y-sorted point set from bottom to top
 * @param   tcx SweepContext object.
 */
function sweepPoints(tcx) {
    var i, len = tcx.pointCount();
    for (i = 1; i < len; ++i) {
        var point = tcx.getPoint(i);
        var node = pointEvent(tcx, point);
        var edges = point._p2t_edge_list;
        for (var j = 0; edges && j < edges.length; ++j) {
            edgeEventByEdge(tcx, edges[j], node);
        }
    }
}

function finalizationPolygon(tcx) {
    // Get an Internal triangle to start with
    var t = tcx.front().head().next.triangle;
    var p = tcx.front().head().next.point;
    while (!t.getConstrainedEdgeCW(p)) {
        t = t.neighborCCW(p);
    }

    // Collect interior triangles constrained by edges
    tcx.meshClean(t);
}

/**
 * Find closes node to the left of the new point and
 * create a new triangle. If needed new holes and basins
 * will be filled to.
 */
function pointEvent(tcx, point) {
    var node = tcx.locateNode(point);
    var new_node = newFrontTriangle(tcx, point, node);

    // Only need to check +epsilon since point never have smaller
    // x value than node due to how we fetch nodes from the front
    if (point.x <= node.point.x + (EPSILON)) {
        fill(tcx, node);
    }

    //tcx.AddNode(new_node);

    fillAdvancingFront(tcx, new_node);
    return new_node;
}

function edgeEventByEdge(tcx, edge, node) {
    tcx.edge_event.constrained_edge = edge;
    tcx.edge_event.right = (edge.p.x > edge.q.x);

    if (isEdgeSideOfTriangle(node.triangle, edge.p, edge.q)) {
        return;
    }

    // For now we will do all needed filling
    // TODO: integrate with flip process might give some better performance
    //       but for now this avoid the issue with cases that needs both flips and fills
    fillEdgeEvent(tcx, edge, node);
    edgeEventByPoints(tcx, edge.p, edge.q, node.triangle, edge.q);
}

function edgeEventByPoints(tcx, ep, eq, triangle, point) {
    if (isEdgeSideOfTriangle(triangle, ep, eq)) {
        return;
    }

    var p1 = triangle.pointCCW(point);
    var o1 = orient2d(eq, p1, ep);
    if (o1 === Orientation.COLLINEAR) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision 09880a869095 dated March 8, 2011)
        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p1, ep]);
    }

    var p2 = triangle.pointCW(point);
    var o2 = orient2d(eq, p2, ep);
    if (o2 === Orientation.COLLINEAR) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision 09880a869095 dated March 8, 2011)
        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p2, ep]);
    }

    if (o1 === o2) {
        // Need to decide if we are rotating CW or CCW to get to a triangle
        // that will cross edge
        if (o1 === Orientation.CW) {
            triangle = triangle.neighborCCW(point);
        } else {
            triangle = triangle.neighborCW(point);
        }
        edgeEventByPoints(tcx, ep, eq, triangle, point);
    } else {
        // This triangle crosses constraint so lets flippin start!
        flipEdgeEvent(tcx, ep, eq, triangle, point);
    }
}

function isEdgeSideOfTriangle(triangle, ep, eq) {
    var index = triangle.edgeIndex(ep, eq);
    if (index !== -1) {
        triangle.markConstrainedEdgeByIndex(index);
        var t = triangle.getNeighbor(index);
        if (t) {
            t.markConstrainedEdgeByPoints(ep, eq);
        }
        return true;
    }
    return false;
}

/**
 * Creates a new front triangle and legalize it
 */
function newFrontTriangle(tcx, point, node) {
    var triangle = new Triangle(point, node.point, node.next.point);

    triangle.markNeighbor(node.triangle);
    tcx.addToMap(triangle);

    var new_node = new Node(point);
    new_node.next = node.next;
    new_node.prev = node;
    node.next.prev = new_node;
    node.next = new_node;

    if (!legalize(tcx, triangle)) {
        tcx.mapTriangleToNodes(triangle);
    }

    return new_node;
}

/**
 * Adds a triangle to the advancing front to fill a hole.
 * @param tcx
 * @param node - middle node, that is the bottom of the hole
 */
function fill(tcx, node) {
    var triangle = new Triangle(node.prev.point, node.point, node.next.point);

    // TODO: should copy the constrained_edge value from neighbor triangles
    //       for now constrained_edge values are copied during the legalize
    triangle.markNeighbor(node.prev.triangle);
    triangle.markNeighbor(node.triangle);

    tcx.addToMap(triangle);

    // Update the advancing front
    node.prev.next = node.next;
    node.next.prev = node.prev;


    // If it was legalized the triangle has already been mapped
    if (!legalize(tcx, triangle)) {
        tcx.mapTriangleToNodes(triangle);
    }

    //tcx.removeNode(node);
}

/**
 * Fills holes in the Advancing Front
 */
function fillAdvancingFront(tcx, n) {
    // Fill right holes
    var node = n.next;
    var angle;
    while (node.next) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision acf81f1f1764 dated April 7, 2012)
        angle = holeAngle(node);
        if (angle > PI_div2 || angle < -(PI_div2)) {
            break;
        }
        fill(tcx, node);
        node = node.next;
    }

    // Fill left holes
    node = n.prev;
    while (node.prev) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision acf81f1f1764 dated April 7, 2012)
        angle = holeAngle(node);
        if (angle > PI_div2 || angle < -(PI_div2)) {
            break;
        }
        fill(tcx, node);
        node = node.prev;
    }

    // Fill right basins
    if (n.next && n.next.next) {
        angle = basinAngle(n);
        if (angle < PI_3div4) {
            fillBasin(tcx, n);
        }
    }
}

/**
 * The basin angle is decided against the horizontal line [1,0]
 */
function basinAngle(node) {
    var ax = node.point.x - node.next.next.point.x;
    var ay = node.point.y - node.next.next.point.y;
    return Math.atan2(ay, ax);
}

/**
 *
 * @param node - middle node
 * @return the angle between 3 front nodes
 */
function holeAngle(node) {
    /* Complex plane
     * ab = cosA +i*sinA
     * ab = (ax + ay*i)(bx + by*i) = (ax*bx + ay*by) + i(ax*by-ay*bx)
     * atan2(y,x) computes the principal value of the argument function
     * applied to the complex number x+iy
     * Where x = ax*bx + ay*by
     *       y = ax*by - ay*bx
     */
    var ax = node.next.point.x - node.point.x;
    var ay = node.next.point.y - node.point.y;
    var bx = node.prev.point.x - node.point.x;
    var by = node.prev.point.y - node.point.y;
    return Math.atan2(ax * by - ay * bx, ax * bx + ay * by);
}

/**
 * Returns true if triangle was legalized
 */
function legalize(tcx, t) {
    // To legalize a triangle we start by finding if any of the three edges
    // violate the Delaunay condition
    for (var i = 0; i < 3; ++i) {
        if (t.delaunay_edge[i]) {
            continue;
        }
        var ot = t.getNeighbor(i);
        if (ot) {
            var p = t.getPoint(i);
            var op = ot.oppositePoint(t, p);
            var oi = ot.index(op);

            // If this is a Constrained Edge or a Delaunay Edge(only during recursive legalization)
            // then we should not try to legalize
            if (ot.constrained_edge[oi] || ot.delaunay_edge[oi]) {
                t.constrained_edge[i] = ot.constrained_edge[oi];
                continue;
            }

            var inside = inCircle(p, t.pointCCW(p), t.pointCW(p), op);
            if (inside) {
                // Lets mark this shared edge as Delaunay
                t.delaunay_edge[i] = true;
                ot.delaunay_edge[oi] = true;

                // Lets rotate shared edge one vertex CW to legalize it
                rotateTrianglePair(t, p, ot, op);

                // We now got one valid Delaunay Edge shared by two triangles
                // This gives us 4 new edges to check for Delaunay

                // Make sure that triangle to node mapping is done only one time for a specific triangle
                var not_legalized = !legalize(tcx, t);
                if (not_legalized) {
                    tcx.mapTriangleToNodes(t);
                }

                not_legalized = !legalize(tcx, ot);
                if (not_legalized) {
                    tcx.mapTriangleToNodes(ot);
                }
                // Reset the Delaunay edges, since they only are valid Delaunay edges
                // until we add a new triangle or point.
                // XXX: need to think about this. Can these edges be tried after we
                //      return to previous recursive level?
                t.delaunay_edge[i] = false;
                ot.delaunay_edge[oi] = false;

                // If triangle have been legalized no need to check the other edges since
                // the recursive legalization will handles those so we can end here.
                return true;
            }
        }
    }
    return false;
}

/**
 * <b>Requirement</b>:<br>
 * 1. a,b and c form a triangle.<br>
 * 2. a and d is know to be on opposite side of bc<br>
 * <pre>
 *                a
 *                +
 *               / \
 *              /   \
 *            b/     \c
 *            +-------+
 *           /    d    \
 *          /           \
 * </pre>
 * <b>Fact</b>: d has to be in area B to have a chance to be inside the circle formed by
 *  a,b and c<br>
 *  d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW<br>
 *  This preknowledge gives us a way to optimize the incircle test
 * @param pa - triangle point, opposite d
 * @param pb - triangle point
 * @param pc - triangle point
 * @param pd - point opposite a
 * @return true if d is inside circle, false if on circle edge
 */
function inCircle(pa, pb, pc, pd) {
    var adx = pa.x - pd.x;
    var ady = pa.y - pd.y;
    var bdx = pb.x - pd.x;
    var bdy = pb.y - pd.y;

    var adxbdy = adx * bdy;
    var bdxady = bdx * ady;
    var oabd = adxbdy - bdxady;
    if (oabd <= 0) {
        return false;
    }

    var cdx = pc.x - pd.x;
    var cdy = pc.y - pd.y;

    var cdxady = cdx * ady;
    var adxcdy = adx * cdy;
    var ocad = cdxady - adxcdy;
    if (ocad <= 0) {
        return false;
    }

    var bdxcdy = bdx * cdy;
    var cdxbdy = cdx * bdy;

    var alift = adx * adx + ady * ady;
    var blift = bdx * bdx + bdy * bdy;
    var clift = cdx * cdx + cdy * cdy;

    var det = alift * (bdxcdy - cdxbdy) + blift * ocad + clift * oabd;
    return det > 0;
}

/**
 * Rotates a triangle pair one vertex CW
 *<pre>
 *       n2                    n2
 *  P +-----+             P +-----+
 *    | t  /|               |\  t |
 *    |   / |               | \   |
 *  n1|  /  |n3           n1|  \  |n3
 *    | /   |    after CW   |   \ |
 *    |/ oT |               | oT \|
 *    +-----+ oP            +-----+
 *       n4                    n4
 * </pre>
 */
function rotateTrianglePair(t, p, ot, op) {
    var n1, n2, n3, n4;
    n1 = t.neighborCCW(p);
    n2 = t.neighborCW(p);
    n3 = ot.neighborCCW(op);
    n4 = ot.neighborCW(op);

    var ce1, ce2, ce3, ce4;
    ce1 = t.getConstrainedEdgeCCW(p);
    ce2 = t.getConstrainedEdgeCW(p);
    ce3 = ot.getConstrainedEdgeCCW(op);
    ce4 = ot.getConstrainedEdgeCW(op);

    var de1, de2, de3, de4;
    de1 = t.getDelaunayEdgeCCW(p);
    de2 = t.getDelaunayEdgeCW(p);
    de3 = ot.getDelaunayEdgeCCW(op);
    de4 = ot.getDelaunayEdgeCW(op);

    t.legalize(p, op);
    ot.legalize(op, p);

    // Remap delaunay_edge
    ot.setDelaunayEdgeCCW(p, de1);
    t.setDelaunayEdgeCW(p, de2);
    t.setDelaunayEdgeCCW(op, de3);
    ot.setDelaunayEdgeCW(op, de4);

    // Remap constrained_edge
    ot.setConstrainedEdgeCCW(p, ce1);
    t.setConstrainedEdgeCW(p, ce2);
    t.setConstrainedEdgeCCW(op, ce3);
    ot.setConstrainedEdgeCW(op, ce4);

    // Remap neighbors
    // XXX: might optimize the markNeighbor by keeping track of
    //      what side should be assigned to what neighbor after the
    //      rotation. Now mark neighbor does lots of testing to find
    //      the right side.
    t.clearNeigbors();
    ot.clearNeigbors();
    if (n1) {
        ot.markNeighbor(n1);
    }
    if (n2) {
        t.markNeighbor(n2);
    }
    if (n3) {
        t.markNeighbor(n3);
    }
    if (n4) {
        ot.markNeighbor(n4);
    }
    t.markNeighbor(ot);
}

/**
 * Fills a basin that has formed on the Advancing Front to the right
 * of given node.<br>
 * First we decide a left,bottom and right node that forms the
 * boundaries of the basin. Then we do a reqursive fill.
 *
 * @param tcx
 * @param node - starting node, this or next node will be left node
 */
function fillBasin(tcx, node) {
    if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
        tcx.basin.left_node = node.next.next;
    } else {
        tcx.basin.left_node = node.next;
    }

    // Find the bottom and right node
    tcx.basin.bottom_node = tcx.basin.left_node;
    while (tcx.basin.bottom_node.next && tcx.basin.bottom_node.point.y >= tcx.basin.bottom_node.next.point.y) {
        tcx.basin.bottom_node = tcx.basin.bottom_node.next;
    }
    if (tcx.basin.bottom_node === tcx.basin.left_node) {
        // No valid basin
        return;
    }

    tcx.basin.right_node = tcx.basin.bottom_node;
    while (tcx.basin.right_node.next && tcx.basin.right_node.point.y < tcx.basin.right_node.next.point.y) {
        tcx.basin.right_node = tcx.basin.right_node.next;
    }
    if (tcx.basin.right_node === tcx.basin.bottom_node) {
        // No valid basins
        return;
    }

    tcx.basin.width = tcx.basin.right_node.point.x - tcx.basin.left_node.point.x;
    tcx.basin.left_highest = tcx.basin.left_node.point.y > tcx.basin.right_node.point.y;

    fillBasinReq(tcx, tcx.basin.bottom_node);
}

/**
 * Recursive algorithm to fill a Basin with triangles
 *
 * @param tcx
 * @param node - bottom_node
 */
function fillBasinReq(tcx, node) {
    // if shallow stop filling
    if (isShallow(tcx, node)) {
        return;
    }

    fill(tcx, node);

    var o;
    if (node.prev === tcx.basin.left_node && node.next === tcx.basin.right_node) {
        return;
    } else if (node.prev === tcx.basin.left_node) {
        o = orient2d(node.point, node.next.point, node.next.next.point);
        if (o === Orientation.CW) {
            return;
        }
        node = node.next;
    } else if (node.next === tcx.basin.right_node) {
        o = orient2d(node.point, node.prev.point, node.prev.prev.point);
        if (o === Orientation.CCW) {
            return;
        }
        node = node.prev;
    } else {
        // Continue with the neighbor node with lowest Y value
        if (node.prev.point.y < node.next.point.y) {
            node = node.prev;
        } else {
            node = node.next;
        }
    }

    fillBasinReq(tcx, node);
}

function isShallow(tcx, node) {
    var height;
    if (tcx.basin.left_highest) {
        height = tcx.basin.left_node.point.y - node.point.y;
    } else {
        height = tcx.basin.right_node.point.y - node.point.y;
    }

    // if shallow stop filling
    if (tcx.basin.width > height) {
        return true;
    }
    return false;
}

function fillEdgeEvent(tcx, edge, node) {
    if (tcx.edge_event.right) {
        fillRightAboveEdgeEvent(tcx, edge, node);
    } else {
        fillLeftAboveEdgeEvent(tcx, edge, node);
    }
}

function fillRightAboveEdgeEvent(tcx, edge, node) {
    while (node.next.point.x < edge.p.x) {
        // Check if next node is below the edge
        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
            fillRightBelowEdgeEvent(tcx, edge, node);
        } else {
            node = node.next;
        }
    }
}

function fillRightBelowEdgeEvent(tcx, edge, node) {
    if (node.point.x < edge.p.x) {
        if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
            // Concave
            fillRightConcaveEdgeEvent(tcx, edge, node);
        } else {
            // Convex
            fillRightConvexEdgeEvent(tcx, edge, node);
            // Retry this one
            fillRightBelowEdgeEvent(tcx, edge, node);
        }
    }
}

function fillRightConcaveEdgeEvent(tcx, edge, node) {
    fill(tcx, node.next);
    if (node.next.point !== edge.p) {
        // Next above or below edge?
        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
            // Below
            if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
                // Next is concave
                fillRightConcaveEdgeEvent(tcx, edge, node);
            } else {
                // Next is convex
                /* jshint noempty:false */
            }
        }
    }
}

function fillRightConvexEdgeEvent(tcx, edge, node) {
    // Next concave or convex?
    if (orient2d(node.next.point, node.next.next.point, node.next.next.next.point) === Orientation.CCW) {
        // Concave
        fillRightConcaveEdgeEvent(tcx, edge, node.next);
    } else {
        // Convex
        // Next above or below edge?
        if (orient2d(edge.q, node.next.next.point, edge.p) === Orientation.CCW) {
            // Below
            fillRightConvexEdgeEvent(tcx, edge, node.next);
        } else {
            // Above
            /* jshint noempty:false */
        }
    }
}

function fillLeftAboveEdgeEvent(tcx, edge, node) {
    while (node.prev.point.x > edge.p.x) {
        // Check if next node is below the edge
        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
            fillLeftBelowEdgeEvent(tcx, edge, node);
        } else {
            node = node.prev;
        }
    }
}

function fillLeftBelowEdgeEvent(tcx, edge, node) {
    if (node.point.x > edge.p.x) {
        if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
            // Concave
            fillLeftConcaveEdgeEvent(tcx, edge, node);
        } else {
            // Convex
            fillLeftConvexEdgeEvent(tcx, edge, node);
            // Retry this one
            fillLeftBelowEdgeEvent(tcx, edge, node);
        }
    }
}

function fillLeftConvexEdgeEvent(tcx, edge, node) {
    // Next concave or convex?
    if (orient2d(node.prev.point, node.prev.prev.point, node.prev.prev.prev.point) === Orientation.CW) {
        // Concave
        fillLeftConcaveEdgeEvent(tcx, edge, node.prev);
    } else {
        // Convex
        // Next above or below edge?
        if (orient2d(edge.q, node.prev.prev.point, edge.p) === Orientation.CW) {
            // Below
            fillLeftConvexEdgeEvent(tcx, edge, node.prev);
        } else {
            // Above
            /* jshint noempty:false */
        }
    }
}

function fillLeftConcaveEdgeEvent(tcx, edge, node) {
    fill(tcx, node.prev);
    if (node.prev.point !== edge.p) {
        // Next above or below edge?
        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
            // Below
            if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
                // Next is concave
                fillLeftConcaveEdgeEvent(tcx, edge, node);
            } else {
                // Next is convex
                /* jshint noempty:false */
            }
        }
    }
}

function flipEdgeEvent(tcx, ep, eq, t, p) {
    var ot = t.neighborAcross(p);
    if (!ot) {
        // If we want to integrate the fillEdgeEvent do it here
        // With current implementation we should never get here
        throw new Error('poly2tri [BUG:FIXME] FLIP failed due to missing triangle!');
    }
    var op = ot.oppositePoint(t, p);

    // Additional check from Java version (see issue #88)
    if (t.getConstrainedEdgeAcross(p)) {
        var index = t.index(p);
        throw new PointError("poly2tri Intersecting Constraints",
                [p, op, t.getPoint((index + 1) % 3), t.getPoint((index + 2) % 3)]);
    }

    if (inScanArea(p, t.pointCCW(p), t.pointCW(p), op)) {
        // Lets rotate shared edge one vertex CW
        rotateTrianglePair(t, p, ot, op);
        tcx.mapTriangleToNodes(t);
        tcx.mapTriangleToNodes(ot);

        // XXX: in the original C++ code for the next 2 lines, we are
        // comparing point values (and not pointers). In this JavaScript
        // code, we are comparing point references (pointers). This works
        // because we can't have 2 different points with the same values.
        // But to be really equivalent, we should use "Point.equals" here.
        if (p === eq && op === ep) {
            if (eq === tcx.edge_event.constrained_edge.q && ep === tcx.edge_event.constrained_edge.p) {
                t.markConstrainedEdgeByPoints(ep, eq);
                ot.markConstrainedEdgeByPoints(ep, eq);
                legalize(tcx, t);
                legalize(tcx, ot);
            } else {
                // XXX: I think one of the triangles should be legalized here?
                /* jshint noempty:false */
            }
        } else {
            var o = orient2d(eq, op, ep);
            t = nextFlipTriangle(tcx, o, t, ot, p, op);
            flipEdgeEvent(tcx, ep, eq, t, p);
        }
    } else {
        var newP = nextFlipPoint(ep, eq, ot, op);
        flipScanEdgeEvent(tcx, ep, eq, t, ot, newP);
        edgeEventByPoints(tcx, ep, eq, t, p);
    }
}

/**
 * After a flip we have two triangles and know that only one will still be
 * intersecting the edge. So decide which to contiune with and legalize the other
 *
 * @param tcx
 * @param o - should be the result of an orient2d( eq, op, ep )
 * @param t - triangle 1
 * @param ot - triangle 2
 * @param p - a point shared by both triangles
 * @param op - another point shared by both triangles
 * @return returns the triangle still intersecting the edge
 */
function nextFlipTriangle(tcx, o, t, ot, p, op) {
    var edge_index;
    if (o === Orientation.CCW) {
        // ot is not crossing edge after flip
        edge_index = ot.edgeIndex(p, op);
        ot.delaunay_edge[edge_index] = true;
        legalize(tcx, ot);
        ot.clearDelunayEdges();
        return t;
    }

    // t is not crossing edge after flip
    edge_index = t.edgeIndex(p, op);

    t.delaunay_edge[edge_index] = true;
    legalize(tcx, t);
    t.clearDelunayEdges();
    return ot;
}

/**
 * When we need to traverse from one triangle to the next we need
 * the point in current triangle that is the opposite point to the next
 * triangle.
 */
function nextFlipPoint(ep, eq, ot, op) {
    var o2d = orient2d(eq, op, ep);
    if (o2d === Orientation.CW) {
        // Right
        return ot.pointCCW(op);
    } else if (o2d === Orientation.CCW) {
        // Left
        return ot.pointCW(op);
    } else {
        throw new PointError("poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!", [eq, op, ep]);
    }
}

/**
 * Scan part of the FlipScan algorithm<br>
 * When a triangle pair isn't flippable we will scan for the next
 * point that is inside the flip triangle scan area. When found
 * we generate a new flipEdgeEvent
 *
 * @param tcx
 * @param ep - last point on the edge we are traversing
 * @param eq - first point on the edge we are traversing
 * @param flipTriangle - the current triangle sharing the point eq with edge
 * @param t
 * @param p
 */
function flipScanEdgeEvent(tcx, ep, eq, flip_triangle, t, p) {
    var ot = t.neighborAcross(p);
    if (!ot) {
        // If we want to integrate the fillEdgeEvent do it here
        // With current implementation we should never get here
        throw new Error('poly2tri [BUG:FIXME] FLIP failed due to missing triangle');
    }
    var op = ot.oppositePoint(t, p);

    if (inScanArea(eq, flip_triangle.pointCCW(eq), flip_triangle.pointCW(eq), op)) {
        // flip with new edge op.eq
        flipEdgeEvent(tcx, eq, op, ot, op);
        // TODO: Actually I just figured out that it should be possible to
        //       improve this by getting the next ot and op before the the above
        //       flip and continue the flipScanEdgeEvent here
        // set new ot and op here and loop back to inScanArea test
        // also need to set a new flip_triangle first
        // Turns out at first glance that this is somewhat complicated
        // so it will have to wait.
    } else {
        var newP = nextFlipPoint(ep, eq, ot, op);
        flipScanEdgeEvent(tcx, ep, eq, flip_triangle, ot, newP);
    }
}


// ----------------------------------------------------------------------Exports

exports.triangulate = triangulate;

},{"./advancingfront":2,"./pointerror":4,"./triangle":8,"./utils":9}],7:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2013, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2013, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint maxcomplexity:6 */

"use strict";


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var PointError = _dereq_('./pointerror');
var Point = _dereq_('./point');
var Triangle = _dereq_('./triangle');
var sweep = _dereq_('./sweep');
var AdvancingFront = _dereq_('./advancingfront');
var Node = AdvancingFront.Node;


// ------------------------------------------------------------------------utils

/* 
 * Initial triangle factor, seed triangle will extend 30% of
 * PointSet width to both left and right.
 */
var kAlpha = 0.3;


// -------------------------------------------------------------------------Edge
/**
 * Represents a simple polygon's edge
 * @param {Point} p1
 * @param {Point} p2
 */
var Edge = function(p1, p2) {
    this.p = p1;
    this.q = p2;

    if (p1.y > p2.y) {
        this.q = p1;
        this.p = p2;
    } else if (p1.y === p2.y) {
        if (p1.x > p2.x) {
            this.q = p1;
            this.p = p2;
        } else if (p1.x === p2.x) {
            throw new PointError('poly2tri Invalid Edge constructor: repeated points!', [p1]);
        }
    }

    if (!this.q._p2t_edge_list) {
        this.q._p2t_edge_list = [];
    }
    this.q._p2t_edge_list.push(this);
};


// ------------------------------------------------------------------------Basin
var Basin = function() {
    this.left_node = null; // Node
    this.bottom_node = null; // Node
    this.right_node = null; // Node
    this.width = 0.0; // number
    this.left_highest = false;
};

Basin.prototype.clear = function() {
    this.left_node = null;
    this.bottom_node = null;
    this.right_node = null;
    this.width = 0.0;
    this.left_highest = false;
};

// --------------------------------------------------------------------EdgeEvent
var EdgeEvent = function() {
    this.constrained_edge = null; // Edge
    this.right = false;
};

// ----------------------------------------------------SweepContext (public API)
/**
 * Constructor for the triangulation context.
 * It accepts a simple polyline (with non repeating points), 
 * which defines the constrained edges.
 * Possible options are:
 *    cloneArrays:  if true, do a shallow copy of the Array parameters 
 *                  (contour, holes). Points inside arrays are never copied.
 *                  Default is false : keep a reference to the array arguments,
 *                  who will be modified in place.
 * @param {Array} contour  array of "Point like" objects with {x,y} (duck typing)
 * @param {Object} options  constructor options
 */
var SweepContext = function(contour, options) {
    options = options || {};
    this.triangles_ = [];
    this.map_ = [];
    this.points_ = (options.cloneArrays ? contour.slice(0) : contour);
    this.edge_list = [];

    // Bounding box of all points. Computed at the start of the triangulation, 
    // it is stored in case it is needed by the caller.
    this.pmin_ = this.pmax_ = null;

    // Advancing front
    this.front_ = null; // AdvancingFront
    // head point used with advancing front
    this.head_ = null; // Point
    // tail point used with advancing front
    this.tail_ = null; // Point

    this.af_head_ = null; // Node
    this.af_middle_ = null; // Node
    this.af_tail_ = null; // Node

    this.basin = new Basin();
    this.edge_event = new EdgeEvent();

    this.initEdges(this.points_);
};


/**
 * Add a hole to the constraints
 * @param {Array} polyline  array of "Point like" objects with {x,y} (duck typing)
 */
SweepContext.prototype.addHole = function(polyline) {
    this.initEdges(polyline);
    var i, len = polyline.length;
    for (i = 0; i < len; i++) {
        this.points_.push(polyline[i]);
    }
    return this; // for chaining
};
// Backward compatibility
SweepContext.prototype.AddHole = SweepContext.prototype.addHole;


/**
 * Add a Steiner point to the constraints
 * @param {Point} point     any "Point like" object with {x,y} (duck typing)
 */
SweepContext.prototype.addPoint = function(point) {
    this.points_.push(point);
    return this; // for chaining
};
// Backward compatibility
SweepContext.prototype.AddPoint = SweepContext.prototype.addPoint;


/**
 * Add several Steiner points to the constraints
 * @param {array<Point>} points     array of "Point like" object with {x,y} 
 */
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.addPoints = function(points) {
    this.points_ = this.points_.concat(points);
    return this; // for chaining
};


/**
 * Triangulate the polygon with holes and Steiner points.
 * Do this AFTER you've added the polyline, holes, and Steiner points
 */
// Shortcut method for sweep.triangulate(SweepContext).
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.triangulate = function() {
    sweep.triangulate(this);
    return this; // for chaining
};


/**
 * Get the bounding box of the provided constraints (contour, holes and 
 * Steinter points). Warning : these values are not available if the triangulation 
 * has not been done yet.
 * @returns {Object} object with 'min' and 'max' Point
 */
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.getBoundingBox = function() {
    return {min: this.pmin_, max: this.pmax_};
};

/**
 * Get result of triangulation
 * @returns {array<Triangle>}   array of triangles
 */
SweepContext.prototype.getTriangles = function() {
    return this.triangles_;
};
// Backward compatibility
SweepContext.prototype.GetTriangles = SweepContext.prototype.getTriangles;


// ---------------------------------------------------SweepContext (private API)

SweepContext.prototype.front = function() {
    return this.front_;
};

SweepContext.prototype.pointCount = function() {
    return this.points_.length;
};

SweepContext.prototype.head = function() {
    return this.head_;
};

SweepContext.prototype.setHead = function(p1) {
    this.head_ = p1;
};

SweepContext.prototype.tail = function() {
    return this.tail_;
};

SweepContext.prototype.setTail = function(p1) {
    this.tail_ = p1;
};

SweepContext.prototype.getMap = function() {
    return this.map_;
};

SweepContext.prototype.initTriangulation = function() {
    var xmax = this.points_[0].x;
    var xmin = this.points_[0].x;
    var ymax = this.points_[0].y;
    var ymin = this.points_[0].y;

    // Calculate bounds
    var i, len = this.points_.length;
    for (i = 1; i < len; i++) {
        var p = this.points_[i];
        /* jshint expr:true */
        (p.x > xmax) && (xmax = p.x);
        (p.x < xmin) && (xmin = p.x);
        (p.y > ymax) && (ymax = p.y);
        (p.y < ymin) && (ymin = p.y);
    }
    this.pmin_ = new Point(xmin, ymin);
    this.pmax_ = new Point(xmax, ymax);

    var dx = kAlpha * (xmax - xmin);
    var dy = kAlpha * (ymax - ymin);
    this.head_ = new Point(xmax + dx, ymin - dy);
    this.tail_ = new Point(xmin - dx, ymin - dy);

    // Sort points along y-axis
    this.points_.sort(Point.compare);
};

SweepContext.prototype.initEdges = function(polyline) {
    var i, len = polyline.length;
    for (i = 0; i < len; ++i) {
        this.edge_list.push(new Edge(polyline[i], polyline[(i + 1) % len]));
    }
};

SweepContext.prototype.getPoint = function(index) {
    return this.points_[index];
};

SweepContext.prototype.addToMap = function(triangle) {
    this.map_.push(triangle);
};

SweepContext.prototype.locateNode = function(point) {
    return this.front_.locateNode(point.x);
};

SweepContext.prototype.createAdvancingFront = function() {
    var head;
    var middle;
    var tail;
    // Initial triangle
    var triangle = new Triangle(this.points_[0], this.tail_, this.head_);

    this.map_.push(triangle);

    head = new Node(triangle.getPoint(1), triangle);
    middle = new Node(triangle.getPoint(0), triangle);
    tail = new Node(triangle.getPoint(2));

    this.front_ = new AdvancingFront(head, tail);

    head.next = middle;
    middle.next = tail;
    middle.prev = head;
    tail.prev = middle;
};

SweepContext.prototype.removeNode = function(node) {
    // do nothing
    /* jshint unused:false */
};

SweepContext.prototype.mapTriangleToNodes = function(t) {
    for (var i = 0; i < 3; ++i) {
        if (!t.getNeighbor(i)) {
            var n = this.front_.locatePoint(t.pointCW(t.getPoint(i)));
            if (n) {
                n.triangle = t;
            }
        }
    }
};

SweepContext.prototype.removeFromMap = function(triangle) {
    var i, map = this.map_, len = map.length;
    for (i = 0; i < len; i++) {
        if (map[i] === triangle) {
            map.splice(i, 1);
            break;
        }
    }
};

/**
 * Do a depth first traversal to collect triangles
 * @param {Triangle} triangle start
 */
SweepContext.prototype.meshClean = function(triangle) {
    // New implementation avoids recursive calls and use a loop instead.
    // Cf. issues # 57, 65 and 69.
    var triangles = [triangle], t, i;
    /* jshint boss:true */
    while (t = triangles.pop()) {
        if (!t.isInterior()) {
            t.setInterior(true);
            this.triangles_.push(t);
            for (i = 0; i < 3; i++) {
                if (!t.constrained_edge[i]) {
                    triangles.push(t.getNeighbor(i));
                }
            }
        }
    }
};

// ----------------------------------------------------------------------Exports

module.exports = SweepContext;

},{"./advancingfront":2,"./point":3,"./pointerror":4,"./sweep":6,"./triangle":8}],8:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2013, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2013, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 *
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint maxcomplexity:10 */

"use strict";


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var xy = _dereq_("./xy");


// ---------------------------------------------------------------------Triangle
/**
 * Triangle class.<br>
 * Triangle-based data structures are known to have better performance than
 * quad-edge structures.
 * See: J. Shewchuk, "Triangle: Engineering a 2D Quality Mesh Generator and
 * Delaunay Triangulator", "Triangulations in CGAL"
 * 
 * @param   a,b,c   any "Point like" objects with {x,y} (duck typing)
 */
var Triangle = function(a, b, c) {
    // Triangle points
    this.points_ = [a, b, c];
    // Neighbor list
    this.neighbors_ = [null, null, null];
    // Has this triangle been marked as an interior triangle?
    this.interior_ = false;
    // Flags to determine if an edge is a Constrained edge
    this.constrained_edge = [false, false, false];
    // Flags to determine if an edge is a Delauney edge
    this.delaunay_edge = [false, false, false];
};

/**
 * For pretty printing ex. <i>"[(5;42)(10;20)(21;30)]"</i>)
 */
var p2s = xy.toString;
Triangle.prototype.toString = function() {
    return ("[" + p2s(this.points_[0]) + p2s(this.points_[1]) + p2s(this.points_[2]) + "]");
};

Triangle.prototype.getPoint = function(index) {
    return this.points_[index];
};
// for backward compatibility
Triangle.prototype.GetPoint = Triangle.prototype.getPoint;

// Method added in the JavaScript version (was not present in the c++ version)
Triangle.prototype.getPoints = function() {
    return this.points_;
};

Triangle.prototype.getNeighbor = function(index) {
    return this.neighbors_[index];
};

/**
 * Test if this Triangle contains the Point object given as parameters as its
 * vertices. Only point references are compared, not values.
 * @return <code>True</code> if the Point object is of the Triangle's vertices,
 *         <code>false</code> otherwise.
 */
Triangle.prototype.containsPoint = function(point) {
    var points = this.points_;
    // Here we are comparing point references, not values
    return (point === points[0] || point === points[1] || point === points[2]);
};

/**
 * Test if this Triangle contains the Edge object given as parameter as its
 * bounding edges. Only point references are compared, not values.
 * @return <code>True</code> if the Edge object is of the Triangle's bounding
 *         edges, <code>false</code> otherwise.
 */
Triangle.prototype.containsEdge = function(edge) {
    return this.containsPoint(edge.p) && this.containsPoint(edge.q);
};
Triangle.prototype.containsPoints = function(p1, p2) {
    return this.containsPoint(p1) && this.containsPoint(p2);
};


Triangle.prototype.isInterior = function() {
    return this.interior_;
};
Triangle.prototype.setInterior = function(interior) {
    this.interior_ = interior;
    return this;
};

/**
 * Update neighbor pointers.
 * @param {Point} p1 Point object.
 * @param {Point} p2 Point object.
 * @param {Triangle} t Triangle object.
 */
Triangle.prototype.markNeighborPointers = function(p1, p2, t) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if ((p1 === points[2] && p2 === points[1]) || (p1 === points[1] && p2 === points[2])) {
        this.neighbors_[0] = t;
    } else if ((p1 === points[0] && p2 === points[2]) || (p1 === points[2] && p2 === points[0])) {
        this.neighbors_[1] = t;
    } else if ((p1 === points[0] && p2 === points[1]) || (p1 === points[1] && p2 === points[0])) {
        this.neighbors_[2] = t;
    } else {
        throw new Error('poly2tri Invalid Triangle.markNeighborPointers() call');
    }
};

/**
 * Exhaustive search to update neighbor pointers
 * @param {Triangle} t
 */
Triangle.prototype.markNeighbor = function(t) {
    var points = this.points_;
    if (t.containsPoints(points[1], points[2])) {
        this.neighbors_[0] = t;
        t.markNeighborPointers(points[1], points[2], this);
    } else if (t.containsPoints(points[0], points[2])) {
        this.neighbors_[1] = t;
        t.markNeighborPointers(points[0], points[2], this);
    } else if (t.containsPoints(points[0], points[1])) {
        this.neighbors_[2] = t;
        t.markNeighborPointers(points[0], points[1], this);
    }
};


Triangle.prototype.clearNeigbors = function() {
    this.neighbors_[0] = null;
    this.neighbors_[1] = null;
    this.neighbors_[2] = null;
};

Triangle.prototype.clearDelunayEdges = function() {
    this.delaunay_edge[0] = false;
    this.delaunay_edge[1] = false;
    this.delaunay_edge[2] = false;
};

/**
 * Returns the point clockwise to the given point.
 */
Triangle.prototype.pointCW = function(p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
        return points[2];
    } else if (p === points[1]) {
        return points[0];
    } else if (p === points[2]) {
        return points[1];
    } else {
        return null;
    }
};

/**
 * Returns the point counter-clockwise to the given point.
 */
Triangle.prototype.pointCCW = function(p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
        return points[1];
    } else if (p === points[1]) {
        return points[2];
    } else if (p === points[2]) {
        return points[0];
    } else {
        return null;
    }
};

/**
 * Returns the neighbor clockwise to given point.
 */
Triangle.prototype.neighborCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.neighbors_[1];
    } else if (p === this.points_[1]) {
        return this.neighbors_[2];
    } else {
        return this.neighbors_[0];
    }
};

/**
 * Returns the neighbor counter-clockwise to given point.
 */
Triangle.prototype.neighborCCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.neighbors_[2];
    } else if (p === this.points_[1]) {
        return this.neighbors_[0];
    } else {
        return this.neighbors_[1];
    }
};

Triangle.prototype.getConstrainedEdgeCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.constrained_edge[1];
    } else if (p === this.points_[1]) {
        return this.constrained_edge[2];
    } else {
        return this.constrained_edge[0];
    }
};

Triangle.prototype.getConstrainedEdgeCCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.constrained_edge[2];
    } else if (p === this.points_[1]) {
        return this.constrained_edge[0];
    } else {
        return this.constrained_edge[1];
    }
};

// Additional check from Java version (see issue #88)
Triangle.prototype.getConstrainedEdgeAcross = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.constrained_edge[0];
    } else if (p === this.points_[1]) {
        return this.constrained_edge[1];
    } else {
        return this.constrained_edge[2];
    }
};

Triangle.prototype.setConstrainedEdgeCW = function(p, ce) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.constrained_edge[1] = ce;
    } else if (p === this.points_[1]) {
        this.constrained_edge[2] = ce;
    } else {
        this.constrained_edge[0] = ce;
    }
};

Triangle.prototype.setConstrainedEdgeCCW = function(p, ce) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.constrained_edge[2] = ce;
    } else if (p === this.points_[1]) {
        this.constrained_edge[0] = ce;
    } else {
        this.constrained_edge[1] = ce;
    }
};

Triangle.prototype.getDelaunayEdgeCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.delaunay_edge[1];
    } else if (p === this.points_[1]) {
        return this.delaunay_edge[2];
    } else {
        return this.delaunay_edge[0];
    }
};

Triangle.prototype.getDelaunayEdgeCCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.delaunay_edge[2];
    } else if (p === this.points_[1]) {
        return this.delaunay_edge[0];
    } else {
        return this.delaunay_edge[1];
    }
};

Triangle.prototype.setDelaunayEdgeCW = function(p, e) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.delaunay_edge[1] = e;
    } else if (p === this.points_[1]) {
        this.delaunay_edge[2] = e;
    } else {
        this.delaunay_edge[0] = e;
    }
};

Triangle.prototype.setDelaunayEdgeCCW = function(p, e) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.delaunay_edge[2] = e;
    } else if (p === this.points_[1]) {
        this.delaunay_edge[0] = e;
    } else {
        this.delaunay_edge[1] = e;
    }
};

/**
 * The neighbor across to given point.
 */
Triangle.prototype.neighborAcross = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.neighbors_[0];
    } else if (p === this.points_[1]) {
        return this.neighbors_[1];
    } else {
        return this.neighbors_[2];
    }
};

Triangle.prototype.oppositePoint = function(t, p) {
    var cw = t.pointCW(p);
    return this.pointCW(cw);
};

/**
 * Legalize triangle by rotating clockwise around oPoint
 * @param {Point} opoint
 * @param {Point} npoint
 */
Triangle.prototype.legalize = function(opoint, npoint) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (opoint === points[0]) {
        points[1] = points[0];
        points[0] = points[2];
        points[2] = npoint;
    } else if (opoint === points[1]) {
        points[2] = points[1];
        points[1] = points[0];
        points[0] = npoint;
    } else if (opoint === points[2]) {
        points[0] = points[2];
        points[2] = points[1];
        points[1] = npoint;
    } else {
        throw new Error('poly2tri Invalid Triangle.legalize() call');
    }
};

/**
 * Returns the index of a point in the triangle. 
 * The point *must* be a reference to one of the triangle's vertices.
 * @param {Point} p Point object
 * @returns {Number} index 0, 1 or 2
 */
Triangle.prototype.index = function(p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
        return 0;
    } else if (p === points[1]) {
        return 1;
    } else if (p === points[2]) {
        return 2;
    } else {
        throw new Error('poly2tri Invalid Triangle.index() call');
    }
};

Triangle.prototype.edgeIndex = function(p1, p2) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p1 === points[0]) {
        if (p2 === points[1]) {
            return 2;
        } else if (p2 === points[2]) {
            return 1;
        }
    } else if (p1 === points[1]) {
        if (p2 === points[2]) {
            return 0;
        } else if (p2 === points[0]) {
            return 2;
        }
    } else if (p1 === points[2]) {
        if (p2 === points[0]) {
            return 1;
        } else if (p2 === points[1]) {
            return 0;
        }
    }
    return -1;
};

/**
 * Mark an edge of this triangle as constrained.<br>
 * This method takes either 1 parameter (an edge index or an Edge instance) or
 * 2 parameters (two Point instances defining the edge of the triangle).
 */
Triangle.prototype.markConstrainedEdgeByIndex = function(index) {
    this.constrained_edge[index] = true;
};
Triangle.prototype.markConstrainedEdgeByEdge = function(edge) {
    this.markConstrainedEdgeByPoints(edge.p, edge.q);
};
Triangle.prototype.markConstrainedEdgeByPoints = function(p, q) {
    var points = this.points_;
    // Here we are comparing point references, not values        
    if ((q === points[0] && p === points[1]) || (q === points[1] && p === points[0])) {
        this.constrained_edge[2] = true;
    } else if ((q === points[0] && p === points[2]) || (q === points[2] && p === points[0])) {
        this.constrained_edge[1] = true;
    } else if ((q === points[1] && p === points[2]) || (q === points[2] && p === points[1])) {
        this.constrained_edge[0] = true;
    }
};


// ---------------------------------------------------------Exports (public API)

module.exports = Triangle;

},{"./xy":10}],9:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2013, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2013, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";

/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var EPSILON = 1e-12;

var Orientation = {
    "CW": 1,
    "CCW": -1,
    "COLLINEAR": 0
};

/**
 * Forumla to calculate signed area<br>
 * Positive if CCW<br>
 * Negative if CW<br>
 * 0 if collinear<br>
 * <pre>
 * A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)
 *              =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)
 * </pre>
 * 
 * @param   pa,pb,pc   any "Point like" objects with {x,y} (duck typing)
 */
function orient2d(pa, pb, pc) {
    var detleft = (pa.x - pc.x) * (pb.y - pc.y);
    var detright = (pa.y - pc.y) * (pb.x - pc.x);
    var val = detleft - detright;
    if (val > -(EPSILON) && val < (EPSILON)) {
        return Orientation.COLLINEAR;
    } else if (val > 0) {
        return Orientation.CCW;
    } else {
        return Orientation.CW;
    }
}

/**
 *  
 * @param   pa,pb,pc,pd   any "Point like" objects with {x,y} (duck typing)
 */
function inScanArea(pa, pb, pc, pd) {
    var oadb = (pa.x - pb.x) * (pd.y - pb.y) - (pd.x - pb.x) * (pa.y - pb.y);
    if (oadb >= -EPSILON) {
        return false;
    }

    var oadc = (pa.x - pc.x) * (pd.y - pc.y) - (pd.x - pc.x) * (pa.y - pc.y);
    if (oadc <= EPSILON) {
        return false;
    }
    return true;
}


// ----------------------------------------------------------------------Exports

module.exports = {
    EPSILON: EPSILON,
    Orientation: Orientation,
    orient2d: orient2d,
    inScanArea: inScanArea
};

},{}],10:[function(_dereq_,module,exports){
/*
 * Poly2Tri Copyright (c) 2009-2013, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2013, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

"use strict";

/*
 * The following functions operate on "Point" or any "Point like" object 
 * with {x,y} (duck typing).
 */


/**
 * Point pretty printing ex. <i>"(5;42)"</i>)
 * @param   p   any "Point like" object with {x,y} 
 * @returns {String}
 */
function toStringBase(p) {
    return ("(" + p.x + ";" + p.y + ")");
}
function toString(p) {
    // Try a custom toString first, and fallback to own implementation if none
    var s = p.toString();
    return (s === '[object Object]' ? toStringBase(p) : s);
}

/**
 * Compare two points component-wise. Ordered by y axis first, then x axis.
 * @param   a,b   any "Point like" objects with {x,y} 
 * @return <code>&lt; 0</code> if <code>a &lt; b</code>, 
 *         <code>&gt; 0</code> if <code>a &gt; b</code>, 
 *         <code>0</code> otherwise.
 */
function compare(a, b) {
    if (a.y === b.y) {
        return a.x - b.x;
    } else {
        return a.y - b.y;
    }
}

/**
 * Test two Point objects for equality.
 * @param   a,b   any "Point like" objects with {x,y} 
 * @return <code>True</code> if <code>a == b</code>, <code>false</code> otherwise.
 */
function equals(a, b) {
    return a.x === b.x && a.y === b.y;
}


module.exports = {
    toString: toString,
    toStringBase: toStringBase,
    compare: compare,
    equals: equals
};

},{}]},{},[5])
(5)
});// rev 452
/********************************************************************************
 *                                                                              *
 * Author    :  Angus Johnson                                                   *
 * Version   :  6.1.3                                                           *
 * Date      :  19 January 2014                                                 *
 * Website   :  http://www.angusj.com                                           *
 * Copyright :  Angus Johnson 2010-2014                                         *
 *                                                                              *
 * License:                                                                     *
 * Use, modification & distribution is subject to Boost Software License Ver 1. *
 * http://www.boost.org/LICENSE_1_0.txt                                         *
 *                                                                              *
 * Attributions:                                                                *
 * The code in this library is an extension of Bala Vatti's clipping algorithm: *
 * "A generic solution to polygon clipping"                                     *
 * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *
 * http://portal.acm.org/citation.cfm?id=129906                                 *
 *                                                                              *
 * Computer graphics and geometric modeling: implementation and algorithms      *
 * By Max K. Agoston                                                            *
 * Springer; 1 edition (January 4, 2005)                                        *
 * http://books.google.com/books?q=vatti+clipping+agoston                       *
 *                                                                              *
 * See also:                                                                    *
 * "Polygon Offsetting by Computing Winding Numbers"                            *
 * Paper no. DETC2005-85513 pp. 565-575                                         *
 * ASME 2005 International Design Engineering Technical Conferences             *
 * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *
 * September 24-28, 2005 , Long Beach, California, USA                          *
 * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *
 *                                                                              *
 *******************************************************************************/
/*******************************************************************************
 *                                                                              *
 * Author    :  Timo                                                            *
 * Version   :  6.1.3.1                                                         *
 * Date      :  21 January 2014                                                 *
 *                                                                              *
 * This is a translation of the C# Clipper library to Javascript.               *
 * Int128 struct of C# is implemented using JSBN of Tom Wu.                     *
 * Because Javascript lacks support for 64-bit integers, the space              *
 * is a little more restricted than in C# version.                              *
 *                                                                              *
 * C# version has support for coordinate space:                                 *
 * +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *
 * while Javascript version has support for space:                              *
 * +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *
 *                                                                              *
 * Tom Wu's JSBN proved to be the fastest big integer library:                  *
 * http://jsperf.com/big-integer-library-test                                   *
 *                                                                              *
 * This class can be made simpler when (if ever) 64-bit integer support comes.  *
 *                                                                              *
 *******************************************************************************/
/*******************************************************************************
 *                                                                              *
 * Basic JavaScript BN library - subset useful for RSA encryption.              *
 * http://www-cs-students.stanford.edu/~tjw/jsbn/                               *
 * Copyright (c) 2005  Tom Wu                                                   *
 * All Rights Reserved.                                                         *
 * See "LICENSE" for details:                                                   *
 * http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *
 *                                                                              *
 *******************************************************************************/
(function ()
{
  "use strict";
  //use_int32: When enabled 32bit ints are used instead of 64bit ints. This
  //improve performance but coordinate values are limited to the range +/- 46340
  var use_int32 = false;
  //use_xyz: adds a Z member to IntPoint. Adds a minor cost to performance.
  var use_xyz = false;
  //UseLines: Enables line clipping. Adds a very minor cost to performance.
  var use_lines = true;
  //use_deprecated: Enables support for the obsolete OffsetPaths() function
  //which has been replace with the ClipperOffset class.
  var use_deprecated = false;

  var ClipperLib = {};
  var isNode = false;
  if (typeof module !== 'undefined' && module.exports)
  {
    module.exports = ClipperLib;
    isNode = true;
  }
  else
  {
    if (typeof (document) !== "undefined") window.ClipperLib = ClipperLib;
    else self['ClipperLib'] = ClipperLib;
  }
  var navigator_appName;
  if (!isNode)
  {
    var nav = navigator.userAgent.toString().toLowerCase();
    navigator_appName = navigator.appName;
  }
  else
  {
    var nav = "chrome"; // Node.js uses Chrome's V8 engine
    navigator_appName = "Netscape"; // Firefox, Chrome and Safari returns "Netscape", so Node.js should also
  }
  // Browser test to speedup performance critical functions
  var browser = {};
  if (nav.indexOf("chrome") != -1 && nav.indexOf("chromium") == -1) browser.chrome = 1;
  else browser.chrome = 0;
  if (nav.indexOf("chromium") != -1) browser.chromium = 1;
  else browser.chromium = 0;
  if (nav.indexOf("safari") != -1 && nav.indexOf("chrome") == -1 && nav.indexOf("chromium") == -1) browser.safari = 1;
  else browser.safari = 0;
  if (nav.indexOf("firefox") != -1) browser.firefox = 1;
  else browser.firefox = 0;
  if (nav.indexOf("firefox/17") != -1) browser.firefox17 = 1;
  else browser.firefox17 = 0;
  if (nav.indexOf("firefox/15") != -1) browser.firefox15 = 1;
  else browser.firefox15 = 0;
  if (nav.indexOf("firefox/3") != -1) browser.firefox3 = 1;
  else browser.firefox3 = 0;
  if (nav.indexOf("opera") != -1) browser.opera = 1;
  else browser.opera = 0;
  if (nav.indexOf("msie 10") != -1) browser.msie10 = 1;
  else browser.msie10 = 0;
  if (nav.indexOf("msie 9") != -1) browser.msie9 = 1;
  else browser.msie9 = 0;
  if (nav.indexOf("msie 8") != -1) browser.msie8 = 1;
  else browser.msie8 = 0;
  if (nav.indexOf("msie 7") != -1) browser.msie7 = 1;
  else browser.msie7 = 0;
  if (nav.indexOf("msie ") != -1) browser.msie = 1;
  else browser.msie = 0;
  // patch, treat ejecta as safari
  if ( nav.indexOf("ejecta") != -1 ) browser.safari = 1; else browser.safari = 0;
  ClipperLib.biginteger_used = null;
  // Copyright (c) 2005  Tom Wu
  // All Rights Reserved.
  // See "LICENSE" for details.
  // Basic JavaScript BN library - subset useful for RSA encryption.
  // Bits per digit
  var dbits;
  // JavaScript engine analysis
  var canary = 0xdeadbeefcafe;
  var j_lm = ((canary & 0xffffff) == 0xefcafe);
  // (public) Constructor
  function BigInteger(a, b, c)
  {
    // This test variable can be removed,
    // but at least for performance tests it is useful piece of knowledge
    // This is the only ClipperLib related variable in BigInteger library
    ClipperLib.biginteger_used = 1;
    if (a != null)
      if ("number" == typeof a && "undefined" == typeof (b)) this.fromInt(a); // faster conversion
      else if ("number" == typeof a) this.fromNumber(a, b, c);
    else if (b == null && "string" != typeof a) this.fromString(a, 256);
    else this.fromString(a, b);
  }
  // return new, unset BigInteger
  function nbi()
  {
    return new BigInteger(null);
  }
  // am: Compute w_j += (x*this_i), propagate carries,
  // c is initial carry, returns final carry.
  // c < 3*dvalue, x < 2*dvalue, this_i < dvalue
  // We need to select the fastest one that works in this environment.
  // am1: use a single mult and divide to get the high bits,
  // max digit bits should be 26 because
  // max internal value = 2*dvalue^2-2*dvalue (< 2^53)
  function am1(i, x, w, j, c, n)
  {
    while (--n >= 0)
    {
      var v = x * this[i++] + w[j] + c;
      c = Math.floor(v / 0x4000000);
      w[j++] = v & 0x3ffffff;
    }
    return c;
  }
  // am2 avoids a big mult-and-extract completely.
  // Max digit bits should be <= 30 because we do bitwise ops
  // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
  function am2(i, x, w, j, c, n)
  {
    var xl = x & 0x7fff,
      xh = x >> 15;
    while (--n >= 0)
    {
      var l = this[i] & 0x7fff;
      var h = this[i++] >> 15;
      var m = xh * l + h * xl;
      l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);
      c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
      w[j++] = l & 0x3fffffff;
    }
    return c;
  }
  // Alternately, set max digit bits to 28 since some
  // browsers slow down when dealing with 32-bit numbers.
  function am3(i, x, w, j, c, n)
  {
    var xl = x & 0x3fff,
      xh = x >> 14;
    while (--n >= 0)
    {
      var l = this[i] & 0x3fff;
      var h = this[i++] >> 14;
      var m = xh * l + h * xl;
      l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;
      c = (l >> 28) + (m >> 14) + xh * h;
      w[j++] = l & 0xfffffff;
    }
    return c;
  }
  if (j_lm && (navigator_appName == "Microsoft Internet Explorer"))
  {
    BigInteger.prototype.am = am2;
    dbits = 30;
  }
  else if (j_lm && (navigator_appName != "Netscape"))
  {
    BigInteger.prototype.am = am1;
    dbits = 26;
  }
  else
  { // Mozilla/Netscape seems to prefer am3
    BigInteger.prototype.am = am3;
    dbits = 28;
  }
  BigInteger.prototype.DB = dbits;
  BigInteger.prototype.DM = ((1 << dbits) - 1);
  BigInteger.prototype.DV = (1 << dbits);
  var BI_FP = 52;
  BigInteger.prototype.FV = Math.pow(2, BI_FP);
  BigInteger.prototype.F1 = BI_FP - dbits;
  BigInteger.prototype.F2 = 2 * dbits - BI_FP;
  // Digit conversions
  var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
  var BI_RC = new Array();
  var rr, vv;
  rr = "0".charCodeAt(0);
  for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
  rr = "a".charCodeAt(0);
  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
  rr = "A".charCodeAt(0);
  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

  function int2char(n)
  {
    return BI_RM.charAt(n);
  }

  function intAt(s, i)
  {
    var c = BI_RC[s.charCodeAt(i)];
    return (c == null) ? -1 : c;
  }
  // (protected) copy this to r
  function bnpCopyTo(r)
  {
    for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];
    r.t = this.t;
    r.s = this.s;
  }
  // (protected) set from integer value x, -DV <= x < DV
  function bnpFromInt(x)
  {
    this.t = 1;
    this.s = (x < 0) ? -1 : 0;
    if (x > 0) this[0] = x;
    else if (x < -1) this[0] = x + this.DV;
    else this.t = 0;
  }
  // return bigint initialized to value
  function nbv(i)
  {
    var r = nbi();
    r.fromInt(i);
    return r;
  }
  // (protected) set from string and radix
  function bnpFromString(s, b)
  {
    var k;
    if (b == 16) k = 4;
    else if (b == 8) k = 3;
    else if (b == 256) k = 8; // byte array
    else if (b == 2) k = 1;
    else if (b == 32) k = 5;
    else if (b == 4) k = 2;
    else
    {
      this.fromRadix(s, b);
      return;
    }
    this.t = 0;
    this.s = 0;
    var i = s.length,
      mi = false,
      sh = 0;
    while (--i >= 0)
    {
      var x = (k == 8) ? s[i] & 0xff : intAt(s, i);
      if (x < 0)
      {
        if (s.charAt(i) == "-") mi = true;
        continue;
      }
      mi = false;
      if (sh == 0)
        this[this.t++] = x;
      else if (sh + k > this.DB)
      {
        this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;
        this[this.t++] = (x >> (this.DB - sh));
      }
      else
        this[this.t - 1] |= x << sh;
      sh += k;
      if (sh >= this.DB) sh -= this.DB;
    }
    if (k == 8 && (s[0] & 0x80) != 0)
    {
      this.s = -1;
      if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;
    }
    this.clamp();
    if (mi) BigInteger.ZERO.subTo(this, this);
  }
  // (protected) clamp off excess high words
  function bnpClamp()
  {
    var c = this.s & this.DM;
    while (this.t > 0 && this[this.t - 1] == c)--this.t;
  }
  // (public) return string representation in given radix
  function bnToString(b)
  {
    if (this.s < 0) return "-" + this.negate().toString(b);
    var k;
    if (b == 16) k = 4;
    else if (b == 8) k = 3;
    else if (b == 2) k = 1;
    else if (b == 32) k = 5;
    else if (b == 4) k = 2;
    else return this.toRadix(b);
    var km = (1 << k) - 1,
      d, m = false,
      r = "",
      i = this.t;
    var p = this.DB - (i * this.DB) % k;
    if (i-- > 0)
    {
      if (p < this.DB && (d = this[i] >> p) > 0)
      {
        m = true;
        r = int2char(d);
      }
      while (i >= 0)
      {
        if (p < k)
        {
          d = (this[i] & ((1 << p) - 1)) << (k - p);
          d |= this[--i] >> (p += this.DB - k);
        }
        else
        {
          d = (this[i] >> (p -= k)) & km;
          if (p <= 0)
          {
            p += this.DB;
            --i;
          }
        }
        if (d > 0) m = true;
        if (m) r += int2char(d);
      }
    }
    return m ? r : "0";
  }
  // (public) -this
  function bnNegate()
  {
    var r = nbi();
    BigInteger.ZERO.subTo(this, r);
    return r;
  }
  // (public) |this|
  function bnAbs()
  {
    return (this.s < 0) ? this.negate() : this;
  }
  // (public) return + if this > a, - if this < a, 0 if equal
  function bnCompareTo(a)
  {
    var r = this.s - a.s;
    if (r != 0) return r;
    var i = this.t;
    r = i - a.t;
    if (r != 0) return (this.s < 0) ? -r : r;
    while (--i >= 0)
      if ((r = this[i] - a[i]) != 0) return r;
    return 0;
  }
  // returns bit length of the integer x
  function nbits(x)
  {
    var r = 1,
      t;
    if ((t = x >>> 16) != 0)
    {
      x = t;
      r += 16;
    }
    if ((t = x >> 8) != 0)
    {
      x = t;
      r += 8;
    }
    if ((t = x >> 4) != 0)
    {
      x = t;
      r += 4;
    }
    if ((t = x >> 2) != 0)
    {
      x = t;
      r += 2;
    }
    if ((t = x >> 1) != 0)
    {
      x = t;
      r += 1;
    }
    return r;
  }
  // (public) return the number of bits in "this"
  function bnBitLength()
  {
    if (this.t <= 0) return 0;
    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));
  }
  // (protected) r = this << n*DB
  function bnpDLShiftTo(n, r)
  {
    var i;
    for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];
    for (i = n - 1; i >= 0; --i) r[i] = 0;
    r.t = this.t + n;
    r.s = this.s;
  }
  // (protected) r = this >> n*DB
  function bnpDRShiftTo(n, r)
  {
    for (var i = n; i < this.t; ++i) r[i - n] = this[i];
    r.t = Math.max(this.t - n, 0);
    r.s = this.s;
  }
  // (protected) r = this << n
  function bnpLShiftTo(n, r)
  {
    var bs = n % this.DB;
    var cbs = this.DB - bs;
    var bm = (1 << cbs) - 1;
    var ds = Math.floor(n / this.DB),
      c = (this.s << bs) & this.DM,
      i;
    for (i = this.t - 1; i >= 0; --i)
    {
      r[i + ds + 1] = (this[i] >> cbs) | c;
      c = (this[i] & bm) << bs;
    }
    for (i = ds - 1; i >= 0; --i) r[i] = 0;
    r[ds] = c;
    r.t = this.t + ds + 1;
    r.s = this.s;
    r.clamp();
  }
  // (protected) r = this >> n
  function bnpRShiftTo(n, r)
  {
    r.s = this.s;
    var ds = Math.floor(n / this.DB);
    if (ds >= this.t)
    {
      r.t = 0;
      return;
    }
    var bs = n % this.DB;
    var cbs = this.DB - bs;
    var bm = (1 << bs) - 1;
    r[0] = this[ds] >> bs;
    for (var i = ds + 1; i < this.t; ++i)
    {
      r[i - ds - 1] |= (this[i] & bm) << cbs;
      r[i - ds] = this[i] >> bs;
    }
    if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;
    r.t = this.t - ds;
    r.clamp();
  }
  // (protected) r = this - a
  function bnpSubTo(a, r)
  {
    var i = 0,
      c = 0,
      m = Math.min(a.t, this.t);
    while (i < m)
    {
      c += this[i] - a[i];
      r[i++] = c & this.DM;
      c >>= this.DB;
    }
    if (a.t < this.t)
    {
      c -= a.s;
      while (i < this.t)
      {
        c += this[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      c += this.s;
    }
    else
    {
      c += this.s;
      while (i < a.t)
      {
        c -= a[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      c -= a.s;
    }
    r.s = (c < 0) ? -1 : 0;
    if (c < -1) r[i++] = this.DV + c;
    else if (c > 0) r[i++] = c;
    r.t = i;
    r.clamp();
  }
  // (protected) r = this * a, r != this,a (HAC 14.12)
  // "this" should be the larger one if appropriate.
  function bnpMultiplyTo(a, r)
  {
    var x = this.abs(),
      y = a.abs();
    var i = x.t;
    r.t = i + y.t;
    while (--i >= 0) r[i] = 0;
    for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
    r.s = 0;
    r.clamp();
    if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
  }
  // (protected) r = this^2, r != this (HAC 14.16)
  function bnpSquareTo(r)
  {
    var x = this.abs();
    var i = r.t = 2 * x.t;
    while (--i >= 0) r[i] = 0;
    for (i = 0; i < x.t - 1; ++i)
    {
      var c = x.am(i, x[i], r, 2 * i, 0, 1);
      if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV)
      {
        r[i + x.t] -= x.DV;
        r[i + x.t + 1] = 1;
      }
    }
    if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
    r.s = 0;
    r.clamp();
  }
  // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
  // r != q, this != m.  q or r may be null.
  function bnpDivRemTo(m, q, r)
  {
    var pm = m.abs();
    if (pm.t <= 0) return;
    var pt = this.abs();
    if (pt.t < pm.t)
    {
      if (q != null) q.fromInt(0);
      if (r != null) this.copyTo(r);
      return;
    }
    if (r == null) r = nbi();
    var y = nbi(),
      ts = this.s,
      ms = m.s;
    var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus
    if (nsh > 0)
    {
      pm.lShiftTo(nsh, y);
      pt.lShiftTo(nsh, r);
    }
    else
    {
      pm.copyTo(y);
      pt.copyTo(r);
    }
    var ys = y.t;
    var y0 = y[ys - 1];
    if (y0 == 0) return;
    var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);
    var d1 = this.FV / yt,
      d2 = (1 << this.F1) / yt,
      e = 1 << this.F2;
    var i = r.t,
      j = i - ys,
      t = (q == null) ? nbi() : q;
    y.dlShiftTo(j, t);
    if (r.compareTo(t) >= 0)
    {
      r[r.t++] = 1;
      r.subTo(t, r);
    }
    BigInteger.ONE.dlShiftTo(ys, t);
    t.subTo(y, y); // "negative" y so we can replace sub with am later
    while (y.t < ys) y[y.t++] = 0;
    while (--j >= 0)
    {
      // Estimate quotient digit
      var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
      if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd)
      { // Try it out
        y.dlShiftTo(j, t);
        r.subTo(t, r);
        while (r[i] < --qd) r.subTo(t, r);
      }
    }
    if (q != null)
    {
      r.drShiftTo(ys, q);
      if (ts != ms) BigInteger.ZERO.subTo(q, q);
    }
    r.t = ys;
    r.clamp();
    if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder
    if (ts < 0) BigInteger.ZERO.subTo(r, r);
  }
  // (public) this mod a
  function bnMod(a)
  {
    var r = nbi();
    this.abs().divRemTo(a, null, r);
    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
    return r;
  }
  // Modular reduction using "classic" algorithm
  function Classic(m)
  {
    this.m = m;
  }

  function cConvert(x)
  {
    if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
    else return x;
  }

  function cRevert(x)
  {
    return x;
  }

  function cReduce(x)
  {
    x.divRemTo(this.m, null, x);
  }

  function cMulTo(x, y, r)
  {
    x.multiplyTo(y, r);
    this.reduce(r);
  }

  function cSqrTo(x, r)
  {
    x.squareTo(r);
    this.reduce(r);
  }
  Classic.prototype.convert = cConvert;
  Classic.prototype.revert = cRevert;
  Classic.prototype.reduce = cReduce;
  Classic.prototype.mulTo = cMulTo;
  Classic.prototype.sqrTo = cSqrTo;
  // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
  // justification:
  //         xy == 1 (mod m)
  //         xy =  1+km
  //   xy(2-xy) = (1+km)(1-km)
  // x[y(2-xy)] = 1-k^2m^2
  // x[y(2-xy)] == 1 (mod m^2)
  // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
  // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
  // JS multiply "overflows" differently from C/C++, so care is needed here.
  function bnpInvDigit()
  {
    if (this.t < 1) return 0;
    var x = this[0];
    if ((x & 1) == 0) return 0;
    var y = x & 3; // y == 1/x mod 2^2
    y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4
    y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8
    y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16
    // last step - calculate inverse mod DV directly;
    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
    y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits
    // we really want the negative inverse, and -DV < y < DV
    return (y > 0) ? this.DV - y : -y;
  }
  // Montgomery reduction
  function Montgomery(m)
  {
    this.m = m;
    this.mp = m.invDigit();
    this.mpl = this.mp & 0x7fff;
    this.mph = this.mp >> 15;
    this.um = (1 << (m.DB - 15)) - 1;
    this.mt2 = 2 * m.t;
  }
  // xR mod m
  function montConvert(x)
  {
    var r = nbi();
    x.abs().dlShiftTo(this.m.t, r);
    r.divRemTo(this.m, null, r);
    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
    return r;
  }
  // x/R mod m
  function montRevert(x)
  {
    var r = nbi();
    x.copyTo(r);
    this.reduce(r);
    return r;
  }
  // x = x/R mod m (HAC 14.32)
  function montReduce(x)
  {
    while (x.t <= this.mt2) // pad x so am has enough room later
      x[x.t++] = 0;
    for (var i = 0; i < this.m.t; ++i)
    {
      // faster way of calculating u0 = x[i]*mp mod DV
      var j = x[i] & 0x7fff;
      var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;
      // use am to combine the multiply-shift-add into one call
      j = i + this.m.t;
      x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
      // propagate carry
      while (x[j] >= x.DV)
      {
        x[j] -= x.DV;
        x[++j]++;
      }
    }
    x.clamp();
    x.drShiftTo(this.m.t, x);
    if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
  }
  // r = "x^2/R mod m"; x != r
  function montSqrTo(x, r)
  {
    x.squareTo(r);
    this.reduce(r);
  }
  // r = "xy/R mod m"; x,y != r
  function montMulTo(x, y, r)
  {
    x.multiplyTo(y, r);
    this.reduce(r);
  }
  Montgomery.prototype.convert = montConvert;
  Montgomery.prototype.revert = montRevert;
  Montgomery.prototype.reduce = montReduce;
  Montgomery.prototype.mulTo = montMulTo;
  Montgomery.prototype.sqrTo = montSqrTo;
  // (protected) true iff this is even
  function bnpIsEven()
  {
    return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;
  }
  // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
  function bnpExp(e, z)
  {
    if (e > 0xffffffff || e < 1) return BigInteger.ONE;
    var r = nbi(),
      r2 = nbi(),
      g = z.convert(this),
      i = nbits(e) - 1;
    g.copyTo(r);
    while (--i >= 0)
    {
      z.sqrTo(r, r2);
      if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);
      else
      {
        var t = r;
        r = r2;
        r2 = t;
      }
    }
    return z.revert(r);
  }
  // (public) this^e % m, 0 <= e < 2^32
  function bnModPowInt(e, m)
  {
    var z;
    if (e < 256 || m.isEven()) z = new Classic(m);
    else z = new Montgomery(m);
    return this.exp(e, z);
  }
  // protected
  BigInteger.prototype.copyTo = bnpCopyTo;
  BigInteger.prototype.fromInt = bnpFromInt;
  BigInteger.prototype.fromString = bnpFromString;
  BigInteger.prototype.clamp = bnpClamp;
  BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
  BigInteger.prototype.drShiftTo = bnpDRShiftTo;
  BigInteger.prototype.lShiftTo = bnpLShiftTo;
  BigInteger.prototype.rShiftTo = bnpRShiftTo;
  BigInteger.prototype.subTo = bnpSubTo;
  BigInteger.prototype.multiplyTo = bnpMultiplyTo;
  BigInteger.prototype.squareTo = bnpSquareTo;
  BigInteger.prototype.divRemTo = bnpDivRemTo;
  BigInteger.prototype.invDigit = bnpInvDigit;
  BigInteger.prototype.isEven = bnpIsEven;
  BigInteger.prototype.exp = bnpExp;
  // public
  BigInteger.prototype.toString = bnToString;
  BigInteger.prototype.negate = bnNegate;
  BigInteger.prototype.abs = bnAbs;
  BigInteger.prototype.compareTo = bnCompareTo;
  BigInteger.prototype.bitLength = bnBitLength;
  BigInteger.prototype.mod = bnMod;
  BigInteger.prototype.modPowInt = bnModPowInt;
  // "constants"
  BigInteger.ZERO = nbv(0);
  BigInteger.ONE = nbv(1);
  // Copyright (c) 2005-2009  Tom Wu
  // All Rights Reserved.
  // See "LICENSE" for details.
  // Extended JavaScript BN functions, required for RSA private ops.
  // Version 1.1: new BigInteger("0", 10) returns "proper" zero
  // Version 1.2: square() API, isProbablePrime fix
  // (public)
  function bnClone()
  {
    var r = nbi();
    this.copyTo(r);
    return r;
  }
  // (public) return value as integer
  function bnIntValue()
  {
    if (this.s < 0)
    {
      if (this.t == 1) return this[0] - this.DV;
      else if (this.t == 0) return -1;
    }
    else if (this.t == 1) return this[0];
    else if (this.t == 0) return 0;
    // assumes 16 < DB < 32
    return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];
  }
  // (public) return value as byte
  function bnByteValue()
  {
    return (this.t == 0) ? this.s : (this[0] << 24) >> 24;
  }
  // (public) return value as short (assumes DB>=16)
  function bnShortValue()
  {
    return (this.t == 0) ? this.s : (this[0] << 16) >> 16;
  }
  // (protected) return x s.t. r^x < DV
  function bnpChunkSize(r)
  {
    return Math.floor(Math.LN2 * this.DB / Math.log(r));
  }
  // (public) 0 if this == 0, 1 if this > 0
  function bnSigNum()
  {
    if (this.s < 0) return -1;
    else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
    else return 1;
  }
  // (protected) convert to radix string
  function bnpToRadix(b)
  {
    if (b == null) b = 10;
    if (this.signum() == 0 || b < 2 || b > 36) return "0";
    var cs = this.chunkSize(b);
    var a = Math.pow(b, cs);
    var d = nbv(a),
      y = nbi(),
      z = nbi(),
      r = "";
    this.divRemTo(d, y, z);
    while (y.signum() > 0)
    {
      r = (a + z.intValue()).toString(b).substr(1) + r;
      y.divRemTo(d, y, z);
    }
    return z.intValue().toString(b) + r;
  }
  // (protected) convert from radix string
  function bnpFromRadix(s, b)
  {
    this.fromInt(0);
    if (b == null) b = 10;
    var cs = this.chunkSize(b);
    var d = Math.pow(b, cs),
      mi = false,
      j = 0,
      w = 0;
    for (var i = 0; i < s.length; ++i)
    {
      var x = intAt(s, i);
      if (x < 0)
      {
        if (s.charAt(i) == "-" && this.signum() == 0) mi = true;
        continue;
      }
      w = b * w + x;
      if (++j >= cs)
      {
        this.dMultiply(d);
        this.dAddOffset(w, 0);
        j = 0;
        w = 0;
      }
    }
    if (j > 0)
    {
      this.dMultiply(Math.pow(b, j));
      this.dAddOffset(w, 0);
    }
    if (mi) BigInteger.ZERO.subTo(this, this);
  }
  // (protected) alternate constructor
  function bnpFromNumber(a, b, c)
  {
    if ("number" == typeof b)
    {
      // new BigInteger(int,int,RNG)
      if (a < 2) this.fromInt(1);
      else
      {
        this.fromNumber(a, c);
        if (!this.testBit(a - 1)) // force MSB set
          this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
        if (this.isEven()) this.dAddOffset(1, 0); // force odd
        while (!this.isProbablePrime(b))
        {
          this.dAddOffset(2, 0);
          if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
        }
      }
    }
    else
    {
      // new BigInteger(int,RNG)
      var x = new Array(),
        t = a & 7;
      x.length = (a >> 3) + 1;
      b.nextBytes(x);
      if (t > 0) x[0] &= ((1 << t) - 1);
      else x[0] = 0;
      this.fromString(x, 256);
    }
  }
  // (public) convert to bigendian byte array
  function bnToByteArray()
  {
    var i = this.t,
      r = new Array();
    r[0] = this.s;
    var p = this.DB - (i * this.DB) % 8,
      d, k = 0;
    if (i-- > 0)
    {
      if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
        r[k++] = d | (this.s << (this.DB - p));
      while (i >= 0)
      {
        if (p < 8)
        {
          d = (this[i] & ((1 << p) - 1)) << (8 - p);
          d |= this[--i] >> (p += this.DB - 8);
        }
        else
        {
          d = (this[i] >> (p -= 8)) & 0xff;
          if (p <= 0)
          {
            p += this.DB;
            --i;
          }
        }
        if ((d & 0x80) != 0) d |= -256;
        if (k == 0 && (this.s & 0x80) != (d & 0x80))++k;
        if (k > 0 || d != this.s) r[k++] = d;
      }
    }
    return r;
  }

  function bnEquals(a)
  {
    return (this.compareTo(a) == 0);
  }

  function bnMin(a)
  {
    return (this.compareTo(a) < 0) ? this : a;
  }

  function bnMax(a)
  {
    return (this.compareTo(a) > 0) ? this : a;
  }
  // (protected) r = this op a (bitwise)
  function bnpBitwiseTo(a, op, r)
  {
    var i, f, m = Math.min(a.t, this.t);
    for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);
    if (a.t < this.t)
    {
      f = a.s & this.DM;
      for (i = m; i < this.t; ++i) r[i] = op(this[i], f);
      r.t = this.t;
    }
    else
    {
      f = this.s & this.DM;
      for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);
      r.t = a.t;
    }
    r.s = op(this.s, a.s);
    r.clamp();
  }
  // (public) this & a
  function op_and(x, y)
  {
    return x & y;
  }

  function bnAnd(a)
  {
    var r = nbi();
    this.bitwiseTo(a, op_and, r);
    return r;
  }
  // (public) this | a
  function op_or(x, y)
  {
    return x | y;
  }

  function bnOr(a)
  {
    var r = nbi();
    this.bitwiseTo(a, op_or, r);
    return r;
  }
  // (public) this ^ a
  function op_xor(x, y)
  {
    return x ^ y;
  }

  function bnXor(a)
  {
    var r = nbi();
    this.bitwiseTo(a, op_xor, r);
    return r;
  }
  // (public) this & ~a
  function op_andnot(x, y)
  {
    return x & ~y;
  }

  function bnAndNot(a)
  {
    var r = nbi();
    this.bitwiseTo(a, op_andnot, r);
    return r;
  }
  // (public) ~this
  function bnNot()
  {
    var r = nbi();
    for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];
    r.t = this.t;
    r.s = ~this.s;
    return r;
  }
  // (public) this << n
  function bnShiftLeft(n)
  {
    var r = nbi();
    if (n < 0) this.rShiftTo(-n, r);
    else this.lShiftTo(n, r);
    return r;
  }
  // (public) this >> n
  function bnShiftRight(n)
  {
    var r = nbi();
    if (n < 0) this.lShiftTo(-n, r);
    else this.rShiftTo(n, r);
    return r;
  }
  // return index of lowest 1-bit in x, x < 2^31
  function lbit(x)
  {
    if (x == 0) return -1;
    var r = 0;
    if ((x & 0xffff) == 0)
    {
      x >>= 16;
      r += 16;
    }
    if ((x & 0xff) == 0)
    {
      x >>= 8;
      r += 8;
    }
    if ((x & 0xf) == 0)
    {
      x >>= 4;
      r += 4;
    }
    if ((x & 3) == 0)
    {
      x >>= 2;
      r += 2;
    }
    if ((x & 1) == 0)++r;
    return r;
  }
  // (public) returns index of lowest 1-bit (or -1 if none)
  function bnGetLowestSetBit()
  {
    for (var i = 0; i < this.t; ++i)
      if (this[i] != 0) return i * this.DB + lbit(this[i]);
    if (this.s < 0) return this.t * this.DB;
    return -1;
  }
  // return number of 1 bits in x
  function cbit(x)
  {
    var r = 0;
    while (x != 0)
    {
      x &= x - 1;
      ++r;
    }
    return r;
  }
  // (public) return number of set bits
  function bnBitCount()
  {
    var r = 0,
      x = this.s & this.DM;
    for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);
    return r;
  }
  // (public) true iff nth bit is set
  function bnTestBit(n)
  {
    var j = Math.floor(n / this.DB);
    if (j >= this.t) return (this.s != 0);
    return ((this[j] & (1 << (n % this.DB))) != 0);
  }
  // (protected) this op (1<<n)
  function bnpChangeBit(n, op)
  {
    var r = BigInteger.ONE.shiftLeft(n);
    this.bitwiseTo(r, op, r);
    return r;
  }
  // (public) this | (1<<n)
  function bnSetBit(n)
  {
    return this.changeBit(n, op_or);
  }
  // (public) this & ~(1<<n)
  function bnClearBit(n)
  {
    return this.changeBit(n, op_andnot);
  }
  // (public) this ^ (1<<n)
  function bnFlipBit(n)
  {
    return this.changeBit(n, op_xor);
  }
  // (protected) r = this + a
  function bnpAddTo(a, r)
  {
    var i = 0,
      c = 0,
      m = Math.min(a.t, this.t);
    while (i < m)
    {
      c += this[i] + a[i];
      r[i++] = c & this.DM;
      c >>= this.DB;
    }
    if (a.t < this.t)
    {
      c += a.s;
      while (i < this.t)
      {
        c += this[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      c += this.s;
    }
    else
    {
      c += this.s;
      while (i < a.t)
      {
        c += a[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      c += a.s;
    }
    r.s = (c < 0) ? -1 : 0;
    if (c > 0) r[i++] = c;
    else if (c < -1) r[i++] = this.DV + c;
    r.t = i;
    r.clamp();
  }
  // (public) this + a
  function bnAdd(a)
  {
    var r = nbi();
    this.addTo(a, r);
    return r;
  }
  // (public) this - a
  function bnSubtract(a)
  {
    var r = nbi();
    this.subTo(a, r);
    return r;
  }
  // (public) this * a
  function bnMultiply(a)
  {
    var r = nbi();
    this.multiplyTo(a, r);
    return r;
  }
  // (public) this^2
  function bnSquare()
  {
    var r = nbi();
    this.squareTo(r);
    return r;
  }
  // (public) this / a
  function bnDivide(a)
  {
    var r = nbi();
    this.divRemTo(a, r, null);
    return r;
  }
  // (public) this % a
  function bnRemainder(a)
  {
    var r = nbi();
    this.divRemTo(a, null, r);
    return r;
  }
  // (public) [this/a,this%a]
  function bnDivideAndRemainder(a)
  {
    var q = nbi(),
      r = nbi();
    this.divRemTo(a, q, r);
    return new Array(q, r);
  }
  // (protected) this *= n, this >= 0, 1 < n < DV
  function bnpDMultiply(n)
  {
    this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
    ++this.t;
    this.clamp();
  }
  // (protected) this += n << w words, this >= 0
  function bnpDAddOffset(n, w)
  {
    if (n == 0) return;
    while (this.t <= w) this[this.t++] = 0;
    this[w] += n;
    while (this[w] >= this.DV)
    {
      this[w] -= this.DV;
      if (++w >= this.t) this[this.t++] = 0;
      ++this[w];
    }
  }
  // A "null" reducer
  function NullExp()
  {}

  function nNop(x)
  {
    return x;
  }

  function nMulTo(x, y, r)
  {
    x.multiplyTo(y, r);
  }

  function nSqrTo(x, r)
  {
    x.squareTo(r);
  }
  NullExp.prototype.convert = nNop;
  NullExp.prototype.revert = nNop;
  NullExp.prototype.mulTo = nMulTo;
  NullExp.prototype.sqrTo = nSqrTo;
  // (public) this^e
  function bnPow(e)
  {
    return this.exp(e, new NullExp());
  }
  // (protected) r = lower n words of "this * a", a.t <= n
  // "this" should be the larger one if appropriate.
  function bnpMultiplyLowerTo(a, n, r)
  {
    var i = Math.min(this.t + a.t, n);
    r.s = 0; // assumes a,this >= 0
    r.t = i;
    while (i > 0) r[--i] = 0;
    var j;
    for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
    for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);
    r.clamp();
  }
  // (protected) r = "this * a" without lower n words, n > 0
  // "this" should be the larger one if appropriate.
  function bnpMultiplyUpperTo(a, n, r)
  {
    --n;
    var i = r.t = this.t + a.t - n;
    r.s = 0; // assumes a,this >= 0
    while (--i >= 0) r[i] = 0;
    for (i = Math.max(n - this.t, 0); i < a.t; ++i)
      r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
    r.clamp();
    r.drShiftTo(1, r);
  }
  // Barrett modular reduction
  function Barrett(m)
  {
    // setup Barrett
    this.r2 = nbi();
    this.q3 = nbi();
    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
    this.mu = this.r2.divide(m);
    this.m = m;
  }

  function barrettConvert(x)
  {
    if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
    else if (x.compareTo(this.m) < 0) return x;
    else
    {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }
  }

  function barrettRevert(x)
  {
    return x;
  }
  // x = x mod m (HAC 14.42)
  function barrettReduce(x)
  {
    x.drShiftTo(this.m.t - 1, this.r2);
    if (x.t > this.m.t + 1)
    {
      x.t = this.m.t + 1;
      x.clamp();
    }
    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
    while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
    x.subTo(this.r2, x);
    while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
  }
  // r = x^2 mod m; x != r
  function barrettSqrTo(x, r)
  {
    x.squareTo(r);
    this.reduce(r);
  }
  // r = x*y mod m; x,y != r
  function barrettMulTo(x, y, r)
  {
    x.multiplyTo(y, r);
    this.reduce(r);
  }
  Barrett.prototype.convert = barrettConvert;
  Barrett.prototype.revert = barrettRevert;
  Barrett.prototype.reduce = barrettReduce;
  Barrett.prototype.mulTo = barrettMulTo;
  Barrett.prototype.sqrTo = barrettSqrTo;
  // (public) this^e % m (HAC 14.85)
  function bnModPow(e, m)
  {
    var i = e.bitLength(),
      k, r = nbv(1),
      z;
    if (i <= 0) return r;
    else if (i < 18) k = 1;
    else if (i < 48) k = 3;
    else if (i < 144) k = 4;
    else if (i < 768) k = 5;
    else k = 6;
    if (i < 8)
      z = new Classic(m);
    else if (m.isEven())
      z = new Barrett(m);
    else
      z = new Montgomery(m);
    // precomputation
    var g = new Array(),
      n = 3,
      k1 = k - 1,
      km = (1 << k) - 1;
    g[1] = z.convert(this);
    if (k > 1)
    {
      var g2 = nbi();
      z.sqrTo(g[1], g2);
      while (n <= km)
      {
        g[n] = nbi();
        z.mulTo(g2, g[n - 2], g[n]);
        n += 2;
      }
    }
    var j = e.t - 1,
      w, is1 = true,
      r2 = nbi(),
      t;
    i = nbits(e[j]) - 1;
    while (j >= 0)
    {
      if (i >= k1) w = (e[j] >> (i - k1)) & km;
      else
      {
        w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);
        if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);
      }
      n = k;
      while ((w & 1) == 0)
      {
        w >>= 1;
        --n;
      }
      if ((i -= n) < 0)
      {
        i += this.DB;
        --j;
      }
      if (is1)
      { // ret == 1, don't bother squaring or multiplying it
        g[w].copyTo(r);
        is1 = false;
      }
      else
      {
        while (n > 1)
        {
          z.sqrTo(r, r2);
          z.sqrTo(r2, r);
          n -= 2;
        }
        if (n > 0) z.sqrTo(r, r2);
        else
        {
          t = r;
          r = r2;
          r2 = t;
        }
        z.mulTo(r2, g[w], r);
      }
      while (j >= 0 && (e[j] & (1 << i)) == 0)
      {
        z.sqrTo(r, r2);
        t = r;
        r = r2;
        r2 = t;
        if (--i < 0)
        {
          i = this.DB - 1;
          --j;
        }
      }
    }
    return z.revert(r);
  }
  // (public) gcd(this,a) (HAC 14.54)
  function bnGCD(a)
  {
    var x = (this.s < 0) ? this.negate() : this.clone();
    var y = (a.s < 0) ? a.negate() : a.clone();
    if (x.compareTo(y) < 0)
    {
      var t = x;
      x = y;
      y = t;
    }
    var i = x.getLowestSetBit(),
      g = y.getLowestSetBit();
    if (g < 0) return x;
    if (i < g) g = i;
    if (g > 0)
    {
      x.rShiftTo(g, x);
      y.rShiftTo(g, y);
    }
    while (x.signum() > 0)
    {
      if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
      if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
      if (x.compareTo(y) >= 0)
      {
        x.subTo(y, x);
        x.rShiftTo(1, x);
      }
      else
      {
        y.subTo(x, y);
        y.rShiftTo(1, y);
      }
    }
    if (g > 0) y.lShiftTo(g, y);
    return y;
  }
  // (protected) this % n, n < 2^26
  function bnpModInt(n)
  {
    if (n <= 0) return 0;
    var d = this.DV % n,
      r = (this.s < 0) ? n - 1 : 0;
    if (this.t > 0)
      if (d == 0) r = this[0] % n;
      else
        for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;
    return r;
  }
  // (public) 1/this % m (HAC 14.61)
  function bnModInverse(m)
  {
    var ac = m.isEven();
    if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
    var u = m.clone(),
      v = this.clone();
    var a = nbv(1),
      b = nbv(0),
      c = nbv(0),
      d = nbv(1);
    while (u.signum() != 0)
    {
      while (u.isEven())
      {
        u.rShiftTo(1, u);
        if (ac)
        {
          if (!a.isEven() || !b.isEven())
          {
            a.addTo(this, a);
            b.subTo(m, b);
          }
          a.rShiftTo(1, a);
        }
        else if (!b.isEven()) b.subTo(m, b);
        b.rShiftTo(1, b);
      }
      while (v.isEven())
      {
        v.rShiftTo(1, v);
        if (ac)
        {
          if (!c.isEven() || !d.isEven())
          {
            c.addTo(this, c);
            d.subTo(m, d);
          }
          c.rShiftTo(1, c);
        }
        else if (!d.isEven()) d.subTo(m, d);
        d.rShiftTo(1, d);
      }
      if (u.compareTo(v) >= 0)
      {
        u.subTo(v, u);
        if (ac) a.subTo(c, a);
        b.subTo(d, b);
      }
      else
      {
        v.subTo(u, v);
        if (ac) c.subTo(a, c);
        d.subTo(b, d);
      }
    }
    if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
    if (d.compareTo(m) >= 0) return d.subtract(m);
    if (d.signum() < 0) d.addTo(m, d);
    else return d;
    if (d.signum() < 0) return d.add(m);
    else return d;
  }
  var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
  var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
  // (public) test primality with certainty >= 1-.5^t
  function bnIsProbablePrime(t)
  {
    var i, x = this.abs();
    if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1])
    {
      for (i = 0; i < lowprimes.length; ++i)
        if (x[0] == lowprimes[i]) return true;
      return false;
    }
    if (x.isEven()) return false;
    i = 1;
    while (i < lowprimes.length)
    {
      var m = lowprimes[i],
        j = i + 1;
      while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
      m = x.modInt(m);
      while (i < j)
        if (m % lowprimes[i++] == 0) return false;
    }
    return x.millerRabin(t);
  }
  // (protected) true if probably prime (HAC 4.24, Miller-Rabin)
  function bnpMillerRabin(t)
  {
    var n1 = this.subtract(BigInteger.ONE);
    var k = n1.getLowestSetBit();
    if (k <= 0) return false;
    var r = n1.shiftRight(k);
    t = (t + 1) >> 1;
    if (t > lowprimes.length) t = lowprimes.length;
    var a = nbi();
    for (var i = 0; i < t; ++i)
    {
      //Pick bases at random, instead of starting at 2
      a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
      var y = a.modPow(r, this);
      if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0)
      {
        var j = 1;
        while (j++ < k && y.compareTo(n1) != 0)
        {
          y = y.modPowInt(2, this);
          if (y.compareTo(BigInteger.ONE) == 0) return false;
        }
        if (y.compareTo(n1) != 0) return false;
      }
    }
    return true;
  }
  // protected
  BigInteger.prototype.chunkSize = bnpChunkSize;
  BigInteger.prototype.toRadix = bnpToRadix;
  BigInteger.prototype.fromRadix = bnpFromRadix;
  BigInteger.prototype.fromNumber = bnpFromNumber;
  BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
  BigInteger.prototype.changeBit = bnpChangeBit;
  BigInteger.prototype.addTo = bnpAddTo;
  BigInteger.prototype.dMultiply = bnpDMultiply;
  BigInteger.prototype.dAddOffset = bnpDAddOffset;
  BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
  BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
  BigInteger.prototype.modInt = bnpModInt;
  BigInteger.prototype.millerRabin = bnpMillerRabin;
  // public
  BigInteger.prototype.clone = bnClone;
  BigInteger.prototype.intValue = bnIntValue;
  BigInteger.prototype.byteValue = bnByteValue;
  BigInteger.prototype.shortValue = bnShortValue;
  BigInteger.prototype.signum = bnSigNum;
  BigInteger.prototype.toByteArray = bnToByteArray;
  BigInteger.prototype.equals = bnEquals;
  BigInteger.prototype.min = bnMin;
  BigInteger.prototype.max = bnMax;
  BigInteger.prototype.and = bnAnd;
  BigInteger.prototype.or = bnOr;
  BigInteger.prototype.xor = bnXor;
  BigInteger.prototype.andNot = bnAndNot;
  BigInteger.prototype.not = bnNot;
  BigInteger.prototype.shiftLeft = bnShiftLeft;
  BigInteger.prototype.shiftRight = bnShiftRight;
  BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
  BigInteger.prototype.bitCount = bnBitCount;
  BigInteger.prototype.testBit = bnTestBit;
  BigInteger.prototype.setBit = bnSetBit;
  BigInteger.prototype.clearBit = bnClearBit;
  BigInteger.prototype.flipBit = bnFlipBit;
  BigInteger.prototype.add = bnAdd;
  BigInteger.prototype.subtract = bnSubtract;
  BigInteger.prototype.multiply = bnMultiply;
  BigInteger.prototype.divide = bnDivide;
  BigInteger.prototype.remainder = bnRemainder;
  BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
  BigInteger.prototype.modPow = bnModPow;
  BigInteger.prototype.modInverse = bnModInverse;
  BigInteger.prototype.pow = bnPow;
  BigInteger.prototype.gcd = bnGCD;
  BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
  // JSBN-specific extension
  BigInteger.prototype.square = bnSquare;
  var Int128 = BigInteger;
  // BigInteger interfaces not implemented in jsbn:
  // BigInteger(int signum, byte[] magnitude)
  // double doubleValue()
  // float floatValue()
  // int hashCode()
  // long longValue()
  // static BigInteger valueOf(long val)
  // Helper functions to make BigInteger functions callable with two parameters
  // as in original C# Clipper
  Int128.prototype.IsNegative = function ()
  {
    if (this.compareTo(Int128.ZERO) == -1) return true;
    else return false;
  };
  Int128.op_Equality = function (val1, val2)
  {
    if (val1.compareTo(val2) == 0) return true;
    else return false;
  };
  Int128.op_Inequality = function (val1, val2)
  {
    if (val1.compareTo(val2) != 0) return true;
    else return false;
  };
  Int128.op_GreaterThan = function (val1, val2)
  {
    if (val1.compareTo(val2) > 0) return true;
    else return false;
  };
  Int128.op_LessThan = function (val1, val2)
  {
    if (val1.compareTo(val2) < 0) return true;
    else return false;
  };
  Int128.op_Addition = function (lhs, rhs)
  {
    return new Int128(lhs).add(new Int128(rhs));
  };
  Int128.op_Subtraction = function (lhs, rhs)
  {
    return new Int128(lhs).subtract(new Int128(rhs));
  };
  Int128.Int128Mul = function (lhs, rhs)
  {
    return new Int128(lhs).multiply(new Int128(rhs));
  };
  Int128.op_Division = function (lhs, rhs)
  {
    return lhs.divide(rhs);
  };
  Int128.prototype.ToDouble = function ()
  {
    return parseFloat(this.toString()); // This could be something faster
  };
  // end of Int128 section
  /*
  // Uncomment the following two lines if you want to use Int128 outside ClipperLib
  if (typeof(document) !== "undefined") window.Int128 = Int128;
  else self.Int128 = Int128;
  */
  // ---------------------------------------------  
  // Here starts the actual Clipper library:
  // Helper function to support Inheritance in Javascript
  if (typeof (Inherit) == 'undefined')
  {
    var Inherit = function (ce, ce2)
    {
      var p;
      if (typeof (Object.getOwnPropertyNames) == 'undefined')
      {
        for (p in ce2.prototype)
          if (typeof (ce.prototype[p]) == 'undefined' || ce.prototype[p] == Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];
        for (p in ce2)
          if (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];
        ce.$baseCtor = ce2;
      }
      else
      {
        var props = Object.getOwnPropertyNames(ce2.prototype);
        for (var i = 0; i < props.length; i++)
          if (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) == 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));
        for (p in ce2)
          if (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];
        ce.$baseCtor = ce2;
      }
    };
  }
  ClipperLib.Path = function ()
  {
    return [];
  };
  ClipperLib.Paths = function ()
  {
    return []; // Was previously [[]], but caused problems when pushed
  };
  // Preserves the calling way of original C# Clipper
  // Is essential due to compatibility, because DoublePoint is public class in original C# version
  ClipperLib.DoublePoint = function ()
  {
    var a = arguments;
    this.x = 0;
    this.y = 0;
    // public DoublePoint(DoublePoint dp)
    // public DoublePoint(IntPoint ip)
    if (a.length == 1)
    {
      this.x = a[0].x; 
      this.y = a[0].y; 
    }
    else if (a.length == 2)
    {
      this.x = a[0];
      this.y = a[1];
    }
  }; // This is internal faster function when called without arguments
  ClipperLib.DoublePoint0 = function ()
  {
    this.x = 0;
    this.y = 0;
  };
  // This is internal faster function when called with 1 argument (dp or ip)
  ClipperLib.DoublePoint1 = function (dp)
  {
    this.x = dp.x; 
    this.y = dp.y; 
  };
  // This is internal faster function when called with 2 arguments (x and y)
  ClipperLib.DoublePoint2 = function (x, y)
  {
    this.x = x;
    this.y = y;
  };
  // PolyTree & PolyNode start
  // -------------------------------
  ClipperLib.PolyNode = function ()
  {
    this.m_Parent = null;
    this.m_polygon = new ClipperLib.Path();
    this.m_Index = 0;
    this.m_jointype = 0;
    this.m_endtype = 0;
    this.m_Childs = [];
    this.IsOpen = false;
  };
  ClipperLib.PolyNode.prototype.IsHoleNode = function ()
  {
    var result = true;
    var node = this.m_Parent;
    while (node !== null)
    {
      result = !result;
      node = node.m_Parent;
    }
    return result;
  };
  ClipperLib.PolyNode.prototype.ChildCount = function ()
  {
    return this.m_Childs.length;
  };
  ClipperLib.PolyNode.prototype.Contour = function ()
  {
    return this.m_polygon;
  };
  ClipperLib.PolyNode.prototype.AddChild = function (Child)
  {
    var cnt = this.m_Childs.length;
    this.m_Childs.push(Child);
    Child.m_Parent = this;
    Child.m_Index = cnt;
  };
  ClipperLib.PolyNode.prototype.GetNext = function ()
  {
    if (this.m_Childs.length > 0)
      return this.m_Childs[0];
    else
      return this.GetNextSiblingUp();
  };
  ClipperLib.PolyNode.prototype.GetNextSiblingUp = function ()
  {
    if (this.m_Parent === null)
      return null;
    else if (this.m_Index == this.m_Parent.m_Childs.length - 1)
      return this.m_Parent.GetNextSiblingUp();
    else
      return this.m_Parent.m_Childs[this.m_Index + 1];
  };
  ClipperLib.PolyNode.prototype.Childs = function ()
  {
    return this.m_Childs;
  };
  ClipperLib.PolyNode.prototype.Parent = function ()
  {
    return this.m_Parent;
  };
  ClipperLib.PolyNode.prototype.IsHole = function ()
  {
    return this.IsHoleNode();
  };
  // PolyTree : PolyNode
  ClipperLib.PolyTree = function ()
  {
    this.m_AllPolys = [];
    ClipperLib.PolyNode.call(this);
  };
  ClipperLib.PolyTree.prototype.Clear = function ()
  {
    for (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++)
      this.m_AllPolys[i] = null;
    this.m_AllPolys.length = 0;
    this.m_Childs.length = 0;
  };
  ClipperLib.PolyTree.prototype.GetFirst = function ()
  {
    if (this.m_Childs.length > 0)
      return this.m_Childs[0];
    else
      return null;
  };
  ClipperLib.PolyTree.prototype.Total = function ()
  {
    return this.m_AllPolys.length;
  };
  Inherit(ClipperLib.PolyTree, ClipperLib.PolyNode);
  // -------------------------------
  // PolyTree & PolyNode end
  ClipperLib.Math_Abs_Int64 = ClipperLib.Math_Abs_Int32 = ClipperLib.Math_Abs_Double = function (a)
  {
    return Math.abs(a);
  };
  ClipperLib.Math_Max_Int32_Int32 = function (a, b)
  {
    return Math.max(a, b);
  };
  /*
  -----------------------------------
  cast_32 speedtest: http://jsperf.com/truncate-float-to-integer/2
  -----------------------------------
  */
  if (browser.msie || browser.opera || browser.safari) ClipperLib.Cast_Int32 = function (a)
  {
    return a | 0;
  };
  else ClipperLib.Cast_Int32 = function (a)
  { // eg. browser.chrome || browser.chromium || browser.firefox
    return~~ a;
  };
  /*
  --------------------------
  cast_64 speedtests: http://jsperf.com/truncate-float-to-integer
  Chrome: bitwise_not_floor
  Firefox17: toInteger (typeof test)
  IE9: bitwise_or_floor
  IE7 and IE8: to_parseint
  Chromium: to_floor_or_ceil
  Firefox3: to_floor_or_ceil
  Firefox15: to_floor_or_ceil
  Opera: to_floor_or_ceil
  Safari: to_floor_or_ceil
  --------------------------
  */
  if (browser.chrome) ClipperLib.Cast_Int64 = function (a)
  {
    if (a < -2147483648 || a > 2147483647)
      return a < 0 ? Math.ceil(a) : Math.floor(a);
    else return~~ a;
  };
  else if (browser.firefox && typeof (Number.toInteger) == "function") ClipperLib.Cast_Int64 = function (a)
  {
    return Number.toInteger(a);
  };
  else if (browser.msie7 || browser.msie8) ClipperLib.Cast_Int64 = function (a)
  {
    return parseInt(a, 10);
  };
  else if (browser.msie) ClipperLib.Cast_Int64 = function (a)
  {
    if (a < -2147483648 || a > 2147483647)
      return a < 0 ? Math.ceil(a) : Math.floor(a);
    return a | 0;
  };
  // eg. browser.chromium || browser.firefox || browser.opera || browser.safari
  else ClipperLib.Cast_Int64 = function (a)
  {
    return a < 0 ? Math.ceil(a) : Math.floor(a);
  };
  ClipperLib.Clear = function (a)
  {
    a.length = 0;
  };
  //ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function
  ClipperLib.PI = 3.141592653589793;
  ClipperLib.PI2 = 2 * 3.141592653589793;
  ClipperLib.IntPoint = function ()
  {
    var a = arguments,
      alen = a.length;
    this.x = 0;
    this.y = 0;
    if (use_xyz)
    {
      this.z = 0;
      if (alen == 3) // public IntPoint(cInt x, cInt y, cInt z = 0)
      {
        this.x = a[0];
        this.y = a[1];
        this.z = a[2];
      }
      else if (alen == 2) // public IntPoint(cInt x, cInt y)
      {
        this.x = a[0];
        this.y = a[1];
        this.z = 0;
      }
      else if (alen == 1)
      {
        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)
        {
          var dp = a[0];
          this.x = ClipperLib.Clipper.Round(dp.x);
          this.y = ClipperLib.Clipper.Round(dp.y);
          this.z = 0;
        }
        else // public IntPoint(IntPoint pt)
        {
          var pt = a[0];
          if (typeof (pt.z) == "undefined") pt.z = 0;
          this.x = pt.x; 
          this.y = pt.y; 
          this.z = pt.z;
        }
      }
      else // public IntPoint()
      {
        this.x = 0;
        this.y = 0;
        this.z = 0;
      }
    }
    else // if (!use_xyz)
    {
      if (alen == 2) // public IntPoint(cInt X, cInt Y)
      {
        this.x = a[0];
        this.y = a[1];
      }
      else if (alen == 1)
      {
        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)
        {
          var dp = a[0];
          this.x = ClipperLib.Clipper.Round(dp.x);
          this.y = ClipperLib.Clipper.Round(dp.y);
        }
        else // public IntPoint(IntPoint pt)
        {
          var pt = a[0];
          this.x = pt.x; 
          this.y = pt.y; 
        }
      }
      else // public IntPoint(IntPoint pt)
      {
        this.x = 0;
        this.y = 0;
      }
    }
  };
  ClipperLib.IntPoint.op_Equality = function (a, b)
  {
    //return a == b;
    return a.x == b.x && a.y == b.y; 
  };
  ClipperLib.IntPoint.op_Inequality = function (a, b)
  {
    //return a != b;
    return a.x != b.x || a.y != b.y; 
  };
  /*
  ClipperLib.IntPoint.prototype.Equals = function (obj)
  {
    if (obj === null)
        return false;
    if (obj instanceof ClipperLib.IntPoint)
    {
        var a = Cast(obj, ClipperLib.IntPoint);
        return (this.x == a.x) && (this.y == a.y);
    }
    else
        return false;
  };
*/
  if (use_xyz)
  {
    ClipperLib.IntPoint0 = function ()
    {
      this.x = 0;
      this.y = 0;
      this.z = 0;
    };
    ClipperLib.IntPoint1 = function (pt)
    {
      this.x = pt.x; 
      this.y = pt.y; 
      this.z = pt.z;
    };
    ClipperLib.IntPoint1dp = function (dp)
    {
      this.x = ClipperLib.Clipper.Round(dp.x);
      this.y = ClipperLib.Clipper.Round(dp.y);
      this.z = 0;
    };
    ClipperLib.IntPoint2 = function (x, y)
    {
      this.x = x;
      this.y = y;
      this.z = 0;
    };
    ClipperLib.IntPoint3 = function (x, y, z)
    {
      this.x = x;
      this.y = y;
      this.z = z;
    };
  }
  else // if (!use_xyz)
  {
    ClipperLib.IntPoint0 = function ()
    {
      this.x = 0;
      this.y = 0;
    };
    ClipperLib.IntPoint1 = function (pt)
    {
      this.x = pt.x; 
      this.y = pt.y; 
    };
    ClipperLib.IntPoint1dp = function (dp)
    {
      this.x = ClipperLib.Clipper.Round(dp.x);
      this.y = ClipperLib.Clipper.Round(dp.y);
    };
    ClipperLib.IntPoint2 = function (x, y)
    {
      this.x = x;
      this.y = y;
    };
  }
  ClipperLib.IntRect = function ()
  {
    var a = arguments,
      alen = a.length;
    if (alen == 4) // function (l, t, r, b)
    {
      this.left = a[0];
      this.top = a[1];
      this.right = a[2];
      this.bottom = a[3];
    }
    else if (alen == 1) // function (ir)
    {
      this.left = ir.left;
      this.top = ir.top;
      this.right = ir.right;
      this.bottom = ir.bottom;
    }
    else // function ()
    {
      this.left = 0;
      this.top = 0;
      this.right = 0;
      this.bottom = 0;
    }
  };
  ClipperLib.IntRect0 = function ()
  {
    this.left = 0;
    this.top = 0;
    this.right = 0;
    this.bottom = 0;
  };
  ClipperLib.IntRect1 = function (ir)
  {
    this.left = ir.left;
    this.top = ir.top;
    this.right = ir.right;
    this.bottom = ir.bottom;
  };
  ClipperLib.IntRect4 = function (l, t, r, b)
  {
    this.left = l;
    this.top = t;
    this.right = r;
    this.bottom = b;
  };
  ClipperLib.ClipType = {
    ctIntersection: 0,
    ctUnion: 1,
    ctDifference: 2,
    ctXor: 3
  };
  ClipperLib.PolyType = {
    ptSubject: 0,
    ptClip: 1
  };
  ClipperLib.PolyFillType = {
    pftEvenOdd: 0,
    pftNonZero: 1,
    pftPositive: 2,
    pftNegative: 3
  };
  ClipperLib.JoinType = {
    jtSquare: 0,
    jtRound: 1,
    jtMiter: 2
  };
  ClipperLib.EndType = {
    etOpenSquare: 0,
    etOpenRound: 1,
    etOpenButt: 2,
    etClosedLine: 3,
    etClosedPolygon: 4
  };
  if (use_deprecated)
    ClipperLib.EndType_ = {
      etSquare: 0,
      etRound: 1,
      etButt: 2,
      etClosed: 3
    };
  ClipperLib.EdgeSide = {
    esLeft: 0,
    esRight: 1
  };
  ClipperLib.Direction = {
    dRightToLeft: 0,
    dLeftToRight: 1
  };
  ClipperLib.TEdge = function ()
  {
    this.Bot = new ClipperLib.IntPoint();
    this.Curr = new ClipperLib.IntPoint();
    this.Top = new ClipperLib.IntPoint();
    this.Delta = new ClipperLib.IntPoint();
    this.Dx = 0;
    this.PolyTyp = ClipperLib.PolyType.ptSubject;
    this.Side = ClipperLib.EdgeSide.esLeft;
    this.WindDelta = 0;
    this.WindCnt = 0;
    this.WindCnt2 = 0;
    this.OutIdx = 0;
    this.Next = null;
    this.Prev = null;
    this.NextInLML = null;
    this.NextInAEL = null;
    this.PrevInAEL = null;
    this.NextInSEL = null;
    this.PrevInSEL = null;
  };
  ClipperLib.IntersectNode = function ()
  {
    this.Edge1 = null;
    this.Edge2 = null;
    this.Pt = new ClipperLib.IntPoint();
  };
  ClipperLib.MyIntersectNodeSort = function () {};
  ClipperLib.MyIntersectNodeSort.Compare = function (node1, node2)
  {
    return (node2.Pt.y - node1.Pt.y);
  };
  ClipperLib.LocalMinima = function ()
  {
    this.y = 0;
    this.LeftBound = null;
    this.RightBound = null;
    this.Next = null;
  };
  ClipperLib.Scanbeam = function ()
  {
    this.y = 0;
    this.Next = null;
  };
  ClipperLib.OutRec = function ()
  {
    this.Idx = 0;
    this.IsHole = false;
    this.IsOpen = false;
    this.FirstLeft = null;
    this.Pts = null;
    this.BottomPt = null;
    this.PolyNode = null;
  };
  ClipperLib.OutPt = function ()
  {
    this.Idx = 0;
    this.Pt = new ClipperLib.IntPoint();
    this.Next = null;
    this.Prev = null;
  };
  ClipperLib.Join = function ()
  {
    this.OutPt1 = null;
    this.OutPt2 = null;
    this.OffPt = new ClipperLib.IntPoint();
  };
  ClipperLib.ClipperBase = function ()
  {
    this.m_MinimaList = null;
    this.m_CurrentLM = null;
    this.m_edges = new Array();
    this.m_UseFullRange = false;
    this.m_HasOpenPaths = false;
    this.PreserveCollinear = false;
    this.m_MinimaList = null;
    this.m_CurrentLM = null;
    this.m_UseFullRange = false;
    this.m_HasOpenPaths = false;
  };
  // Ranges are in original C# too high for Javascript (in current state 2013 september):
  // protected const double horizontal = -3.4E+38;
  // internal const cInt loRange = 0x3FFFFFFF; // = 1073741823 = sqrt(2^63 -1)/2
  // internal const cInt hiRange = 0x3FFFFFFFFFFFFFFFL; // = 4611686018427387903 = sqrt(2^127 -1)/2
  // So had to adjust them to more suitable for Javascript.
  // If JS some day supports truly 64-bit integers, then these ranges can be as in C#
  // and biginteger library can be more simpler (as then 128bit can be represented as two 64bit numbers)
  ClipperLib.ClipperBase.horizontal = -9007199254740992; //-2^53
  ClipperLib.ClipperBase.Skip = -2;
  ClipperLib.ClipperBase.Unassigned = -1;
  ClipperLib.ClipperBase.tolerance = 1E-20;
  if (use_int32)
  {
    ClipperLib.ClipperBase.loRange = 46340;
    ClipperLib.ClipperBase.hiRange = 46340;
  }
  else
  {
    ClipperLib.ClipperBase.loRange = 47453132; // sqrt(2^53 -1)/2
    ClipperLib.ClipperBase.hiRange = 4503599627370495; // sqrt(2^106 -1)/2
  }
  ClipperLib.ClipperBase.near_zero = function (val)
  {
    return (val > -ClipperLib.ClipperBase.tolerance) && (val < ClipperLib.ClipperBase.tolerance);
  };
  ClipperLib.ClipperBase.IsHorizontal = function (e)
  {
    return e.Delta.y === 0;
  };
  ClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp)
  {
    var pp2 = pp;
    do {
      if (ClipperLib.IntPoint.op_Equality(pp2.Pt, pt))
        return true;
      pp2 = pp2.Next;
    }
    while (pp2 != pp)
    return false;
  };
  ClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2, UseFullRange)
  {
    if (UseFullRange)
      return ((pt.x == linePt1.x) && (pt.y == linePt1.y)) ||
        ((pt.x == linePt2.x) && (pt.y == linePt2.y)) ||
        (((pt.x > linePt1.x) == (pt.x < linePt2.x)) &&
        ((pt.y > linePt1.y) == (pt.y < linePt2.y)) &&
        (Int128.op_Equality(Int128.Int128Mul((pt.x - linePt1.x), (linePt2.y - linePt1.y)),
          Int128.Int128Mul((linePt2.x - linePt1.x), (pt.y - linePt1.y)))));
    else
      return ((pt.x == linePt1.x) && (pt.y == linePt1.y)) || ((pt.x == linePt2.x) && (pt.y == linePt2.y)) || (((pt.x > linePt1.x) == (pt.x < linePt2.x)) && ((pt.y > linePt1.y) == (pt.y < linePt2.y)) && ((pt.x - linePt1.x) * (linePt2.y - linePt1.y) == (linePt2.x - linePt1.x) * (pt.y - linePt1.y)));
  };
  ClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp, UseFullRange)
  {
    var pp2 = pp;
    while (true)
    {
      if (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt, UseFullRange))
        return true;
      pp2 = pp2.Next;
      if (pp2 == pp)
        break;
    }
    return false;
  };
  ClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function ()
  {
    var a = arguments,
      alen = a.length;
    var e1, e2, pt1, pt2, pt3, pt4, UseFullRange;
    if (alen == 3) // function (e1, e2, UseFullRange)
    {
      e1 = a[0];
      e2 = a[1];
      UseFullRange = a[2];
      if (UseFullRange)
        return Int128.op_Equality(Int128.Int128Mul(e1.Delta.y, e2.Delta.x), Int128.Int128Mul(e1.Delta.x, e2.Delta.y));
      else
        return ClipperLib.Cast_Int64((e1.Delta.y) * (e2.Delta.x)) == ClipperLib.Cast_Int64((e1.Delta.x) * (e2.Delta.y));
    }
    else if (alen == 4) // function (pt1, pt2, pt3, UseFullRange)
    {
      pt1 = a[0];
      pt2 = a[1];
      pt3 = a[2];
      UseFullRange = a[3];
      if (UseFullRange)
        return Int128.op_Equality(Int128.Int128Mul(pt1.y - pt2.y, pt2.x - pt3.x), Int128.Int128Mul(pt1.x - pt2.x, pt2.y - pt3.y));
      else
        return ClipperLib.Cast_Int64((pt1.y - pt2.y) * (pt2.x - pt3.x)) - ClipperLib.Cast_Int64((pt1.x - pt2.x) * (pt2.y - pt3.y)) === 0;
    }
    else // function (pt1, pt2, pt3, pt4, UseFullRange)
    {
      pt1 = a[0];
      pt2 = a[1];
      pt3 = a[2];
      pt4 = a[3];
      UseFullRange = a[4];
      if (UseFullRange)
        return Int128.op_Equality(Int128.Int128Mul(pt1.y - pt2.y, pt3.x - pt4.x), Int128.Int128Mul(pt1.x - pt2.x, pt3.y - pt4.y));
      else
        return ClipperLib.Cast_Int64((pt1.y - pt2.y) * (pt3.x - pt4.x)) - ClipperLib.Cast_Int64((pt1.x - pt2.x) * (pt3.y - pt4.y)) === 0;
    }
  };
  ClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2, UseFullRange)
  {
    if (UseFullRange)
      return Int128.op_Equality(Int128.Int128Mul(e1.Delta.y, e2.Delta.x), Int128.Int128Mul(e1.Delta.x, e2.Delta.y));
    else
      return ClipperLib.Cast_Int64((e1.Delta.y) * (e2.Delta.x)) == ClipperLib.Cast_Int64((e1.Delta.x) * (e2.Delta.y));
  };
  ClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3, UseFullRange)
  {
    if (UseFullRange)
      return Int128.op_Equality(Int128.Int128Mul(pt1.y - pt2.y, pt2.x - pt3.x), Int128.Int128Mul(pt1.x - pt2.x, pt2.y - pt3.y));
    else
      return ClipperLib.Cast_Int64((pt1.y - pt2.y) * (pt2.x - pt3.x)) - ClipperLib.Cast_Int64((pt1.x - pt2.x) * (pt2.y - pt3.y)) === 0;
  };
  ClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4, UseFullRange)
  {
    if (UseFullRange)
      return Int128.op_Equality(Int128.Int128Mul(pt1.y - pt2.y, pt3.x - pt4.x), Int128.Int128Mul(pt1.x - pt2.x, pt3.y - pt4.y));
    else
      return ClipperLib.Cast_Int64((pt1.y - pt2.y) * (pt3.x - pt4.x)) - ClipperLib.Cast_Int64((pt1.x - pt2.x) * (pt3.y - pt4.y)) === 0;
  };
  ClipperLib.ClipperBase.prototype.Clear = function ()
  {
    this.DisposeLocalMinimaList();
    for (var i = 0, ilen = this.m_edges.length; i < ilen; ++i)
    {
      for (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j)
        this.m_edges[i][j] = null;
      ClipperLib.Clear(this.m_edges[i]);
    }
    ClipperLib.Clear(this.m_edges);
    this.m_UseFullRange = false;
    this.m_HasOpenPaths = false;
  };
  ClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function ()
  {
    while (this.m_MinimaList !== null)
    {
      var tmpLm = this.m_MinimaList.Next;
      this.m_MinimaList = null;
      this.m_MinimaList = tmpLm;
    }
    this.m_CurrentLM = null;
  };
  ClipperLib.ClipperBase.prototype.RangeTest = function (Pt, useFullRange)
  {
    if (useFullRange.Value)
    {
      if (Pt.x > ClipperLib.ClipperBase.hiRange || Pt.y > ClipperLib.ClipperBase.hiRange || -Pt.x > ClipperLib.ClipperBase.hiRange || -Pt.y > ClipperLib.ClipperBase.hiRange)
        ClipperLib.Error("Coordinate outside allowed range in RangeTest().");
    }
    else if (Pt.x > ClipperLib.ClipperBase.loRange || Pt.y > ClipperLib.ClipperBase.loRange || -Pt.x > ClipperLib.ClipperBase.loRange || -Pt.y > ClipperLib.ClipperBase.loRange)
    {
      useFullRange.Value = true;
      this.RangeTest(Pt, useFullRange);
    }
  };
  ClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt)
  {
    e.Next = eNext;
    e.Prev = ePrev;
    //e.Curr = pt;
    e.Curr.x = pt.x; 
    e.Curr.y = pt.y; 
    e.OutIdx = -1;
  };
  ClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType)
  {
    if (e.Curr.y >= e.Next.Curr.y)
    {
      //e.Bot = e.Curr;
      e.Bot.x = e.Curr.x; 
      e.Bot.y = e.Curr.y; 
      //e.Top = e.Next.Curr;
      e.Top.x = e.Next.Curr.x; 
      e.Top.y = e.Next.Curr.y; 
    }
    else
    {
      //e.Top = e.Curr;
      e.Top.x = e.Curr.x; 
      e.Top.y = e.Curr.y; 
      //e.Bot = e.Next.Curr;
      e.Bot.x = e.Next.Curr.x; 
      e.Bot.y = e.Next.Curr.y; 
    }
    this.SetDx(e);
    e.PolyTyp = polyType;
  };
  ClipperLib.ClipperBase.prototype.FindNextLocMin = function (E)
  {
    var E2;
    for (;;)
    {
      while (ClipperLib.IntPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.IntPoint.op_Equality(E.Curr, E.Top))
        E = E.Next;
      if (E.Dx != ClipperLib.ClipperBase.horizontal && E.Prev.Dx != ClipperLib.ClipperBase.horizontal)
        break;
      while (E.Prev.Dx == ClipperLib.ClipperBase.horizontal)
        E = E.Prev;
      E2 = E;
      while (E.Dx == ClipperLib.ClipperBase.horizontal)
        E = E.Next;
      if (E.Top.y == E.Prev.Bot.y)
        continue;
      //ie just an intermediate horz.
      if (E2.Prev.Bot.x < E.Bot.x)
        E = E2;
      break;
    }
    return E;
  };
  ClipperLib.ClipperBase.prototype.ProcessBound = function (E, IsClockwise)
  {
    var EStart = E,
      Result = E;
    var Horz;
    var StartX;
    if (E.Dx == ClipperLib.ClipperBase.horizontal)
    {
      //it's possible for adjacent overlapping horz edges to start heading left
      //before finishing right, so ...
      if (IsClockwise)
        StartX = E.Prev.Bot.x; 
      else
        StartX = E.Next.Bot.x; 
      if (E.Bot.x != StartX)
        this.ReverseHorizontal(E);
    }
    if (Result.OutIdx != ClipperLib.ClipperBase.Skip)
    {
      if (IsClockwise)
      {
        while (Result.Top.y == Result.Next.Bot.y && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)
          Result = Result.Next;
        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)
        {
          //nb: at the top of a bound, horizontals are added to the bound
          //only when the preceding edge attaches to the horizontal's left vertex
          //unless a Skip edge is encountered when that becomes the top divide
          Horz = Result;
          while (Horz.Prev.Dx == ClipperLib.ClipperBase.horizontal)
            Horz = Horz.Prev;
          if (Horz.Prev.Top.x == Result.Next.Top.x)
          {
            if (!IsClockwise)
              Result = Horz.Prev;
          }
          else if (Horz.Prev.Top.x > Result.Next.Top.x)
            Result = Horz.Prev;
        }
        while (E != Result)
        {
          E.NextInLML = E.Next;
          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.x != E.Prev.Top.x)
            this.ReverseHorizontal(E);
          E = E.Next;
        }
        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.x != E.Prev.Top.x)
          this.ReverseHorizontal(E);
        Result = Result.Next;
        //move to the edge just beyond current bound
      }
      else
      {
        while (Result.Top.y == Result.Prev.Bot.y && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)
          Result = Result.Prev;
        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)
        {
          Horz = Result;
          while (Horz.Next.Dx == ClipperLib.ClipperBase.horizontal)
            Horz = Horz.Next;
          if (Horz.Next.Top.x == Result.Prev.Top.x)
          {
            if (!IsClockwise)
              Result = Horz.Next;
          }
          else if (Horz.Next.Top.x > Result.Prev.Top.x)
            Result = Horz.Next;
        }
        while (E != Result)
        {
          E.NextInLML = E.Prev;
          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.x != E.Next.Top.x)
            this.ReverseHorizontal(E);
          E = E.Prev;
        }
        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.x != E.Next.Top.x)
          this.ReverseHorizontal(E);
        Result = Result.Prev;
        //move to the edge just beyond current bound
      }
    }
    if (Result.OutIdx == ClipperLib.ClipperBase.Skip)
    {
      //if edges still remain in the current bound beyond the skip edge then
      //create another LocMin and call ProcessBound once more
      E = Result;
      if (IsClockwise)
      {
        while (E.Top.y == E.Next.Bot.y)
          E = E.Next;
        //don't include top horizontals when parsing a bound a second time,
        //they will be contained in the opposite bound ...
        while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal)
          E = E.Prev;
      }
      else
      {
        while (E.Top.y == E.Prev.Bot.y)
          E = E.Prev;
        while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal)
          E = E.Next;
      }
      if (E == Result)
      {
        if (IsClockwise)
          Result = E.Next;
        else
          Result = E.Prev;
      }
      else
      {
        //there are more edges in the bound beyond result starting with E
        if (IsClockwise)
          E = Result.Next;
        else
          E = Result.Prev;
        var locMin = new ClipperLib.LocalMinima();
        locMin.Next = null;
        locMin.y = E.Bot.y; 
        locMin.LeftBound = null;
        locMin.RightBound = E;
        locMin.RightBound.WindDelta = 0;
        Result = this.ProcessBound(locMin.RightBound, IsClockwise);
        this.InsertLocalMinima(locMin);
      }
    }
    return Result;
  };
  ClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed)
  {
    if (use_lines)
    {
      if (!Closed && polyType == ClipperLib.PolyType.ptClip)
        ClipperLib.Error("AddPath: Open paths must be subject.");
    }
    else
    {
      if (!Closed)
        ClipperLib.Error("AddPath: Open paths have been disabled.");
    }
    var highI = pg.length - 1;
    if (Closed)
      while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[0])))
    --highI;
    while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[highI - 1])))
    --highI;
    if ((Closed && highI < 2) || (!Closed && highI < 1))
      return false;
    //create a new edge array ...
    var edges = new Array();
    for (var i = 0; i <= highI; i++)
      edges.push(new ClipperLib.TEdge());
    var IsFlat = true;
    //1. Basic (first) edge initialization ...

    //edges[1].Curr = pg[1];
    edges[1].Curr.x = pg[1].x; 
    edges[1].Curr.y = pg[1].y; 
    (function ()
    {
      var $1 = {
        Value: this.m_UseFullRange
      };
      var $res = this.RangeTest(pg[0], $1);
      this.m_UseFullRange = $1.Value;
      return $res;
    }).call(this);
    (function ()
    {
      var $1 = {
        Value: this.m_UseFullRange
      };
      var $res = this.RangeTest(pg[highI], $1);
      this.m_UseFullRange = $1.Value;
      return $res;
    }).call(this);
    this.InitEdge(edges[0], edges[1], edges[highI], pg[0]);
    this.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);
    for (var i = highI - 1; i >= 1; --i)
    {
      (function ()
      {
        var $1 = {
          Value: this.m_UseFullRange
        };
        var $res = this.RangeTest(pg[i], $1);
        this.m_UseFullRange = $1.Value;
        return $res;
      }).call(this);
      this.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);
    }

    var eStart = edges[0];
    //2. Remove duplicate vertices, and (when closed) collinear edges ...
    var E = eStart,
      eLoopStop = eStart;
    for (;;)
    {
      if (ClipperLib.IntPoint.op_Equality(E.Curr, E.Next.Curr))
      {
        if (E == E.Next)
          break;
        if (E == eStart)
          eStart = E.Next;
        E = this.RemoveEdge(E);
        eLoopStop = E;
        continue;
      }
      if (E.Prev == E.Next)
        break;
      else if (Closed && ClipperLib.ClipperBase.SlopesEqual(E.Prev.Curr, E.Curr, E.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr)))
      {
        //Collinear edges are allowed for open paths but in closed paths
        //the default is to merge adjacent collinear edges into a single edge.
        //However, if the PreserveCollinear property is enabled, only overlapping
        //collinear edges (ie spikes) will be removed from closed paths.
        if (E == eStart)
          eStart = E.Next;
        E = this.RemoveEdge(E);
        E = E.Prev;
        eLoopStop = E;
        continue;
      }
      E = E.Next;
      if (E == eLoopStop)
        break;
    }
    if ((!Closed && (E == E.Next)) || (Closed && (E.Prev == E.Next)))
      return false;
    if (!Closed)
    {
      this.m_HasOpenPaths = true;
      eStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;
    }
    //3. Do second stage of edge initialization ...
    var eHighest = eStart;
    E = eStart;
    do {
      this.InitEdge2(E, polyType);
      E = E.Next;
      if (IsFlat && E.Curr.y != eStart.Curr.y)
        IsFlat = false;
    }
    while (E != eStart)
    //4. Finally, add edge bounds to LocalMinima list ...
    //Totally flat paths must be handled differently when adding them
    //to LocalMinima list to avoid endless loops etc ...
    if (IsFlat)
    {
      if (Closed)
        return false;
      E.Prev.OutIdx = ClipperLib.ClipperBase.Skip;
      if (E.Prev.Bot.x < E.Prev.Top.x)
        this.ReverseHorizontal(E.Prev);
      var locMin = new ClipperLib.LocalMinima();
      locMin.Next = null;
      locMin.y = E.Bot.y; 
      locMin.LeftBound = null;
      locMin.RightBound = E;
      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;
      locMin.RightBound.WindDelta = 0;
      while (E.Next.OutIdx != ClipperLib.ClipperBase.Skip)
      {
        E.NextInLML = E.Next;
        if (E.Bot.x != E.Prev.Top.x)
          this.ReverseHorizontal(E);
        E = E.Next;
      }
      this.InsertLocalMinima(locMin);
      this.m_edges.push(edges);
      return true;
    }
    this.m_edges.push(edges);
    var clockwise;
    var EMin = null;
    for (;;)
    {
      E = this.FindNextLocMin(E);
      if (E == EMin)
        break;
      else if (EMin == null)
        EMin = E;
      //E and E.Prev now share a local minima (left aligned if horizontal).
      //Compare their slopes to find which starts which bound ...
      var locMin = new ClipperLib.LocalMinima();
      locMin.Next = null;
      locMin.y = E.Bot.y; 
      if (E.Dx < E.Prev.Dx)
      {
        locMin.LeftBound = E.Prev;
        locMin.RightBound = E;
        clockwise = false;
        //Q.nextInLML = Q.prev
      }
      else
      {
        locMin.LeftBound = E;
        locMin.RightBound = E.Prev;
        clockwise = true;
        //Q.nextInLML = Q.next
      }
      locMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;
      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;
      if (!Closed)
        locMin.LeftBound.WindDelta = 0;
      else if (locMin.LeftBound.Next == locMin.RightBound)
        locMin.LeftBound.WindDelta = -1;
      else
        locMin.LeftBound.WindDelta = 1;
      locMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;
      E = this.ProcessBound(locMin.LeftBound, clockwise);
      var E2 = this.ProcessBound(locMin.RightBound, !clockwise);
      if (locMin.LeftBound.OutIdx == ClipperLib.ClipperBase.Skip)
        locMin.LeftBound = null;
      else if (locMin.RightBound.OutIdx == ClipperLib.ClipperBase.Skip)
        locMin.RightBound = null;
      this.InsertLocalMinima(locMin);
      if (!clockwise)
        E = E2;
    }
    return true;
  };
  ClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed)
  {
    //  console.log("-------------------------------------------");
    //  console.log(JSON.stringify(ppg));
    var result = false;
    for (var i = 0, ilen = ppg.length; i < ilen; ++i)
      if (this.AddPath(ppg[i], polyType, closed))
        result = true;
    return result;
  };
  //------------------------------------------------------------------------------
  ClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3)
  {
    if ((ClipperLib.IntPoint.op_Equality(pt1, pt3)) || (ClipperLib.IntPoint.op_Equality(pt1, pt2)) ||
      (ClipperLib.IntPoint.op_Equality(pt3, pt2)))
      return false;
    else if (pt1.x != pt3.x)
      return (pt2.x > pt1.x) == (pt2.x < pt3.x);
    else
      return (pt2.y > pt1.y) == (pt2.y < pt3.y);
  };
  ClipperLib.ClipperBase.prototype.RemoveEdge = function (e)
  {
    //removes e from double_linked_list (but without removing from memory)
    e.Prev.Next = e.Next;
    e.Next.Prev = e.Prev;
    var result = e.Next;
    e.Prev = null; //flag as removed (see ClipperBase.Clear)
    return result;
  };
  ClipperLib.ClipperBase.prototype.SetDx = function (e)
  {
    e.Delta.x = (e.Top.x - e.Bot.x);
    e.Delta.y = (e.Top.y - e.Bot.y);
    if (e.Delta.y === 0) e.Dx = ClipperLib.ClipperBase.horizontal;
    else e.Dx = (e.Delta.x) / (e.Delta.y);
  };
  ClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm)
  {
    if (this.m_MinimaList === null)
    {
      this.m_MinimaList = newLm;
    }
    else if (newLm.y >= this.m_MinimaList.y)
    {
      newLm.Next = this.m_MinimaList;
      this.m_MinimaList = newLm;
    }
    else
    {
      var tmpLm = this.m_MinimaList;
      while (tmpLm.Next !== null && (newLm.y < tmpLm.Next.y))
        tmpLm = tmpLm.Next;
      newLm.Next = tmpLm.Next;
      tmpLm.Next = newLm;
    }
  };
  ClipperLib.ClipperBase.prototype.PopLocalMinima = function ()
  {
    if (this.m_CurrentLM === null)
      return;
    this.m_CurrentLM = this.m_CurrentLM.Next;
  };
  ClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e)
  {
    //swap horizontal edges' top and bottom x's so they follow the natural
    //progression of the bounds - ie so their xbots will align with the
    //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]
    var tmp = e.Top.x; 
    e.Top.x = e.Bot.x; 
    e.Bot.x = tmp;
    if (use_xyz)
    {
      tmp = e.Top.z;
      e.Top.z = e.Bot.z;
      e.Bot.z = tmp;
    }
  };
  ClipperLib.ClipperBase.prototype.Reset = function ()
  {
    this.m_CurrentLM = this.m_MinimaList;
    if (this.m_CurrentLM == null)
      return;
    //ie nothing to process
    //reset all edges ...
    var lm = this.m_MinimaList;
    while (lm != null)
    {
      var e = lm.LeftBound;
      if (e != null)
      {
        //e.Curr = e.Bot;
        e.Curr.x = e.Bot.x; 
        e.Curr.y = e.Bot.y; 
        e.Side = ClipperLib.EdgeSide.esLeft;
        e.OutIdx = ClipperLib.ClipperBase.Unassigned;
      }
      e = lm.RightBound;
      if (e != null)
      {
        //e.Curr = e.Bot;
        e.Curr.x = e.Bot.x; 
        e.Curr.y = e.Bot.y; 
        e.Side = ClipperLib.EdgeSide.esRight;
        e.OutIdx = ClipperLib.ClipperBase.Unassigned;
      }
      lm = lm.Next;
    }
  };
  ClipperLib.Clipper = function (InitOptions) // public Clipper(int InitOptions = 0)
  {
    if (typeof (InitOptions) == "undefined") InitOptions = 0;
    this.m_PolyOuts = null;
    this.m_ClipType = ClipperLib.ClipType.ctIntersection;
    this.m_Scanbeam = null;
    this.m_ActiveEdges = null;
    this.m_SortedEdges = null;
    this.m_IntersectList = null;
    this.m_IntersectNodeComparer = null;
    this.m_ExecuteLocked = false;
    this.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;
    this.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;
    this.m_Joins = null;
    this.m_GhostJoins = null;
    this.m_UsingPolyTree = false;
    this.ReverseSolution = false;
    this.StrictlySimple = false;
    ClipperLib.ClipperBase.call(this);
    this.m_Scanbeam = null;
    this.m_ActiveEdges = null;
    this.m_SortedEdges = null;
    this.m_IntersectList = new Array();
    this.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;
    this.m_ExecuteLocked = false;
    this.m_UsingPolyTree = false;
    this.m_PolyOuts = new Array();
    this.m_Joins = new Array();
    this.m_GhostJoins = new Array();
    this.ReverseSolution = (1 & InitOptions) !== 0;
    this.StrictlySimple = (2 & InitOptions) !== 0;
    this.PreserveCollinear = (4 & InitOptions) !== 0;
    if (use_xyz)
    {
      this.ZFillFunction = null; // function (IntPoint vert1, IntPoint vert2, ref IntPoint intersectPt);
    }
  };
  ClipperLib.Clipper.ioReverseSolution = 1;
  ClipperLib.Clipper.ioStrictlySimple = 2;
  ClipperLib.Clipper.ioPreserveCollinear = 4;

  ClipperLib.Clipper.prototype.Clear = function ()
  {
    if (this.m_edges.length === 0)
      return;
    //avoids problems with ClipperBase destructor
    this.DisposeAllPolyPts();
    ClipperLib.ClipperBase.prototype.Clear.call(this);
  };

  ClipperLib.Clipper.prototype.DisposeScanbeamList = function ()
  {
    while (this.m_Scanbeam !== null)
    {
      var sb2 = this.m_Scanbeam.Next;
      this.m_Scanbeam = null;
      this.m_Scanbeam = sb2;
    }
  };
  ClipperLib.Clipper.prototype.Reset = function ()
  {
    ClipperLib.ClipperBase.prototype.Reset.call(this);
    this.m_Scanbeam = null;
    this.m_ActiveEdges = null;
    this.m_SortedEdges = null;

    var lm = this.m_MinimaList;
    while (lm !== null)
    {
      this.InsertScanbeam(lm.y);
      lm = lm.Next;
    }
  };
  ClipperLib.Clipper.prototype.InsertScanbeam = function (Y)
  {
    if (this.m_Scanbeam === null)
    {
      this.m_Scanbeam = new ClipperLib.Scanbeam();
      this.m_Scanbeam.Next = null;
      this.m_Scanbeam.y = Y;
    }
    else if (Y > this.m_Scanbeam.y)
    {
      var newSb = new ClipperLib.Scanbeam();
      newSb.y = Y;
      newSb.Next = this.m_Scanbeam;
      this.m_Scanbeam = newSb;
    }
    else
    {
      var sb2 = this.m_Scanbeam;
      while (sb2.Next !== null && (Y <= sb2.Next.y))
        sb2 = sb2.Next;
      if (Y == sb2.y)
        return;
      //ie ignores duplicates
      var newSb = new ClipperLib.Scanbeam();
      newSb.y = Y;
      newSb.Next = sb2.Next;
      sb2.Next = newSb;
    }
  };
  // ************************************
  ClipperLib.Clipper.prototype.Execute = function ()
  {
    var a = arguments,
      alen = a.length,
      ispolytree = a[1] instanceof ClipperLib.PolyTree;
    if (alen == 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)
    {
      var clipType = a[0],
        solution = a[1],
        subjFillType = a[2],
        clipFillType = a[3];
      if (this.m_ExecuteLocked)
        return false;
      if (this.m_HasOpenPaths)
        ClipperLib.Error("Error: PolyTree struct is need for open path clipping.");
      this.m_ExecuteLocked = true;
      ClipperLib.Clear(solution);
      this.m_SubjFillType = subjFillType;
      this.m_ClipFillType = clipFillType;
      this.m_ClipType = clipType;
      this.m_UsingPolyTree = false;
      try
      {
        var succeeded = this.ExecuteInternal();
        //build the return polygons ...
        if (succeeded) this.BuildResult(solution);
      }
      finally
      {
        this.DisposeAllPolyPts();
        this.m_ExecuteLocked = false;
      }
      return succeeded;
    }
    else if (alen == 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)
    {
      var clipType = a[0],
        polytree = a[1],
        subjFillType = a[2],
        clipFillType = a[3];
      if (this.m_ExecuteLocked)
        return false;
      this.m_ExecuteLocked = true;
      this.m_SubjFillType = subjFillType;
      this.m_ClipFillType = clipFillType;
      this.m_ClipType = clipType;
      this.m_UsingPolyTree = true;
      try
      {
        var succeeded = this.ExecuteInternal();
        //build the return polygons ...
        if (succeeded) this.BuildResult2(polytree);
      }
      finally
      {
        this.DisposeAllPolyPts();
        this.m_ExecuteLocked = false;
      }
      return succeeded;
    }
    else if (alen == 2 && !ispolytree) // function (clipType, solution)
    {
      var clipType = a[0],
        solution = a[1];
      return this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);
    }
    else if (alen == 2 && ispolytree) // function (clipType, polytree)
    {
      var clipType = a[0],
        polytree = a[1];
      return this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);
    }
  };
  ClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec)
  {
    //skip if an outermost polygon or
    //already already points to the correct FirstLeft ...
    if (outRec.FirstLeft === null || (outRec.IsHole != outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null))
      return;
    var orfl = outRec.FirstLeft;
    while (orfl !== null && ((orfl.IsHole == outRec.IsHole) || orfl.Pts === null))
      orfl = orfl.FirstLeft;
    outRec.FirstLeft = orfl;
  };
  ClipperLib.Clipper.prototype.ExecuteInternal = function ()
  {
    try
    {
      this.Reset();
      if (this.m_CurrentLM === null)
        return false;
      var botY = this.PopScanbeam();
      do {
        this.InsertLocalMinimaIntoAEL(botY);
        ClipperLib.Clear(this.m_GhostJoins);
        this.ProcessHorizontals(false);
        if (this.m_Scanbeam === null)
          break;
        var topY = this.PopScanbeam();
        //console.log("boty:" + botY + ", topy:" + topY);
        if (!this.ProcessIntersections(botY, topY))
          return false;
        this.ProcessEdgesAtTopOfScanbeam(topY);
        botY = topY;
      }
      while (this.m_Scanbeam !== null || this.m_CurrentLM !== null)
      //fix orientations ...
      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)
      {
        var outRec = this.m_PolyOuts[i];
        if (outRec.Pts === null || outRec.IsOpen)
          continue;
        if ((outRec.IsHole ^ this.ReverseSolution) == (this.Area(outRec) > 0))
          this.ReversePolyPtLinks(outRec.Pts);
      }
      this.JoinCommonEdges();
      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)
      {
        var outRec = this.m_PolyOuts[i];
        if (outRec.Pts !== null && !outRec.IsOpen)
          this.FixupOutPolygon(outRec);
      }
      if (this.StrictlySimple)
        this.DoSimplePolygons();
      return true;
    }
    finally
    {
      ClipperLib.Clear(this.m_Joins);
      ClipperLib.Clear(this.m_GhostJoins);
    }
  };
  ClipperLib.Clipper.prototype.PopScanbeam = function ()
  {
    var Y = this.m_Scanbeam.y; 
    var sb2 = this.m_Scanbeam;
    this.m_Scanbeam = this.m_Scanbeam.Next;
    sb2 = null;
    return Y;
  };
  ClipperLib.Clipper.prototype.DisposeAllPolyPts = function ()
  {
    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i)
      this.DisposeOutRec(i);
    ClipperLib.Clear(this.m_PolyOuts);
  };
  ClipperLib.Clipper.prototype.DisposeOutRec = function (index)
  {
    var outRec = this.m_PolyOuts[index];
    if (outRec.Pts !== null)
      this.DisposeOutPts(outRec.Pts);
    outRec = null;
    this.m_PolyOuts[index] = null;
  };
  ClipperLib.Clipper.prototype.DisposeOutPts = function (pp)
  {
    if (pp === null)
      return;
    var tmpPp = null;
    pp.Prev.Next = null;
    while (pp !== null)
    {
      tmpPp = pp;
      pp = pp.Next;
      tmpPp = null;
    }
  };
  ClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt)
  {
    var j = new ClipperLib.Join();
    j.OutPt1 = Op1;
    j.OutPt2 = Op2;
    //j.OffPt = OffPt;
    j.OffPt.x = OffPt.x; 
    j.OffPt.y = OffPt.y; 
    this.m_Joins.push(j);
  };
  ClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt)
  {
    var j = new ClipperLib.Join();
    j.OutPt1 = Op;
    //j.OffPt = OffPt;
    j.OffPt.x = OffPt.x; 
    j.OffPt.y = OffPt.y; 
    this.m_GhostJoins.push(j);
  };
  if (use_xyz)
  {
    ClipperLib.Clipper.prototype.SetZ = function (pt, e)
    {
      pt.z = 0;
      if (this.ZFillFunction !== null)
      {
        //put the 'preferred' point as first parameter ...
        if (e.OutIdx < 0)
          this.ZFillFunction(e.Bot, e.Top, pt); //outside a path so presume entering
        else
          this.ZFillFunction(e.Top, e.Bot, pt); //inside a path so presume exiting
      }
    };
    //------------------------------------------------------------------------------
  }
  ClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY)
  {
    while (this.m_CurrentLM !== null && (this.m_CurrentLM.y == botY))
    {
      var lb = this.m_CurrentLM.LeftBound;
      var rb = this.m_CurrentLM.RightBound;
      this.PopLocalMinima();
      var Op1 = null;
      if (lb === null)
      {
        this.InsertEdgeIntoAEL(rb, null);
        this.SetWindingCount(rb);
        if (this.IsContributing(rb))
          Op1 = this.AddOutPt(rb, rb.Bot);
      }
      else if (rb == null)
      {
        this.InsertEdgeIntoAEL(lb, null);
        this.SetWindingCount(lb);
        if (this.IsContributing(lb))
          Op1 = this.AddOutPt(lb, lb.Bot);
        this.InsertScanbeam(lb.Top.y);
      }
      else
      {
        this.InsertEdgeIntoAEL(lb, null);
        this.InsertEdgeIntoAEL(rb, lb);
        this.SetWindingCount(lb);
        rb.WindCnt = lb.WindCnt;
        rb.WindCnt2 = lb.WindCnt2;
        if (this.IsContributing(lb))
          Op1 = this.AddLocalMinPoly(lb, rb, lb.Bot);
        this.InsertScanbeam(lb.Top.y);
      }
      if (rb != null)
      {
        if (ClipperLib.ClipperBase.IsHorizontal(rb))
          this.AddEdgeToSEL(rb);
        else
          this.InsertScanbeam(rb.Top.y);
      }
      if (lb == null || rb == null) continue;
      //if output polygons share an Edge with a horizontal rb, they'll need joining later ...
      if (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0)
      {
        for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++)
        {
          //if the horizontal Rb and a 'ghost' horizontal overlap, then convert
          //the 'ghost' join to a real join ready for later ...
          var j = this.m_GhostJoins[i];
          if (this.HorzSegmentsOverlap(j.OutPt1.Pt, j.OffPt, rb.Bot, rb.Top))
            this.AddJoin(j.OutPt1, Op1, j.OffPt);
        }
      }
      if (lb.OutIdx >= 0 && lb.PrevInAEL !== null &&
        lb.PrevInAEL.Curr.x == lb.Bot.x &&
        lb.PrevInAEL.OutIdx >= 0 &&
        ClipperLib.ClipperBase.SlopesEqual(lb.PrevInAEL, lb, this.m_UseFullRange) &&
        lb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0)
      {
        var Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);
        this.AddJoin(Op1, Op2, lb.Top);
      }
      if (lb.NextInAEL != rb)
      {
        if (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&
          ClipperLib.ClipperBase.SlopesEqual(rb.PrevInAEL, rb, this.m_UseFullRange) &&
          rb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0)
        {
          var Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);
          this.AddJoin(Op1, Op2, rb.Top);
        }
        var e = lb.NextInAEL;
        if (e !== null)
          while (e != rb)
          {
            //nb: For calculating winding counts etc, IntersectEdges() assumes
            //that param1 will be to the right of param2 ABOVE the intersection ...
            this.IntersectEdges(rb, e, lb.Curr, false);
            //order important here
            e = e.NextInAEL;
          }
      }
    }
  };
  ClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge)
  {
    if (this.m_ActiveEdges === null)
    {
      edge.PrevInAEL = null;
      edge.NextInAEL = null;
      this.m_ActiveEdges = edge;
    }
    else if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge))
    {
      edge.PrevInAEL = null;
      edge.NextInAEL = this.m_ActiveEdges;
      this.m_ActiveEdges.PrevInAEL = edge;
      this.m_ActiveEdges = edge;
    }
    else
    {
      if (startEdge === null)
        startEdge = this.m_ActiveEdges;
      while (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge))
        startEdge = startEdge.NextInAEL;
      edge.NextInAEL = startEdge.NextInAEL;
      if (startEdge.NextInAEL !== null)
        startEdge.NextInAEL.PrevInAEL = edge;
      edge.PrevInAEL = startEdge;
      startEdge.NextInAEL = edge;
    }
  };
  ClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2)
  {
    if (e2.Curr.x == e1.Curr.x)
    {
      if (e2.Top.y > e1.Top.y)
        return e2.Top.x < ClipperLib.Clipper.TopX(e1, e2.Top.y);
      else
        return e1.Top.x > ClipperLib.Clipper.TopX(e2, e1.Top.y);
    }
    else
      return e2.Curr.x < e1.Curr.x; 
  };
  ClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge)
  {
    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)
      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;
    else
      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;
  };
  ClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge)
  {
    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)
      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;
    else
      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;
  };
  ClipperLib.Clipper.prototype.IsContributing = function (edge)
  {
    var pft, pft2;
    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)
    {
      pft = this.m_SubjFillType;
      pft2 = this.m_ClipFillType;
    }
    else
    {
      pft = this.m_ClipFillType;
      pft2 = this.m_SubjFillType;
    }
    switch (pft)
    {
    case ClipperLib.PolyFillType.pftEvenOdd:
      if (edge.WindDelta === 0 && edge.WindCnt != 1)
        return false;
      break;
    case ClipperLib.PolyFillType.pftNonZero:
      if (Math.abs(edge.WindCnt) != 1)
        return false;
      break;
    case ClipperLib.PolyFillType.pftPositive:
      if (edge.WindCnt != 1)
        return false;
      break;
    default:
      if (edge.WindCnt != -1)
        return false;
      break;
    }
    switch (this.m_ClipType)
    {
    case ClipperLib.ClipType.ctIntersection:
      switch (pft2)
      {
      case ClipperLib.PolyFillType.pftEvenOdd:
      case ClipperLib.PolyFillType.pftNonZero:
        return (edge.WindCnt2 !== 0);
      case ClipperLib.PolyFillType.pftPositive:
        return (edge.WindCnt2 > 0);
      default:
        return (edge.WindCnt2 < 0);
      }
    case ClipperLib.ClipType.ctUnion:
      switch (pft2)
      {
      case ClipperLib.PolyFillType.pftEvenOdd:
      case ClipperLib.PolyFillType.pftNonZero:
        return (edge.WindCnt2 === 0);
      case ClipperLib.PolyFillType.pftPositive:
        return (edge.WindCnt2 <= 0);
      default:
        return (edge.WindCnt2 >= 0);
      }
    case ClipperLib.ClipType.ctDifference:
      if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)
        switch (pft2)
        {
        case ClipperLib.PolyFillType.pftEvenOdd:
        case ClipperLib.PolyFillType.pftNonZero:
          return (edge.WindCnt2 === 0);
        case ClipperLib.PolyFillType.pftPositive:
          return (edge.WindCnt2 <= 0);
        default:
          return (edge.WindCnt2 >= 0);
        }
      else
        switch (pft2)
        {
        case ClipperLib.PolyFillType.pftEvenOdd:
        case ClipperLib.PolyFillType.pftNonZero:
          return (edge.WindCnt2 !== 0);
        case ClipperLib.PolyFillType.pftPositive:
          return (edge.WindCnt2 > 0);
        default:
          return (edge.WindCnt2 < 0);
        }
    case ClipperLib.ClipType.ctXor:
      if (edge.WindDelta === 0)
        switch (pft2)
        {
        case ClipperLib.PolyFillType.pftEvenOdd:
        case ClipperLib.PolyFillType.pftNonZero:
          return (edge.WindCnt2 === 0);
        case ClipperLib.PolyFillType.pftPositive:
          return (edge.WindCnt2 <= 0);
        default:
          return (edge.WindCnt2 >= 0);
        }
      else
        return true;
    }
    return true;
  };
  ClipperLib.Clipper.prototype.SetWindingCount = function (edge)
  {
    var e = edge.PrevInAEL;
    //find the edge of the same polytype that immediately preceeds 'edge' in AEL
    while (e !== null && ((e.PolyTyp != edge.PolyTyp) || (e.WindDelta === 0)))
      e = e.PrevInAEL;
    if (e === null)
    {
      edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);
      edge.WindCnt2 = 0;
      e = this.m_ActiveEdges;
      //ie get ready to calc WindCnt2
    }
    else if (edge.WindDelta === 0 && this.m_ClipType != ClipperLib.ClipType.ctUnion)
    {
      edge.WindCnt = 1;
      edge.WindCnt2 = e.WindCnt2;
      e = e.NextInAEL;
      //ie get ready to calc WindCnt2
    }
    else if (this.IsEvenOddFillType(edge))
    {
      //EvenOdd filling ...
      if (edge.WindDelta === 0)
      {
        //are we inside a subj polygon ...
        var Inside = true;
        var e2 = e.PrevInAEL;
        while (e2 !== null)
        {
          if (e2.PolyTyp == e.PolyTyp && e2.WindDelta !== 0)
            Inside = !Inside;
          e2 = e2.PrevInAEL;
        }
        edge.WindCnt = (Inside ? 0 : 1);
      }
      else
      {
        edge.WindCnt = edge.WindDelta;
      }
      edge.WindCnt2 = e.WindCnt2;
      e = e.NextInAEL;
      //ie get ready to calc WindCnt2
    }
    else
    {
      //nonZero, Positive or Negative filling ...
      if (e.WindCnt * e.WindDelta < 0)
      {
        //prev edge is 'decreasing' WindCount (WC) toward zero
        //so we're outside the previous polygon ...
        if (Math.abs(e.WindCnt) > 1)
        {
          //outside prev poly but still inside another.
          //when reversing direction of prev poly use the same WC 
          if (e.WindDelta * edge.WindDelta < 0)
            edge.WindCnt = e.WindCnt;
          else
            edge.WindCnt = e.WindCnt + edge.WindDelta;
        }
        else
          edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);
      }
      else
      {
        //prev edge is 'increasing' WindCount (WC) away from zero
        //so we're inside the previous polygon ...
        if (edge.WindDelta === 0)
          edge.WindCnt = (e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1);
        else if (e.WindDelta * edge.WindDelta < 0)
          edge.WindCnt = e.WindCnt;
        else
          edge.WindCnt = e.WindCnt + edge.WindDelta;
      }
      edge.WindCnt2 = e.WindCnt2;
      e = e.NextInAEL;
      //ie get ready to calc WindCnt2
    }
    //update WindCnt2 ...
    if (this.IsEvenOddAltFillType(edge))
    {
      //EvenOdd filling ...
      while (e != edge)
      {
        if (e.WindDelta !== 0)
          edge.WindCnt2 = (edge.WindCnt2 === 0 ? 1 : 0);
        e = e.NextInAEL;
      }
    }
    else
    {
      //nonZero, Positive or Negative filling ...
      while (e != edge)
      {
        edge.WindCnt2 += e.WindDelta;
        e = e.NextInAEL;
      }
    }
  };
  ClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge)
  {
    //SEL pointers in PEdge are reused to build a list of horizontal edges.
    //However, we don't need to worry about order with horizontal edge processing.
    if (this.m_SortedEdges === null)
    {
      this.m_SortedEdges = edge;
      edge.PrevInSEL = null;
      edge.NextInSEL = null;
    }
    else
    {
      edge.NextInSEL = this.m_SortedEdges;
      edge.PrevInSEL = null;
      this.m_SortedEdges.PrevInSEL = edge;
      this.m_SortedEdges = edge;
    }
  };
  ClipperLib.Clipper.prototype.CopyAELToSEL = function ()
  {
    var e = this.m_ActiveEdges;
    this.m_SortedEdges = e;
    while (e !== null)
    {
      e.PrevInSEL = e.PrevInAEL;
      e.NextInSEL = e.NextInAEL;
      e = e.NextInAEL;
    }
  };
  ClipperLib.Clipper.prototype.SwapPositionsInAEL = function (edge1, edge2)
  {
    //check that one or other edge hasn't already been removed from AEL ...
    if (edge1.NextInAEL == edge1.PrevInAEL || edge2.NextInAEL == edge2.PrevInAEL)
      return;
    if (edge1.NextInAEL == edge2)
    {
      var next = edge2.NextInAEL;
      if (next !== null)
        next.PrevInAEL = edge1;
      var prev = edge1.PrevInAEL;
      if (prev !== null)
        prev.NextInAEL = edge2;
      edge2.PrevInAEL = prev;
      edge2.NextInAEL = edge1;
      edge1.PrevInAEL = edge2;
      edge1.NextInAEL = next;
    }
    else if (edge2.NextInAEL == edge1)
    {
      var next = edge1.NextInAEL;
      if (next !== null)
        next.PrevInAEL = edge2;
      var prev = edge2.PrevInAEL;
      if (prev !== null)
        prev.NextInAEL = edge1;
      edge1.PrevInAEL = prev;
      edge1.NextInAEL = edge2;
      edge2.PrevInAEL = edge1;
      edge2.NextInAEL = next;
    }
    else
    {
      var next = edge1.NextInAEL;
      var prev = edge1.PrevInAEL;
      edge1.NextInAEL = edge2.NextInAEL;
      if (edge1.NextInAEL !== null)
        edge1.NextInAEL.PrevInAEL = edge1;
      edge1.PrevInAEL = edge2.PrevInAEL;
      if (edge1.PrevInAEL !== null)
        edge1.PrevInAEL.NextInAEL = edge1;
      edge2.NextInAEL = next;
      if (edge2.NextInAEL !== null)
        edge2.NextInAEL.PrevInAEL = edge2;
      edge2.PrevInAEL = prev;
      if (edge2.PrevInAEL !== null)
        edge2.PrevInAEL.NextInAEL = edge2;
    }
    if (edge1.PrevInAEL === null)
      this.m_ActiveEdges = edge1;
    else if (edge2.PrevInAEL === null)
      this.m_ActiveEdges = edge2;
  };
  ClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2)
  {
    if (edge1.NextInSEL === null && edge1.PrevInSEL === null)
      return;
    if (edge2.NextInSEL === null && edge2.PrevInSEL === null)
      return;
    if (edge1.NextInSEL == edge2)
    {
      var next = edge2.NextInSEL;
      if (next !== null)
        next.PrevInSEL = edge1;
      var prev = edge1.PrevInSEL;
      if (prev !== null)
        prev.NextInSEL = edge2;
      edge2.PrevInSEL = prev;
      edge2.NextInSEL = edge1;
      edge1.PrevInSEL = edge2;
      edge1.NextInSEL = next;
    }
    else if (edge2.NextInSEL == edge1)
    {
      var next = edge1.NextInSEL;
      if (next !== null)
        next.PrevInSEL = edge2;
      var prev = edge2.PrevInSEL;
      if (prev !== null)
        prev.NextInSEL = edge1;
      edge1.PrevInSEL = prev;
      edge1.NextInSEL = edge2;
      edge2.PrevInSEL = edge1;
      edge2.NextInSEL = next;
    }
    else
    {
      var next = edge1.NextInSEL;
      var prev = edge1.PrevInSEL;
      edge1.NextInSEL = edge2.NextInSEL;
      if (edge1.NextInSEL !== null)
        edge1.NextInSEL.PrevInSEL = edge1;
      edge1.PrevInSEL = edge2.PrevInSEL;
      if (edge1.PrevInSEL !== null)
        edge1.PrevInSEL.NextInSEL = edge1;
      edge2.NextInSEL = next;
      if (edge2.NextInSEL !== null)
        edge2.NextInSEL.PrevInSEL = edge2;
      edge2.PrevInSEL = prev;
      if (edge2.PrevInSEL !== null)
        edge2.PrevInSEL.NextInSEL = edge2;
    }
    if (edge1.PrevInSEL === null)
      this.m_SortedEdges = edge1;
    else if (edge2.PrevInSEL === null)
      this.m_SortedEdges = edge2;
  };
  ClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt)
  {
    this.AddOutPt(e1, pt);
    if (e2.WindDelta == 0) this.AddOutPt(e2, pt);
    if (e1.OutIdx == e2.OutIdx)
    {
      e1.OutIdx = -1;
      e2.OutIdx = -1;
    }
    else if (e1.OutIdx < e2.OutIdx)
      this.AppendPolygon(e1, e2);
    else
      this.AppendPolygon(e2, e1);
  };
  ClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt)
  {
    var result;
    var e, prevE;
    if (ClipperLib.ClipperBase.IsHorizontal(e2) || (e1.Dx > e2.Dx))
    {
      result = this.AddOutPt(e1, pt);
      e2.OutIdx = e1.OutIdx;
      e1.Side = ClipperLib.EdgeSide.esLeft;
      e2.Side = ClipperLib.EdgeSide.esRight;
      e = e1;
      if (e.PrevInAEL == e2)
        prevE = e2.PrevInAEL;
      else
        prevE = e.PrevInAEL;
    }
    else
    {
      result = this.AddOutPt(e2, pt);
      e1.OutIdx = e2.OutIdx;
      e1.Side = ClipperLib.EdgeSide.esRight;
      e2.Side = ClipperLib.EdgeSide.esLeft;
      e = e2;
      if (e.PrevInAEL == e1)
        prevE = e1.PrevInAEL;
      else
        prevE = e.PrevInAEL;
    }
    if (prevE !== null && prevE.OutIdx >= 0 && (ClipperLib.Clipper.TopX(prevE, pt.y) == ClipperLib.Clipper.TopX(e, pt.y)) && ClipperLib.ClipperBase.SlopesEqual(e, prevE, this.m_UseFullRange) && (e.WindDelta !== 0) && (prevE.WindDelta !== 0))
    {
      var outPt = this.AddOutPt(prevE, pt);
      this.AddJoin(result, outPt, e.Top);
    }
    return result;
  };
  ClipperLib.Clipper.prototype.CreateOutRec = function ()
  {
    var result = new ClipperLib.OutRec();
    result.Idx = -1;
    result.IsHole = false;
    result.IsOpen = false;
    result.FirstLeft = null;
    result.Pts = null;
    result.BottomPt = null;
    result.PolyNode = null;
    this.m_PolyOuts.push(result);
    result.Idx = this.m_PolyOuts.length - 1;
    return result;
  };
  ClipperLib.Clipper.prototype.AddOutPt = function (e, pt)
  {
    var ToFront = (e.Side == ClipperLib.EdgeSide.esLeft);
    if (e.OutIdx < 0)
    {
      var outRec = this.CreateOutRec();
      outRec.IsOpen = (e.WindDelta === 0);
      var newOp = new ClipperLib.OutPt();
      outRec.Pts = newOp;
      newOp.Idx = outRec.Idx;
      //newOp.Pt = pt;
      newOp.Pt.x = pt.x; 
      newOp.Pt.y = pt.y; 
      newOp.Next = newOp;
      newOp.Prev = newOp;
      if (!outRec.IsOpen)
        this.SetHoleState(e, outRec);
      if (use_xyz)
      {
        if (ClipperLib.IntPoint.op_Equality(pt, e.Bot))
        {
          //newOp.Pt = e.Bot;
          newOp.Pt.x = e.Bot.x; 
          newOp.Pt.y = e.Bot.y; 
          newOp.Pt.z = e.Bot.z;
        }
        else if (ClipperLib.IntPoint.op_Equality(pt, e.Top))
        {
          //newOp.Pt = e.Top;
          newOp.Pt.x = e.Top.x; 
          newOp.Pt.y = e.Top.y; 
          newOp.Pt.z = e.Top.z;
        }
        else
          this.SetZ(newOp.Pt, e);
      }
      e.OutIdx = outRec.Idx;
      //nb: do this after SetZ !
      return newOp;
    }
    else
    {
      var outRec = this.m_PolyOuts[e.OutIdx];
      //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'
      var op = outRec.Pts;
      if (ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Pt))
        return op;
      else if (!ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Prev.Pt))
        return op.Prev;
      var newOp = new ClipperLib.OutPt();
      newOp.Idx = outRec.Idx;
      //newOp.Pt = pt;
      newOp.Pt.x = pt.x; 
      newOp.Pt.y = pt.y; 
      newOp.Next = op;
      newOp.Prev = op.Prev;
      newOp.Prev.Next = newOp;
      op.Prev = newOp;
      if (ToFront)
        outRec.Pts = newOp;
      if (use_xyz)
      {
        if (ClipperLib.IntPoint.op_Equality(pt, e.Bot))
        {
          //newOp.Pt = e.Bot;
          newOp.Pt.x = e.Bot.x; 
          newOp.Pt.y = e.Bot.y; 
          newOp.Pt.z = e.Bot.z;
        }
        else if (ClipperLib.IntPoint.op_Equality(pt, e.Top))
        {
          //newOp.Pt = e.Top;
          newOp.Pt.x = e.Top.x; 
          newOp.Pt.y = e.Top.y; 
          newOp.Pt.z = e.Top.z;
        }
        else
          this.SetZ(newOp.Pt, e);
      }
      return newOp;
    }
  };
  ClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2)
  {
    var tmp = new ClipperLib.IntPoint(pt1.Value);
    //pt1.Value = pt2.Value;
    pt1.Value.x = pt2.Value.x; 
    pt1.Value.y = pt2.Value.y; 
    //pt2.Value = tmp;
    pt2.Value.x = tmp.x; 
    pt2.Value.y = tmp.y; 
  };
  ClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (Pt1a, Pt1b, Pt2a, Pt2b)
  {
    //precondition: both segments are horizontal
    if ((Pt1a.x > Pt2a.x) == (Pt1a.x < Pt2b.x))
      return true;
    else if ((Pt1b.x > Pt2a.x) == (Pt1b.x < Pt2b.x))
      return true;
    else if ((Pt2a.x > Pt1a.x) == (Pt2a.x < Pt1b.x))
      return true;
    else if ((Pt2b.x > Pt1a.x) == (Pt2b.x < Pt1b.x))
      return true;
    else if ((Pt1a.x == Pt2a.x) && (Pt1b.x == Pt2b.x))
      return true;
    else if ((Pt1a.x == Pt2b.x) && (Pt1b.x == Pt2a.x))
      return true;
    else
      return false;
  };
  ClipperLib.Clipper.prototype.InsertPolyPtBetween = function (p1, p2, pt)
  {
    var result = new ClipperLib.OutPt();
    //result.Pt = pt;
    result.Pt.x = pt.x; 
    result.Pt.y = pt.y; 
    if (p2 == p1.Next)
    {
      p1.Next = result;
      p2.Prev = result;
      result.Next = p2;
      result.Prev = p1;
    }
    else
    {
      p2.Next = result;
      p1.Prev = result;
      result.Next = p1;
      result.Prev = p2;
    }
    return result;
  };
  ClipperLib.Clipper.prototype.SetHoleState = function (e, outRec)
  {
    var isHole = false;
    var e2 = e.PrevInAEL;
    while (e2 !== null)
    {
      if (e2.OutIdx >= 0 && e2.WindDelta != 0)
      {
        isHole = !isHole;
        if (outRec.FirstLeft === null)
          outRec.FirstLeft = this.m_PolyOuts[e2.OutIdx];
      }
      e2 = e2.PrevInAEL;
    }
    if (isHole)
      outRec.IsHole = true;
  };
  ClipperLib.Clipper.prototype.GetDx = function (pt1, pt2)
  {
    if (pt1.y == pt2.y)
      return ClipperLib.ClipperBase.horizontal;
    else
      return (pt2.x - pt1.x) / (pt2.y - pt1.y);
  };
  ClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2)
  {
    var p = btmPt1.Prev;
    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))
      p = p.Prev;
    var dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));
    p = btmPt1.Next;
    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))
      p = p.Next;
    var dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));
    p = btmPt2.Prev;
    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))
      p = p.Prev;
    var dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));
    p = btmPt2.Next;
    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))
      p = p.Next;
    var dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));
    return (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);
  };
  ClipperLib.Clipper.prototype.GetBottomPt = function (pp)
  {
    var dups = null;
    var p = pp.Next;
    while (p != pp)
    {
      if (p.Pt.y > pp.Pt.y)
      {
        pp = p;
        dups = null;
      }
      else if (p.Pt.y == pp.Pt.y && p.Pt.x <= pp.Pt.x)
      {
        if (p.Pt.x < pp.Pt.x)
        {
          dups = null;
          pp = p;
        }
        else
        {
          if (p.Next != pp && p.Prev != pp)
            dups = p;
        }
      }
      p = p.Next;
    }
    if (dups !== null)
    {
      //there appears to be at least 2 vertices at bottomPt so ...
      while (dups != p)
      {
        if (!this.FirstIsBottomPt(p, dups))
          pp = dups;
        dups = dups.Next;
        while (ClipperLib.IntPoint.op_Inequality(dups.Pt, pp.Pt))
          dups = dups.Next;
      }
    }
    return pp;
  };
  ClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2)
  {
    //work out which polygon fragment has the correct hole state ...
    if (outRec1.BottomPt === null)
      outRec1.BottomPt = this.GetBottomPt(outRec1.Pts);
    if (outRec2.BottomPt === null)
      outRec2.BottomPt = this.GetBottomPt(outRec2.Pts);
    var bPt1 = outRec1.BottomPt;
    var bPt2 = outRec2.BottomPt;
    if (bPt1.Pt.y > bPt2.Pt.y)
      return outRec1;
    else if (bPt1.Pt.y < bPt2.Pt.y)
      return outRec2;
    else if (bPt1.Pt.x < bPt2.Pt.x)
      return outRec1;
    else if (bPt1.Pt.x > bPt2.Pt.x)
      return outRec2;
    else if (bPt1.Next == bPt1)
      return outRec2;
    else if (bPt2.Next == bPt2)
      return outRec1;
    else if (this.FirstIsBottomPt(bPt1, bPt2))
      return outRec1;
    else
      return outRec2;
  };
  ClipperLib.Clipper.prototype.Param1RightOfParam2 = function (outRec1, outRec2)
  {
    do {
      outRec1 = outRec1.FirstLeft;
      if (outRec1 == outRec2)
        return true;
    }
    while (outRec1 !== null)
    return false;
  };
  ClipperLib.Clipper.prototype.GetOutRec = function (idx)
  {
    var outrec = this.m_PolyOuts[idx];
    while (outrec != this.m_PolyOuts[outrec.Idx])
      outrec = this.m_PolyOuts[outrec.Idx];
    return outrec;
  };
  ClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2)
  {
    //get the start and ends of both output polygons ...
    var outRec1 = this.m_PolyOuts[e1.OutIdx];
    var outRec2 = this.m_PolyOuts[e2.OutIdx];
    var holeStateRec;
    if (this.Param1RightOfParam2(outRec1, outRec2))
      holeStateRec = outRec2;
    else if (this.Param1RightOfParam2(outRec2, outRec1))
      holeStateRec = outRec1;
    else
      holeStateRec = this.GetLowermostRec(outRec1, outRec2);
    var p1_lft = outRec1.Pts;
    var p1_rt = p1_lft.Prev;
    var p2_lft = outRec2.Pts;
    var p2_rt = p2_lft.Prev;
    var side;
    //join e2 poly onto e1 poly and delete pointers to e2 ...
    if (e1.Side == ClipperLib.EdgeSide.esLeft)
    {
      if (e2.Side == ClipperLib.EdgeSide.esLeft)
      {
        //z y x a b c
        this.ReversePolyPtLinks(p2_lft);
        p2_lft.Next = p1_lft;
        p1_lft.Prev = p2_lft;
        p1_rt.Next = p2_rt;
        p2_rt.Prev = p1_rt;
        outRec1.Pts = p2_rt;
      }
      else
      {
        //x y z a b c
        p2_rt.Next = p1_lft;
        p1_lft.Prev = p2_rt;
        p2_lft.Prev = p1_rt;
        p1_rt.Next = p2_lft;
        outRec1.Pts = p2_lft;
      }
      side = ClipperLib.EdgeSide.esLeft;
    }
    else
    {
      if (e2.Side == ClipperLib.EdgeSide.esRight)
      {
        //a b c z y x
        this.ReversePolyPtLinks(p2_lft);
        p1_rt.Next = p2_rt;
        p2_rt.Prev = p1_rt;
        p2_lft.Next = p1_lft;
        p1_lft.Prev = p2_lft;
      }
      else
      {
        //a b c x y z
        p1_rt.Next = p2_lft;
        p2_lft.Prev = p1_rt;
        p1_lft.Prev = p2_rt;
        p2_rt.Next = p1_lft;
      }
      side = ClipperLib.EdgeSide.esRight;
    }
    outRec1.BottomPt = null;
    if (holeStateRec == outRec2)
    {
      if (outRec2.FirstLeft != outRec1)
        outRec1.FirstLeft = outRec2.FirstLeft;
      outRec1.IsHole = outRec2.IsHole;
    }
    outRec2.Pts = null;
    outRec2.BottomPt = null;
    outRec2.FirstLeft = outRec1;
    var OKIdx = e1.OutIdx;
    var ObsoleteIdx = e2.OutIdx;
    e1.OutIdx = -1;
    //nb: safe because we only get here via AddLocalMaxPoly
    e2.OutIdx = -1;
    var e = this.m_ActiveEdges;
    while (e !== null)
    {
      if (e.OutIdx == ObsoleteIdx)
      {
        e.OutIdx = OKIdx;
        e.Side = side;
        break;
      }
      e = e.NextInAEL;
    }
    outRec2.Idx = outRec1.Idx;
  };
  ClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp)
  {
    if (pp === null)
      return;
    var pp1;
    var pp2;
    pp1 = pp;
    do {
      pp2 = pp1.Next;
      pp1.Next = pp1.Prev;
      pp1.Prev = pp2;
      pp1 = pp2;
    }
    while (pp1 != pp)
  };
  ClipperLib.Clipper.SwapSides = function (edge1, edge2)
  {
    var side = edge1.Side;
    edge1.Side = edge2.Side;
    edge2.Side = side;
  };
  ClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2)
  {
    var outIdx = edge1.OutIdx;
    edge1.OutIdx = edge2.OutIdx;
    edge2.OutIdx = outIdx;
  };
  ClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt, protect)
  {
    //e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before
    //e2 in AEL except when e1 is being inserted at the intersection point ...
    var e1stops = !protect && e1.NextInLML === null &&
      e1.Top.x == pt.x && e1.Top.y == pt.y; 
    var e2stops = !protect && e2.NextInLML === null &&
      e2.Top.x == pt.x && e2.Top.y == pt.y; 
    var e1Contributing = (e1.OutIdx >= 0);
    var e2Contributing = (e2.OutIdx >= 0);
    if (use_lines)
    {
      //if either edge is on an OPEN path ...
      if (e1.WindDelta === 0 || e2.WindDelta === 0)
      {
        //ignore subject-subject open path intersections UNLESS they
        //are both open paths, AND they are both 'contributing maximas' ...
        if (e1.WindDelta === 0 && e2.WindDelta === 0)
        {
          if ((e1stops || e2stops) && e1Contributing && e2Contributing)
            this.AddLocalMaxPoly(e1, e2, pt);
        }
        //if intersecting a subj line with a subj poly ...
        else if (e1.PolyTyp == e2.PolyTyp &&
          e1.WindDelta != e2.WindDelta && this.m_ClipType == ClipperLib.ClipType.ctUnion)
        {
          if (e1.WindDelta === 0)
          {
            if (e2Contributing)
            {
              this.AddOutPt(e1, pt);
              if (e1Contributing)
                e1.OutIdx = -1;
            }
          }
          else
          {
            if (e1Contributing)
            {
              this.AddOutPt(e2, pt);
              if (e2Contributing)
                e2.OutIdx = -1;
            }
          }
        }
        else if (e1.PolyTyp != e2.PolyTyp)
        {
          if ((e1.WindDelta === 0) && Math.abs(e2.WindCnt) == 1 &&
            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0))
          {
            this.AddOutPt(e1, pt);
            if (e1Contributing)
              e1.OutIdx = -1;
          }
          else if ((e2.WindDelta === 0) && (Math.abs(e1.WindCnt) == 1) &&
            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0))
          {
            this.AddOutPt(e2, pt);
            if (e2Contributing)
              e2.OutIdx = -1;
          }
        }
        if (e1stops)
          if (e1.OutIdx < 0)
            this.DeleteFromAEL(e1);
          else
            ClipperLib.Error("Error intersecting polylines");
        if (e2stops)
          if (e2.OutIdx < 0)
            this.DeleteFromAEL(e2);
          else
            ClipperLib.Error("Error intersecting polylines");
        return;
      }
    }
    //update winding counts...
    //assumes that e1 will be to the Right of e2 ABOVE the intersection
    if (e1.PolyTyp == e2.PolyTyp)
    {
      if (this.IsEvenOddFillType(e1))
      {
        var oldE1WindCnt = e1.WindCnt;
        e1.WindCnt = e2.WindCnt;
        e2.WindCnt = oldE1WindCnt;
      }
      else
      {
        if (e1.WindCnt + e2.WindDelta === 0)
          e1.WindCnt = -e1.WindCnt;
        else
          e1.WindCnt += e2.WindDelta;
        if (e2.WindCnt - e1.WindDelta === 0)
          e2.WindCnt = -e2.WindCnt;
        else
          e2.WindCnt -= e1.WindDelta;
      }
    }
    else
    {
      if (!this.IsEvenOddFillType(e2))
        e1.WindCnt2 += e2.WindDelta;
      else
        e1.WindCnt2 = (e1.WindCnt2 === 0) ? 1 : 0;
      if (!this.IsEvenOddFillType(e1))
        e2.WindCnt2 -= e1.WindDelta;
      else
        e2.WindCnt2 = (e2.WindCnt2 === 0) ? 1 : 0;
    }
    var e1FillType, e2FillType, e1FillType2, e2FillType2;
    if (e1.PolyTyp == ClipperLib.PolyType.ptSubject)
    {
      e1FillType = this.m_SubjFillType;
      e1FillType2 = this.m_ClipFillType;
    }
    else
    {
      e1FillType = this.m_ClipFillType;
      e1FillType2 = this.m_SubjFillType;
    }
    if (e2.PolyTyp == ClipperLib.PolyType.ptSubject)
    {
      e2FillType = this.m_SubjFillType;
      e2FillType2 = this.m_ClipFillType;
    }
    else
    {
      e2FillType = this.m_ClipFillType;
      e2FillType2 = this.m_SubjFillType;
    }
    var e1Wc, e2Wc;
    switch (e1FillType)
    {
    case ClipperLib.PolyFillType.pftPositive:
      e1Wc = e1.WindCnt;
      break;
    case ClipperLib.PolyFillType.pftNegative:
      e1Wc = -e1.WindCnt;
      break;
    default:
      e1Wc = Math.abs(e1.WindCnt);
      break;
    }
    switch (e2FillType)
    {
    case ClipperLib.PolyFillType.pftPositive:
      e2Wc = e2.WindCnt;
      break;
    case ClipperLib.PolyFillType.pftNegative:
      e2Wc = -e2.WindCnt;
      break;
    default:
      e2Wc = Math.abs(e2.WindCnt);
      break;
    }
    if (e1Contributing && e2Contributing)
    {
      if (e1stops || e2stops || (e1Wc !== 0 && e1Wc != 1) || (e2Wc !== 0 && e2Wc != 1) ||
        (e1.PolyTyp != e2.PolyTyp && this.m_ClipType != ClipperLib.ClipType.ctXor))
        this.AddLocalMaxPoly(e1, e2, pt);
      else
      {
        this.AddOutPt(e1, pt);
        this.AddOutPt(e2, pt);
        ClipperLib.Clipper.SwapSides(e1, e2);
        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);
      }
    }
    else if (e1Contributing)
    {
      if (e2Wc === 0 || e2Wc == 1)
      {
        this.AddOutPt(e1, pt);
        ClipperLib.Clipper.SwapSides(e1, e2);
        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);
      }
    }
    else if (e2Contributing)
    {
      if (e1Wc === 0 || e1Wc == 1)
      {
        this.AddOutPt(e2, pt);
        ClipperLib.Clipper.SwapSides(e1, e2);
        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);
      }
    }
    else if ((e1Wc === 0 || e1Wc == 1) &&
      (e2Wc === 0 || e2Wc == 1) && !e1stops && !e2stops)
    {
      //neither edge is currently contributing ...
      var e1Wc2, e2Wc2;
      switch (e1FillType2)
      {
      case ClipperLib.PolyFillType.pftPositive:
        e1Wc2 = e1.WindCnt2;
        break;
      case ClipperLib.PolyFillType.pftNegative:
        e1Wc2 = -e1.WindCnt2;
        break;
      default:
        e1Wc2 = Math.abs(e1.WindCnt2);
        break;
      }
      switch (e2FillType2)
      {
      case ClipperLib.PolyFillType.pftPositive:
        e2Wc2 = e2.WindCnt2;
        break;
      case ClipperLib.PolyFillType.pftNegative:
        e2Wc2 = -e2.WindCnt2;
        break;
      default:
        e2Wc2 = Math.abs(e2.WindCnt2);
        break;
      }
      if (e1.PolyTyp != e2.PolyTyp)
        this.AddLocalMinPoly(e1, e2, pt);
      else if (e1Wc == 1 && e2Wc == 1)
        switch (this.m_ClipType)
        {
        case ClipperLib.ClipType.ctIntersection:
          if (e1Wc2 > 0 && e2Wc2 > 0)
            this.AddLocalMinPoly(e1, e2, pt);
          break;
        case ClipperLib.ClipType.ctUnion:
          if (e1Wc2 <= 0 && e2Wc2 <= 0)
            this.AddLocalMinPoly(e1, e2, pt);
          break;
        case ClipperLib.ClipType.ctDifference:
          if (((e1.PolyTyp == ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||
            ((e1.PolyTyp == ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))
            this.AddLocalMinPoly(e1, e2, pt);
          break;
        case ClipperLib.ClipType.ctXor:
          this.AddLocalMinPoly(e1, e2, pt);
          break;
        }
      else
        ClipperLib.Clipper.SwapSides(e1, e2);
    }
    if ((e1stops != e2stops) &&
      ((e1stops && (e1.OutIdx >= 0)) || (e2stops && (e2.OutIdx >= 0))))
    {
      ClipperLib.Clipper.SwapSides(e1, e2);
      ClipperLib.Clipper.SwapPolyIndexes(e1, e2);
    }
    //finally, delete any non-contributing maxima edges  ...
    if (e1stops)
      this.DeleteFromAEL(e1);
    if (e2stops)
      this.DeleteFromAEL(e2);
  };
  ClipperLib.Clipper.prototype.DeleteFromAEL = function (e)
  {
    var AelPrev = e.PrevInAEL;
    var AelNext = e.NextInAEL;
    if (AelPrev === null && AelNext === null && (e != this.m_ActiveEdges))
      return;
    //already deleted
    if (AelPrev !== null)
      AelPrev.NextInAEL = AelNext;
    else
      this.m_ActiveEdges = AelNext;
    if (AelNext !== null)
      AelNext.PrevInAEL = AelPrev;
    e.NextInAEL = null;
    e.PrevInAEL = null;
  };
  ClipperLib.Clipper.prototype.DeleteFromSEL = function (e)
  {
    var SelPrev = e.PrevInSEL;
    var SelNext = e.NextInSEL;
    if (SelPrev === null && SelNext === null && (e != this.m_SortedEdges))
      return;
    //already deleted
    if (SelPrev !== null)
      SelPrev.NextInSEL = SelNext;
    else
      this.m_SortedEdges = SelNext;
    if (SelNext !== null)
      SelNext.PrevInSEL = SelPrev;
    e.NextInSEL = null;
    e.PrevInSEL = null;
  };
  ClipperLib.Clipper.prototype.UpdateEdgeIntoAEL = function (e)
  {
    if (e.Value.NextInLML === null)
      ClipperLib.Error("UpdateEdgeIntoAEL: invalid call");
    var AelPrev = e.Value.PrevInAEL;
    var AelNext = e.Value.NextInAEL;
    e.Value.NextInLML.OutIdx = e.Value.OutIdx;
    if (AelPrev !== null)
      AelPrev.NextInAEL = e.Value.NextInLML;
    else
      this.m_ActiveEdges = e.Value.NextInLML;
    if (AelNext !== null)
      AelNext.PrevInAEL = e.Value.NextInLML;
    e.Value.NextInLML.Side = e.Value.Side;
    e.Value.NextInLML.WindDelta = e.Value.WindDelta;
    e.Value.NextInLML.WindCnt = e.Value.WindCnt;
    e.Value.NextInLML.WindCnt2 = e.Value.WindCnt2;
    e.Value = e.Value.NextInLML;
    //    e.Value.Curr = e.Value.Bot;
    e.Value.Curr.x = e.Value.Bot.x; 
    e.Value.Curr.y = e.Value.Bot.y; 
    e.Value.PrevInAEL = AelPrev;
    e.Value.NextInAEL = AelNext;
    if (!ClipperLib.ClipperBase.IsHorizontal(e.Value))
      this.InsertScanbeam(e.Value.Top.y);
  };
  ClipperLib.Clipper.prototype.ProcessHorizontals = function (isTopOfScanbeam)
  {
    var horzEdge = this.m_SortedEdges;
    while (horzEdge !== null)
    {
      this.DeleteFromSEL(horzEdge);
      this.ProcessHorizontal(horzEdge, isTopOfScanbeam);
      horzEdge = this.m_SortedEdges;
    }
  };
  ClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, Dir, Left, Right)
  {
    if (HorzEdge.Bot.x < HorzEdge.Top.x)
    {
      Left.Value = HorzEdge.Bot.x; 
      Right.Value = HorzEdge.Top.x; 
      Dir.Value = ClipperLib.Direction.dLeftToRight;
    }
    else
    {
      Left.Value = HorzEdge.Top.x; 
      Right.Value = HorzEdge.Bot.x; 
      Dir.Value = ClipperLib.Direction.dRightToLeft;
    }
  };
  ClipperLib.Clipper.prototype.PrepareHorzJoins = function (horzEdge, isTopOfScanbeam)
  {
    //get the last Op for this horizontal edge
    //the point may be anywhere along the horizontal ...
    var outPt = this.m_PolyOuts[horzEdge.OutIdx].Pts;
    if (horzEdge.Side != ClipperLib.EdgeSide.esLeft)
      outPt = outPt.Prev;
    //First, match up overlapping horizontal edges (eg when one polygon's
    //intermediate horz edge overlaps an intermediate horz edge of another, or
    //when one polygon sits on top of another) ...
    //for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; ++i) {
    //  var j = this.m_GhostJoins[i];
    //  if (this.HorzSegmentsOverlap(j.OutPt1.Pt, j.OffPt, horzEdge.Bot, horzEdge.Top))
    //    this.AddJoin(j.OutPt1, outPt, j.OffPt);
    //}

    //Also, since horizontal edges at the top of one SB are often removed from
    //the AEL before we process the horizontal edges at the bottom of the next,
    //we need to create 'ghost' Join records of 'contrubuting' horizontals that
    //we can compare with horizontals at the bottom of the next SB.
    if (isTopOfScanbeam)
      if (ClipperLib.IntPoint.op_Equality(outPt.Pt, horzEdge.Top))
        this.AddGhostJoin(outPt, horzEdge.Bot);
      else
        this.AddGhostJoin(outPt, horzEdge.Top);
  };
  ClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge, isTopOfScanbeam)
  {
    var dir;
    var horzLeft, horzRight;
    (function ()
    {
      dir = {
        Value: dir
      };
      horzLeft = {
        Value: horzLeft
      };
      horzRight = {
        Value: horzRight
      };
      var $res = this.GetHorzDirection(horzEdge, dir, horzLeft, horzRight);
      dir = dir.Value;
      horzLeft = horzLeft.Value;
      horzRight = horzRight.Value;
      return $res;
    }).call(this);
    var eLastHorz = horzEdge,
      eMaxPair = null;
    while (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML))
      eLastHorz = eLastHorz.NextInLML;
    if (eLastHorz.NextInLML === null)
      eMaxPair = this.GetMaximaPair(eLastHorz);
    for (;;)
    {
      var IsLastHorz = (horzEdge == eLastHorz);
      var e = this.GetNextInAEL(horzEdge, dir);
      while (e !== null)
      {
        //Break if we've got to the end of an intermediate horizontal edge ...
        //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.
        if (e.Curr.x == horzEdge.Top.x && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx)
          break;
        var eNext = this.GetNextInAEL(e, dir);
        //saves eNext for later
        if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.x <= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.x >= horzLeft))
        {

          if (horzEdge.OutIdx >= 0 && horzEdge.WindDelta != 0)
            this.PrepareHorzJoins(horzEdge, isTopOfScanbeam);

          //so far we're still in range of the horizontal Edge  but make sure
          //we're at the last of consec. horizontals when matching with eMaxPair
          if (e == eMaxPair && IsLastHorz)
          {
            if (dir == ClipperLib.Direction.dLeftToRight)
              this.IntersectEdges(horzEdge, e, e.Top, false);
            else
              this.IntersectEdges(e, horzEdge, e.Top, false);
            if (eMaxPair.OutIdx >= 0)
              ClipperLib.Error("ProcessHorizontal error");
            return;
          }
          else if (dir == ClipperLib.Direction.dLeftToRight)
          {
            var Pt = new ClipperLib.IntPoint(e.Curr.x, horzEdge.Curr.y);
            this.IntersectEdges(horzEdge, e, Pt, true);
          }
          else
          {
            var Pt = new ClipperLib.IntPoint(e.Curr.x, horzEdge.Curr.y);
            this.IntersectEdges(e, horzEdge, Pt, true);
          }
          this.SwapPositionsInAEL(horzEdge, e);
        }
        else if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.x >= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.x <= horzLeft))
          break;
        e = eNext;
      }
      //end while
      if (horzEdge.OutIdx >= 0 && horzEdge.WindDelta !== 0)
        this.PrepareHorzJoins(horzEdge, isTopOfScanbeam);
      if (horzEdge.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML))
      {
        (function ()
        {
          horzEdge = {
            Value: horzEdge
          };
          var $res = this.UpdateEdgeIntoAEL(horzEdge);
          horzEdge = horzEdge.Value;
          return $res;
        }).call(this);
        if (horzEdge.OutIdx >= 0)
          this.AddOutPt(horzEdge, horzEdge.Bot);
        (function ()
        {
          dir = {
            Value: dir
          };
          horzLeft = {
            Value: horzLeft
          };
          horzRight = {
            Value: horzRight
          };
          var $res = this.GetHorzDirection(horzEdge, dir, horzLeft, horzRight);
          dir = dir.Value;
          horzLeft = horzLeft.Value;
          horzRight = horzRight.Value;
          return $res;
        }).call(this);
      }
      else
        break;
    }
    //end for (;;)
    if (horzEdge.NextInLML !== null)
    {
      if (horzEdge.OutIdx >= 0)
      {
        var op1 = this.AddOutPt(horzEdge, horzEdge.Top);
        (function ()
        {
          horzEdge = {
            Value: horzEdge
          };
          var $res = this.UpdateEdgeIntoAEL(horzEdge);
          horzEdge = horzEdge.Value;
          return $res;
        }).call(this);
        if (horzEdge.WindDelta === 0)
          return;
        //nb: HorzEdge is no longer horizontal here
        var ePrev = horzEdge.PrevInAEL;
        var eNext = horzEdge.NextInAEL;
        if (ePrev !== null && ePrev.Curr.x == horzEdge.Bot.x &&
          ePrev.Curr.y == horzEdge.Bot.y && ePrev.WindDelta !== 0 &&
          (ePrev.OutIdx >= 0 && ePrev.Curr.y > ePrev.Top.y &&
            ClipperLib.ClipperBase.SlopesEqual(horzEdge, ePrev, this.m_UseFullRange)))
        {
          var op2 = this.AddOutPt(ePrev, horzEdge.Bot);
          this.AddJoin(op1, op2, horzEdge.Top);
        }
        else if (eNext !== null && eNext.Curr.x == horzEdge.Bot.x &&
          eNext.Curr.y == horzEdge.Bot.y && eNext.WindDelta !== 0 &&
          eNext.OutIdx >= 0 && eNext.Curr.y > eNext.Top.y &&
          ClipperLib.ClipperBase.SlopesEqual(horzEdge, eNext, this.m_UseFullRange))
        {
          var op2 = this.AddOutPt(eNext, horzEdge.Bot);
          this.AddJoin(op1, op2, horzEdge.Top);
        }
      }
      else
        (function ()
        {
          horzEdge = {
            Value: horzEdge
          };
          var $res = this.UpdateEdgeIntoAEL(horzEdge);
          horzEdge = horzEdge.Value;
          return $res;
        }).call(this);
    }
    else if (eMaxPair !== null)
    {
      if (eMaxPair.OutIdx >= 0)
      {
        if (dir == ClipperLib.Direction.dLeftToRight)
          this.IntersectEdges(horzEdge, eMaxPair, horzEdge.Top, false);
        else
          this.IntersectEdges(eMaxPair, horzEdge, horzEdge.Top, false);
        if (eMaxPair.OutIdx >= 0)
          ClipperLib.Error("ProcessHorizontal error");
      }
      else
      {
        this.DeleteFromAEL(horzEdge);
        this.DeleteFromAEL(eMaxPair);
      }
    }
    else
    {
      if (horzEdge.OutIdx >= 0)
        this.AddOutPt(horzEdge, horzEdge.Top);
      this.DeleteFromAEL(horzEdge);
    }
  };
  ClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction)
  {
    return Direction == ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;
  };
  ClipperLib.Clipper.prototype.IsMinima = function (e)
  {
    return e !== null && (e.Prev.NextInLML != e) && (e.Next.NextInLML != e);
  };
  ClipperLib.Clipper.prototype.IsMaxima = function (e, Y)
  {
    return (e !== null && e.Top.y == Y && e.NextInLML === null);
  };
  ClipperLib.Clipper.prototype.IsIntermediate = function (e, Y)
  {
    return (e.Top.y == Y && e.NextInLML !== null);
  };
  ClipperLib.Clipper.prototype.GetMaximaPair = function (e)
  {
    var result = null;
    if ((ClipperLib.IntPoint.op_Equality(e.Next.Top, e.Top)) && e.Next.NextInLML === null)
      result = e.Next;
    else if ((ClipperLib.IntPoint.op_Equality(e.Prev.Top, e.Top)) && e.Prev.NextInLML === null)
      result = e.Prev;
    if (result !== null && (result.OutIdx == -2 || (result.NextInAEL == result.PrevInAEL && !ClipperLib.ClipperBase.IsHorizontal(result))))
      return null;
    return result;
  };
  ClipperLib.Clipper.prototype.ProcessIntersections = function (botY, topY)
  {
    if (this.m_ActiveEdges == null)
      return true;
    try
    {
      this.BuildIntersectList(botY, topY);
      if (this.m_IntersectList.length == 0)
        return true;
      if (this.m_IntersectList.length == 1 || this.FixupIntersectionOrder())
        this.ProcessIntersectList();
      else
        return false;
    }
    catch ($$e2)
    {
      this.m_SortedEdges = null;
      this.m_IntersectList.length = 0;
      ClipperLib.Error("ProcessIntersections error");
    }
    this.m_SortedEdges = null;
    return true;
  };
  ClipperLib.Clipper.prototype.BuildIntersectList = function (botY, topY)
  {
    if (this.m_ActiveEdges === null)
      return;
    //prepare for sorting ...
    var e = this.m_ActiveEdges;
    //console.log(JSON.stringify(JSON.decycle( e )));
    this.m_SortedEdges = e;
    while (e !== null)
    {
      e.PrevInSEL = e.PrevInAEL;
      e.NextInSEL = e.NextInAEL;
      e.Curr.x = ClipperLib.Clipper.TopX(e, topY);
      e = e.NextInAEL;
    }
    //bubblesort ...
    var isModified = true;
    while (isModified && this.m_SortedEdges !== null)
    {
      isModified = false;
      e = this.m_SortedEdges;
      while (e.NextInSEL !== null)
      {
        var eNext = e.NextInSEL;
        var pt = new ClipperLib.IntPoint();
        //console.log("e.Curr.x: " + e.Curr.x + " eNext.Curr.X" + eNext.Curr.x);
        if (e.Curr.x > eNext.Curr.x)
        {
          if (!(function ()
          {
            pt = {
              Value: pt
            };
            var $res = this.IntersectPoint(e, eNext, pt);
            pt = pt.Value;
            //console.log("pt: "+JSON.stringify(JSON.decycle( pt )));
            return $res;
          }).call(this) && e.Curr.x > eNext.Curr.x + 1)
          {
            //console.log("e.Curr.x: "+JSON.stringify(JSON.decycle( e.Curr.x )));
            //console.log("eNext.Curr.X+1: "+JSON.stringify(JSON.decycle( eNext.Curr.X+1)));
            ClipperLib.Error("Intersection error");
          }
          if (pt.y > botY)
          {
            pt.y = botY;
            if (Math.abs(e.Dx) > Math.abs(eNext.Dx))
              pt.x = ClipperLib.Clipper.TopX(eNext, botY);
            else
              pt.x = ClipperLib.Clipper.TopX(e, botY);
          }
          var newNode = new ClipperLib.IntersectNode();
          newNode.Edge1 = e;
          newNode.Edge2 = eNext;
          //newNode.Pt = pt;
          newNode.Pt.x = pt.x; 
          newNode.Pt.y = pt.y; 
          this.m_IntersectList.push(newNode);
          this.SwapPositionsInSEL(e, eNext);
          isModified = true;
        }
        else
          e = eNext;
      }
      if (e.PrevInSEL !== null)
        e.PrevInSEL.NextInSEL = null;
      else
        break;
    }
    this.m_SortedEdges = null;
  };
  ClipperLib.Clipper.prototype.EdgesAdjacent = function (inode)
  {
    return (inode.Edge1.NextInSEL == inode.Edge2) || (inode.Edge1.PrevInSEL == inode.Edge2);
  };
  ClipperLib.Clipper.IntersectNodeSort = function (node1, node2)
  {
    //the following typecast is safe because the differences in Pt.y will
    //be limited to the height of the scanbeam.
    return (node2.Pt.y - node1.Pt.y);
  };
  ClipperLib.Clipper.prototype.FixupIntersectionOrder = function ()
  {
    //pre-condition: intersections are sorted bottom-most first.
    //Now it's crucial that intersections are made only between adjacent edges,
    //so to ensure this the order of intersections may need adjusting ...
    this.m_IntersectList.sort(this.m_IntersectNodeComparer);
    this.CopyAELToSEL();
    var cnt = this.m_IntersectList.length;
    for (var i = 0; i < cnt; i++)
    {
      if (!this.EdgesAdjacent(this.m_IntersectList[i]))
      {
        var j = i + 1;
        while (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j]))
          j++;
        if (j == cnt)
          return false;
        var tmp = this.m_IntersectList[i];
        this.m_IntersectList[i] = this.m_IntersectList[j];
        this.m_IntersectList[j] = tmp;
      }
      this.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);
    }
    return true;
  };
  ClipperLib.Clipper.prototype.ProcessIntersectList = function ()
  {
    for (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++)
    {
      var iNode = this.m_IntersectList[i];
      this.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt, true);
      this.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);
    }
    this.m_IntersectList.length = 0;
  };
  /*
  --------------------------------
  Round speedtest: http://jsperf.com/fastest-round
  --------------------------------
  */
  var R1 = function (a)
  {
    return a < 0 ? Math.ceil(a - 0.5) : Math.round(a)
  };
  var R2 = function (a)
  {
    return a < 0 ? Math.ceil(a - 0.5) : Math.floor(a + 0.5)
  };
  var R3 = function (a)
  {
    return a < 0 ? -Math.round(Math.abs(a)) : Math.round(a)
  };
  var R4 = function (a)
  {
    if (a < 0)
    {
      a -= 0.5;
      return a < -2147483648 ? Math.ceil(a) : a | 0;
    }
    else
    {
      a += 0.5;
      return a > 2147483647 ? Math.floor(a) : a | 0;
    }
  };
  if (browser.msie) ClipperLib.Clipper.Round = R1;
  else if (browser.chromium) ClipperLib.Clipper.Round = R3;
  else if (browser.safari) ClipperLib.Clipper.Round = R4;
  else ClipperLib.Clipper.Round = R2; // eg. browser.chrome || browser.firefox || browser.opera
  ClipperLib.Clipper.TopX = function (edge, currentY)
  {
    //if (edge.Bot == edge.Curr) alert ("edge.Bot = edge.Curr");
    //if (edge.Bot == edge.Top) alert ("edge.Bot = edge.Top");
    if (currentY == edge.Top.y)
      return edge.Top.x; 
    return edge.Bot.x + ClipperLib.Clipper.Round(edge.Dx * (currentY - edge.Bot.y));
  };
  ClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip)
  {
    ip.Value = new ClipperLib.IntPoint();
    var b1, b2;
    //nb: with very large coordinate values, it's possible for SlopesEqual() to 
    //return false but for the edge.Dx value be equal due to double precision rounding.
    if (ClipperLib.ClipperBase.SlopesEqual(edge1, edge2, this.m_UseFullRange) || edge1.Dx == edge2.Dx)
    {
      if (edge2.Bot.y > edge1.Bot.y)
      {
        ip.Value.x = edge2.Bot.x; 
        ip.Value.y = edge2.Bot.y; 
      }
      else
      {
        ip.Value.x = edge1.Bot.x; 
        ip.Value.y = edge1.Bot.y; 
      }
      return false;
    }
    else if (edge1.Delta.x === 0)
    {
      ip.Value.x = edge1.Bot.x; 
      if (ClipperLib.ClipperBase.IsHorizontal(edge2))
      {
        ip.Value.y = edge2.Bot.y; 
      }
      else
      {
        b2 = edge2.Bot.y - (edge2.Bot.x / edge2.Dx);
        ip.Value.y = ClipperLib.Clipper.Round(ip.Value.x / edge2.Dx + b2);
      }
    }
    else if (edge2.Delta.x === 0)
    {
      ip.Value.x = edge2.Bot.x; 
      if (ClipperLib.ClipperBase.IsHorizontal(edge1))
      {
        ip.Value.y = edge1.Bot.y; 
      }
      else
      {
        b1 = edge1.Bot.y - (edge1.Bot.x / edge1.Dx);
        ip.Value.y = ClipperLib.Clipper.Round(ip.Value.x / edge1.Dx + b1);
      }
    }
    else
    {
      b1 = edge1.Bot.x - edge1.Bot.y * edge1.Dx;
      b2 = edge2.Bot.x - edge2.Bot.y * edge2.Dx;
      var q = (b2 - b1) / (edge1.Dx - edge2.Dx);
      ip.Value.y = ClipperLib.Clipper.Round(q);
      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))
        ip.Value.x = ClipperLib.Clipper.Round(edge1.Dx * q + b1);
      else
        ip.Value.x = ClipperLib.Clipper.Round(edge2.Dx * q + b2);
    }
    if (ip.Value.y < edge1.Top.y || ip.Value.y < edge2.Top.y)
    {
      if (edge1.Top.y > edge2.Top.y)
      {
        ip.Value.y = edge1.Top.y; 
        ip.Value.x = ClipperLib.Clipper.TopX(edge2, edge1.Top.y);
        return ip.Value.x < edge1.Top.x; 
      }
      else
        ip.Value.y = edge2.Top.y; 
      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))
        ip.Value.x = ClipperLib.Clipper.TopX(edge1, ip.Value.y);
      else
        ip.Value.x = ClipperLib.Clipper.TopX(edge2, ip.Value.y);
    }
    return true;
  };
  ClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY)
  {
    var e = this.m_ActiveEdges;
    while (e !== null)
    {
      //1. process maxima, treating them as if they're 'bent' horizontal edges,
      //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.
      var IsMaximaEdge = this.IsMaxima(e, topY);
      if (IsMaximaEdge)
      {
        var eMaxPair = this.GetMaximaPair(e);
        IsMaximaEdge = (eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair));
      }
      if (IsMaximaEdge)
      {
        var ePrev = e.PrevInAEL;
        this.DoMaxima(e);
        if (ePrev === null)
          e = this.m_ActiveEdges;
        else
          e = ePrev.NextInAEL;
      }
      else
      {
        //2. promote horizontal edges, otherwise update Curr.x and Curr.y ...
        if (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML))
        {
          (function ()
          {
            e = {
              Value: e
            };
            var $res = this.UpdateEdgeIntoAEL(e);
            e = e.Value;
            return $res;
          }).call(this);
          if (e.OutIdx >= 0)
            this.AddOutPt(e, e.Bot);
          this.AddEdgeToSEL(e);
        }
        else
        {
          e.Curr.x = ClipperLib.Clipper.TopX(e, topY);
          e.Curr.y = topY;
        }
        if (this.StrictlySimple)
        {
          var ePrev = e.PrevInAEL;
          if ((e.OutIdx >= 0) && (e.WindDelta !== 0) && ePrev !== null &&
            (ePrev.OutIdx >= 0) && (ePrev.Curr.x == e.Curr.x) &&
            (ePrev.WindDelta !== 0))
          {
            var op = this.AddOutPt(ePrev, e.Curr);
            var op2 = this.AddOutPt(e, e.Curr);
            this.AddJoin(op, op2, e.Curr);
            //StrictlySimple (type-3) join
          }
        }
        e = e.NextInAEL;
      }
    }
    //3. Process horizontals at the Top of the scanbeam ...
    this.ProcessHorizontals(true);
    //4. Promote intermediate vertices ...
    e = this.m_ActiveEdges;
    while (e !== null)
    {
      if (this.IsIntermediate(e, topY))
      {
        var op = null;
        if (e.OutIdx >= 0)
          op = this.AddOutPt(e, e.Top);
        (function ()
        {
          e = {
            Value: e
          };
          var $res = this.UpdateEdgeIntoAEL(e);
          e = e.Value;
          return $res;
        }).call(this);
        //if output polygons share an edge, they'll need joining later ...
        var ePrev = e.PrevInAEL;
        var eNext = e.NextInAEL;
        if (ePrev !== null && ePrev.Curr.x == e.Bot.x &&
          ePrev.Curr.y == e.Bot.y && op !== null &&
          ePrev.OutIdx >= 0 && ePrev.Curr.y > ePrev.Top.y &&
          ClipperLib.ClipperBase.SlopesEqual(e, ePrev, this.m_UseFullRange) &&
          (e.WindDelta !== 0) && (ePrev.WindDelta !== 0))
        {
          var op2 = this.AddOutPt(ePrev, e.Bot);
          this.AddJoin(op, op2, e.Top);
        }
        else if (eNext !== null && eNext.Curr.x == e.Bot.x &&
          eNext.Curr.y == e.Bot.y && op !== null &&
          eNext.OutIdx >= 0 && eNext.Curr.y > eNext.Top.y &&
          ClipperLib.ClipperBase.SlopesEqual(e, eNext, this.m_UseFullRange) &&
          (e.WindDelta !== 0) && (eNext.WindDelta !== 0))
        {
          var op2 = this.AddOutPt(eNext, e.Bot);
          this.AddJoin(op, op2, e.Top);
        }
      }
      e = e.NextInAEL;
    }
  };
  ClipperLib.Clipper.prototype.DoMaxima = function (e)
  {
    var eMaxPair = this.GetMaximaPair(e);
    if (eMaxPair === null)
    {
      if (e.OutIdx >= 0)
        this.AddOutPt(e, e.Top);
      this.DeleteFromAEL(e);
      return;
    }
    var eNext = e.NextInAEL;
    var use_lines = true;
    while (eNext !== null && eNext != eMaxPair)
    {
      this.IntersectEdges(e, eNext, e.Top, true);
      this.SwapPositionsInAEL(e, eNext);
      eNext = e.NextInAEL;
    }
    if (e.OutIdx == -1 && eMaxPair.OutIdx == -1)
    {
      this.DeleteFromAEL(e);
      this.DeleteFromAEL(eMaxPair);
    }
    else if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0)
    {
      this.IntersectEdges(e, eMaxPair, e.Top, false);
    }
    else if (use_lines && e.WindDelta === 0)
    {
      if (e.OutIdx >= 0)
      {
        this.AddOutPt(e, e.Top);
        e.OutIdx = -1;
      }
      this.DeleteFromAEL(e);
      if (eMaxPair.OutIdx >= 0)
      {
        this.AddOutPt(eMaxPair, e.Top);
        eMaxPair.OutIdx = -1;
      }
      this.DeleteFromAEL(eMaxPair);
    }
    else
      ClipperLib.Error("DoMaxima error");
  };
  ClipperLib.Clipper.ReversePaths = function (polys)
  {
    for (var i = 0, len = polys.length; i < len; i++)
      polys[i].reverse();
  };
  ClipperLib.Clipper.Orientation = function (poly)
  {
    return ClipperLib.Clipper.Area(poly) >= 0;
  };
  ClipperLib.Clipper.prototype.PointCount = function (pts)
  {
    if (pts === null)
      return 0;
    var result = 0;
    var p = pts;
    do {
      result++;
      p = p.Next;
    }
    while (p != pts)
    return result;
  };
  ClipperLib.Clipper.prototype.BuildResult = function (polyg)
  {
    ClipperLib.Clear(polyg);
    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)
    {
      var outRec = this.m_PolyOuts[i];
      if (outRec.Pts === null)
        continue;
      var p = outRec.Pts.Prev;
      var cnt = this.PointCount(p);
      if (cnt < 2)
        continue;
      var pg = new Array(cnt);
      for (var j = 0; j < cnt; j++)
      {
        pg[j] = p.Pt;
        p = p.Prev;
      }
      polyg.push(pg);
    }
  };
  ClipperLib.Clipper.prototype.BuildResult2 = function (polytree)
  {
    polytree.Clear();
    //add each output polygon/contour to polytree ...
    //polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);
    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)
    {
      var outRec = this.m_PolyOuts[i];
      var cnt = this.PointCount(outRec.Pts);
      if ((outRec.IsOpen && cnt < 2) || (!outRec.IsOpen && cnt < 3))
        continue;
      this.FixHoleLinkage(outRec);
      var pn = new ClipperLib.PolyNode();
      polytree.m_AllPolys.push(pn);
      outRec.PolyNode = pn;
      pn.m_polygon.length = cnt;
      var op = outRec.Pts.Prev;
      for (var j = 0; j < cnt; j++)
      {
        pn.m_polygon[j] = op.Pt;
        op = op.Prev;
      }
    }
    //fixup PolyNode links etc ...
    //polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);
    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)
    {
      var outRec = this.m_PolyOuts[i];
      if (outRec.PolyNode === null)
        continue;
      else if (outRec.IsOpen)
      {
        outRec.PolyNode.IsOpen = true;
        polytree.AddChild(outRec.PolyNode);
      }
      else if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode != null)
        outRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);
      else
        polytree.AddChild(outRec.PolyNode);
    }
  };
  ClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec)
  {
    //FixupOutPolygon() - removes duplicate points and simplifies consecutive
    //parallel edges by removing the middle vertex.
    var lastOK = null;
    outRec.BottomPt = null;
    var pp = outRec.Pts;
    for (;;)
    {
      if (pp.Prev == pp || pp.Prev == pp.Next)
      {
        this.DisposeOutPts(pp);
        outRec.Pts = null;
        return;
      }
      //test for duplicate points and collinear edges ...
      if ((ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Next.Pt)) || (ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Prev.Pt)) ||
        (ClipperLib.ClipperBase.SlopesEqual(pp.Prev.Pt, pp.Pt, pp.Next.Pt, this.m_UseFullRange) &&
          (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt))))
      {
        lastOK = null;
        var tmp = pp;
        pp.Prev.Next = pp.Next;
        pp.Next.Prev = pp.Prev;
        pp = pp.Prev;
        tmp = null;
      }
      else if (pp == lastOK)
        break;
      else
      {
        if (lastOK === null)
          lastOK = pp;
        pp = pp.Next;
      }
    }
    outRec.Pts = pp;
  };
  ClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter)
  {
    var result = new ClipperLib.OutPt();
    //result.Pt = outPt.Pt;
    result.Pt.x = outPt.Pt.x; 
    result.Pt.y = outPt.Pt.y; 
    result.Idx = outPt.Idx;
    if (InsertAfter)
    {
      result.Next = outPt.Next;
      result.Prev = outPt;
      outPt.Next.Prev = result;
      outPt.Next = result;
    }
    else
    {
      result.Prev = outPt.Prev;
      result.Next = outPt;
      outPt.Prev.Next = result;
      outPt.Prev = result;
    }
    return result;
  };
  ClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, Left, Right)
  {
    if (a1 < a2)
    {
      if (b1 < b2)
      {
        Left.Value = Math.max(a1, b1);
        Right.Value = Math.min(a2, b2);
      }
      else
      {
        Left.Value = Math.max(a1, b2);
        Right.Value = Math.min(a2, b1);
      }
    }
    else
    {
      if (b1 < b2)
      {
        Left.Value = Math.max(a2, b1);
        Right.Value = Math.min(a1, b2);
      }
      else
      {
        Left.Value = Math.max(a2, b2);
        Right.Value = Math.min(a1, b1);
      }
    }
    return Left.Value < Right.Value;
  };
  ClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft)
  {
    var Dir1 = (op1.Pt.x > op1b.Pt.x ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);
    var Dir2 = (op2.Pt.x > op2b.Pt.x ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);
    if (Dir1 == Dir2)
      return false;
    //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we
    //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)
    //So, to facilitate this while inserting Op1b and Op2b ...
    //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,
    //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)
    if (Dir1 == ClipperLib.Direction.dLeftToRight)
    {
      while (op1.Next.Pt.x <= Pt.x &&
        op1.Next.Pt.x >= op1.Pt.x && op1.Next.Pt.y == Pt.y)
        op1 = op1.Next;
      if (DiscardLeft && (op1.Pt.x != Pt.x))
        op1 = op1.Next;
      op1b = this.DupOutPt(op1, !DiscardLeft);
      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))
      {
        op1 = op1b;
        //op1.Pt = Pt;
        op1.Pt.x = Pt.x; 
        op1.Pt.y = Pt.y; 
        op1b = this.DupOutPt(op1, !DiscardLeft);
      }
    }
    else
    {
      while (op1.Next.Pt.x >= Pt.x &&
        op1.Next.Pt.x <= op1.Pt.x && op1.Next.Pt.y == Pt.y)
        op1 = op1.Next;
      if (!DiscardLeft && (op1.Pt.x != Pt.x))
        op1 = op1.Next;
      op1b = this.DupOutPt(op1, DiscardLeft);
      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))
      {
        op1 = op1b;
        //op1.Pt = Pt;
        op1.Pt.x = Pt.x; 
        op1.Pt.y = Pt.y; 
        op1b = this.DupOutPt(op1, DiscardLeft);
      }
    }
    if (Dir2 == ClipperLib.Direction.dLeftToRight)
    {
      while (op2.Next.Pt.x <= Pt.x &&
        op2.Next.Pt.x >= op2.Pt.x && op2.Next.Pt.y == Pt.y)
        op2 = op2.Next;
      if (DiscardLeft && (op2.Pt.x != Pt.x))
        op2 = op2.Next;
      op2b = this.DupOutPt(op2, !DiscardLeft);
      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))
      {
        op2 = op2b;
        //op2.Pt = Pt;
        op2.Pt.x = Pt.x; 
        op2.Pt.y = Pt.y; 
        op2b = this.DupOutPt(op2, !DiscardLeft);
      }
    }
    else
    {
      while (op2.Next.Pt.x >= Pt.x &&
        op2.Next.Pt.x <= op2.Pt.x && op2.Next.Pt.y == Pt.y)
        op2 = op2.Next;
      if (!DiscardLeft && (op2.Pt.x != Pt.x))
        op2 = op2.Next;
      op2b = this.DupOutPt(op2, DiscardLeft);
      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))
      {
        op2 = op2b;
        //op2.Pt = Pt;
        op2.Pt.x = Pt.x; 
        op2.Pt.y = Pt.y; 
        op2b = this.DupOutPt(op2, DiscardLeft);
      }
    }
    if ((Dir1 == ClipperLib.Direction.dLeftToRight) == DiscardLeft)
    {
      op1.Prev = op2;
      op2.Next = op1;
      op1b.Next = op2b;
      op2b.Prev = op1b;
    }
    else
    {
      op1.Next = op2;
      op2.Prev = op1;
      op1b.Prev = op2b;
      op2b.Next = op1b;
    }
    return true;
  };
  ClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2)
  {
    var op1 = j.OutPt1,
      op1b = new ClipperLib.OutPt();
    var op2 = j.OutPt2,
      op2b = new ClipperLib.OutPt();
    //There are 3 kinds of joins for output polygons ...
    //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are a vertices anywhere
    //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).
    //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same
    //location at the Bottom of the overlapping segment (& Join.OffPt is above).
    //3. StrictlySimple joins where edges touch but are not collinear and where
    //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.
    var isHorizontal = (j.OutPt1.Pt.y == j.OffPt.y);
    if (isHorizontal && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt1.Pt)) && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt2.Pt)))
    {
      //Strictly Simple join ...
      op1b = j.OutPt1.Next;
      while (op1b != op1 && (ClipperLib.IntPoint.op_Equality(op1b.Pt, j.OffPt)))
        op1b = op1b.Next;
      var reverse1 = (op1b.Pt.y > j.OffPt.y);
      op2b = j.OutPt2.Next;
      while (op2b != op2 && (ClipperLib.IntPoint.op_Equality(op2b.Pt, j.OffPt)))
        op2b = op2b.Next;
      var reverse2 = (op2b.Pt.y > j.OffPt.y);
      if (reverse1 == reverse2)
        return false;
      if (reverse1)
      {
        op1b = this.DupOutPt(op1, false);
        op2b = this.DupOutPt(op2, true);
        op1.Prev = op2;
        op2.Next = op1;
        op1b.Next = op2b;
        op2b.Prev = op1b;
        j.OutPt1 = op1;
        j.OutPt2 = op1b;
        return true;
      }
      else
      {
        op1b = this.DupOutPt(op1, true);
        op2b = this.DupOutPt(op2, false);
        op1.Next = op2;
        op2.Prev = op1;
        op1b.Prev = op2b;
        op2b.Next = op1b;
        j.OutPt1 = op1;
        j.OutPt2 = op1b;
        return true;
      }
    }
    else if (isHorizontal)
    {
      //treat horizontal joins differently to non-horizontal joins since with
      //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt
      //may be anywhere along the horizontal edge.
      op1b = op1;
      while (op1.Prev.Pt.y == op1.Pt.y && op1.Prev != op1b && op1.Prev != op2)
        op1 = op1.Prev;
      while (op1b.Next.Pt.y == op1b.Pt.y && op1b.Next != op1 && op1b.Next != op2)
        op1b = op1b.Next;
      if (op1b.Next == op1 || op1b.Next == op2)
        return false;
      //a flat 'polygon'
      op2b = op2;
      while (op2.Prev.Pt.y == op2.Pt.y && op2.Prev != op2b && op2.Prev != op1b)
        op2 = op2.Prev;
      while (op2b.Next.Pt.y == op2b.Pt.y && op2b.Next != op2 && op2b.Next != op1)
        op2b = op2b.Next;
      if (op2b.Next == op2 || op2b.Next == op1)
        return false;
      //a flat 'polygon'
      var Left, Right;
      //Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges
      if (!(function ()
      {
        Left = {
          Value: Left
        };
        Right = {
          Value: Right
        };
        var $res = this.GetOverlap(op1.Pt.x, op1b.Pt.x, op2.Pt.x, op2b.Pt.x, Left, Right);
        Left = Left.Value;
        Right = Right.Value;
        return $res;
      }).call(this))
        return false;
      //DiscardLeftSide: when overlapping edges are joined, a spike will created
      //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up
      //on the discard Side as either may still be needed for other joins ...
      var Pt = new ClipperLib.IntPoint();
      var DiscardLeftSide;
      if (op1.Pt.x >= Left && op1.Pt.x <= Right)
      {
        //Pt = op1.Pt;
        Pt.x = op1.Pt.x; 
        Pt.y = op1.Pt.y; 
        DiscardLeftSide = (op1.Pt.x > op1b.Pt.x);
      }
      else if (op2.Pt.x >= Left && op2.Pt.x <= Right)
      {
        //Pt = op2.Pt;
        Pt.x = op2.Pt.x; 
        Pt.y = op2.Pt.y; 
        DiscardLeftSide = (op2.Pt.x > op2b.Pt.x);
      }
      else if (op1b.Pt.x >= Left && op1b.Pt.x <= Right)
      {
        //Pt = op1b.Pt;
        Pt.x = op1b.Pt.x; 
        Pt.y = op1b.Pt.y; 
        DiscardLeftSide = op1b.Pt.x > op1.Pt.x; 
      }
      else
      {
        //Pt = op2b.Pt;
        Pt.x = op2b.Pt.x; 
        Pt.y = op2b.Pt.y; 
        DiscardLeftSide = (op2b.Pt.x > op2.Pt.x);
      }
      j.OutPt1 = op1;
      j.OutPt2 = op2;
      return this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);
    }
    else
    {
      //nb: For non-horizontal joins ...
      //    1. Jr.OutPt1.Pt.y == Jr.OutPt2.Pt.Y
      //    2. Jr.OutPt1.Pt > Jr.OffPt.Y
      //make sure the polygons are correctly oriented ...
      op1b = op1.Next;
      while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))
        op1b = op1b.Next;
      var Reverse1 = ((op1b.Pt.y > op1.Pt.y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange));
      if (Reverse1)
      {
        op1b = op1.Prev;
        while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))
          op1b = op1b.Prev;
        if ((op1b.Pt.y > op1.Pt.y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange))
          return false;
      }
      op2b = op2.Next;
      while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))
        op2b = op2b.Next;
      var Reverse2 = ((op2b.Pt.y > op2.Pt.y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange));
      if (Reverse2)
      {
        op2b = op2.Prev;
        while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))
          op2b = op2b.Prev;
        if ((op2b.Pt.y > op2.Pt.y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange))
          return false;
      }
      if ((op1b == op1) || (op2b == op2) || (op1b == op2b) ||
        ((outRec1 == outRec2) && (Reverse1 == Reverse2)))
        return false;
      if (Reverse1)
      {
        op1b = this.DupOutPt(op1, false);
        op2b = this.DupOutPt(op2, true);
        op1.Prev = op2;
        op2.Next = op1;
        op1b.Next = op2b;
        op2b.Prev = op1b;
        j.OutPt1 = op1;
        j.OutPt2 = op1b;
        return true;
      }
      else
      {
        op1b = this.DupOutPt(op1, true);
        op2b = this.DupOutPt(op2, false);
        op1.Next = op2;
        op2.Prev = op1;
        op1b.Prev = op2b;
        op2b.Next = op1b;
        j.OutPt1 = op1;
        j.OutPt2 = op1b;
        return true;
      }
    }
  };
  ClipperLib.Clipper.GetBounds = function (paths)
  {
    var i = 0,
      cnt = paths.length;
    while (i < cnt && paths[i].length == 0) i++;
    if (i == cnt) return new ClipperLib.IntRect(0, 0, 0, 0);
    var result = new ClipperLib.IntRect();
    result.left = paths[i][0].x; 
    result.right = result.left;
    result.top = paths[i][0].y; 
    result.bottom = result.top;
    for (; i < cnt; i++)
      for (var j = 0, jlen = paths[i].length; j < jlen; j++)
      {
        if (paths[i][j].x < result.left) result.left = paths[i][j].x; 
        else if (paths[i][j].x > result.right) result.right = paths[i][j].x; 
        if (paths[i][j].y < result.top) result.top = paths[i][j].y; 
        else if (paths[i][j].y > result.bottom) result.bottom = paths[i][j].y; 
      }
    return result;
  }
  ClipperLib.Clipper.prototype.GetBounds2 = function (ops)
  {
    var opStart = ops;
    var result = new ClipperLib.IntRect();
    result.left = ops.Pt.x; 
    result.right = ops.Pt.x; 
    result.top = ops.Pt.y; 
    result.bottom = ops.Pt.y; 
    ops = ops.Next;
    while (ops != opStart)
    {
      if (ops.Pt.x < result.left)
        result.left = ops.Pt.x; 
      if (ops.Pt.x > result.right)
        result.right = ops.Pt.x; 
      if (ops.Pt.y < result.top)
        result.top = ops.Pt.y; 
      if (ops.Pt.y > result.bottom)
        result.bottom = ops.Pt.y; 
      ops = ops.Next;
    }
    return result;
  };

  ClipperLib.Clipper.PointInPolygon = function (pt, path)
  {
    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary
    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf
    var result = 0,
      cnt = path.length;
    if (cnt < 3)
      return 0;
    var ip = path[0];
    for (var i = 1; i <= cnt; ++i)
    {
      var ipNext = (i == cnt ? path[0] : path[i]);
      if (ipNext.y == pt.y)
      {
        if ((ipNext.x == pt.x) || (ip.y == pt.y && ((ipNext.x > pt.x) == (ip.x < pt.x))))
          return -1;
      }
      if ((ip.y < pt.y) != (ipNext.y < pt.y))
      {
        if (ip.x >= pt.x)
        {
          if (ipNext.x > pt.x)
            result = 1 - result;
          else
          {
            var d = (ip.x - pt.x) * (ipNext.y - pt.y) - (ipNext.x - pt.x) * (ip.y - pt.y);
            if (d == 0)
              return -1;
            else if ((d > 0) == (ipNext.y > ip.y))
              result = 1 - result;
          }
        }
        else
        {
          if (ipNext.x > pt.x)
          {
            var d = (ip.x - pt.x) * (ipNext.y - pt.y) - (ipNext.x - pt.x) * (ip.y - pt.y);
            if (d == 0)
              return -1;
            else if ((d > 0) == (ipNext.y > ip.y))
              result = 1 - result;
          }
        }
      }
      ip = ipNext;
    }
    return result;
  };
      
  ClipperLib.Clipper.prototype.PointInPolygon = function (pt, op)
  {
    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary
    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf
    var result = 0;
    var startOp = op;
    for (;;)
    {
      var poly0x = op.Pt.x,
        poly0y = op.Pt.y; 
      var poly1x = op.Next.Pt.x,
        poly1y = op.Next.Pt.y; 
      if (poly1y == pt.y)
      {
        if ((poly1x == pt.x) || (poly0y == pt.y && ((poly1x > pt.x) == (poly0x < pt.x))))
          return -1;
      }
      if ((poly0y < pt.y) != (poly1y < pt.y))
      {
        if (poly0x >= pt.x)
        {
          if (poly1x > pt.x)
            result = 1 - result;
          else
          {
            var d = (poly0x - pt.x) * (poly1y - pt.y) - (poly1x - pt.x) * (poly0y - pt.y);
            if (d == 0)
              return -1;
            if ((d > 0) == (poly1y > poly0y))
              result = 1 - result;
          }
        }
        else
        {
          if (poly1x > pt.x)
          {
            var d = (poly0x - pt.x) * (poly1y - pt.y) - (poly1x - pt.x) * (poly0y - pt.y);
            if (d == 0)
              return -1;
            if ((d > 0) == (poly1y > poly0y))
              result = 1 - result;
          }
        }
      }
      op = op.Next;
      if (startOp == op)
        break;
    }
    return result;
  };

  ClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2)
  {
    var op = outPt1;
    do {
      var res = this.PointInPolygon(op.Pt, outPt2);
      if (res >= 0)
        return res != 0;
      op = op.Next;
    }
    while (op != outPt1)
    return true;
  };
  ClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec)
  {
    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)
    {
      var outRec = this.m_PolyOuts[i];
      if (outRec.Pts !== null && outRec.FirstLeft == OldOutRec)
      {
        if (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts))
          outRec.FirstLeft = NewOutRec;
      }
    }
  };
  ClipperLib.Clipper.prototype.FixupFirstLefts2 = function (OldOutRec, NewOutRec)
  {
    for (var $i2 = 0, $t2 = this.m_PolyOuts, $l2 = $t2.length, outRec = $t2[$i2]; $i2 < $l2; $i2++, outRec = $t2[$i2])
      if (outRec.FirstLeft == OldOutRec)
        outRec.FirstLeft = NewOutRec;
  };
  ClipperLib.Clipper.ParseFirstLeft = function (FirstLeft)
  {
    while (FirstLeft != null && FirstLeft.Pts == null)
      FirstLeft = FirstLeft.FirstLeft;
    return FirstLeft;
  };
  ClipperLib.Clipper.prototype.JoinCommonEdges = function ()
  {
    for (var i = 0, ilen = this.m_Joins.length; i < ilen; i++)
    {
      var join = this.m_Joins[i];
      var outRec1 = this.GetOutRec(join.OutPt1.Idx);
      var outRec2 = this.GetOutRec(join.OutPt2.Idx);
      if (outRec1.Pts == null || outRec2.Pts == null)
        continue;
      //get the polygon fragment with the correct hole state (FirstLeft)
      //before calling JoinPoints() ...
      var holeStateRec;
      if (outRec1 == outRec2)
        holeStateRec = outRec1;
      else if (this.Param1RightOfParam2(outRec1, outRec2))
        holeStateRec = outRec2;
      else if (this.Param1RightOfParam2(outRec2, outRec1))
        holeStateRec = outRec1;
      else
        holeStateRec = this.GetLowermostRec(outRec1, outRec2);

      if (!this.JoinPoints(join, outRec1, outRec2)) continue;

      if (outRec1 == outRec2)
      {
        //instead of joining two polygons, we've just created a new one by
        //splitting one polygon into two.
        outRec1.Pts = join.OutPt1;
        outRec1.BottomPt = null;
        outRec2 = this.CreateOutRec();
        outRec2.Pts = join.OutPt2;
        //update all OutRec2.Pts Idx's ...
        this.UpdateOutPtIdxs(outRec2);
        //We now need to check every OutRec.FirstLeft pointer. If it points
        //to OutRec1 it may need to point to OutRec2 instead ...
        if (this.m_UsingPolyTree)
          for (var j = 0, jlen = this.m_PolyOuts.length; j < jlen - 1; j++)
          {
            var oRec = this.m_PolyOuts[j];
            if (oRec.Pts == null || ClipperLib.Clipper.ParseFirstLeft(oRec.FirstLeft) != outRec1 || oRec.IsHole == outRec1.IsHole)
              continue;
            if (this.Poly2ContainsPoly1(oRec.Pts, join.OutPt2))
              oRec.FirstLeft = outRec2;
          }
        if (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts))
        {
          //outRec2 is contained by outRec1 ...
          outRec2.IsHole = !outRec1.IsHole;
          outRec2.FirstLeft = outRec1;
          //fixup FirstLeft pointers that may need reassigning to OutRec1
          if (this.m_UsingPolyTree)
            this.FixupFirstLefts2(outRec2, outRec1);
          if ((outRec2.IsHole ^ this.ReverseSolution) == (this.Area(outRec2) > 0))
            this.ReversePolyPtLinks(outRec2.Pts);
        }
        else if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts))
        {
          //outRec1 is contained by outRec2 ...
          outRec2.IsHole = outRec1.IsHole;
          outRec1.IsHole = !outRec2.IsHole;
          outRec2.FirstLeft = outRec1.FirstLeft;
          outRec1.FirstLeft = outRec2;
          //fixup FirstLeft pointers that may need reassigning to OutRec1
          if (this.m_UsingPolyTree)
            this.FixupFirstLefts2(outRec1, outRec2);
          if ((outRec1.IsHole ^ this.ReverseSolution) == (this.Area(outRec1) > 0))
            this.ReversePolyPtLinks(outRec1.Pts);
        }
        else
        {
          //the 2 polygons are completely separate ...
          outRec2.IsHole = outRec1.IsHole;
          outRec2.FirstLeft = outRec1.FirstLeft;
          //fixup FirstLeft pointers that may need reassigning to OutRec2
          if (this.m_UsingPolyTree)
            this.FixupFirstLefts1(outRec1, outRec2);
        }
      }
      else
      {
        //joined 2 polygons together ...
        outRec2.Pts = null;
        outRec2.BottomPt = null;
        outRec2.Idx = outRec1.Idx;
        outRec1.IsHole = holeStateRec.IsHole;
        if (holeStateRec == outRec2)
          outRec1.FirstLeft = outRec2.FirstLeft;
        outRec2.FirstLeft = outRec1;
        //fixup FirstLeft pointers that may need reassigning to OutRec1
        if (this.m_UsingPolyTree)
          this.FixupFirstLefts2(outRec2, outRec1);
      }
    }
  };
  ClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec)
  {
    var op = outrec.Pts;
    do {
      op.Idx = outrec.Idx;
      op = op.Prev;
    }
    while (op != outrec.Pts)
  };
  ClipperLib.Clipper.prototype.DoSimplePolygons = function ()
  {
    var i = 0;
    while (i < this.m_PolyOuts.length)
    {
      var outrec = this.m_PolyOuts[i++];
      var op = outrec.Pts;
      if (op === null)
        continue;
      do //for each Pt in Polygon until duplicate found do ...
      {
        var op2 = op.Next;
        while (op2 != outrec.Pts)
        {
          if ((ClipperLib.IntPoint.op_Equality(op.Pt, op2.Pt)) && op2.Next != op && op2.Prev != op)
          {
            //split the polygon into two ...
            var op3 = op.Prev;
            var op4 = op2.Prev;
            op.Prev = op4;
            op4.Next = op;
            op2.Prev = op3;
            op3.Next = op2;
            outrec.Pts = op;
            var outrec2 = this.CreateOutRec();
            outrec2.Pts = op2;
            this.UpdateOutPtIdxs(outrec2);
            if (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts))
            {
              //OutRec2 is contained by OutRec1 ...
              outrec2.IsHole = !outrec.IsHole;
              outrec2.FirstLeft = outrec;
            }
            else if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts))
            {
              //OutRec1 is contained by OutRec2 ...
              outrec2.IsHole = outrec.IsHole;
              outrec.IsHole = !outrec2.IsHole;
              outrec2.FirstLeft = outrec.FirstLeft;
              outrec.FirstLeft = outrec2;
            }
            else
            {
              //the 2 polygons are separate ...
              outrec2.IsHole = outrec.IsHole;
              outrec2.FirstLeft = outrec.FirstLeft;
            }
            op2 = op;
            //ie get ready for the next iteration
          }
          op2 = op2.Next;
        }
        op = op.Next;
      }
      while (op != outrec.Pts)
    }
  };
  ClipperLib.Clipper.Area = function (poly)
  {
    var cnt = poly.length;
    if (cnt < 3)
      return 0;
    var a = 0;
    for (var i = 0, j = cnt - 1; i < cnt; ++i)
    {
      a += (poly[j].x + poly[i].x) * (poly[j].y - poly[i].y);
      j = i;
    }
    return -a * 0.5;
  };
  ClipperLib.Clipper.prototype.Area = function (outRec)
  {
    var op = outRec.Pts;
    if (op == null)
      return 0;
    var a = 0;
    do {
      a = a + (op.Prev.Pt.x + op.Pt.x) * (op.Prev.Pt.y - op.Pt.y);
      op = op.Next;
    }
    while (op != outRec.Pts)
    return a * 0.5;
  };
  if (use_deprecated)
  {
    ClipperLib.Clipper.OffsetPaths = function (polys, delta, jointype, endtype, MiterLimit)
    {
      var result = new ClipperLib.Paths();
      var co = new ClipperLib.ClipperOffset(MiterLimit, MiterLimit);
      co.AddPaths(polys, jointype, endtype);
      co.Execute(result, delta);
      return result;
    };
  }
  ClipperLib.Clipper.SimplifyPolygon = function (poly, fillType)
  {
    var result = new Array();
    var c = new ClipperLib.Clipper(0);
    c.StrictlySimple = true;
    c.AddPath(poly, ClipperLib.PolyType.ptSubject, true);
    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);
    return result;
  };
  ClipperLib.Clipper.SimplifyPolygons = function (polys, fillType)
  {
    if (typeof (fillType) == "undefined") fillType = ClipperLib.PolyFillType.pftEvenOdd;
    var result = new Array();
    var c = new ClipperLib.Clipper(0);
    c.StrictlySimple = true;
    c.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);
    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);
    return result;
  };
  ClipperLib.Clipper.DistanceSqrd = function (pt1, pt2)
  {
    var dx = (pt1.x - pt2.x);
    var dy = (pt1.y - pt2.y);
    return (dx * dx + dy * dy);
  };
  ClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2)
  {
    //The equation of a line in general form (Ax + By + C = 0)
    //given 2 points (x¹,y¹) & (x²,y²) is ...
    //(y¹ - y²)x + (x² - x¹)y + (y² - y¹)x¹ - (x² - x¹)y¹ = 0
    //A = (y¹ - y²); B = (x² - x¹); C = (y² - y¹)x¹ - (x² - x¹)y¹
    //perpendicular distance of point (x³,y³) = (Ax³ + By³ + C)/Sqrt(A² + B²)
    //see http://en.wikipedia.org/wiki/Perpendicular_distance
    var A = ln1.y - ln2.y; 
    var B = ln2.x - ln1.x; 
    var C = A * ln1.x + B * ln1.y; 
    C = A * pt.x + B * pt.y - C;
    return (C * C) / (A * A + B * B);
  };
  ClipperLib.Clipper.SlopesNearCollinear = function (pt1, pt2, pt3, distSqrd)
  {
    return ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;
  };
  ClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd)
  {
    var dx = pt1.x - pt2.x; 
    var dy = pt1.y - pt2.y; 
    return ((dx * dx) + (dy * dy) <= distSqrd);
  };
  //------------------------------------------------------------------------------
  ClipperLib.Clipper.ExcludeOp = function (op)
  {
    var result = op.Prev;
    result.Next = op.Next;
    op.Next.Prev = result;
    result.Idx = 0;
    return result;
  };
  ClipperLib.Clipper.CleanPolygon = function (path, distance)
  {
    if (typeof (distance) == "undefined") distance = 1.415;
    //distance = proximity in units/pixels below which vertices will be stripped. 
    //Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have 
    //both x & y coords within 1 unit, then the second vertex will be stripped.
    var cnt = path.length;
    if (cnt == 0)
      return new Array();
    var outPts = new Array(cnt);
    for (var i = 0; i < cnt; ++i)
      outPts[i] = new ClipperLib.OutPt();
    for (var i = 0; i < cnt; ++i)
    {
      outPts[i].Pt = path[i];
      outPts[i].Next = outPts[(i + 1) % cnt];
      outPts[i].Next.Prev = outPts[i];
      outPts[i].Idx = 0;
    }
    var distSqrd = distance * distance;
    var op = outPts[0];
    while (op.Idx == 0 && op.Next != op.Prev)
    {
      if (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd))
      {
        op = ClipperLib.Clipper.ExcludeOp(op);
        cnt--;
      }
      else if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd))
      {
        ClipperLib.Clipper.ExcludeOp(op.Next);
        op = ClipperLib.Clipper.ExcludeOp(op);
        cnt -= 2;
      }
      else if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd))
      {
        op = ClipperLib.Clipper.ExcludeOp(op);
        cnt--;
      }
      else
      {
        op.Idx = 1;
        op = op.Next;
      }
    }
    if (cnt < 3)
      cnt = 0;
    var result = new Array(cnt);
    for (var i = 0; i < cnt; ++i)
    {
      result[i] = new ClipperLib.IntPoint(op.Pt);
      op = op.Next;
    }
    outPts = null;
    return result;
  };
  ClipperLib.Clipper.CleanPolygons = function (polys, distance)
  {
    var result = new Array(polys.length);
    for (var i = 0, ilen = polys.length; i < ilen; i++)
      result[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);
    return result;
  };
  ClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed)
  {
    var delta = (IsClosed ? 1 : 0);
    var polyCnt = pattern.length;
    var pathCnt = path.length;
    var result = new Array();
    if (IsSum)
      for (var i = 0; i < pathCnt; i++)
      {
        var p = new Array(polyCnt);
        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])
          p[j] = new ClipperLib.IntPoint(path[i].x + ip.x, path[i].y + ip.y);
        result.push(p);
      }
    else
      for (var i = 0; i < pathCnt; i++)
      {
        var p = new Array(polyCnt);
        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])
          p[j] = new ClipperLib.IntPoint(path[i].x - ip.x, path[i].y - ip.y);
        result.push(p);
      }
    var quads = new Array();
    for (var i = 0; i < pathCnt - 1 + delta; i++)
      for (var j = 0; j < polyCnt; j++)
      {
        var quad = new Array();
        quad.push(result[i % pathCnt][j % polyCnt]);
        quad.push(result[(i + 1) % pathCnt][j % polyCnt]);
        quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);
        quad.push(result[i % pathCnt][(j + 1) % polyCnt]);
        if (!ClipperLib.Clipper.Orientation(quad))
          quad.reverse();
        quads.push(quad);
      }
    var c = new ClipperLib.Clipper(0);
    c.AddPaths(quads, ClipperLib.PolyType.ptSubject, true);
    c.Execute(ClipperLib.ClipType.ctUnion, result, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);
    return result;
  };

  ClipperLib.Clipper.MinkowskiSum = function ()
  {
    var a = arguments,
      alen = a.length;
    if (alen == 3) // MinkowskiSum(Path pattern, path, pathIsClosed)
    {
      var pattern = a[0],
        path = a[1],
        pathIsClosed = a[2];
      return ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);
    }
    else if (alen == 4) // MinkowskiSum(pattern, paths, pathFillType, pathIsClosed)
    {
      var pattern = a[0],
        paths = a[1],
        pathFillType = a[2],
        pathIsClosed = a[3];
      var c = new ClipperLib.Clipper(),
        tmp;
      for (var i = 0, ilen = paths.length; i < ilen; ++i)
      {
        var tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);
        c.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);
      }
      if (pathIsClosed) c.AddPaths(paths, ClipperLib.PolyType.ptClip, true);
      var solution = new ClipperLib.Paths();
      c.Execute(ClipperLib.ClipType.ctUnion, solution, pathFillType, pathFillType);
      return solution;
    }
  };

  ClipperLib.Clipper.MinkowskiDiff = function (pattern, path, pathIsClosed)
  {
    return ClipperLib.Clipper.Minkowski(pattern, path, false, pathIsClosed);
  };

  ClipperLib.Clipper.PolyTreeToPaths = function (polytree)
  {
    var result = new Array();
    //result.set_Capacity(polytree.get_Total());
    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);
    return result;
  };
  ClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths)
  {
    var match = true;
    switch (nt)
    {
    case ClipperLib.Clipper.NodeType.ntOpen:
      return;
    case ClipperLib.Clipper.NodeType.ntClosed:
      match = !polynode.IsOpen;
      break;
    default:
      break;
    }
    if (polynode.m_polygon.length > 0 && match)
      paths.push(polynode.m_polygon);
    for (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3])
      ClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);
  };
  ClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree)
  {
    var result = new ClipperLib.Paths();
    //result.set_Capacity(polytree.ChildCount());
    for (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++)
      if (polytree.Childs()[i].IsOpen)
        result.push(polytree.Childs()[i].m_polygon);
    return result;
  };
  ClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree)
  {
    var result = new ClipperLib.Paths();
    //result.set_Capacity(polytree.Total());
    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);
    return result;
  };
  Inherit(ClipperLib.Clipper, ClipperLib.ClipperBase);
  ClipperLib.Clipper.NodeType = {
    ntAny: 0,
    ntOpen: 1,
    ntClosed: 2
  };
  ClipperLib.ClipperOffset = function (miterLimit, arcTolerance)
  {
    if (typeof (miterLimit) == "undefined") miterLimit = 2;
    if (typeof (arcTolerance) == "undefined") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;
    this.m_destPolys = new ClipperLib.Paths();
    this.m_srcPoly = new ClipperLib.Path();
    this.m_destPoly = new ClipperLib.Path();
    this.m_normals = new Array();
    this.m_delta = 0;
    this.m_sinA = 0;
    this.m_sin = 0;
    this.m_cos = 0;
    this.m_miterLim = 0;
    this.m_StepsPerRad = 0;
    this.m_lowest = new ClipperLib.IntPoint();
    this.m_polyNodes = new ClipperLib.PolyNode();
    this.MiterLimit = miterLimit;
    this.ArcTolerance = arcTolerance;
    this.m_lowest.x = -1;
  };
  ClipperLib.ClipperOffset.two_pi = 6.28318530717959;
  ClipperLib.ClipperOffset.def_arc_tolerance = 0.25;
  ClipperLib.ClipperOffset.prototype.Clear = function ()
  {
    ClipperLib.Clear(this.m_polyNodes.Childs());
    this.m_lowest.x = -1;
  };
  ClipperLib.ClipperOffset.Round = ClipperLib.Clipper.Round;
  ClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType)
  {
    var highI = path.length - 1;
    if (highI < 0)
      return;
    var newNode = new ClipperLib.PolyNode();
    newNode.m_jointype = joinType;
    newNode.m_endtype = endType;
    //strip duplicate points from path and also get index to the lowest point ...
    if (endType == ClipperLib.EndType.etClosedLine || endType == ClipperLib.EndType.etClosedPolygon)
      while (highI > 0 && ClipperLib.IntPoint.op_Equality(path[0], path[highI]))
        highI--;
    //newNode.m_polygon.set_Capacity(highI + 1);
    newNode.m_polygon.push(path[0]);
    var j = 0,
      k = 0;
    for (var i = 1; i <= highI; i++)
      if (ClipperLib.IntPoint.op_Inequality(newNode.m_polygon[j], path[i]))
      {
        j++;
        newNode.m_polygon.push(path[i]);
        if (path[i].y > newNode.m_polygon[k].y || (path[i].y == newNode.m_polygon[k].y && path[i].x < newNode.m_polygon[k].x))
          k = j;
      }
    if ((endType == ClipperLib.EndType.etClosedPolygon && j < 2) || (endType != ClipperLib.EndType.etClosedPolygon && j < 0))
      return;
    this.m_polyNodes.AddChild(newNode);
    //if this path's lowest pt is lower than all the others then update m_lowest
    if (endType != ClipperLib.EndType.etClosedPolygon)
      return;
    if (this.m_lowest.x < 0)
      this.m_lowest = new ClipperLib.IntPoint(0, k);
    else
    {
      var ip = this.m_polyNodes.Childs()[this.m_lowest.x].m_polygon[this.m_lowest.y];
      if (newNode.m_polygon[k].y > ip.y || (newNode.m_polygon[k].y == ip.y && newNode.m_polygon[k].x < ip.x))
        this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);
    }
  };
  ClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType)
  {
    for (var i = 0, ilen = paths.length; i < ilen; i++)
      this.AddPath(paths[i], joinType, endType);
  };
  ClipperLib.ClipperOffset.prototype.FixOrientations = function ()
  {
    //fixup orientations of all closed paths if the orientation of the
    //closed path with the lowermost vertex is wrong ...
    if (this.m_lowest.x >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.x].m_polygon))
    {
      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)
      {
        var node = this.m_polyNodes.Childs()[i];
        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon || (node.m_endtype == ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)))
          node.m_polygon.reverse();
      }
    }
    else
    {
      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)
      {
        var node = this.m_polyNodes.Childs()[i];
        if (node.m_endtype == ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon))
          node.m_polygon.reverse();
      }
    }
  };
  ClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2)
  {
    var dx = (pt2.x - pt1.x);
    var dy = (pt2.y - pt1.y);
    if ((dx == 0) && (dy == 0))
      return new ClipperLib.DoublePoint(0, 0);
    var f = 1 / Math.sqrt(dx * dx + dy * dy);
    dx *= f;
    dy *= f;
    return new ClipperLib.DoublePoint(dy, -dx);
  };
  ClipperLib.ClipperOffset.prototype.DoOffset = function (delta)
  {
    this.m_destPolys = new Array();
    this.m_delta = delta;
    //if Zero offset, just copy any CLOSED polygons to m_p and return ...
    if (ClipperLib.ClipperBase.near_zero(delta))
    {
      //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);
      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)
      {
        var node = this.m_polyNodes.Childs()[i];
        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)
          this.m_destPolys.push(node.m_polygon);
      }
      return;
    }
    //see offset_triginometry3.svg in the documentation folder ...
    if (this.MiterLimit > 2)
      this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);
    else
      this.m_miterLim = 0.5;
    var y;
    if (this.ArcTolerance <= 0)
      y = ClipperLib.ClipperOffset.def_arc_tolerance;
    else if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance)
      y = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;
    else
      y = this.ArcTolerance;
    //see offset_triginometry2.svg in the documentation folder ...
    var steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));
    this.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);
    this.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);
    this.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;
    if (delta < 0)
      this.m_sin = -this.m_sin;
    //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);
    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)
    {
      var node = this.m_polyNodes.Childs()[i];
      this.m_srcPoly = node.m_polygon;
      var len = this.m_srcPoly.length;
      if (len == 0 || (delta <= 0 && (len < 3 || node.m_endtype != ClipperLib.EndType.etClosedPolygon)))
        continue;
      this.m_destPoly = new Array();
      if (len == 1)
      {
        if (node.m_jointype == ClipperLib.JoinType.jtRound)
        {
          var X = 1,
            Y = 0;
          for (var j = 1; j <= steps; j++)
          {
            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].x + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].y + Y * delta)));
            var X2 = X;
            X = X * this.m_cos - this.m_sin * Y;
            Y = X2 * this.m_sin + Y * this.m_cos;
          }
        }
        else
        {
          var X = -1,
            Y = -1;
          for (var j = 0; j < 4; ++j)
          {
            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].x + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].y + Y * delta)));
            if (X < 0)
              X = 1;
            else if (Y < 0)
              Y = 1;
            else
              X = -1;
          }
        }
        this.m_destPolys.push(this.m_destPoly);
        continue;
      }
      //build m_normals ...
      this.m_normals.length = 0;
      //this.m_normals.set_Capacity(len);
      for (var j = 0; j < len - 1; j++)
        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));
      if (node.m_endtype == ClipperLib.EndType.etClosedLine || node.m_endtype == ClipperLib.EndType.etClosedPolygon)
        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));
      else
        this.m_normals.push(new ClipperLib.DoublePoint(this.m_normals[len - 2]));
      if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)
      {
        var k = len - 1;
        for (var j = 0; j < len; j++)
          k = this.OffsetPoint(j, k, node.m_jointype);
        this.m_destPolys.push(this.m_destPoly);
      }
      else if (node.m_endtype == ClipperLib.EndType.etClosedLine)
      {
        var k = len - 1;
        for (var j = 0; j < len; j++)
          k = this.OffsetPoint(j, k, node.m_jointype);
        this.m_destPolys.push(this.m_destPoly);
        this.m_destPoly = new Array();
        //re-build m_normals ...
        var n = this.m_normals[len - 1];
        for (var j = len - 1; j > 0; j--)
          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].x, -this.m_normals[j - 1].y);
        this.m_normals[0] = new ClipperLib.DoublePoint(-n.x, -n.y);
        k = 0;
        for (var j = len - 1; j >= 0; j--)
          k = this.OffsetPoint(j, k, node.m_jointype);
        this.m_destPolys.push(this.m_destPoly);
      }
      else
      {
        var k = 0;
        for (var j = 1; j < len - 1; ++j)
          k = this.OffsetPoint(j, k, node.m_jointype);
        var pt1;
        if (node.m_endtype == ClipperLib.EndType.etOpenButt)
        {
          var j = len - 1;
          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].x + this.m_normals[j].x * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].y + this.m_normals[j].y * delta));
          this.m_destPoly.push(pt1);
          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].x - this.m_normals[j].x * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].y - this.m_normals[j].y * delta));
          this.m_destPoly.push(pt1);
        }
        else
        {
          var j = len - 1;
          k = len - 2;
          this.m_sinA = 0;
          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j].x, -this.m_normals[j].y);
          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)
            this.DoSquare(j, k);
          else
            this.DoRound(j, k);
        }
        //re-build m_normals ...
        for (var j = len - 1; j > 0; j--)
          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].x, -this.m_normals[j - 1].y);
        this.m_normals[0] = new ClipperLib.DoublePoint(-this.m_normals[1].x, -this.m_normals[1].y);
        k = len - 1;
        for (var j = k - 1; j > 0; --j)
          k = this.OffsetPoint(j, k, node.m_jointype);
        if (node.m_endtype == ClipperLib.EndType.etOpenButt)
        {
          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].x - this.m_normals[0].x * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].y - this.m_normals[0].y * delta));
          this.m_destPoly.push(pt1);
          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].x + this.m_normals[0].x * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].y + this.m_normals[0].y * delta));
          this.m_destPoly.push(pt1);
        }
        else
        {
          k = 1;
          this.m_sinA = 0;
          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)
            this.DoSquare(0, 1);
          else
            this.DoRound(0, 1);
        }
        this.m_destPolys.push(this.m_destPoly);
      }
    }
  };
  ClipperLib.ClipperOffset.prototype.Execute = function ()
  {
    var a = arguments,
      ispolytree = a[0] instanceof ClipperLib.PolyTree;
    if (!ispolytree) // function (solution, delta)
    {
      var solution = a[0],
        delta = a[1];
      ClipperLib.Clear(solution);
      this.FixOrientations();
      this.DoOffset(delta);
      //now clean up 'corners' ...
      var clpr = new ClipperLib.Clipper(0);
      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);
      if (delta > 0)
      {
        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);
      }
      else
      {
        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);
        var outer = new ClipperLib.Path();
        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));
        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));
        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));
        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));
        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);
        clpr.ReverseSolution = true;
        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);
        if (solution.length > 0)
          solution.splice(0, 1);
      }
      //console.log(JSON.stringify(solution));
    }
    else // function (polytree, delta)
    {
      var solution = a[0],
        delta = a[1];
      solution.Clear();
      this.FixOrientations();
      this.DoOffset(delta);
      //now clean up 'corners' ...
      var clpr = new ClipperLib.Clipper(0);
      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);
      if (delta > 0)
      {
        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);
      }
      else
      {
        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);
        var outer = new ClipperLib.Path();
        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));
        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));
        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));
        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));
        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);
        clpr.ReverseSolution = true;
        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);
        //remove the outer PolyNode rectangle ...
        if (solution.ChildCount() == 1 && solution.Childs()[0].ChildCount() > 0)
        {
          var outerNode = solution.Childs()[0];
          //solution.Childs.set_Capacity(outerNode.ChildCount);
          solution.Childs()[0] = outerNode.Childs()[0];
          for (var i = 1; i < outerNode.ChildCount(); i++)
            solution.AddChild(outerNode.Childs()[i]);
        }
        else
          solution.Clear();
      }
    }
  };
  ClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype)
  {
    this.m_sinA = (this.m_normals[k].x * this.m_normals[j].y - this.m_normals[j].x * this.m_normals[k].y);
    if (this.m_sinA < 0.00005 && this.m_sinA > -0.00005)
      return k;
    else if (this.m_sinA > 1)
      this.m_sinA = 1.0;
    else if (this.m_sinA < -1)
      this.m_sinA = -1.0;
    if (this.m_sinA * this.m_delta < 0)
    {
      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].x + this.m_normals[k].x * this.m_delta),
        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].y + this.m_normals[k].y * this.m_delta)));
      this.m_destPoly.push(new ClipperLib.IntPoint(this.m_srcPoly[j]));
      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].x + this.m_normals[j].x * this.m_delta),
        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].y + this.m_normals[j].y * this.m_delta)));
    }
    else
      switch (jointype)
      {
      case ClipperLib.JoinType.jtMiter:
        {
          var r = 1 + (this.m_normals[j].x * this.m_normals[k].x + this.m_normals[j].y * this.m_normals[k].y);
          if (r >= this.m_miterLim)
            this.DoMiter(j, k, r);
          else
            this.DoSquare(j, k);
          break;
        }
      case ClipperLib.JoinType.jtSquare:
        this.DoSquare(j, k);
        break;
      case ClipperLib.JoinType.jtRound:
        this.DoRound(j, k);
        break;
      }
    k = j;
    return k;
  };
  ClipperLib.ClipperOffset.prototype.DoSquare = function (j, k)
  {
    var dx = Math.tan(Math.atan2(this.m_sinA,
      this.m_normals[k].x * this.m_normals[j].x + this.m_normals[k].y * this.m_normals[j].y) / 4);
    this.m_destPoly.push(new ClipperLib.IntPoint(
      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].x + this.m_delta * (this.m_normals[k].x - this.m_normals[k].y * dx)),
      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].y + this.m_delta * (this.m_normals[k].y + this.m_normals[k].x * dx))));
    this.m_destPoly.push(new ClipperLib.IntPoint(
      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].x + this.m_delta * (this.m_normals[j].x + this.m_normals[j].y * dx)),
      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].y + this.m_delta * (this.m_normals[j].y - this.m_normals[j].x * dx))));
  };
  ClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r)
  {
    var q = this.m_delta / r;
    this.m_destPoly.push(new ClipperLib.IntPoint(
      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].x + (this.m_normals[k].x + this.m_normals[j].x) * q),
      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].y + (this.m_normals[k].y + this.m_normals[j].y) * q)));
  };
  ClipperLib.ClipperOffset.prototype.DoRound = function (j, k)
  {
    var a = Math.atan2(this.m_sinA,
      this.m_normals[k].x * this.m_normals[j].x + this.m_normals[k].y * this.m_normals[j].y);
    var steps = ClipperLib.Cast_Int32(ClipperLib.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(a)));
    var X = this.m_normals[k].x,
      Y = this.m_normals[k].y,
      X2;
    for (var i = 0; i < steps; ++i)
    {
      this.m_destPoly.push(new ClipperLib.IntPoint(
        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].x + X * this.m_delta),
        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].y + Y * this.m_delta)));
      X2 = X;
      X = X * this.m_cos - this.m_sin * Y;
      Y = X2 * this.m_sin + Y * this.m_cos;
    }
    this.m_destPoly.push(new ClipperLib.IntPoint(
      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].x + this.m_normals[j].x * this.m_delta),
      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].y + this.m_normals[j].y * this.m_delta)));
  };
  ClipperLib.Error = function (message)
  {
    try
    {
      throw new Error(message);
    }
    catch (err)
    {
      alert(err.message);
    }
  };
  // ---------------------------------
  // JS extension by Timo 2013
  ClipperLib.JS = {};
  ClipperLib.JS.AreaOfPolygon = function (poly, scale)
  {
    if (!scale) scale = 1;
    return ClipperLib.Clipper.Area(poly) / (scale * scale);
  };
  ClipperLib.JS.AreaOfPolygons = function (poly, scale)
  {
    if (!scale) scale = 1;
    var area = 0;
    for (var i = 0; i < poly.length; i++)
    {
      area += ClipperLib.Clipper.Area(poly[i]);
    }
    return area / (scale * scale);
  };
  ClipperLib.JS.BoundsOfPath = function (path, scale)
  {
    return ClipperLib.JS.BoundsOfPaths([path], scale);
  };
  ClipperLib.JS.BoundsOfPaths = function (paths, scale)
  {
    if (!scale) scale = 1;
    var bounds = ClipperLib.Clipper.GetBounds(paths);
    bounds.left /= scale;
    bounds.bottom /= scale;
    bounds.right /= scale;
    bounds.top /= scale;
    return bounds;
  };
  // Clean() joins vertices that are too near each other
  // and causes distortion to offsetted polygons without cleaning
  ClipperLib.JS.Clean = function (polygon, delta)
  {
    if (!(polygon instanceof Array)) return [];
    var isPolygons = polygon[0] instanceof Array;
    var polygon = ClipperLib.JS.Clone(polygon);
    if (typeof delta != "number" || delta === null)
    {
      ClipperLib.Error("Delta is not a number in Clean().");
      return polygon;
    }
    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || delta < 0) return polygon;
    if (!isPolygons) polygon = [polygon];
    var k_length = polygon.length;
    var len, poly, result, d, p, j, i;
    var results = [];
    for (var k = 0; k < k_length; k++)
    {
      poly = polygon[k];
      len = poly.length;
      if (len === 0) continue;
      else if (len < 3)
      {
        result = poly;
        results.push(result);
        continue;
      }
      result = poly;
      d = delta * delta;
      //d = Math.floor(c_delta * c_delta);
      p = poly[0];
      j = 1;
      for (i = 1; i < len; i++)
      {
        if ((poly[i].x - p.x) * (poly[i].x - p.x) +
          (poly[i].y - p.y) * (poly[i].y - p.y) <= d)
          continue;
        result[j] = poly[i];
        p = poly[i];
        j++;
      }
      p = poly[j - 1];
      if ((poly[0].x - p.x) * (poly[0].x - p.x) +
        (poly[0].y - p.y) * (poly[0].y - p.y) <= d)
        j--;
      if (j < len)
        result.splice(j, len - j);
      if (result.length) results.push(result);
    }
    if (!isPolygons && results.length) results = results[0];
    else if (!isPolygons && results.length === 0) results = [];
    else if (isPolygons && results.length === 0) results = [
      []
    ];
    return results;
  }
  // Make deep copy of Polygons or Polygon
  // so that also IntPoint objects are cloned and not only referenced
  // This should be the fastest way
  ClipperLib.JS.Clone = function (polygon)
  {
    if (!(polygon instanceof Array)) return [];
    if (polygon.length === 0) return [];
    else if (polygon.length == 1 && polygon[0].length === 0) return [[]];
    var isPolygons = polygon[0] instanceof Array;
    if (!isPolygons) polygon = [polygon];
    var len = polygon.length,
      plen, i, j, result;
    var results = new Array(len);
    for (i = 0; i < len; i++)
    {
      plen = polygon[i].length;
      result = new Array(plen);
      for (j = 0; j < plen; j++)
      {
        result[j] = {
          x: polygon[i][j].x,
          y: polygon[i][j].y
        };
      }
      results[i] = result;
    }
    if (!isPolygons) results = results[0];
    return results;
  };
  // Removes points that doesn't affect much to the visual appearance.
  // If middle point is at or under certain distance (tolerance) of the line segment between 
  // start and end point, the middle point is removed.
  ClipperLib.JS.Lighten = function (polygon, tolerance)
  {
    if (!(polygon instanceof Array)) return [];
    if (typeof tolerance != "number" || tolerance === null)
    {
      ClipperLib.Error("Tolerance is not a number in Lighten().")
      return ClipperLib.JS.Clone(polygon);
    }
    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || tolerance < 0)
    {
      return ClipperLib.JS.Clone(polygon);
    }
    if (!(polygon[0] instanceof Array)) polygon = [polygon];
    var i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;
    var bxax, byay, l, ax, ay;
    var len = polygon.length;
    var toleranceSq = tolerance * tolerance;
    var results = [];
    for (i = 0; i < len; i++)
    {
      poly = polygon[i];
      plen = poly.length;
      if (plen == 0) continue;
      for (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count
      {
        poly2 = [];
        plen = poly.length;
        // the first have to added to the end, if first and last are not the same
        // this way we ensure that also the actual last point can be removed if needed
        if (poly[plen - 1].x != poly[0].x || poly[plen - 1].y != poly[0].y)
        {
          addlast = 1;
          poly.push(
          {
            x: poly[0].x,
            y: poly[0].y
          });
          plen = poly.length;
        }
        else addlast = 0;
        rem = []; // Indexes of removed points
        for (j = 0; j < plen - 2; j++)
        {
          A = poly[j]; // Start point of line segment
          P = poly[j + 1]; // Middle point. This is the one to be removed.
          B = poly[j + 2]; // End point of line segment
          ax = A.x; 
          ay = A.y; 
          bxax = B.x - ax;
          byay = B.y - ay;
          if (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.
          {
            l = ((P.x - ax) * bxax + (P.y - ay) * byay) / (bxax * bxax + byay * byay);
            if (l > 1)
            {
              ax = B.x; 
              ay = B.y; 
            }
            else if (l > 0)
            {
              ax += bxax * l;
              ay += byay * l;
            }
          }
          bxax = P.x - ax;
          byay = P.y - ay;
          d = bxax * bxax + byay * byay;
          if (d <= toleranceSq)
          {
            rem[j + 1] = 1;
            j++; // when removed, transfer the pointer to the next one
          }
        }
        // add all unremoved points to poly2
        poly2.push(
        {
          x: poly[0].x,
          y: poly[0].y
        });
        for (j = 1; j < plen - 1; j++)
          if (!rem[j]) poly2.push(
          {
            x: poly[j].x,
            y: poly[j].y
          });
        poly2.push(
        {
          x: poly[plen - 1].x,
          y: poly[plen - 1].y
        });
        // if the first point was added to the end, remove it
        if (addlast) poly.pop();
        // break, if there was not anymore removed points
        if (!rem.length) break;
        // else continue looping using poly2, to check if there are points to remove
        else poly = poly2;
      }
      plen = poly2.length;
      // remove duplicate from end, if needed
      if (poly2[plen - 1].x == poly2[0].x && poly2[plen - 1].y == poly2[0].y)
      {
        poly2.pop();
      }
      if (poly2.length > 2) // to avoid two-point-polygons
        results.push(poly2);
    }
    if (!polygon[0] instanceof Array) results = results[0];
    if (typeof (results) == "undefined") results = [
      []
    ];
    return results;
  }
  ClipperLib.JS.PerimeterOfPath = function (path, closed, scale)
  {
    if (typeof (path) == "undefined") return 0;
    var sqrt = Math.sqrt;
    var perimeter = 0.0;
    var p1, p2, p1x = 0.0,
      p1y = 0.0,
      p2x = 0.0,
      p2y = 0.0;
    var j = path.length;
    if (j < 2) return 0;
    if (closed)
    {
      path[j] = path[0];
      j++;
    }
    while (--j)
    {
      p1 = path[j];
      p1x = p1.x; 
      p1y = p1.y; 
      p2 = path[j - 1];
      p2x = p2.x; 
      p2y = p2.y; 
      perimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));
    }
    if (closed) path.pop();
    return perimeter / scale;
  };
  ClipperLib.JS.PerimeterOfPaths = function (paths, closed, scale)
  {
    if (!scale) scale = 1;
    var perimeter = 0;
    for (var i = 0; i < paths.length; i++)
    {
      perimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed, scale);
    }
    return perimeter;
  };
  ClipperLib.JS.ScaleDownPath = function (path, scale)
  {
    var i, p;
    if (!scale) scale = 1;
    i = path.length;
    while (i--)
    {
      p = path[i];
      p.x = p.x / scale;
      p.y = p.y / scale;
    }
  };
  ClipperLib.JS.ScaleDownPaths = function (paths, scale)
  {
    var i, j, p, round = Math.round;
    if (!scale) scale = 1;
    i = paths.length;
    while (i--)
    {
      j = paths[i].length;
      while (j--)
      {
        p = paths[i][j];
        p.x = p.x / scale;
        p.y = p.y / scale;
      }
    }
  };
  ClipperLib.JS.ScaleUpPath = function (path, scale)
  {
    var i, p, round = Math.round;
    if (!scale) scale = 1;
    i = path.length;
    while (i--)
    {
      p = path[i];
      p.x = round(p.x * scale);
      p.y = round(p.y * scale);
    }
  };
  ClipperLib.JS.ScaleUpPaths = function (paths, scale)
  {
    var i, j, p, round = Math.round;
    if (!scale) scale = 1;
    i = paths.length;
    while (i--)
    {
      j = paths[i].length;
      while (j--)
      {
        p = paths[i][j];
        p.x = round(p.x * scale);
        p.y = round(p.y * scale);
      }
    }
  };
  ClipperLib.ExPolygons = function ()
  {
    return [];
  }
  ClipperLib.ExPolygon = function ()
  {
    this.outer = null;
    this.holes = null;
  };
  ClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons)
  {
    var ep = new ClipperLib.ExPolygon();
    ep.outer = polynode.Contour();
    var childs = polynode.Childs();
    var ilen = childs.length;
    ep.holes = new Array(ilen);
    var node, n, i, j, childs2, jlen;
    for (i = 0; i < ilen; i++)
    {
      node = childs[i];
      ep.holes[i] = node.Contour();
      //Add outer polygons contained by (nested within) holes ...
      for (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++)
      {
        n = childs2[j];
        ClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);
      }
    }
    expolygons.push(ep);
  };
  ClipperLib.JS.ExPolygonsToPaths = function (expolygons)
  {
    var a, i, alen, ilen;
    var paths = new ClipperLib.Paths();
    for (a = 0, alen = expolygons.length; a < alen; a++)
    {
      paths.push(expolygons[a].outer);
      for (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++)
      {
        paths.push(expolygons[a].holes[i]);
      }
    }
    return paths;
  }
  ClipperLib.JS.PolyTreeToExPolygons = function (polytree)
  {
    var expolygons = new ClipperLib.ExPolygons();
    var node, i, childs, ilen;
    for (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++)
    {
      node = childs[i];
      ClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);
    }
    return expolygons;
  };
})();/******************************************************************************
 * Spine Runtime Software License - Version 1.1
 * 
 * Copyright (c) 2013, Esoteric Software
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms in whole or in part, with
 * or without modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. A Spine Essential, Professional, Enterprise, or Education License must
 *    be purchased from Esoteric Software and the license must remain valid:
 *    http://esotericsoftware.com/
 * 2. Redistributions of source code must retain this license, which is the
 *    above copyright notice, this declaration of conditions and the following
 *    disclaimer.
 * 3. Redistributions in binary form must reproduce this license, which is the
 *    above copyright notice, this declaration of conditions and the following
 *    disclaimer, in the documentation and/or other materials provided with the
 *    distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

var spine = {};

spine.BoneData = function (name, parent) {
	this.name = name;
	this.parent = parent;
};
spine.BoneData.prototype = {
	length: 0,
	x: 0, y: 0,
	rotation: 0,
	scaleX: 1, scaleY: 1,
	inheritScale: true,
	inheritRotation: true
};

spine.SlotData = function (name, boneData) {
	this.name = name;
	this.boneData = boneData;
};
spine.SlotData.prototype = {
	r: 1, g: 1, b: 1, a: 1,
	attachmentName: null,
	additiveBlending: false
};

spine.Bone = function (boneData, parent) {
	this.data = boneData;
	this.parent = parent;
	this.setToSetupPose();
};
spine.Bone.yDown = false;
spine.Bone.prototype = {
	x: 0, y: 0,
	rotation: 0,
	scaleX: 1, scaleY: 1,
	m00: 0, m01: 0, worldX: 0, // a b x
	m10: 0, m11: 0, worldY: 0, // c d y
	worldRotation: 0,
	worldScaleX: 1, worldScaleY: 1,
	updateWorldTransform: function (flipX, flipY) {
		var parent = this.parent;
		if (parent != null) {
			this.worldX = this.x * parent.m00 + this.y * parent.m01 + parent.worldX;
			this.worldY = this.x * parent.m10 + this.y * parent.m11 + parent.worldY;
			if (this.data.inheritScale) {
				this.worldScaleX = parent.worldScaleX * this.scaleX;
				this.worldScaleY = parent.worldScaleY * this.scaleY;
			} else {
				this.worldScaleX = this.scaleX;
				this.worldScaleY = this.scaleY;
			}
			this.worldRotation = this.data.inheritRotation ? parent.worldRotation + this.rotation : this.rotation;
		} else {
			this.worldX = this.x; // flipX ? -this.x : this.x;
			this.worldY = this.y; //(flipY != spine.Bone.yDown) ? -this.y : this.y;
			this.worldScaleX = this.scaleX;
			this.worldScaleY = this.scaleY;
			this.worldRotation = this.rotation;
		}
		var radians = this.worldRotation * Math.PI / 180;
		var cos = Math.cos(radians);
		var sin = Math.sin(radians);
		this.m00 = cos * this.worldScaleX;
		this.m10 = sin * this.worldScaleX;
		this.m01 = -sin * this.worldScaleY;
		this.m11 = cos * this.worldScaleY;
		if (flipX) {
			this.m00 = -this.m00;
			this.m01 = -this.m01;
		}
		if (flipY != spine.Bone.yDown) {
			this.m10 = -this.m10;
			this.m11 = -this.m11;
		}
	},
	setToSetupPose: function () {
		var data = this.data;
		this.x = data.x;
		this.y = data.y;
		this.rotation = data.rotation;
		this.scaleX = data.scaleX;
		this.scaleY = data.scaleY;
	}
};

spine.Slot = function (slotData, skeleton, bone) {
	this.data = slotData;
	this.skeleton = skeleton;
	this.bone = bone;
	this.setToSetupPose();
};
spine.Slot.prototype = {
	r: 1, g: 1, b: 1, a: 1,
	_attachmentTime: 0,
	attachment: null,
	setAttachment: function (attachment) {
		this.attachment = attachment;
		this._attachmentTime = this.skeleton.time;
	},
	setAttachmentTime: function (time) {
		this._attachmentTime = this.skeleton.time - time;
	},
	getAttachmentTime: function () {
		return this.skeleton.time - this._attachmentTime;
	},
	setToSetupPose: function () {
		var data = this.data;
		this.r = data.r;
		this.g = data.g;
		this.b = data.b;
		this.a = data.a;

		var slotDatas = this.skeleton.data.slots;
		for (var i = 0, n = slotDatas.length; i < n; i++) {
			if (slotDatas[i] == data) {
				this.setAttachment(!data.attachmentName ? null : this.skeleton.getAttachmentBySlotIndex(i, data.attachmentName));
				break;
			}
		}
	}
};

spine.Skin = function (name) {
	this.name = name;
	this.attachments = {};
};
spine.Skin.prototype = {
	addAttachment: function (slotIndex, name, attachment) {
		this.attachments[slotIndex + ":" + name] = attachment;
	},
	getAttachment: function (slotIndex, name) {
		return this.attachments[slotIndex + ":" + name];
	},
	_attachAll: function (skeleton, oldSkin) {
		for (var key in oldSkin.attachments) {
			var colon = key.indexOf(":");
			var slotIndex = parseInt(key.substring(0, colon));
			var name = key.substring(colon + 1);
			var slot = skeleton.slots[slotIndex];
			if (slot.attachment && slot.attachment.name == name) {
				var attachment = this.getAttachment(slotIndex, name);
				if (attachment) slot.setAttachment(attachment);
			}
		}
	}
};

spine.Animation = function (name, timelines, duration) {
	this.name = name;
	this.timelines = timelines;
	this.duration = duration;
};
spine.Animation.prototype = {
	apply: function (skeleton, lastTime, time, loop, events) {
		if (loop && this.duration != 0) {
			time %= this.duration;
			lastTime %= this.duration;
		}
		var timelines = this.timelines;
		for (var i = 0, n = timelines.length; i < n; i++)
			timelines[i].apply(skeleton, lastTime, time, events, 1);
	},
	mix: function (skeleton, lastTime, time, loop, events, alpha) {
		if (loop && this.duration != 0) {
			time %= this.duration;
			lastTime %= this.duration;
		}
		var timelines = this.timelines;
		for (var i = 0, n = timelines.length; i < n; i++)
			timelines[i].apply(skeleton, lastTime, time, events, alpha);
	}
};

spine.binarySearch = function (values, target, step) {
	var low = 0;
	var high = Math.floor(values.length / step) - 2;
	if (high == 0) return step;
	var current = high >>> 1;
	while (true) {
		if (values[(current + 1) * step] <= target)
			low = current + 1;
		else
			high = current;
		if (low == high) return (low + 1) * step;
		current = (low + high) >>> 1;
	}
};
spine.linearSearch = function (values, target, step) {
	for (var i = 0, last = values.length - step; i <= last; i += step)
		if (values[i] > target) return i;
	return -1;
};

spine.Curves = function (frameCount) {
	this.curves = []; // dfx, dfy, ddfx, ddfy, dddfx, dddfy, ...
	this.curves.length = (frameCount - 1) * 6;
};
spine.Curves.prototype = {
	setLinear: function (frameIndex) {
		this.curves[frameIndex * 6] = 0/*LINEAR*/;
	},
	setStepped: function (frameIndex) {
		this.curves[frameIndex * 6] = -1/*STEPPED*/;
	},
	/** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.
	 * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of
	 * the difference between the keyframe's values. */
	setCurve: function (frameIndex, cx1, cy1, cx2, cy2) {
		var subdiv_step = 1 / 10/*BEZIER_SEGMENTS*/;
		var subdiv_step2 = subdiv_step * subdiv_step;
		var subdiv_step3 = subdiv_step2 * subdiv_step;
		var pre1 = 3 * subdiv_step;
		var pre2 = 3 * subdiv_step2;
		var pre4 = 6 * subdiv_step2;
		var pre5 = 6 * subdiv_step3;
		var tmp1x = -cx1 * 2 + cx2;
		var tmp1y = -cy1 * 2 + cy2;
		var tmp2x = (cx1 - cx2) * 3 + 1;
		var tmp2y = (cy1 - cy2) * 3 + 1;
		var i = frameIndex * 6;
		var curves = this.curves;
		curves[i] = cx1 * pre1 + tmp1x * pre2 + tmp2x * subdiv_step3;
		curves[i + 1] = cy1 * pre1 + tmp1y * pre2 + tmp2y * subdiv_step3;
		curves[i + 2] = tmp1x * pre4 + tmp2x * pre5;
		curves[i + 3] = tmp1y * pre4 + tmp2y * pre5;
		curves[i + 4] = tmp2x * pre5;
		curves[i + 5] = tmp2y * pre5;
	},
	getCurvePercent: function (frameIndex, percent) {
		percent = percent < 0 ? 0 : (percent > 1 ? 1 : percent);
		var curveIndex = frameIndex * 6;
		var curves = this.curves;
		var dfx = curves[curveIndex];
		if (!dfx/*LINEAR*/) return percent;
		if (dfx == -1/*STEPPED*/) return 0;
		var dfy = curves[curveIndex + 1];
		var ddfx = curves[curveIndex + 2];
		var ddfy = curves[curveIndex + 3];
		var dddfx = curves[curveIndex + 4];
		var dddfy = curves[curveIndex + 5];
		var x = dfx, y = dfy;
		var i = 10/*BEZIER_SEGMENTS*/ - 2;
		while (true) {
			if (x >= percent) {
				var lastX = x - dfx;
				var lastY = y - dfy;
				return lastY + (y - lastY) * (percent - lastX) / (x - lastX);
			}
			if (i == 0) break;
			i--;
			dfx += ddfx;
			dfy += ddfy;
			ddfx += dddfx;
			ddfy += dddfy;
			x += dfx;
			y += dfy;
		}
		return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.
	}
};

spine.RotateTimeline = function (frameCount) {
	this.curves = new spine.Curves(frameCount);
	this.frames = []; // time, angle, ...
	this.frames.length = frameCount * 2;
};
spine.RotateTimeline.prototype = {
	boneIndex: 0,
	getFrameCount: function () {
		return this.frames.length / 2;
	},
	setFrame: function (frameIndex, time, angle) {
		frameIndex *= 2;
		this.frames[frameIndex] = time;
		this.frames[frameIndex + 1] = angle;
	},
	apply: function (skeleton, lastTime, time, firedEvents, alpha) {
		var frames = this.frames;
		if (time < frames[0]) return; // Time is before first frame.

		var bone = skeleton.bones[this.boneIndex];

		if (time >= frames[frames.length - 2]) { // Time is after last frame.
			var amount = bone.data.rotation + frames[frames.length - 1] - bone.rotation;
			while (amount > 180)
				amount -= 360;
			while (amount < -180)
				amount += 360;
			bone.rotation += amount * alpha;
			return;
		}

		// Interpolate between the last frame and the current frame.
		var frameIndex = spine.binarySearch(frames, time, 2);
		var lastFrameValue = frames[frameIndex - 1];
		var frameTime = frames[frameIndex];
		var percent = 1 - (time - frameTime) / (frames[frameIndex - 2/*LAST_FRAME_TIME*/] - frameTime);
		percent = this.curves.getCurvePercent(frameIndex / 2 - 1, percent);

		var amount = frames[frameIndex + 1/*FRAME_VALUE*/] - lastFrameValue;
		while (amount > 180)
			amount -= 360;
		while (amount < -180)
			amount += 360;
		amount = bone.data.rotation + (lastFrameValue + amount * percent) - bone.rotation;
		while (amount > 180)
			amount -= 360;
		while (amount < -180)
			amount += 360;
		bone.rotation += amount * alpha;
	}
};

spine.TranslateTimeline = function (frameCount) {
	this.curves = new spine.Curves(frameCount);
	this.frames = []; // time, x, y, ...
	this.frames.length = frameCount * 3;
};
spine.TranslateTimeline.prototype = {
	boneIndex: 0,
	getFrameCount: function () {
		return this.frames.length / 3;
	},
	setFrame: function (frameIndex, time, x, y) {
		frameIndex *= 3;
		this.frames[frameIndex] = time;
		this.frames[frameIndex + 1] = x;
		this.frames[frameIndex + 2] = y;
	},
	apply: function (skeleton, lastTime, time, firedEvents, alpha) {
		var frames = this.frames;
		if (time < frames[0]) return; // Time is before first frame.

		var bone = skeleton.bones[this.boneIndex];

		if (time >= frames[frames.length - 3]) { // Time is after last frame.
			bone.x += (bone.data.x + frames[frames.length - 2] - bone.x) * alpha;
			bone.y += (bone.data.y + frames[frames.length - 1] - bone.y) * alpha;
			return;
		}

		// Interpolate between the last frame and the current frame.
		var frameIndex = spine.binarySearch(frames, time, 3);
		var lastFrameX = frames[frameIndex - 2];
		var lastFrameY = frames[frameIndex - 1];
		var frameTime = frames[frameIndex];
		var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*LAST_FRAME_TIME*/] - frameTime);
		percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);

		bone.x += (bone.data.x + lastFrameX + (frames[frameIndex + 1/*FRAME_X*/] - lastFrameX) * percent - bone.x) * alpha;
		bone.y += (bone.data.y + lastFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - lastFrameY) * percent - bone.y) * alpha;
	}
};

spine.ScaleTimeline = function (frameCount) {
	this.curves = new spine.Curves(frameCount);
	this.frames = []; // time, x, y, ...
	this.frames.length = frameCount * 3;
};
spine.ScaleTimeline.prototype = {
	boneIndex: 0,
	getFrameCount: function () {
		return this.frames.length / 3;
	},
	setFrame: function (frameIndex, time, x, y) {
		frameIndex *= 3;
		this.frames[frameIndex] = time;
		this.frames[frameIndex + 1] = x;
		this.frames[frameIndex + 2] = y;
	},
	apply: function (skeleton, lastTime, time, firedEvents, alpha) {
		var frames = this.frames;
		if (time < frames[0]) return; // Time is before first frame.

		var bone = skeleton.bones[this.boneIndex];

		if (time >= frames[frames.length - 3]) { // Time is after last frame.
			bone.scaleX += (bone.data.scaleX - 1 + frames[frames.length - 2] - bone.scaleX) * alpha;
			bone.scaleY += (bone.data.scaleY - 1 + frames[frames.length - 1] - bone.scaleY) * alpha;
			return;
		}

		// Interpolate between the last frame and the current frame.
		var frameIndex = spine.binarySearch(frames, time, 3);
		var lastFrameX = frames[frameIndex - 2];
		var lastFrameY = frames[frameIndex - 1];
		var frameTime = frames[frameIndex];
		var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*LAST_FRAME_TIME*/] - frameTime);
		percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);

		bone.scaleX += (bone.data.scaleX - 1 + lastFrameX + (frames[frameIndex + 1/*FRAME_X*/] - lastFrameX) * percent - bone.scaleX) * alpha;
		bone.scaleY += (bone.data.scaleY - 1 + lastFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - lastFrameY) * percent - bone.scaleY) * alpha;
	}
};

spine.ColorTimeline = function (frameCount) {
	this.curves = new spine.Curves(frameCount);
	this.frames = []; // time, r, g, b, a, ...
	this.frames.length = frameCount * 5;
};
spine.ColorTimeline.prototype = {
	slotIndex: 0,
	getFrameCount: function () {
		return this.frames.length / 5;
	},
	setFrame: function (frameIndex, time, r, g, b, a) {
		frameIndex *= 5;
		this.frames[frameIndex] = time;
		this.frames[frameIndex + 1] = r;
		this.frames[frameIndex + 2] = g;
		this.frames[frameIndex + 3] = b;
		this.frames[frameIndex + 4] = a;
	},
	apply: function (skeleton, lastTime, time, firedEvents, alpha) {
		var frames = this.frames;
		if (time < frames[0]) return; // Time is before first frame.

		var slot = skeleton.slots[this.slotIndex];

		if (time >= frames[frames.length - 5]) { // Time is after last frame.
			var i = frames.length - 1;
			slot.r = frames[i - 3];
			slot.g = frames[i - 2];
			slot.b = frames[i - 1];
			slot.a = frames[i];
			return;
		}

		// Interpolate between the last frame and the current frame.
		var frameIndex = spine.binarySearch(frames, time, 5);
		var lastFrameR = frames[frameIndex - 4];
		var lastFrameG = frames[frameIndex - 3];
		var lastFrameB = frames[frameIndex - 2];
		var lastFrameA = frames[frameIndex - 1];
		var frameTime = frames[frameIndex];
		var percent = 1 - (time - frameTime) / (frames[frameIndex - 5/*LAST_FRAME_TIME*/] - frameTime);
		percent = this.curves.getCurvePercent(frameIndex / 5 - 1, percent);

		var r = lastFrameR + (frames[frameIndex + 1/*FRAME_R*/] - lastFrameR) * percent;
		var g = lastFrameG + (frames[frameIndex + 2/*FRAME_G*/] - lastFrameG) * percent;
		var b = lastFrameB + (frames[frameIndex + 3/*FRAME_B*/] - lastFrameB) * percent;
		var a = lastFrameA + (frames[frameIndex + 4/*FRAME_A*/] - lastFrameA) * percent;
		if (alpha < 1) {
			slot.r += (r - slot.r) * alpha;
			slot.g += (g - slot.g) * alpha;
			slot.b += (b - slot.b) * alpha;
			slot.a += (a - slot.a) * alpha;
		} else {
			slot.r = r;
			slot.g = g;
			slot.b = b;
			slot.a = a;
		}
	}
};

spine.AttachmentTimeline = function (frameCount) {
	this.curves = new spine.Curves(frameCount);
	this.frames = []; // time, ...
	this.frames.length = frameCount;
	this.attachmentNames = [];
	this.attachmentNames.length = frameCount;
};
spine.AttachmentTimeline.prototype = {
	slotIndex: 0,
	getFrameCount: function () {
		return this.frames.length;
	},
	setFrame: function (frameIndex, time, attachmentName) {
		this.frames[frameIndex] = time;
		this.attachmentNames[frameIndex] = attachmentName;
	},
	apply: function (skeleton, lastTime, time, firedEvents, alpha) {
		var frames = this.frames;
		if (time < frames[0]) return; // Time is before first frame.

		var frameIndex;
		if (time >= frames[frames.length - 1]) // Time is after last frame.
			frameIndex = frames.length - 1;
		else
			frameIndex = spine.binarySearch(frames, time, 1) - 1;

		var attachmentName = this.attachmentNames[frameIndex];
		skeleton.slots[this.slotIndex].setAttachment(!attachmentName ? null : skeleton.getAttachmentBySlotIndex(this.slotIndex, attachmentName));
	}
};

spine.EventTimeline = function (frameCount) {
	this.frames = []; // time, ...
	this.frames.length = frameCount;
	this.events = [];
	this.events.length = frameCount;
};
spine.EventTimeline.prototype = {
	getFrameCount: function () {
		return this.frames.length;
	},
	setFrame: function (frameIndex, time, event) {
		this.frames[frameIndex] = time;
		this.events[frameIndex] = event;
	},
	/** Fires events for frames > lastTime and <= time. */
	apply: function (skeleton, lastTime, time, firedEvents, alpha) {
		if (!firedEvents) return;

		var frames = this.frames;
		var frameCount = frames.length;

		if (lastTime > time) { // Fire events after last time for looped animations.
			this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha);
			lastTime = -1;
		} else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.
			return;
		if (time < frames[0]) return; // Time is before first frame.

		var frameIndex;
		if (lastTime < frames[0])
			frameIndex = 0;
		else {
			frameIndex = spine.binarySearch(frames, lastTime, 1);
			var frame = frames[frameIndex];
			while (frameIndex > 0) { // Fire multiple events with the same frame.
				if (frames[frameIndex - 1] != frame) break;
				frameIndex--;
			}
		}
		var events = this.events;
		for (; frameIndex < frameCount && time >= frames[frameIndex]; frameIndex++)
			firedEvents.push(events[frameIndex]);
	}
};

spine.DrawOrderTimeline = function (frameCount) {
	this.frames = []; // time, ...
	this.frames.length = frameCount;
	this.drawOrders = [];
	this.drawOrders.length = frameCount;
};
spine.DrawOrderTimeline.prototype = {
	getFrameCount: function () {
		return this.frames.length;
	},
	setFrame: function (frameIndex, time, drawOrder) {
		this.frames[frameIndex] = time;
		this.drawOrders[frameIndex] = drawOrder;
	},
	apply: function (skeleton, lastTime, time, firedEvents, alpha) {
		var frames = this.frames;
		if (time < frames[0]) return; // Time is before first frame.

		var frameIndex;
		if (time >= frames[frames.length - 1]) // Time is after last frame.
			frameIndex = frames.length - 1;
		else
			frameIndex = spine.binarySearch(frames, time, 1) - 1;

		var drawOrder = skeleton.drawOrder;
		var slots = skeleton.slots;
		var drawOrderToSetupIndex = this.drawOrders[frameIndex];
		if (!drawOrderToSetupIndex) {
			for (var i = 0, n = slots.length; i < n; i++)
				drawOrder[i] = slots[i];
		} else {
			for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)
				drawOrder[i] = skeleton.slots[drawOrderToSetupIndex[i]];
		}

	}
};

spine.SkeletonData = function () {
	this.bones = [];
	this.slots = [];
	this.skins = [];
	this.events = [];
	this.animations = [];
};
spine.SkeletonData.prototype = {
	defaultSkin: null,
	/** @return May be null. */
	findBone: function (boneName) {
		var bones = this.bones;
		for (var i = 0, n = bones.length; i < n; i++)
			if (bones[i].name == boneName) return bones[i];
		return null;
	},
	/** @return -1 if the bone was not found. */
	findBoneIndex: function (boneName) {
		var bones = this.bones;
		for (var i = 0, n = bones.length; i < n; i++)
			if (bones[i].name == boneName) return i;
		return -1;
	},
	/** @return May be null. */
	findSlot: function (slotName) {
		var slots = this.slots;
		for (var i = 0, n = slots.length; i < n; i++) {
			if (slots[i].name == slotName) return slots[i];
		}
		return null;
	},
	/** @return -1 if the bone was not found. */
	findSlotIndex: function (slotName) {
		var slots = this.slots;
		for (var i = 0, n = slots.length; i < n; i++)
			if (slots[i].name == slotName) return i;
		return -1;
	},
	/** @return May be null. */
	findSkin: function (skinName) {
		var skins = this.skins;
		for (var i = 0, n = skins.length; i < n; i++)
			if (skins[i].name == skinName) return skins[i];
		return null;
	},
	/** @return May be null. */
	findEvent: function (eventName) {
		var events = this.events;
		for (var i = 0, n = events.length; i < n; i++)
			if (events[i].name == eventName) return events[i];
		return null;
	},
	/** @return May be null. */
	findAnimation: function (animationName) {
		var animations = this.animations;
		for (var i = 0, n = animations.length; i < n; i++)
			if (animations[i].name == animationName) return animations[i];
		return null;
	}
};

spine.Skeleton = function (skeletonData) {
	this.data = skeletonData;

	this.bones = [];
	for (var i = 0, n = skeletonData.bones.length; i < n; i++) {
		var boneData = skeletonData.bones[i];
		var parent = !boneData.parent ? null : this.bones[skeletonData.bones.indexOf(boneData.parent)];
		this.bones.push(new spine.Bone(boneData, parent));
	}

	this.slots = [];
	this.drawOrder = [];
	for (var i = 0, n = skeletonData.slots.length; i < n; i++) {
		var slotData = skeletonData.slots[i];
		var bone = this.bones[skeletonData.bones.indexOf(slotData.boneData)];
		var slot = new spine.Slot(slotData, this, bone);
		this.slots.push(slot);
		this.drawOrder.push(slot);
	}
};
spine.Skeleton.prototype = {
	x: 0, y: 0,
	skin: null,
	r: 1, g: 1, b: 1, a: 1,
	time: 0,
	flipX: false, flipY: false,
	/** Updates the world transform for each bone. */
	updateWorldTransform: function () {
		var flipX = this.flipX;
		var flipY = this.flipY;
		var bones = this.bones;
		for (var i = 0, n = bones.length; i < n; i++)
			bones[i].updateWorldTransform(flipX, flipY);
	},
	/** Sets the bones and slots to their setup pose values. */
	setToSetupPose: function () {
		this.setBonesToSetupPose();
		this.setSlotsToSetupPose();
	},
	setBonesToSetupPose: function () {
		var bones = this.bones;
		for (var i = 0, n = bones.length; i < n; i++)
			bones[i].setToSetupPose();
	},
	setSlotsToSetupPose: function () {
		var slots = this.slots;
		for (var i = 0, n = slots.length; i < n; i++)
			slots[i].setToSetupPose();
	},
	/** @return May return null. */
	getRootBone: function () {
		return this.bones.length == 0 ? null : this.bones[0];
	},
	/** @return May be null. */
	findBone: function (boneName) {
		var bones = this.bones;
		for (var i = 0, n = bones.length; i < n; i++)
			if (bones[i].data.name == boneName) return bones[i];
		return null;
	},
	/** @return -1 if the bone was not found. */
	findBoneIndex: function (boneName) {
		var bones = this.bones;
		for (var i = 0, n = bones.length; i < n; i++)
			if (bones[i].data.name == boneName) return i;
		return -1;
	},
	/** @return May be null. */
	findSlot: function (slotName) {
		var slots = this.slots;
		for (var i = 0, n = slots.length; i < n; i++)
			if (slots[i].data.name == slotName) return slots[i];
		return null;
	},
	/** @return -1 if the bone was not found. */
	findSlotIndex: function (slotName) {
		var slots = this.slots;
		for (var i = 0, n = slots.length; i < n; i++)
			if (slots[i].data.name == slotName) return i;
		return -1;
	},
	setSkinByName: function (skinName) {
		var skin = this.data.findSkin(skinName);
		if (!skin) throw "Skin not found: " + skinName;
		this.setSkin(skin);
	},
	/** Sets the skin used to look up attachments not found in the {@link SkeletonData#getDefaultSkin() default skin}. Attachments
	 * from the new skin are attached if the corresponding attachment from the old skin was attached.
	 * @param newSkin May be null. */
	setSkin: function (newSkin) {
		if (this.skin && newSkin) newSkin._attachAll(this, this.skin);
		this.skin = newSkin;
	},
	/** @return May be null. */
	getAttachmentBySlotName: function (slotName, attachmentName) {
		return this.getAttachmentBySlotIndex(this.data.findSlotIndex(slotName), attachmentName);
	},
	/** @return May be null. */
	getAttachmentBySlotIndex: function (slotIndex, attachmentName) {
		if (this.skin) {
			var attachment = this.skin.getAttachment(slotIndex, attachmentName);
			if (attachment) return attachment;
		}
		if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
		return null;
	},
	/** @param attachmentName May be null. */
	setAttachment: function (slotName, attachmentName) {
		var slots = this.slots;
		for (var i = 0, n = slots.length; i < n; i++) {
			var slot = slots[i];
			if (slot.data.name == slotName) {
				var attachment = null;
				if (attachmentName) {
                    attachment = this.getAttachmentBySlotIndex(i, attachmentName);
					if (!attachment) throw "Attachment not found: " + attachmentName + ", for slot: " + slotName;
				}
				slot.setAttachment(attachment);
				return;
			}
		}
		throw "Slot not found: " + slotName;
	},
	update: function (delta) {
		this.time += delta;
	}
};

spine.EventData = function (name) {
	this.name = name;
}
spine.EventData.prototype = {
	intValue: 0,
	floatValue: 0,
	stringValue: null
};

spine.Event = function (data) {
	this.data = data;
}
spine.Event.prototype = {
	intValue: 0,
	floatValue: 0,
	stringValue: null
};

spine.AttachmentType = {
	region: 0,
	boundingbox: 1
};

spine.RegionAttachment = function (name) {
	this.name = name;
	this.offset = [];
	this.offset.length = 8;
	this.uvs = [];
	this.uvs.length = 8;
};
spine.RegionAttachment.prototype = {
	type: spine.AttachmentType.region,
	x: 0, y: 0,
	rotation: 0,
	scaleX: 1, scaleY: 1,
	width: 0, height: 0,
	rendererObject: null,
	regionOffsetX: 0, regionOffsetY: 0,
	regionWidth: 0, regionHeight: 0,
	regionOriginalWidth: 0, regionOriginalHeight: 0,
	setUVs: function (u, v, u2, v2, rotate) {
		var uvs = this.uvs;
		if (rotate) {
			uvs[2/*X2*/] = u;
			uvs[3/*Y2*/] = v2;
			uvs[4/*X3*/] = u;
			uvs[5/*Y3*/] = v;
			uvs[6/*X4*/] = u2;
			uvs[7/*Y4*/] = v;
			uvs[0/*X1*/] = u2;
			uvs[1/*Y1*/] = v2;
		} else {
			uvs[0/*X1*/] = u;
			uvs[1/*Y1*/] = v2;
			uvs[2/*X2*/] = u;
			uvs[3/*Y2*/] = v;
			uvs[4/*X3*/] = u2;
			uvs[5/*Y3*/] = v;
			uvs[6/*X4*/] = u2;
			uvs[7/*Y4*/] = v2;
		}
	},
	updateOffset: function () {
		var regionScaleX = this.width / this.regionOriginalWidth * this.scaleX;
		var regionScaleY = this.height / this.regionOriginalHeight * this.scaleY;
		var localX = -this.width / 2 * this.scaleX + this.regionOffsetX * regionScaleX;
		var localY = -this.height / 2 * this.scaleY + this.regionOffsetY * regionScaleY;
		var localX2 = localX + this.regionWidth * regionScaleX;
		var localY2 = localY + this.regionHeight * regionScaleY;
		var radians = this.rotation * Math.PI / 180;
		var cos = Math.cos(radians);
		var sin = Math.sin(radians);
		var localXCos = localX * cos + this.x;
		var localXSin = localX * sin;
		var localYCos = localY * cos + this.y;
		var localYSin = localY * sin;
		var localX2Cos = localX2 * cos + this.x;
		var localX2Sin = localX2 * sin;
		var localY2Cos = localY2 * cos + this.y;
		var localY2Sin = localY2 * sin;
		var offset = this.offset;
		offset[0/*X1*/] = localXCos - localYSin;
		offset[1/*Y1*/] = localYCos + localXSin;
		offset[2/*X2*/] = localXCos - localY2Sin;
		offset[3/*Y2*/] = localY2Cos + localXSin;
		offset[4/*X3*/] = localX2Cos - localY2Sin;
		offset[5/*Y3*/] = localY2Cos + localX2Sin;
		offset[6/*X4*/] = localX2Cos - localYSin;
		offset[7/*Y4*/] = localYCos + localX2Sin;
	},
	computeVertices: function (x, y, bone, vertices) {
		x += bone.worldX;
		y += bone.worldY;
		var m00 = bone.m00;
		var m01 = bone.m01;
		var m10 = bone.m10;
		var m11 = bone.m11;
		var offset = this.offset;
		vertices[0/*X1*/] = offset[0/*X1*/] * m00 + offset[1/*Y1*/] * m01 + x;
		vertices[1/*Y1*/] = offset[0/*X1*/] * m10 + offset[1/*Y1*/] * m11 + y;
		vertices[2/*X2*/] = offset[2/*X2*/] * m00 + offset[3/*Y2*/] * m01 + x;
		vertices[3/*Y2*/] = offset[2/*X2*/] * m10 + offset[3/*Y2*/] * m11 + y;
		vertices[4/*X3*/] = offset[4/*X3*/] * m00 + offset[5/*X3*/] * m01 + x;
		vertices[5/*X3*/] = offset[4/*X3*/] * m10 + offset[5/*X3*/] * m11 + y;
		vertices[6/*X4*/] = offset[6/*X4*/] * m00 + offset[7/*Y4*/] * m01 + x;
		vertices[7/*Y4*/] = offset[6/*X4*/] * m10 + offset[7/*Y4*/] * m11 + y;
	}
};

spine.BoundingBoxAttachment = function (name) {
	this.name = name;
	this.vertices = [];
};
spine.BoundingBoxAttachment.prototype = {
	type: spine.AttachmentType.boundingBox,
	computeWorldVertices: function (x, y, bone, worldVertices) {
		x += bone.worldX;
		y += bone.worldY;
		var m00 = bone.m00;
		var m01 = bone.m01;
		var m10 = bone.m10;
		var m11 = bone.m11;
		var vertices = this.vertices;
		for (var i = 0, n = vertices.length; i < n; i += 2) {
			var px = vertices[i];
			var py = vertices[i + 1];
			worldVertices[i] = px * m00 + py * m01 + x;
			worldVertices[i + 1] = px * m10 + py * m11 + y;
		}
	}
};

spine.AnimationStateData = function (skeletonData) {
	this.skeletonData = skeletonData;
	this.animationToMixTime = {};
};
spine.AnimationStateData.prototype = {
	defaultMix: 0,
	setMixByName: function (fromName, toName, duration) {
		var from = this.skeletonData.findAnimation(fromName);
		if (!from) throw "Animation not found: " + fromName;
		var to = this.skeletonData.findAnimation(toName);
		if (!to) throw "Animation not found: " + toName;
		this.setMix(from, to, duration);
	},
	setMix: function (from, to, duration) {
		this.animationToMixTime[from.name + ":" + to.name] = duration;
	},
	getMix: function (from, to) {
		var time = this.animationToMixTime[from.name + ":" + to.name];
		return time ? time : this.defaultMix;
	}
};

spine.TrackEntry = function () {};
spine.TrackEntry.prototype = {
	next: null, previous: null,
	animation: null,
	loop: false,
	delay: 0, time: 0, lastTime: -1, endTime: 0,
	timeScale: 1,
	mixTime: 0, mixDuration: 0,
	onStart: null, onEnd: null, onComplete: null, onEvent: null
}

spine.AnimationState = function (stateData) {
	this.data = stateData;
	this.tracks = [];
	this.events = [];
};
spine.AnimationState.prototype = {
	onStart: null,
	onEnd: null,
	onComplete: null,
	onEvent: null,
	timeScale: 1,
	update: function (delta) {
		delta *= this.timeScale;
		for (var i = 0; i < this.tracks.length; i++) {
			var current = this.tracks[i];
			if (!current) continue;

			var trackDelta = delta * current.timeScale;
			current.time += trackDelta;
			if (current.previous) {
				current.previous.time += trackDelta;
				current.mixTime += trackDelta;
			}

			var next = current.next;
			if (next) {
				if (current.lastTime >= next.delay) this.setCurrent(i, next);
			} else {
				// End non-looping animation when it reaches its end time and there is no next entry.
				if (!current.loop && current.lastTime >= current.endTime) this.clearTrack(i);
			}
		}
	},
	apply: function (skeleton) {
		for (var i = 0; i < this.tracks.length; i++) {
			var current = this.tracks[i];
			if (!current) continue;

			this.events.length = 0;

			var time = current.time;
			var lastTime = current.lastTime;
			var endTime = current.endTime;
			var loop = current.loop;
			if (!loop && time > endTime) time = endTime;

			var previous = current.previous;
			if (!previous)
				current.animation.apply(skeleton, current.lastTime, time, loop, this.events);
			else {
				var previousTime = previous.time;
				if (!previous.loop && previousTime > previous.endTime) previousTime = previous.endTime;
				previous.animation.apply(skeleton, previousTime, previousTime, previous.loop, null);

				var alpha = current.mixTime / current.mixDuration;
				if (alpha >= 1) {
					alpha = 1;
					current.previous = null;
				}
				current.animation.mix(skeleton, current.lastTime, time, loop, this.events, alpha);
			}

			for (var ii = 0, nn = this.events.length; ii < nn; ii++) {
				var event = this.events[ii];
				if (current.onEvent != null) current.onEvent(i, event);
				if (this.onEvent != null) this.onEvent(i, event);
			}

			// Check if completed the animation or a loop iteration.
			if (loop ? (lastTime % endTime > time % endTime) : (lastTime < endTime && time >= endTime)) {
				var count = Math.floor(time / endTime);
				if (current.onComplete) current.onComplete(i, count);
				if (this.onComplete) this.onComplete(i, count);
			}

			current.lastTime = current.time;
		}
	},
	clearTracks: function () {
		for (var i = 0, n = this.tracks.length; i < n; i++)
			this.clearTrack(i);
		this.tracks.length = 0; 
	},
	clearTrack: function (trackIndex) {
		if (trackIndex >= this.tracks.length) return;
		var current = this.tracks[trackIndex];
		if (!current) return;

		if (current.onEnd != null) current.onEnd(trackIndex);
		if (this.onEnd != null) this.onEnd(trackIndex);

		this.tracks[trackIndex] = null;
	},
	_expandToIndex: function (index) {
		if (index < this.tracks.length) return this.tracks[index];
		while (index >= this.tracks.length)
			this.tracks.push(null);
		return null;
	},
	setCurrent: function (index, entry) {
		var current = this._expandToIndex(index);
		if (current) {
			current.previous = null;

			if (current.onEnd != null) current.onEnd(index);
			if (this.onEnd != null) this.onEnd(index);

			entry.mixDuration = this.data.getMix(current.animation, entry.animation);
			if (entry.mixDuration > 0) {
				entry.mixTime = 0;
				entry.previous = current;
			}
		}

		this.tracks[index] = entry;

		if (entry.onStart != null) entry.onStart(index);
		if (this.onStart != null) this.onStart(index);
	},
	setAnimationByName: function (trackIndex, animationName, loop) {
		var animation = this.data.skeletonData.findAnimation(animationName);
		if (!animation) throw "Animation not found: " + animationName;
		return this.setAnimation(trackIndex, animation, loop);
	},
	/** Set the current animation. Any queued animations are cleared. */
	setAnimation: function (trackIndex, animation, loop) {
		var entry = new spine.TrackEntry();
		entry.animation = animation;
		entry.loop = loop;
		entry.endTime = animation.duration;
		this.setCurrent(trackIndex, entry);
		return entry;
	},
	addAnimationByName: function (trackIndex, animationName, loop, delay) {
		var animation = this.data.skeletonData.findAnimation(animationName);
		if (!animation) throw "Animation not found: " + animationName;
		return this.addAnimation(trackIndex, animation, loop, delay);
	},
	/** Adds an animation to be played delay seconds after the current or last queued animation.
	 * @param delay May be <= 0 to use duration of previous animation minus any mix duration plus the negative delay. */
	addAnimation: function (trackIndex, animation, loop, delay) {
		var entry = new spine.TrackEntry();
		entry.animation = animation;
		entry.loop = loop;
		entry.endTime = animation.duration;

		var last = this._expandToIndex(trackIndex);
		if (last) {
			while (last.next)
				last = last.next;
			last.next = entry;
		} else
			this.tracks[trackIndex] = entry;

		if (delay <= 0) {
			if (last)
				delay += last.endTime - this.data.getMix(last.animation, animation);
			else
				delay = 0;
		}
		entry.delay = delay;

		return entry;
	},
	/** May be null. */
	getCurrent: function (trackIndex) {
		if (trackIndex >= this.tracks.length) return null;
		return this.tracks[trackIndex];
	}
};

spine.SkeletonJson = function (attachmentLoader) {
	this.attachmentLoader = attachmentLoader;
};
spine.SkeletonJson.prototype = {
	scale: 1,
	readSkeletonData: function (root) {
		var skeletonData = new spine.SkeletonData();

		// Bones.
		var bones = root["bones"];
		for (var i = 0, n = bones.length; i < n; i++) {
			var boneMap = bones[i];
			var parent = null;
			if (boneMap["parent"]) {
				parent = skeletonData.findBone(boneMap["parent"]);
				if (!parent) throw "Parent bone not found: " + boneMap["parent"];
			}
			var boneData = new spine.BoneData(boneMap["name"], parent);
			boneData.length = (boneMap["length"] || 0) * this.scale;
			boneData.x = (boneMap["x"] || 0) * this.scale;
			boneData.y = (boneMap["y"] || 0) * this.scale;
			boneData.rotation = (boneMap["rotation"] || 0);
			boneData.scaleX = boneMap["scaleX"] || 1;
			boneData.scaleY = boneMap["scaleY"] || 1;
			boneData.inheritScale = boneMap["inheritScale"] || true;
			boneData.inheritRotation = boneMap["inheritRotation"] || true;
			skeletonData.bones.push(boneData);
		}

		// Slots.
		var slots = root["slots"];
		for (var i = 0, n = slots.length; i < n; i++) {
			var slotMap = slots[i];
			var boneData = skeletonData.findBone(slotMap["bone"]);
			if (!boneData) throw "Slot bone not found: " + slotMap["bone"];
			var slotData = new spine.SlotData(slotMap["name"], boneData);

			var color = slotMap["color"];
			if (color) {
				slotData.r = spine.SkeletonJson.toColor(color, 0);
				slotData.g = spine.SkeletonJson.toColor(color, 1);
				slotData.b = spine.SkeletonJson.toColor(color, 2);
				slotData.a = spine.SkeletonJson.toColor(color, 3);
			}

			slotData.attachmentName = slotMap["attachment"];
			slotData.additiveBlending = slotMap["additive"];

			skeletonData.slots.push(slotData);
		}

		// Skins.
		var skins = root["skins"];
		for (var skinName in skins) {
			if (!skins.hasOwnProperty(skinName)) continue;
			var skinMap = skins[skinName];
			var skin = new spine.Skin(skinName);
			for (var slotName in skinMap) {
				if (!skinMap.hasOwnProperty(slotName)) continue;
				var slotIndex = skeletonData.findSlotIndex(slotName);
				var slotEntry = skinMap[slotName];
				for (var attachmentName in slotEntry) {
					if (!slotEntry.hasOwnProperty(attachmentName)) continue;
					var attachment = this.readAttachment(skin, attachmentName, slotEntry[attachmentName]);
					if (attachment != null) skin.addAttachment(slotIndex, attachmentName, attachment);
				}
			}
			skeletonData.skins.push(skin);
			if (skin.name == "default") skeletonData.defaultSkin = skin;
		}

		// Events.
		var events = root["events"];
		for (var eventName in events) {
			if (!events.hasOwnProperty(eventName)) continue;
			var eventMap = events[eventName];
			var eventData = new spine.EventData(eventName);
			eventData.intValue = eventMap["int"] || 0;
			eventData.floatValue = eventMap["float"] || 0;
			eventData.stringValue = eventMap["string"] || null;
			skeletonData.events.push(eventData);
		}

		// Animations.
		var animations = root["animations"];
		for (var animationName in animations) {
			if (!animations.hasOwnProperty(animationName)) continue;
			this.readAnimation(animationName, animations[animationName], skeletonData);
		}

		return skeletonData;
	},
	readAttachment: function (skin, name, map) {
		name = map["name"] || name;

		var type = spine.AttachmentType[map["type"] || "region"];
		var attachment = this.attachmentLoader.newAttachment(skin, type, name);

		if (type == spine.AttachmentType.region) {
			attachment.x = (map["x"] || 0) * this.scale;
			attachment.y = (map["y"] || 0) * this.scale;
			attachment.scaleX = map["scaleX"] || 1;
			attachment.scaleY = map["scaleY"] || 1;
			attachment.rotation = map["rotation"] || 0;
			attachment.width = (map["width"] || 32) * this.scale;
			attachment.height = (map["height"] || 32) * this.scale;
			attachment.updateOffset();
		} else if (type == spine.AttachmentType.boundingBox) {
			var vertices = map["vertices"];
			for (var i = 0, n = vertices.length; i < n; i++)
				attachment.vertices.push(vertices[i] * scale);
		}

		return attachment;
	},
	readAnimation: function (name, map, skeletonData) {
		var timelines = [];
		var duration = 0;

		var bones = map["bones"];
		for (var boneName in bones) {
			if (!bones.hasOwnProperty(boneName)) continue;
			var boneIndex = skeletonData.findBoneIndex(boneName);
			if (boneIndex == -1) throw "Bone not found: " + boneName;
			var boneMap = bones[boneName];

			for (var timelineName in boneMap) {
				if (!boneMap.hasOwnProperty(timelineName)) continue;
				var values = boneMap[timelineName];
				if (timelineName == "rotate") {
					var timeline = new spine.RotateTimeline(values.length);
					timeline.boneIndex = boneIndex;

					var frameIndex = 0;
					for (var i = 0, n = values.length; i < n; i++) {
						var valueMap = values[i];
						timeline.setFrame(frameIndex, valueMap["time"], valueMap["angle"]);
						spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);
						frameIndex++;
					}
					timelines.push(timeline);
					duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]);

				} else if (timelineName == "translate" || timelineName == "scale") {
					var timeline;
					var timelineScale = 1;
					if (timelineName == "scale")
						timeline = new spine.ScaleTimeline(values.length);
					else {
						timeline = new spine.TranslateTimeline(values.length);
						timelineScale = this.scale;
					}
					timeline.boneIndex = boneIndex;

					var frameIndex = 0;
					for (var i = 0, n = values.length; i < n; i++) {
						var valueMap = values[i];
						var x = (valueMap["x"] || 0) * timelineScale;
						var y = (valueMap["y"] || 0) * timelineScale;
						timeline.setFrame(frameIndex, valueMap["time"], x, y);
						spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);
						frameIndex++;
					}
					timelines.push(timeline);
					duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);

				} else
					throw "Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")";
			}
		}

		var slots = map["slots"];
		for (var slotName in slots) {
			if (!slots.hasOwnProperty(slotName)) continue;
			var slotMap = slots[slotName];
			var slotIndex = skeletonData.findSlotIndex(slotName);

			for (var timelineName in slotMap) {
				if (!slotMap.hasOwnProperty(timelineName)) continue;
				var values = slotMap[timelineName];
				if (timelineName == "color") {
					var timeline = new spine.ColorTimeline(values.length);
					timeline.slotIndex = slotIndex;

					var frameIndex = 0;
					for (var i = 0, n = values.length; i < n; i++) {
						var valueMap = values[i];
						var color = valueMap["color"];
						var r = spine.SkeletonJson.toColor(color, 0);
						var g = spine.SkeletonJson.toColor(color, 1);
						var b = spine.SkeletonJson.toColor(color, 2);
						var a = spine.SkeletonJson.toColor(color, 3);
						timeline.setFrame(frameIndex, valueMap["time"], r, g, b, a);
						spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);
						frameIndex++;
					}
					timelines.push(timeline);
					duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);

				} else if (timelineName == "attachment") {
					var timeline = new spine.AttachmentTimeline(values.length);
					timeline.slotIndex = slotIndex;

					var frameIndex = 0;
					for (var i = 0, n = values.length; i < n; i++) {
						var valueMap = values[i];
						timeline.setFrame(frameIndex++, valueMap["time"], valueMap["name"]);
					}
					timelines.push(timeline);
					duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);

				} else
					throw "Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")";
			}
		}

		var events = map["events"];
		if (events) {
			var timeline = new spine.EventTimeline(events.length);
			var frameIndex = 0;
			for (var i = 0, n = events.length; i < n; i++) {
				var eventMap = events[i];
				var eventData = skeletonData.findEvent(eventMap["name"]);
				if (!eventData) throw "Event not found: " + eventMap["name"];
				var event = new spine.Event(eventData);
				event.intValue = eventMap.hasOwnProperty("int") ? eventMap["int"] : eventData.intValue;
				event.floatValue = eventMap.hasOwnProperty("float") ? eventMap["float"] : eventData.floatValue;
				event.stringValue = eventMap.hasOwnProperty("string") ? eventMap["string"] : eventData.stringValue;
				timeline.setFrame(frameIndex++, eventMap["time"], event);
			}
			timelines.push(timeline);
			duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
		}

		var drawOrderValues = map["draworder"];
		if (drawOrderValues) {
			var timeline = new spine.DrawOrderTimeline(drawOrderValues.length);
			var slotCount = skeletonData.slots.length;
			var frameIndex = 0;
			for (var i = 0, n = drawOrderValues.length; i < n; i++) {
				var drawOrderMap = drawOrderValues[i];
				var drawOrder = null;
				if (drawOrderMap["offsets"]) {
					drawOrder = [];
					drawOrder.length = slotCount;
					for (var ii = slotCount - 1; ii >= 0; ii--)
						drawOrder[ii] = -1;
					var offsets = drawOrderMap["offsets"];
					var unchanged = [];
					unchanged.length = slotCount - offsets.length;
					var originalIndex = 0, unchangedIndex = 0;
					for (var ii = 0, nn = offsets.length; ii < nn; ii++) {
						var offsetMap = offsets[ii];
						var slotIndex = skeletonData.findSlotIndex(offsetMap["slot"]);
						if (slotIndex == -1) throw "Slot not found: " + offsetMap["slot"];
						// Collect unchanged items.
						while (originalIndex != slotIndex)
							unchanged[unchangedIndex++] = originalIndex++;
						// Set changed items.
						drawOrder[originalIndex + offsetMap["offset"]] = originalIndex++;
					}
					// Collect remaining unchanged items.
					while (originalIndex < slotCount)
						unchanged[unchangedIndex++] = originalIndex++;
					// Fill in unchanged items.
					for (var ii = slotCount - 1; ii >= 0; ii--)
						if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];
				}
				timeline.setFrame(frameIndex++, drawOrderMap["time"], drawOrder);
			}
			timelines.push(timeline);
			duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
		}

		skeletonData.animations.push(new spine.Animation(name, timelines, duration));
	}
};
spine.SkeletonJson.readCurve = function (timeline, frameIndex, valueMap) {
	var curve = valueMap["curve"];
	if (!curve) return;
	if (curve == "stepped")
		timeline.curves.setStepped(frameIndex);
	else if (curve instanceof Array)
		timeline.curves.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);
};
spine.SkeletonJson.toColor = function (hexString, colorIndex) {
	if (hexString.length != 8) throw "Color hexidecimal length must be 8, recieved: " + hexString;
	return parseInt(hexString.substring(colorIndex * 2, (colorIndex * 2) + 2), 16) / 255;
};

spine.Atlas = function (atlasText, textureLoader) {
	this.textureLoader = textureLoader;
	this.pages = [];
	this.regions = [];

	var reader = new spine.AtlasReader(atlasText);
	var tuple = [];
	tuple.length = 4;
	var page = null;
	while (true) {
		var line = reader.readLine();
		if (line == null) break;
		line = reader.trim(line);
		if (line.length == 0)
			page = null;
		else if (!page) {
			page = new spine.AtlasPage();
			page.name = line;

			page.format = spine.Atlas.Format[reader.readValue()];

			reader.readTuple(tuple);
			page.minFilter = spine.Atlas.TextureFilter[tuple[0]];
			page.magFilter = spine.Atlas.TextureFilter[tuple[1]];

			var direction = reader.readValue();
			page.uWrap = spine.Atlas.TextureWrap.clampToEdge;
			page.vWrap = spine.Atlas.TextureWrap.clampToEdge;
			if (direction == "x")
				page.uWrap = spine.Atlas.TextureWrap.repeat;
			else if (direction == "y")
				page.vWrap = spine.Atlas.TextureWrap.repeat;
			else if (direction == "xy")
				page.uWrap = page.vWrap = spine.Atlas.TextureWrap.repeat;

			textureLoader.load(page, line, this);

			this.pages.push(page);

		} else {
			var region = new spine.AtlasRegion();
			region.name = line;
			region.page = page;

			region.rotate = reader.readValue() == "true";

			reader.readTuple(tuple);
			var x = parseInt(tuple[0]);
			var y = parseInt(tuple[1]);

			reader.readTuple(tuple);
			var width = parseInt(tuple[0]);
			var height = parseInt(tuple[1]);

			region.u = x / page.width;
			region.v = y / page.height;
			if (region.rotate) {
				region.u2 = (x + height) / page.width;
				region.v2 = (y + width) / page.height;
			} else {
				region.u2 = (x + width) / page.width;
				region.v2 = (y + height) / page.height;
			}
			region.x = x;
			region.y = y;
			region.width = Math.abs(width);
			region.height = Math.abs(height);

			if (reader.readTuple(tuple) == 4) { // split is optional
				region.splits = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];

				if (reader.readTuple(tuple) == 4) { // pad is optional, but only present with splits
					region.pads = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];

					reader.readTuple(tuple);
				}
			}

			region.originalWidth = parseInt(tuple[0]);
			region.originalHeight = parseInt(tuple[1]);

			reader.readTuple(tuple);
			region.offsetX = parseInt(tuple[0]);
			region.offsetY = parseInt(tuple[1]);

			region.index = parseInt(reader.readValue());

			this.regions.push(region);
		}
	}
};
spine.Atlas.prototype = {
	findRegion: function (name) {
		var regions = this.regions;
		for (var i = 0, n = regions.length; i < n; i++)
			if (regions[i].name == name) return regions[i];
		return null;
	},
	dispose: function () {
		var pages = this.pages;
		for (var i = 0, n = pages.length; i < n; i++)
			this.textureLoader.unload(pages[i].rendererObject);
	},
	updateUVs: function (page) {
		var regions = this.regions;
		for (var i = 0, n = regions.length; i < n; i++) {
			var region = regions[i];
			if (region.page != page) continue;
			region.u = region.x / page.width;
			region.v = region.y / page.height;
			if (region.rotate) {
				region.u2 = (region.x + region.height) / page.width;
				region.v2 = (region.y + region.width) / page.height;
			} else {
				region.u2 = (region.x + region.width) / page.width;
				region.v2 = (region.y + region.height) / page.height;
			}
		}
	}
};

spine.Atlas.Format = {
	alpha: 0,
	intensity: 1,
	luminanceAlpha: 2,
	rgb565: 3,
	rgba4444: 4,
	rgb888: 5,
	rgba8888: 6
};

spine.Atlas.TextureFilter = {
	nearest: 0,
	linear: 1,
	mipMap: 2,
	mipMapNearestNearest: 3,
	mipMapLinearNearest: 4,
	mipMapNearestLinear: 5,
	mipMapLinearLinear: 6
};

spine.Atlas.TextureWrap = {
	mirroredRepeat: 0,
	clampToEdge: 1,
	repeat: 2
};

spine.AtlasPage = function () {};
spine.AtlasPage.prototype = {
	name: null,
	format: null,
	minFilter: null,
	magFilter: null,
	uWrap: null,
	vWrap: null,
	rendererObject: null,
	width: 0,
	height: 0
};

spine.AtlasRegion = function () {};
spine.AtlasRegion.prototype = {
	page: null,
	name: null,
	x: 0, y: 0,
	width: 0, height: 0,
	u: 0, v: 0, u2: 0, v2: 0,
	offsetX: 0, offsetY: 0,
	originalWidth: 0, originalHeight: 0,
	index: 0,
	rotate: false,
	splits: null,
	pads: null,
};

spine.AtlasReader = function (text) {
	this.lines = text.split(/\r\n|\r|\n/);
};
spine.AtlasReader.prototype = {
	index: 0,
	trim: function (value) {
		return value.replace(/^\s+|\s+$/g, "");
	},
	readLine: function () {
		if (this.index >= this.lines.length) return null;
		return this.lines[this.index++];
	},
	readValue: function () {
		var line = this.readLine();
		var colon = line.indexOf(":");
		if (colon == -1) throw "Invalid line: " + line;
		return this.trim(line.substring(colon + 1));
	},
	/** Returns the number of tuple values read (2 or 4). */
	readTuple: function (tuple) {
		var line = this.readLine();
		var colon = line.indexOf(":");
		if (colon == -1) throw "Invalid line: " + line;
		var i = 0, lastMatch= colon + 1;
		for (; i < 3; i++) {
			var comma = line.indexOf(",", lastMatch);
			if (comma == -1) {
				if (i == 0) throw "Invalid line: " + line;
				break;
			}
			tuple[i] = this.trim(line.substr(lastMatch, comma - lastMatch));
			lastMatch = comma + 1;
		}
		tuple[i] = this.trim(line.substring(lastMatch));
		return i + 1;
	}
};

spine.AtlasAttachmentLoader = function (atlas) {
	this.atlas = atlas;
};
spine.AtlasAttachmentLoader.prototype = {
	newAttachment: function (skin, type, name) {
		switch (type) {
		case spine.AttachmentType.boundingbox:
			return new spine.BoundingBoxAttachment(name);
		case spine.AttachmentType.region:
			var region = this.atlas.findRegion(name);
			if (!region) throw "Region not found in atlas: " + name + " (" + type + ")";
			var attachment = new spine.RegionAttachment();
			attachment.rendererObject = region;
			attachment.setUVs(region.u, region.v, region.u2, region.v2, region.rotate);
			attachment.regionOffsetX = region.offsetX;
			attachment.regionOffsetY = region.offsetY;
			attachment.regionWidth = region.width;
			attachment.regionHeight = region.height;
			attachment.regionOriginalWidth = region.originalWidth;
			attachment.regionOriginalHeight = region.originalHeight;
			return attachment;
		}
		throw "Unknown attachment type: " + type;
	}
};

spine.SkeletonBounds = function () {
	this.polygonPool = [];
	this.polygons = [];
	this.boundingBoxes = [];
};
spine.SkeletonBounds.prototype = {
	minX: 0, minY: 0, maxX: 0, maxY: 0,
	update: function (skeleton, updateAabb) {
		var slots = skeleton.slots;
		var slotCount = slots.length;
		var x = skeleton.x, y = skeleton.y;
		var boundingBoxes = this.boundingBoxes;
		var polygonPool = this.polygonPool;
		var polygons = this.polygons;

		boundingBoxes.length = 0;
		for (var i = 0, n = polygons.length; i < n; i++)
			polygonPool.push(polygons[i]);
		polygons.length = 0;

		for (var i = 0; i < slotCount; i++) {
			var slot = slots[i];
			var boundingBox = slot.attachment;
			if (boundingBox.type != spine.AttachmentType.boundingBox) continue;
			boundingBoxes.push(boundingBox);

			var poolCount = polygonPool.length;
			if (poolCount > 0) {
				polygon = polygonPool[poolCount - 1];
				polygonPool.splice(poolCount - 1, 1);
			} else
				polygon = [];
			polygons.push(polygon);

			polygon.length = boundingBox.vertices.length;
			boundingBox.computeWorldVertices(x, y, slot.bone, polygon);
		}

		if (updateAabb) this.aabbCompute();
	},
	aabbCompute: function () {
		var polygons = this.polygons;
		var minX = Number.MAX_VALUE, minY = Number.MAX_VALUE, maxX = Number.MIN_VALUE, maxY = Number.MIN_VALUE;
		for (var i = 0, n = polygons.length; i < n; i++) {
			var vertices = polygons[i];
			for (var ii = 0, nn = vertices.length; ii < nn; ii += 2) {
				var x = vertices[ii];
				var y = vertices[ii + 1];
				minX = Math.min(minX, x);
				minY = Math.min(minY, y);
				maxX = Math.max(maxX, x);
				maxY = Math.max(maxY, y);
			}
		}
		this.minX = minX;
		this.minY = minY;
		this.maxX = maxX;
		this.maxY = maxY;
	},
	/** Returns true if the axis aligned bounding box contains the point. */
	aabbContainsPoint: function (x, y) {
		return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;
	},
	/** Returns true if the axis aligned bounding box intersects the line segment. */
	aabbIntersectsSegment: function (x1, y1, x2, y2) {
		var minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;
		if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))
			return false;
		var m = (y2 - y1) / (x2 - x1);
		var y = m * (minX - x1) + y1;
		if (y > minY && y < maxY) return true;
		y = m * (maxX - x1) + y1;
		if (y > minY && y < maxY) return true;
		var x = (minY - y1) / m + x1;
		if (x > minX && x < maxX) return true;
		x = (maxY - y1) / m + x1;
		if (x > minX && x < maxX) return true;
		return false;
	},
	/** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */
	aabbIntersectsSkeleton: function (bounds) {
		return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;
	},
	/** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more
	 * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. */
	containsPoint: function (x, y) {
		var polygons = this.polygons;
		for (var i = 0, n = polygons.length; i < n; i++)
			if (this.polygonContainsPoint(polygons[i], x, y)) return this.boundingBoxes[i];
		return null;
	},
	/** Returns the first bounding box attachment that contains the line segment, or null. When doing many checks, it is usually
	 * more efficient to only call this method if {@link #aabbIntersectsSegment(float, float, float, float)} returns true. */
	intersectsSegment: function (x1, y1, x2, y2) {
		var polygons = this.polygons;
		for (var i = 0, n = polygons.length; i < n; i++)
			if (polygons[i].intersectsSegment(x1, y1, x2, y2)) return boundingBoxes[i];
		return null;
	},
	/** Returns true if the polygon contains the point. */
	polygonContainsPoint: function (polygon, x, y) {
		var nn = polygon.length;
		var prevIndex = nn - 2;
		var inside = false;
		for (var ii = 0; ii < nn; ii += 2) {
			var vertexY = polygon[ii + 1];
			var prevY = polygon[prevIndex + 1];
			if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {
				var vertexX = polygon[ii];
				if (vertexX + (y - vertexY) / (prevY - vertexY) * (polygon[prevIndex] - vertexX) < x) inside = !inside;
			}
			prevIndex = ii;
		}
		return inside;
	},
	/** Returns true if the polygon contains the line segment. */
	intersectsSegment: function (polygon, x1, y1, x2, y2) {
		var nn = polygon.length;
		var width12 = x1 - x2, height12 = y1 - y2;
		var det1 = x1 * y2 - y1 * x2;
		var x3 = polygon[nn - 2], y3 = polygon[nn - 1];
		for (var ii = 0; ii < nn; ii += 2) {
			var x4 = polygon[ii], y4 = polygon[ii + 1];
			var det2 = x3 * y4 - y3 * x4;
			var width34 = x3 - x4, height34 = y3 - y4;
			var det3 = width12 * height34 - height12 * width34;
			var x = (det1 * width34 - width12 * det2) / det3;
			if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {
				var y = (det1 * height34 - height12 * det2) / det3;
				if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;
			}
			x3 = x4;
			y3 = y4;
		}
		return false;
	},
	getPolygon: function (attachment) {
		var index = this.boundingBoxes.indexOf(attachment);
		return index == -1 ? null : this.polygons[index];
	},
	getWidth: function () {
		return this.maxX - this.minX;
	},
	getHeight: function () {
		return this.maxY - this.minY;
	}
};
/**
 * Created with JetBrains WebStorm.
 * User: Apple
 * Date: 23.07.13
 * Time: 22:43
 * To change this template use File | Settings | File Templates.
 */
var Clock = function (targetfps) {

    this.targetfps = targetfps || 60

    /** Member startTime will remain fixed at its integer
     millisecond value returned by Date.now(). Will always
     be equal to the time the clock was started */
    this.startTime = Date.now();

    /** Member ms is updated by tick() to a integer value reprsenting
     the number of milliseconds between the epoch (January 1, 1970)
     and the current date and time of the system. */
    this.ms = this.startTime;
    this.last = this.startTime;  /** millis at last call to tick() */
    this.time = 0;               /** ms in floating point seconds not millis */

    /** Member dt is updated by tick() to an integer value representing
     the number of milliseconds since the last call to tick(). */
    this.dt = 0;
    this.delta = 0; /** dt in floating point seconds not millis */

    /** Member fps is updated by tick() to a floating point value representing
     frames per second, updated and averaged approximately once per second */
    this.fps = 0.0;

    /** Member frameCount is updated to an integer value representing the
     total number of calls to tick() since the clock was created. */
    this.frameCount = 0;

    /** The frameCounter member is a flag you can turn off if you don't need to
     calculate the frameCount or do the average FPS calculation every second */
    this.frameCounter = true;

    /** Private globals needed to calculcate/average fps over eachs second */
    var timeToUpdate = 0;
    var framesToUpdate = 0;

    /************************************************************************************
     The tick() method updates ALL the Clock members, which should only
     be read from and never written to manually. It is recommended that
     tick() is called from a callback loop using requestAnimationFrame

     Learn more: http://paulirish.com/2011/requestanimationframe-for-smart-animating/
     *************************************************************************************/
    this.tick = function () {
        /** This is a new frame with it's very own unique number */

        if (this.frameCounter) this.frameCount++;

        /** Set the private currentTime variable */
        this.ms = Date.now();

        /** Update time delta and immediately set last time to
         be as accurate as possible in our timings. */
        this.dt = this.ms - this.last;
        this.last = this.ms;

        /** Calculate floating-point delta and increment time member */
//        this.delta = 0.001 * this.dt;
//        this.time += this.delta;
        this.delta = this.dt / (1000 / this.targetfps);
        this.time += 0.001 * this.dt;

        /** Calculate private temp variables for fps calculation */
        if (this.frameCounter) {
            timeToUpdate += this.dt;
            framesToUpdate++;
            if (timeToUpdate > 1000) {
                this.fps = Math.round((framesToUpdate * 1000) / timeToUpdate);
                framesToUpdate = 0;
                timeToUpdate = 0;
            }
        }
    }
}// string functions

function loadString(path) {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", path, false);
    xhr.send(null);
    if ((xhr.status == 200) || (xhr.status == 0)) return xhr.responseText;
    return "";
}

String.prototype.ltrim = function (clist) {
    if (clist) return this.replace(new RegExp('^[' + clist + ']+'), '')
    return this.replace(/^\s+/, '')
}
String.prototype.rtrim = function (clist) {
    if (clist) return this.replace(new RegExp('[' + clist + ']+$'), '')
    return this.replace(/\s+$/, '')
}
String.prototype.trim = function (clist) {
    if (clist) return this.ltrim(clist).rtrim(clist);
    return this.ltrim().rtrim();
}
String.prototype.startsWith = function (str) {
    return !this.indexOf(str);
}/**
 * @description
 *
 * A CanvasRenderer with WebGL and Canvas 2D fallback would be really nice ;o)
 * How to implement all the different classes....?
 *
 *
 * @class CG.CanvasRenderer
 * @extend CG.Class
 */


CG.Class.extend('CanvasRenderer', {
    /**
     * @method init
     * @constructor
     * @return {*}
     */
    init: function (canvas) {

        //TODO switch from translate, rotate, scale to transform?

        //TODO the renderer recognizes the canvas features WebGL/Canvas

        //TODO the renderer creates the canvas element

        return this
    },
    /**
     * @description central draw method for all objects that draws to the canvas
     * @method draw
     * @param {object} renderObject the object to render
     */
    draw: function (renderObject) {
        Game.b_ctx.save()


        switch (renderObject.instanceOf) {


            case "Sprite":
            case "Button":
            case "Particle":

                Game.b_ctx.globalAlpha = renderObject.alpha
                Game.b_ctx.transform(1, 0, 0, 1, renderObject.position.x, renderObject.position.y)
                if (renderObject.atlasimage) {
                    Game.b_ctx.rotate((renderObject.rotation - renderObject.imagerotation) * CG.Const_PI_180)
                    Game.b_ctx.drawImage(renderObject.image, renderObject.xoffset, renderObject.yoffset, renderObject.cutwidth, renderObject.cutheight, 0 - renderObject.xhandle, 0 - renderObject.yhandle, renderObject.cutwidth * renderObject.xscale, renderObject.cutheight * renderObject.yscale)
                } else {
                    Game.b_ctx.rotate(renderObject.rotation * CG.Const_PI_180)
                    Game.b_ctx.drawImage(renderObject.image, 0 - renderObject.xhandle, 0 - renderObject.yhandle, renderObject.image.width * renderObject.xscale, renderObject.image.height * renderObject.yscale)
                }
                break;

            case "SpineAnimation":

                Game.b_ctx.globalAlpha = renderObject.alpha

                Game.b_ctx.transform(renderObject.transform.m[0], renderObject.transform.m[1], renderObject.transform.m[2], renderObject.transform.m[3], renderObject.transform.m[4], renderObject.transform.m[5])

                Game.b_ctx.drawImage(renderObject.image, renderObject.xoffset, renderObject.yoffset, renderObject.cutwidth, renderObject.cutheight, renderObject.xpos, renderObject.ypos, renderObject.cutwidth * renderObject.xscale, renderObject.cutheight * renderObject.yscale)
                break;

            case "Animation":

                Game.b_ctx.globalAlpha = renderObject.alpha
                Game.b_ctx.transform(1, 0, 0, 1, renderObject.position.x, renderObject.position.y)
                if (renderObject.frames == 1) {
                    Game.b_ctx.drawImage(renderObject.image, renderObject.position.x, renderObject.position.y, renderObject.image.width * renderObject.xscale, renderObject.image.height * renderObject.yscale)
                }
                else {
                    renderObject.fx = renderObject.currentframe * renderObject.width

                    if ((renderObject.fx / renderObject.image.width) > 0) {
                        renderObject.fx = renderObject.fx % renderObject.image.width
                    }
                    renderObject.fy = Math.floor(renderObject.width * renderObject.currentframe / renderObject.image.width) * renderObject.height

                    Game.b_ctx.rotate(renderObject.rotation * CG.Const_PI_180)
                    try {
                        Game.b_ctx.drawImage(renderObject.image, renderObject.fx, renderObject.fy, renderObject.width, renderObject.height, 0 - renderObject.xhandle, 0 - renderObject.yhandle, renderObject.width * renderObject.xscale, renderObject.height * renderObject.yscale)
                    } catch (e) {

                    }
                }
                break;

            case "Font":

                for (var i = 0, l = renderObject.text.length; i < l; i++) {
                    var charCode = renderObject.text.charCodeAt(i)
                    try {
                        Game.b_ctx.drawImage(
                            renderObject.atlas,
                            renderObject.x[charCode],
                            renderObject.y[charCode],
                            renderObject.width[charCode],
                            renderObject.height[charCode],
                            renderObject.currentX,
                            renderObject.currentY + renderObject.yoff[charCode],
                            renderObject.width[charCode],
                            renderObject.height[charCode]
                        )
                    } catch (e) {
                        //console.log("drawText error: " + e)
                    }
                    renderObject.currentX += renderObject.xadv[charCode]
                }
                break;


            case "Bitmap":

                Game.b_ctx.drawImage(renderObject.bitmap_canvas, renderObject.x, renderObject.y)
                break;


            case "Map":

                Game.b_ctx.globalAlpha = renderObject.layers[renderObject.layer].opacity
                Game.b_ctx.transform(1, 0, 0, 1, renderObject.rx, renderObject.ry)

                if (renderObject.orientation == 'orthogonal') {

                    try {
                        Game.b_ctx.drawImage(renderObject.atlas, renderObject.cx, renderObject.cy, renderObject.tilewidth, renderObject.tileheight, renderObject.sx, renderObject.sy, renderObject.tilewidth * renderObject.xscale, renderObject.tileheight * renderObject.yscale)
                    } catch (e) {
                    }

                } else if (renderObject.orientation == 'isometric') {

                    try {
                        Game.b_ctx.drawImage(renderObject.atlas, renderObject.cx, renderObject.cy, renderObject.tilewidth, renderObject.tileset.tileheight, renderObject.sx, renderObject.sy, renderObject.tilewidth * renderObject.xscale, renderObject.tileset.tileheight * renderObject.yscale)
                    } catch (e) {

                    }

                }

                break;

            case "B2DEntity":
            case "B2DCircle":
            case "B2DRectangle":
            case "B2DPolygon":
            case "B2DBridge":
            case "B2DRope":

                Game.b_ctx.globalAlpha = renderObject.alpha
                Game.b_ctx.transform(1, 0, 0, 1, renderObject.body.GetPosition().x * renderObject.scale, renderObject.body.GetPosition().y * renderObject.scale)
                if (renderObject.atlasimage) {
                    Game.b_ctx.rotate((renderObject.body.GetAngleRadians() - renderObject.imagerotation))
                    Game.b_ctx.drawImage(renderObject.image, renderObject.xoffset, renderObject.yoffset, renderObject.cutwidth, renderObject.cutheight, 0 - renderObject.xhandle, 0 - renderObject.yhandle, renderObject.cutwidth, renderObject.cutheight)
                } else {
                    Game.b_ctx.rotate(renderObject.body.GetAngleRadians())
                    Game.b_ctx.drawImage(renderObject.image, 0 - renderObject.xhandle, 0 - renderObject.yhandle, renderObject.image.width, renderObject.image.height)
                }
                break;

        }

        Game.b_ctx.restore()
    }
})


/*

 Pixi renderer

 context.setTransform(

 transform[0],
 transform[3],
 transform[1],
 transform[4],
 transform[2],
 transform[5]

 );

 context.drawImage(displayObject.texture.baseTexture.source,
 frame.x,
 frame.y,
 frame.width,
 frame.height,
 (displayObject.anchor.x) * -frame.width,
 (displayObject.anchor.y) * -frame.height,
 frame.width,
 frame.height);






 Pixi Displayobject



 *
 * Updates the object transform for rendering
 *
 * @method updateTransform
 * @private
 *
 PIXI.DisplayObject.prototype.updateTransform = function()
 {
 // TODO OPTIMIZE THIS!! with dirty
 if(this.rotation !== this.rotationCache)
 {
 this.rotationCache = this.rotation;
 this._sr =  Math.sin(this.rotation);
 this._cr =  Math.cos(this.rotation);
 }

 var localTransform = this.localTransform;
 var parentTransform = this.parent.worldTransform;
 var worldTransform = this.worldTransform;
 //console.log(localTransform)
 localTransform[0] = this._cr * this.scale.x;
 localTransform[1] = -this._sr * this.scale.y
 localTransform[3] = this._sr * this.scale.x;
 localTransform[4] = this._cr * this.scale.y;

 // TODO --> do we even need a local matrix???

 var px = this.pivot.x;
 var py = this.pivot.y;

 // Cache the matrix values (makes for huge speed increases!)
 var a00 = localTransform[0], a01 = localTransform[1], a02 = this.position.x - localTransform[0] * px - py * localTransform[1],
 a10 = localTransform[3], a11 = localTransform[4], a12 = this.position.y - localTransform[4] * py - px * localTransform[3],

 b00 = parentTransform[0], b01 = parentTransform[1], b02 = parentTransform[2],
 b10 = parentTransform[3], b11 = parentTransform[4], b12 = parentTransform[5];

 localTransform[2] = a02
 localTransform[5] = a12

 worldTransform[0] = b00 * a00 + b01 * a10;
 worldTransform[1] = b00 * a01 + b01 * a11;
 worldTransform[2] = b00 * a02 + b01 * a12 + b02;

 worldTransform[3] = b10 * a00 + b11 * a10;
 worldTransform[4] = b10 * a01 + b11 * a11;
 worldTransform[5] = b10 * a02 + b11 * a12 + b12;

 // because we are using affine transformation, we can optimise the matrix concatenation process.. wooo!
 // mat3.multiply(this.localTransform, this.parent.worldTransform, this.worldTransform);
 this.worldAlpha = this.alpha * this.parent.worldAlpha;

 this.vcount = PIXI.visibleCount;

 }






 *//**
 * @description
 *
 * CG.Delta not really used at the moment ;o)
 *
 * @class CG.Delta
 * @extends Class
 *
 */


CG.Class.extend('Delta', {
    /**
     * @method init
     * @constructor
     * @param fps {Number}
     */
    init: function (fps) {
        /**
         * @property targetfps
         * @type {Number}
         */
        this.targetfps = fps
        /**
         * @property currenttime
         * @type {Number}
         */
        this.currenttime = 0
        /**
         * @property lasttime
         * @type {Number}
         */
        this.lasttime = Date.now()
        /**
         * @property elapsedtime
         * @type {Number}
         */
        this.elapsedtime = 0
        /**
         * @property frametime
         * @type {Number}
         */
        this.frametime = 0
        /**
         * @property delta
         * @type {Number}
         */
        this.delta = 0
        /**
         * @property fps
         * @type {Number}
         */
        this.fps = 0
    },

    update: function () {
        var delta = (Date.now() - this.lasttime) / 1000
        this.fps = 1 / delta
        this.lasttime = Date.now()
    },
    getDelta: function () {
        return this.delta
    },
    getFPS: function () {
        return this.fps
    }
})


/**
 * @description
 *
 * CG.Entity the base class of Cangaja
 *
 * @class CG.Entity
 * @extends CG.Class
 */

CG.Class.extend('Entity', {
    /**
     * Options:
     * name {string}
     * position {CG.Point}
     *
     @example
        var e = new CG.Entity({
           name: 'player',
           position: new CG.Point(100,100)
         })
     *
     * @constructor
     * @method init
     * @param options {Object} the name of the Entity
     */
    init: function (options) {

        CG._extend(this, {
            name: '',
            position: new CG.Point(0, 0),
            /**
             @description visibility option
             @property visible {boolean}
             */
            visible: true,
            /**
             @description Transform object for matrix transformation
             @property transform {Transform}
             */
            transform: new Transform(),
            /**
             @property width {Number}
             */
            width: 0,
            /**
             @property height {Number}
             */
            height: 0,
            /**
             @property dragable {boolean}
             */
            dragable: true,
            /**
             @property rotation {Number}
             */
            rotation: 0,
            /**
             @property xscale {Number}
             */
            xscale: 1,
            /**
             @property xhandle {Number}
             */
            xhandle: 0,
            /**
             @property yscale {Number}
             */
            yscale: 1,
            /**
             @property yhandle {Number}
             */
            yhandle: 0,
            /**
             @property hover {boolean}
             */
            hover: false,
            /**
             @property boundingradius {Number}
             */
            boundingradius: 0,     //radius for circular collision bounds
            /**
             @property mapcollision {boolean}
             */
            mapcollision: false
        })

        if (options) {
            CG._extend(this, options)
        }
        return this
    },
    update: function () {
    },
    updateMatrix: function () {
        this.transform.reset()
        this.transform.translate(this.position.x, this.position.y)
        this.transform.rotate(this.rotation * CG.Const_PI_180)
        this.transform.scale(this.xscale, this.yscale)
    },
    draw: function () {
        throw {
            name: 'Entity Error',
            message: 'Subclass has no draw method.'
        }
    },
    /**
     * @description initialize image for object. for now => sprite, particle, buffer, bitmap and button use it
     * @method setImage
     * @param {image} image image path, image or atlasimage
     */
    setImage: function (image) {
        this.atlasimage = false
        if (image) {
            if (image instanceof CG.AtlasImage) {
                //AtlasImage from MediaAsset
                this.image = Game.asset.getImageByName(image.atlasname)
                this.imagerotation = image.rotation //|| 0
                this.xoffset = image.xoffset
                this.yoffset = image.yoffset
                this.width = image.width
                this.height = image.height
                this.atlasimage = true
                if (this.imagerotation !== 0) {
                    this.cutwidth = image.height
                    this.cutheight = image.width
                    this.xhandle = this.height / 2
                    this.yhandle = this.width / 2
                } else {
                    this.cutwidth = image.width
                    this.cutheight = image.height
                    this.xhandle = this.width / 2
                    this.yhandle = this.height / 2
                }
            } else if (typeof image == 'string' && image != '') {
                //path to image
                this.image = new Image()
                this.image.src = image
                this.image.onload = function () {
                    this.width = this.image.width
                    this.height = this.image.height
                    this.xhandle = this.width / 2
                    this.yhandle = this.height / 2
                }
            } else {
                //image from MediaAsset
                this.image = image
                this.width = this.image.width
                this.height = this.image.height
                this.xhandle = this.width / 2
                this.yhandle = this.height / 2
            }
        }
    },
    /**
     * @description returns the bounds of rotated rectangle
     * @method AABB
     * @return {object} returns the calculated bounds
     */
    AABB: function () {
        //http://willperone.net/Code/coderr.php
        var a = this.rotation * CG.Const_PI_180,
            s = Math.sin(a),
            c = Math.cos(a)

        if (s < 0) s = -s
        if (c < 0) c = -c
        return {
            bw: this.height * this.xscale * s + this.width * this.yscale * c,
            bh: this.height * this.xscale * c + this.width * this.yscale * s
        }
    },
    /**
     * @description checks click inside of the rectangle, supports rotation
     * @method ifClicked
     * @return {true/false}
     */
    ifClicked: function () {
        if (CG.mousedown && this.clickable) {
            var dx = CG.mouse.x - this.position.x,
                dy = CG.mouse.y - this.position.y,
                h1 = Math.sqrt(dx * dx + dy * dy),
                currA = Math.atan2(dy, dx),
                newA = currA - (this.rotation * CG.Const_PI_180),
                x2 = Math.cos(newA) * h1,
                y2 = Math.sin(newA) * h1

            if (x2 > -0.5 * (this.width * this.xscale) &&
                x2 < 0.5 * (this.width * this.xscale) &&
                y2 > -0.5 * (this.height * this.yscale) &&
                y2 < 0.5 * (this.height * this.yscale)) {
                this.clicked = true
                CG.mousedown = false
            } else {
                this.clicked = false
            }
        }
    },
    /**
     * @description checks if the mouse/pointer is over the rectangle
     * @method ifMouseOver
     */
    ifMouseOver: function () {
        var dx = CG.mouse.x - this.position.x,
            dy = CG.mouse.y - this.position.y,
            h1 = Math.sqrt(dx * dx + dy * dy),
            currA = Math.atan2(dy, dx),
            newA = currA - (this.rotation * CG.Const_PI_180),
            x2 = Math.cos(newA) * h1,
            y2 = Math.sin(newA) * h1

        if (x2 > -0.5 * (this.width * this.xscale) &&
            x2 < 0.5 * (this.width * this.xscale) &&
            y2 > -0.5 * (this.height * this.yscale) &&
            y2 < 0.5 * (this.height * this.yscale)) {
            this.hover = true
        } else {
            this.hover = false
        }
    },
    /**
     * @description checks if there is a collision of the given objects to this object http://devmag.org.za/2009/04/13/basic-collision-detection-in-2d-part-1/
     * @method checkCollision
     * @param objects {array} a array of objects to check for collision => Sprites, Animations, MapAreas
     * @param callback {callback} what to do after collision?
     */
    checkCollision: function (objects, callback) {
        objects.forEach(function (obj, index) {
                if (obj.className == 'MapArea') {
                    if ((this.position.y + this.AABB().bh / 2) >= obj.bound.y &&
                        this.position.y - this.AABB().bh / 2 <= (obj.bound.y + obj.bound.height) &&
                        (this.position.x + this.AABB().bw / 2) >= obj.bound.x &&
                        this.position.x - this.AABB().bw / 2 <= (obj.bound.x + obj.bound.width )) {
                        if (obj.type === 'outer') {

                            w = 0.5 * (this.width + obj.bound.width)
                            h = 0.5 * (this.height + obj.bound.height)
                            dx = this.position.x - (obj.bound.width / 2 + obj.bound.x)
                            dy = this.position.y - (obj.bound.height / 2 + obj.bound.y)

                            if (Math.abs(dx) <= w && Math.abs(dy) <= h) {
                                /* collision! */
                                wy = w * dy;
                                hx = h * dx;

                                if (wy > hx) {
                                    if (wy > -hx) {
                                        direction = 'bottom'
                                        overlap = ((this.position.y - this.AABB().bh / 2) - (obj.bound.y + obj.bound.height)) >> 0
                                    } else {
                                        direction = 'left'
                                        overlap = ((this.position.x + this.AABB().bw / 2) - obj.bound.x) >> 0
                                    }
                                } else {
                                    if (wy > -hx) {
                                        direction = 'right'
                                        overlap = ((this.position.x - this.AABB().bw / 2) - (obj.bound.x + obj.bound.width)) >> 0
                                    } else {
                                        direction = 'top'
                                        overlap = ((this.position.y + this.AABB().bh / 2) - obj.bound.y) >> 0
                                    }
                                }
                            }

                            collision = {
                                overlap: overlap,
                                direction: direction
                            }
                            //callback arguments: this => the sprite, obj => the maparea if needed, collision => {collison direction, offset}
                            callback(this, obj, collision)
                        }
                    }
                }
                else if (this.boundingradius > 0 && obj.boundingradius > 0) {
                    //check boundingradius for circuar collision
                    distx = this.position.x - obj.position.x
                    disty = this.position.y - obj.position.y
                    dist = Math.sqrt((distx * distx) + (disty * disty))
                    if (dist <= (this.boundingradius / 2 * this.xscale + obj.boundingradius / 2 * obj.yscale)) {
                        collision = false //dummy
                        callback(this, obj, collision)
                    }
                }
                else {
                    //if boundingradius is 0, fallback to bounding collision
                    if ((this.position.y + this.AABB().bh / 2) >= obj.position.y - obj.AABB().bh / 2 &&
                        this.position.y - this.AABB().bh / 2 <= (obj.position.y + obj.AABB().bh / 2) &&
                        (this.position.x + this.AABB().bw / 2) >= obj.position.x - obj.AABB().bw / 2 &&
                        this.position.x - this.AABB().bw / 2 <= (obj.position.x + obj.AABB().bw / 2)) {

                        w = 0.5 * (this.width + obj.width)
                        h = 0.5 * (this.height + obj.height)
                        dx = this.position.x - obj.position.x
                        dy = this.position.y - obj.position.y

                        if (Math.abs(dx) <= w && Math.abs(dy) <= h) {
                            /* collision! */
                            wy = w * dy;
                            hx = h * dx;

                            if (wy > hx) {
                                if (wy > -hx) {
                                    direction = 'bottom'
                                    overlap = ((this.position.y - this.AABB().bh / 2) - (obj.position.y - obj.AABB().bh / 2)) >> 0
                                } else {
                                    direction = 'left'
                                    overlap = ((this.position.x + this.AABB().bw / 2) - (obj.position.x + obj.AABB().bw / 2)) >> 0
                                }
                            } else {
                                if (wy > -hx) {
                                    direction = 'right'
                                    overlap = ((this.position.x - this.AABB().bw / 2) - (obj.position.x - obj.AABB().bw / 2)) >> 0
                                } else {
                                    direction = 'top'
                                    overlap = ((this.position.y + this.AABB().bh / 2) - (obj.position.y + obj.AABB().bh / 2)) >> 0
                                }
                            }
                        }

                        collision = {
                            overlap: overlap,
                            direction: direction
                        }

                        callback(this, obj, collision)
                    }
                }
            },
            this
        )
        return this
    }
})


/**
 * @description
 *
 * CG.Point
 *
 * @class CG.Point
 * @extends CG.Class
 */
CG.Class.extend('Point', {
    /**
     * @constructor
     * @method init
     * @param x {Number} the x value of the point
     * @param y {Number} the y value of the point
     */
    init:function (x, y) {
        /**
         @property x {Number}
         */
        this.x = x || 0
        /**
         @property y {Number}
         */
        this.y = y || 0
    }
})


/**
 * @description
 *
 * CG.Vector
 *
 * @class CG.Vector
 * @extends CG.Point
 */
CG.Point.extend('Vector', {
    /**
     * @constructor
     * @method init
     * @param x {Number} the x position
     * @param y {Number} the y position
     * @param z {Number} the z position
     */
    init:function (x, y, z) {
        this._super(this, x, y)
        /**
         @property z {Number}
         */
        this.z = z || 0
    }
})



/**
 * @description
 *
 * CG.Bound is used at different places in the Cangaja FW.
 *
 * @class CG.Bound
 * @extends CG.Class
 *
 */
CG.Class.extend('Bound', {
    /**
     * Options:
     * x {number}
     * y {number}
     * width {number}
     * height {number}
     *
     @example
     var b = new CG.Bound({
           x: 0,
           y: 0,
           width: 120,
           height: 120
         })
     *
     * @constructor
     * @method init
     * @param options {object}
     * @return {*}
     */
    init: function (options) {
        CG._extend(this, {
            /**
             * @property x
             * @type {Number}
             */
            x: 0,
            /**
             * @property y
             * @type {Number}
             */
            y: 0,
            /**
             * @property width
             * @type {Number}
             */
            width: 0,
            /**
             * @property height
             * @type {Number}
             */
            height: 0
        })

        if (options) {
            CG._extend(this, options)
        }
        return this
    },

    /**
     * @method setName
     * @param {string} name of the bounding box
     * @return {*}
     */
    setName: function (name) {
        this.name = name
        return this
    }
})


/**
 * @description
 *
 * CG.Buffer for separate canvas rendering/buffering
 * @TODO to be removed?
 *
 * @class CG.Buffer
 * @extends CG.Class
 *
 */
CG.Class.extend('Buffer', {
    /**
     * @constructor
     * @method init
     * @param width {Number} width of the buffer
     * @param height {Number} height of the buffer
     * @return {*}
     */
    init:function (width, height) {
        /**
         * @property b_canvas
         * @type {HTMLElement}
         */
        this.b_canvas = document.createElement('canvas')

        /**
         * @property b_canvas.width
         * @type {*}
         */
        this.b_canvas.width = width
        /**
         * @property b_canvas.height
         * @type {*}
         */
        this.b_canvas.height = height

        /**
         * @property b_ctx
         * @type {CanvasRenderingContext2D}
         */
        this.b_ctx = this.b_canvas.getContext('2d')
        return this
    }
})


/**
 * @description
 *
 * CG.Sprite
 *
 * @class CG.Sprite
 * @extends CG.Entity
 */
CG.Entity.extend('Sprite', {
    /**
     * Options:
     * image {string} imgpath, image object or atlasimage object to use
     * position: {CG.Point}
     *
     @example
     var s = new CG.Sprite({
           image: '../images/demo.png',
           position: new CG.Point(200,200)
         })
     *
     * @method init
     * @constructor
     * @param options {object}
     * @return {*}
     */
    init:function (options) {
        this._super()
        this.instanceOf = 'Sprite'

        if (options) {
            CG._extend(this, options)
            this.setImage(this.image)
        }

        /**
         @property bound {CG.Bound}
         */
        this.bound = Game.bound     //global bounds of game
        /**
         @property diffpoint {CG.Point}
         */
        this.diffpoint = new CG.Point(this.bound.x, this.bound.y)  //store diffpoint if bound is moving

        /**
         @property xspeed {Number}
         */
        this.xspeed = 0 //xspeed of the sprite
        /**
         @property yspeed {Number}
         */
        this.yspeed = 0
        /**
         @property boundsMode {false/string}
         */
        this.boundsMode = false // false, bounce or slide
        /**
         @property rotationspeed {integer/float}
         */
        this.rotationspeed = 0
        /**
         @property alpha {float}
         */
        this.alpha = 1
        /**
         @property followobject {boolean/object}
         */
        this.followobject = false   //object to follow
        /**
         @property followspeed {boolean/integer}
         */
        this.followspeed = false    //followspeed for follower in pixel, has prio over followsteps
        /**
         @property followsteps {boolean/integer}
         */
        this.followsteps = false    //followsteps between follower and target

        /**
         @property attachedobject {boolean}
         */
        this.attachedobject = false //attached object
        /**
         @property offsetx {Number}
         */
        this.offsetx = 0            //offset x for attached object
        /**
         @property offsety {Number}
         */
        this.offsety = 0            //offset y for attached object
        return this
    },
    update:function () {
        this.ifClicked()
        this.ifMouseOver()
        this.ifAttached()

        if (this.followobject) {
            this.follow()
        }

        this.position.x += this.xspeed
        this.position.y += this.yspeed
        this.rotation += this.rotationspeed
        this.xhandle = (this.width * this.xscale / 2)
        this.yhandle = (this.height * this.yscale / 2)

        if (this.boundsMode) {
            this.checkBound()
        }
        this.updateDiff()
        this.updateMatrix()
    },
    draw:function () {

        Game.renderer.draw(this);

    },

    /**
     * @description Checks the bound if a boundMode (bounce or slide) is set
     * @method checkBound
     */
    checkBound:function () {
        switch (this.boundsMode) {
            case 'bounce':
                if (this.position.x > ( this.bound.width - this.xhandle + this.bound.x )) {
                    this.position.x = this.bound.width - this.xhandle + this.bound.x
                    this.xspeed = this.xspeed * -1
                }
                else if (this.position.x < this.bound.x + this.xhandle) {
                    this.position.x = this.bound.x + this.xhandle
                    this.xspeed = this.xspeed * -1
                }
                if (this.position.y > ( this.bound.height - this.yhandle + this.bound.y )) {
                    this.position.y = this.bound.height - this.yhandle + this.bound.y
                    this.yspeed = this.yspeed * -1
                }
                else if (this.position.y < this.bound.y + this.yhandle) {
                    this.position.y = this.bound.y + this.yhandle
                    this.yspeed = this.yspeed * -1
                }
                break
            case 'slide':
                if (this.position.x > ( this.bound.width + this.xhandle + this.bound.x )) {
                    this.position.x = ( this.bound.x - this.xhandle )
                }
                else if (this.position.x < this.bound.x - this.xhandle) {
                    this.position.x = this.bound.x + this.bound.width + this.xhandle
                }
                if (this.position.y > (this.bound.height + this.yhandle + this.bound.y)) {
                    this.position.y = (this.bound.y - this.yhandle)
                }
                else if (this.position.y < this.bound.y - this.yhandle) {
                    this.position.y = this.bound.height + this.yhandle + this.bound.y
                }
                break
            default:
                break
        }
    },

    /**
     * @description calculate offset if bound is moving
     * @method updateDiff
     */
    updateDiff:function () {
        if (this.diffpoint.x !== this.bound.x) {
            this.position.x += this.bound.x - this.diffpoint.x
        }
        if (this.diffpoint.y !== this.bound.y) {
            this.position.y += this.bound.y - this.diffpoint.y
        }
        this.diffpoint.x = this.bound.x
        this.diffpoint.y = this.bound.y
    },
    /**
     * @description is there an attached element, this sprite will follow it depending on followspeed or followsteps it follows different
     * @method follow
     */
    follow:function () {
        if (this.followspeed) {
            //constant follow speed between objects
            angl = Math.atan2(this.followobject.position.x - this.position.x, this.followobject.position.y - this.position.y) * CG.Const_180_PI
            xs = this.followspeed * Math.sin(angl * CG.Const_PI_180)
            ys = this.followspeed * Math.cos(angl * CG.Const_PI_180)

            this.xspeed = xs
            this.yspeed = ys
            this.rotation = angl * -1

        } else if (this.followsteps) {
            //constant steps between objetcs
            angl = Math.atan2(this.followobject.position.x - this.position.x, this.followobject.position.y - this.position.y) * CG.Const_180_PI
            this.rotation = angl * -1
            if (this.followobject.position.x != this.position.x) {
                distx = this.followobject.position.x - this.position.x
                this.xspeed = distx / this.followsteps //>> 0
            } else {
                this.xspeed = 0
            }
            if (this.followobject.position.y != this.position.y) {
                disty = this.followobject.position.y - this.position.y
                this.yspeed = disty / this.followsteps //>> 0
            } else {
                this.yspeed = 0
            }
        }
    },

    /**
     * @description set the bound of the sprite
     * @method setBound
     * @param bound {CG.Bound} the bound
     */
    setBound:function (bound) {
        this.bound = bound
        return this
    },


    /**
     * @description if there is a attached object get its position
     * @method ifAttached
     */
    ifAttached:function () {
        if (this.attachedobject != false) {
            this.attachedobject.position._x = this.attachedobject.position.x = (this.position.x + this.offsetx)
            this.attachedobject.position._y = this.attachedobject.position.y = (this.position.y + this.offsety)
        }
    },

    /**
     * @description attach a reference of the given object to this object
     * @method attachObject
     */
    attachObject:function (obj) {
        this.attachedobject = obj
        return this
    },

    /**
     * @description removes the attached object reference
     * @method removeAttachedObject
     */
    removeAttachedObject:function () {
        this.attachedobject = null
        return this
    },

    /**
     * @description set the x offset of the attached object to this object
     * @method setAttachedOffsetX
     */
    setAttachedOffsetX:function (offsetx) {
        this.offsetx = offsetx
        return this
    },

    /**
     * @description set the y offset of the attached object to this object
     * @method setAttachedOffsetY
     */
    setAttachedOffsetY:function (offsety) {
        this.offsety = offsety
        return this
    }
})



/**
 * @description
 *
 * CG.SpineAnimation - this class is a little wrapper for spine animations (http://esotericsoftware.com). The implementation is not perfect at the moment
 * and is on early stages. There is a lot of stuff that could be implemented: boundingbox collision, eventhandling, box2d support
 *
 * @class CG.SpineAnimation
 * @extends CG.Entity
 *
 *
 * TODO
 * Boundingbox collision see example here:
 * https://github.com/EsotericSoftware/spine-runtimes/blob/master/spine-libgdx/test/com/esotericsoftware/spine/AnimationStateTest.java
 *
 *
 * Eventhandler see example here:
 * https://github.com/EsotericSoftware/spine-runtimes/blob/master/spine-libgdx/test/com/esotericsoftware/spine/SkeletonTest.java
 *
 *
 * Box2d support see example here:
 * https://github.com/EsotericSoftware/spine-runtimes/blob/master/spine-libgdx/test/com/esotericsoftware/spine/Box2DExample.java
 * http://www.esotericsoftware.com/forum/viewtopic.php?f=3&t=1394&p=6691&hilit=skeletonbounds#p6691
 */
CG.Entity.extend('SpineAnimation', {
    /**
     * Options:
     * spinejson {string} Spine json animation file
     * spineatlas {string} Spine atlas file (libGDX)
     * position {CG.Point}
     * scale {number}
     * callback {function}
     *
     @example
     var sa = new CG.SpineAnimation({
           spinejson: this.asset.getJsonByName('spinosaurus-json'),
           spineatlas: this.asset.getTextByName('spinosaurus-atlas'),
           position: new CG.Point(10,10),
           scale: 1,
           callback: function (spineObject) {
//              spineObject.skeleton.setSkinByName("goblingirl");
                spineObject.skeleton.setSlotsToSetupPose();
                spineObject.state.setAnimationByName(0, "animation", true);
            }
         })
     *
     * @constructor
     * @method init
     * @param options {object}
     */
    init: function (options) {
        this._super()
        this.instanceOf = 'SpineAnimation'
        self = this

        if (options){
            CG._extend(this, options)
        }

        this.lastTime = Date.now()

        /**
         * @description initial position for the animation. later position changes at the moment with: obj.skeleton.getRootBone().x and obj.skeleton.getRootBone().y. maybe a TODO for a method ;o)
         * @property skeletonposition
         * @type {CG.Point}
         */
        this.skeletonposition = this.position || new CG.Point(0, 0)

        /**
         * @description spine bone xscale
         * @property xscale
         * @type {Number}
         */
        this.xscale = 1

        /**
         * @description spine bone yscale
         * @property yscale
         * @type {Number}
         */
        this.yscale = 1

        /**
         * @property scale
         * @type {Number}
         */
        this.scale = this.scale || 1

        /**
         * @property vertices
         * @type {Array}
         */
        this.vertices = []

        /**
         * @description counter for the spine image preloader
         * @property textureCount
         * @type {Number}
         */
        this.textureCount = 0

        /**
         * @description data from generated atlas text file. at the moment only the libGDX Format is supported from the spine-js runtime.
         * @property spineAtlasData
         * @type {String}
         */
        if (this.spineatlas.type == 'text') {
            this.spineAtlasData = this.spineatlas.data   //text data from mediaasset object
            console.log('spine atlas: text (libGDX) used')
        } else if (this.spineatlas.type == 'json') {
            this.spineAtlasData = this.spineatlas.src    //pure json text for spine atlas loader?
            console.log('spine atlas: json')
            throw 'json format is not supported by spine-js runtime?'
        } else {
            throw 'check your atlas file format?'
        }

        /**
         * @description spine animation json data loaded and parsed thru MediaAsset.
         * @property spineJsonData
         * @type {Object}
         */
        this.spineJsonData = this.spinejson.data

        /**
         * @description this is used for a callback for custom spine initialization.
         * @property initCustom
         * @type {Object}
         */
        this.initCustom = this.callback

        /**
         * @description this is used for a callback for custom animation configuration.
         * @property spineAtlas
         * @type {Object}
         */
        this.spineAtlas = new spine.Atlas(this.spineAtlasData, {
            load: function (page, path) {
                this.textureCount++
                var image = new Image()
                image.onload = function () {
                    page.rendererObject = image
                    page.width = image.width
                    page.height = image.height
                    self.spineAtlas.updateUVs(page)
                    this.textureCount--
                }
                image.onerror = function () {
                    throw "error: atlas image not loaded! " + path
                }
                image.src = 'media/spine/' + path
            },
            unload: function (texture) {
            }
        });

        this.waitForTextures();
    },
    /**
     * @method waitForTextures
     */
    waitForTextures: function () {
        if (!this.textureCount) {
            this.initSkeleton()
        } else {
            setTimeout(this.waitForTextures, 100)
        }
    },
    /**
     * @description initialises the animation (skeleton, stateData,. ,.) after preloading and calls the callback for custom animation configuration (.setSkinByName(), .setAnimationByName(),. ,.).
     * @method initSkeleton
     */
    initSkeleton: function () {
        /**
         * @property skeletonJson
         * @type {spine.SkeletonJson}
         */
        this.skeletonJson = new spine.SkeletonJson(new spine.AtlasAttachmentLoader(self.spineAtlas))
        this.skeletonJson.scale = this.scale    //experimental scale

        /**
         * @property spineJsonData
         * @type {Object}
         */
        if (typeof this.spineJsonData === 'object') {
            this.skeletonData = this.skeletonJson.readSkeletonData(this.spineJsonData)
        } else {
            this.skeletonData = this.skeletonJson.readSkeletonData(JSON.parse(this.spineJsonData))
        }

        spine.Bone.yDown = true

        /**
         * @property skeleton
         * @type {spine.Skeleton}
         */
        this.skeleton = new spine.Skeleton(this.skeletonData)
        this.skeleton.getRootBone().x = this.skeletonposition.x || 0
        this.skeleton.getRootBone().y = this.skeletonposition.y || 0   //has spine a another origin (bottom left) than the canvas on y axis?
        this.skeleton.updateWorldTransform()

        /**
         * @property stateData
         * @type {spine.AnimationStateData}
         */
        this.stateData = new spine.AnimationStateData(this.skeletonData)
        /**
         * @property state
         * @type {spine.AnimationState}
         */
        this.state = new spine.AnimationState(this.stateData)

        //callback for custom initialization?
        this.initCustom(this)

        this.state.onEvent = function (trackIndex, event) {
            // alert(trackIndex + " event: " + event.data.name)
        }
    },
    /**
     * @method update
     */
    update: function () {
        var dt = (Date.now() - this.lastTime) / 1000
        this.lastTime = Date.now()

        this.state.update(dt)    // delta
        this.state.apply(this.skeleton)
        this.skeleton.updateWorldTransform()
    },
    /**
     * @description this method loops thru skeleton.drawOrder and renders all attachments of type spine.RegionAttachment.
     * @method draw
     */
    draw: function () {
        var drawOrder = this.skeleton.drawOrder
        for (var i = 0, n = drawOrder.length; i < n; i++) {
            var slot = drawOrder[i]
            var attachment = slot.attachment
            var bone = slot.bone
            if (!(attachment instanceof spine.RegionAttachment)) continue
            attachment.computeVertices(this.skeleton.x, this.skeleton.y, slot.bone, this.vertices)

            try {

                this.alpha = slot.a //get alphe value from slot
                this.position = new CG.Point(this.vertices[2], this.vertices[3])
                this.xscale = bone.worldScaleX //* this.scale
                this.yscale = bone.worldScaleY //* this.scale
                this.rotation = -(bone.worldRotation + attachment.rotation)

                this.updateDiff()
                this.updateMatrix.call(this)

                this.xoffset = attachment.rendererObject.x
                this.yoffset = attachment.rendererObject.y
                this.cutwidth = attachment.width
                this.cutheight = attachment.height
                this.xhandle = this.cutwidth / 2 * this.xscale
                this.yhandle = this.cutheight / 2 * this.yscale
                this.xpos = 0
                this.ypos = 0

                if (this.skeleton.flipX) {

                    this.xscale *= -1
                    this.xpos = this.cutwidth
                    this.rotation *= -1
                }

                if (this.skeleton.flipY) {

                    this.yscale *= -1
                    this.ypos = this.cutheight
                    this.rotation *= -1
                }
                this.imagerotation = 0

                this.image = attachment.rendererObject.page.rendererObject
                this.width = attachment.rendererObject.page.rendererObject.width
                this.height = attachment.rendererObject.page.rendererObject.height

                Game.renderer.draw(this)

            } catch (e) {
//                console.log(e)
//                console.log(attachment)
            }

        }


    },
    /**
     * @method updateDiff
     */
    updateDiff: function () {

    }
})/**
 * @description
 *
 * CG.AtlasImage class. It is needed when using TexturePacker atlas files.
 *
 * @class CG.AtlasImage
 * @extends Class
 */
CG.Class.extend('AtlasImage', {
    /**
     * Options:
     * image {string}
     * xoffset {number}
     * yoffset {number}
     * width {number}
     * height {number}
     *
     @example
     var a = new CG.AtlasImage({
           image: 'menuscreen',
           xoffset: 0,
           yoffset: 0,
           width: 10,
           height: 20
         })
     *
     * @method init
     * @constructor
     * @param options {object}
     */
    init: function (options) {
        CG._extend(this, {

            /**
             * @property source
             * @type {String}
             */
            source: '',
            /**
             * @property atlasimage
             * @type {String}
             */
            atlasimage: '',
            /**
             * @property atlasname
             * @type {String}
             */
            atlasname: '',
            /**
             * @property image
             * @type {*}
             */
            image: '',    //imagepath

            /**
             * @property xoffset
             * @type {Number}
             */
            xoffset: 0,
            /**
             * @property yoffset
             * @type {*}
             */
            yoffset: 0,
            /**
             * @property width
             * @type {Number}
             */
            width: 0,
            /**
             * @property height
             * @type {Number}
             */
            height: 0,
            /**
             * @property rotation
             * @type {Number}
             */
            rotation: 0
        })

        if (options) {
            CG._extend(this, options)
            /**
             * @property name
             * @type {String}
             */
            this.name = this.image.split(/(\\|\/)/g).pop().split('.')[0] //image name only for name
        }

    }
})/**
 *  @description
 *  CG.AtlasTexturePacker class supports loading xml and json files from . . . TexturePacker ;o)
 *  No trimming at the moment, keep TexturePacker settings simple! The rotation option of TexturePacker
 *  will be dropped in future releases!
 *  AtlasTexturePacker parses xml/json and generates new CG.AtlasImage objects in the MediaAsset manager.
 *  These atlasimages are only handled within Sprite, Particle and Button class.
 *
 *  @class CG.AtlasTexturePacker
 *  @extends Class
 */
CG.Class.extend('AtlasTexturePacker', {
    /**
     * @constructor
     * @method init
     * @return {*}
     */
    init: function () {
        //ejecta and cocoonjs has no DOMParser!
        if (typeof ejecta === 'undefined' && !navigator.isCocoonJS) {
            this.xml = ''
            this.xmlDoc = ''
            this.parser = new DOMParser() || {}
        }
        /**
         * @property imagename
         * @type {String}
         */
        this.imagename = ''
        /**
         * @property width
         * @type {Number}
         */
        this.width = 0
        /**
         * @property height
         * @type {Number}
         */
        this.height = 0
        /**
         * @property atlasimages
         * @type {Array}
         */
        this.atlasimages = []
        return this
    },
    /**
     * @description load a xml file from TexturePacker
     * @method loadXml
     * @param {string/object} xmlfile path or mediaasset object with data of TexturePacker xml
     * @return {*}
     */
    loadXml: function (xmlfile) {
        //from asset
        if (typeof xmlfile == 'string') {
            this.xml = loadString(xmlfile)
        } else {
            this.xml = xmlfile.data
        }

        this.xmlDoc = this.parser.parseFromString(this.xml, 'text/xml')

        this.imagename = this.xmlDoc.getElementsByTagName('TextureAtlas')[0].getAttribute('imagePath')
        this.width = parseInt(this.xmlDoc.getElementsByTagName('TextureAtlas')[0].getAttribute('width'))
        this.height = parseInt(this.xmlDoc.getElementsByTagName('TextureAtlas')[0].getAttribute('height'))

        var sprites = this.xmlDoc.getElementsByTagName('sprite')
        for (var i = 0, l = sprites.length; i < l; i++) {
            var atlasimage = new CG.atlasimage({
                image: sprites[i].getAttribute('n'),
                xoffset: parseInt(sprites[i].getAttribute('x')),
                yoffset: parseInt(sprites[i].getAttribute('y')),
                width: parseInt(sprites[i].getAttribute('w')),
                height: parseInt(sprites[i].getAttribute('h'))
            })
            if (sprites[i].getAttribute('r') == 'y') {
                atlasimage.rotation = 90
                console.log('!!! support for rotated images in atlas files would be dropped in future versions !!!')
            }
            atlasimage.atlasimage = this.imagename
            atlasimage.source = 'xml'
            atlasimage.atlasname = this.imagename.split(/(\\|\/)/g).pop().split('.')[0] //image name only for name

            this.atlasimages.push(atlasimage)
        }
        return this
    },

    /**
     * @description load a json file from TexturePacker
     * @method loadJson
     * @param {string/object} jsonfile path or mediaasset object with data of TexturePacker json
     * @return {*}
     */
    loadJson: function (jsonfile) {
        //from asset
        if (typeof jsonfile == 'string') {
            this.json = JSON.parse(loadString(jsonfile))
        } else {
            this.json = jsonfile.data
        }
        //meta info from json file
        this.imagename = this.json.meta.image
        this.width = this.json.meta.size.w
        this.height = this.json.meta.size.h

        //loop thru all images
        for (var i = 0, l = this.json.frames.length; i < l; i++) {
            var image = this.json.frames[i]
            var atlasimage = new CG.AtlasImage({
                image: image.filename,
                xoffset: image.frame.x,
                yoffset: image.frame.y,
                width: image.frame.w,
                height: image.frame.h
            })
            if (image.rotated === true) {
                atlasimage.rotation = 90
                console.log('!!! support for rotated images in atlas files would be dropped in future versions !!!')
            }
            atlasimage.atlasimage = this.imagename
            atlasimage.source = 'json'
            atlasimage.atlasname = this.imagename.split(/(\\|\/)/g).pop().split('.')[0] //image name only for name

            this.atlasimages.push(atlasimage)
        }
        return this
    },

    /**
     * @description get all TexturePacker images (Use array.push.apply(array, anotherarray) to append to Game.asset)
     * @method getAtlasImages
     * @return {array} returns all atlasimages of TexturePacker file to use with Game.asset
     */
    getAtlasImages: function () {
        return this.atlasimages
    }
})


/**
 * @description
 *
 * CG.Animation extends CG.Sprite and add support for animations ;o) It needs atlas files with fixed framesizes and with following animation frames.
 * For example you can use Timeline FX generated graphics.
 *
 * @class CG.Animation
 * @extends CG.Sprite
 */
CG.Sprite.extend('Animation', {
    /**
     * Options:
     * image {string} imgpath, image object or atlasimage object to use
     * position {CG.Point}
     * startframe {number}
     * endframe {number}
     * width {number}
     * height {number}
     *
     @example
     var s = new CG.Animation({
           image: '../images/demo.png',
           position: new CG.Point(200,200),
           startframe: 5,
           endframe: 6,
           width: 10,
           height: 20
         })
     *
     * @constructor
     * @method init
     * @param options {object}
     * @return {*}
     */
    init: function (options) {
        this._super()
        this.instanceOf = 'Animation'

        if (options) {
            CG._extend(this, options)
//            this.setImage(this.image)
        }

        /**
         @property loop {boolean}
         */
        this.loop = true
        /**
         @property status {Number}
         */
        this.status = 0
        /**
         @property currentframe {Number}
         */
        this.currentframe = 0
        /**
         @property frames {Number}
         */
        this.frames = 0
        /**
         @property startframe {Number}
         */
        this.startframe = this.startframe - 1
        /**
         @property endframe {Number}
         */
        this.endframe = this.endframe - 1
        /**
         @property width {Number}
         */
        /**
         @property height {Number}
         */

        if (this.startframe === undefined && this.endframe === undefined) {
            this.frames = 1
            this.startframe = 0
            this.endframe = 0
        } else {
            this.currentframe = this.startframe - 1
            this.frames = this.endframe - this.startframe + 1
        }

        /**
         @property fx {Number}
         */
        this.fx = 0
        /**
         @property fy {Number}
         */
        this.fy = 0

        /**
         @property delay {Number}
         */
        this.delay = 0
        /**
         @property tempdelay {Number}
         */
        this.tempdelay = 0

        return this
    },
    update: function () {
        //animation specific stuff
        if (this.status == 0) {
            this.tempdelay += 1
            if (this.tempdelay >= this.delay) {
                this.tempdelay = 0
                if (this.frames > 1) {
                    this.currentframe += 1
                    if ((this.currentframe - this.startframe) >= this.frames) {
                        if (this.loop === false) {
                            this.status = 1 //time to say good by, elements would be deleted at the moment
                        } else {
                            this.currentframe = this.startframe
                        }
                    }
                }
            }
        }
        //update all other stuff in the parent class
        this._super()
    },
    draw: function () {

        Game.renderer.draw(this)

    }
})

/**
 * @description
 *
 * CG.Bitmap is a simple bitmap class.
 *
 * @class CG.Bitmap
 * @extends CG.Entity
 *
 */

//@TODO add surface normal function (http://gamedev.tutsplus.com/tutorials/implementation/coding-destructible-pixel-terrain/, http://en.wikipedia.org/wiki/Surface_normal)
//@TODO add a raycast function ?

CG.Entity.extend('Bitmap', {
    /**
     * Options:
     * width {number}
     * height {number}
     *
     @example
     var b = new CG.Bitmap({
           width: 100,
           height: 100
         })

     *
     * @method init
     * @constructor
     * @param options {object}
     * @return {*}
     */
    init: function (options) {
        this.instanceOf = 'Bitmap'

        CG._extend(this, {
            /**
             @property x {Number}
             */
            x: 0,
            /**
             @property y {Number}
             */
            y: 0,
            /**
             @description tolerance for the getSquareValues method
             @property tolerance {Number}
             */
            tolerance: 128

        })

        if (options) {
            CG._extend(this, options)
        }

        /**
         @property bitmap_canvas {Object}
         */
        this.bitmap_canvas = document.createElement('canvas')
        /**
         @property bitmap_ctx {Context}
         */
        this.bitmap_ctx = this.bitmap_canvas.getContext('2d')
        /**
         @property bitmap_ctx.fillStyle {String}
         */
        this.bitmap_ctx.fillStyle = '#000000'
        /**
         @property bitmap_canvas.width {Number}
         */
        this.bitmap_canvas.width = this.width
        /**
         @property bitmap_canvas.height {Number}
         */
        this.bitmap_canvas.height = this.height


        return this
    },
    /**
     * @description
     *
     * Loads an image and draws it to the buffer
     *
     * @method loadImage
     *
     * @param {string, image, atlasimage} imgpath, image object or atlasimage object to use
     */
    loadImage: function (image) {
        this.setImage(image)
        this.drawImageToBuffer()
        return this
    },


    update: function () {
    },

    draw: function () {

        Game.renderer.draw(this)

    },


    /**
     * @method clearBuffer
     */
    clearBuffer: function () {
        this.bitmap_ctx.clearRect(0, 0, this.bitmap_canvas.width, this.bitmap_canvas.height)
        return this
    },

    /**
     * @method drawImageToBuffer
     */
    drawImageToBuffer: function () {
        if (this.image) {
            this.bitmap_ctx.drawImage(this.image, 0, 0)
        }
        return this
    },


    /**
     * @method clearRect
     *
     * @param {Number} x the x position for clearRect
     * @param {Number} y the y position for clearRect
     * @param {Number} width the width for clearRect
     * @param {Number} height the height for clearRect
     */
    clearRect: function (x, y, width, height) {
        this.bitmap_ctx.save()
        this.bitmap_ctx.globalCompositeOperation = 'destination-out'
        this.bitmap_ctx.clearRect(x, y, width, height)
        this.bitmap_ctx.restore()
    },

    /**
     * @method clearCircle
     *
     * @param {Number} x the x position for clearCircle
     * @param {Number} y the y position for clearCircle
     * @param {Number} radius the radius for clearCircle
     */
    clearCircle: function (x, y, radius) {
        this.bitmap_ctx.save()
        this.bitmap_ctx.globalCompositeOperation = 'destination-out'
        this.bitmap_ctx.beginPath()
        this.bitmap_ctx.arc(x, y, radius, 0, 2 * Math.PI, false)
        this.bitmap_ctx.closePath()
        this.bitmap_ctx.fill()
        this.bitmap_ctx.restore()
    },

    /**
     * @method getPixel
     *
     * @param {Number} x the x position for getPixel
     * @param {Number} y the y position for getPixel
     * @returns {imagedata} data from canvas
     */
    getPixel: function (x, y) {
        return this.bitmap_ctx.getImageData(x, y, 1, 1)
    },

    /**
     * @method getPixels
     *
     * @param {Number} x the x position for getPixels
     * @param {Number} y the y position for getPixels
     * @param {Number} width for getPixels
     * @param {Number} height for getPixels
     * @returns {imagedata} data from canvas
     */
    getPixels: function (x, y, width, height) {
        return this.bitmap_ctx.getImageData(x, y, width, height)
    },
    /**
     * @method getPixelAlpha
     *
     * @param x
     * @param y
     * @returns {*}
     */
    getPixelAlpha: function (x, y) {
        return this.bitmap_ctx.getImageData(x, y, 1, 1).data[3]
    },
    /**
     * @method traceContour
     *
     * @description
     * trace the outer contour of an bitmap body clockwise (CW)
     * http://www.emanueleferonato.com/2013/03/01/using-marching-squares-algorithm-to-trace-the-contour-of-an-image/)
     *
     * @returns {Array}
     */
    traceContour: function () {
        var startPoint = this.getStartingPixel()
        var contourVector = []
        if (startPoint) {
            var pX = startPoint.x,
                pY = startPoint.y,
                stepX,
                stepY,
                prevX,
                prevY,
                closedLoop = false

            while (!closedLoop) {
                var squareValue = this.getSquareValue(pX, pY)
                switch (squareValue) {
                    /* going UP with these cases:

                     +---+---+   +---+---+   +---+---+
                     | 1 |   |   | 1 |   |   | 1 |   |
                     +---+---+   +---+---+   +---+---+
                     |   |   |   | 4 |   |   | 4 | 8 |
                     +---+---+  	+---+---+  	+---+---+

                     */
                    case 1 :
                    case 5 :
                    case 13 :
                        stepX = 0;
                        stepY = -1;
                        break;
                    /* going DOWN with these cases:

                     +---+---+   +---+---+   +---+---+
                     |   |   |   |   | 2 |   | 1 | 2 |
                     +---+---+   +---+---+   +---+---+
                     |   | 8 |   |   | 8 |   |   | 8 |
                     +---+---+  	+---+---+  	+---+---+

                     */
                    case 8 :
                    case 10 :
                    case 11 :
                        stepX = 0;
                        stepY = 1;
                        break;
                    /* going LEFT with these cases:

                     +---+---+   +---+---+   +---+---+
                     |   |   |   |   |   |   |   | 2 |
                     +---+---+   +---+---+   +---+---+
                     | 4 |   |   | 4 | 8 |   | 4 | 8 |
                     +---+---+  	+---+---+  	+---+---+

                     */
                    case 4 :
                    case 12 :
                    case 14 :
                        stepX = -1;
                        stepY = 0;
                        break;
                    /* going RIGHT with these cases:

                     +---+---+   +---+---+   +---+---+
                     |   | 2 |   | 1 | 2 |   | 1 | 2 |
                     +---+---+   +---+---+   +---+---+
                     |   |   |   |   |   |   | 4 |   |
                     +---+---+  	+---+---+  	+---+---+

                     */
                    case 2 :
                    case 3 :
                    case 7 :
                        stepX = 1;
                        stepY = 0;
                        break;
                    case 6 :
                        /* special saddle point case 1:

                         +---+---+
                         |   | 2 |
                         +---+---+
                         | 4 |   |
                         +---+---+

                         going LEFT if coming from UP
                         else going RIGHT

                         */
                        if (prevX == 0 && prevY == -1) {
                            stepX = -1;
                            stepY = 0;
                        }
                        else {
                            stepX = 1;
                            stepY = 0;
                        }
                        break;
                    case 9 :
                        /* special saddle point case 2:

                         +---+---+
                         | 1 |   |
                         +---+---+
                         |   | 8 |
                         +---+---+

                         going UP if coming from RIGHT
                         else going DOWN

                         */
                        if (prevX == 1 && prevY == 0) {
                            stepX = 0;
                            stepY = -1;
                        }
                        else {
                            stepX = 0;
                            stepY = 1;
                        }
                        break;
                }
                // moving onto next point
                pX += stepX;
                pY += stepY;
                // saving contour point
                contourVector.push({x: pX, y: pY});
                prevX = stepX;
                prevY = stepY;

                // if we returned to the first point visited, the loop has finished
                if (pX == startPoint.x && pY == startPoint.y) {
                    closedLoop = true;
                }
            }

        }
        return contourVector
    },
    /**
     * @method drawContour
     * @description draws the traced contour for debuging at the moment
     * @param vertices {Array}
     */
    drawContour: function (vertices) {
        this.bitmap_ctx.save()
        for (var i = 0; i < vertices.length; i++) {
            this.bitmap_ctx.fillStyle = '#f00'
            this.bitmap_ctx.fillRect(vertices[i].x, vertices[i].y, 1, 1);
        }
        this.bitmap_ctx.restore()
    },
    /**
     * @method lightenContour
     * @description removes points that doesn't affect much to the visual appearance. the order after ClipperLib.JS.Lighten is counter clockwise (CCW)
     * @param vertices
     * @param tolerance
     * @returns {Array}
     */
    lightenCountur: function (vertices, tolerance) {
        var tolerance = tolerance || 1
        return ClipperLib.JS.Lighten(vertices, tolerance)[0]
    },
    /**
     * @method triangulateContour
     * @param vertices
     * @returns {array.<Triangle>|*|Array}
     */
    triangulateContour: function (vertices) {
        var swctx = new poly2tri.SweepContext(vertices, {cloneArrays: true})
        swctx.triangulate();
        return swctx.getTriangles() || []
    },
    /**
     * @method getStartingPixel
     * @description scanline trace to get the first pixel
     * @returns {Object|false}
     */
    getStartingPixel: function () {
        for (var ys = 0; ys < this.height; ys++) {
            for (var xs = 0; xs < this.width; xs++) {
                if (this.getPixelAlpha(xs, ys) >= this.tolerance) {
                    return {x: xs, y: ys}
                }
            }
        }
        return false
    },
    /**
     * @method getSquareValue
     * @description get four squared pixels to trace a contour
     * @param x
     * @param y
     * @returns {number}
     */
    getSquareValue: function (x, y) {
        var squareValue = 0

        // check upper left pixel
        if (this.getPixelAlpha(x - 1, y - 1) >= this.tolerance) {
            squareValue += 1
        }
        // check upper pixel
        if (this.getPixelAlpha(x, y - 1) >= this.tolerance) {
            squareValue += 2
        }
        // check left pixel
        if (this.getPixelAlpha(x - 1, y) >= this.tolerance) {
            squareValue += 4
        }
        // checking pixel itself
        if (this.getPixelAlpha(x, y) >= this.tolerance) {
            squareValue += 8
        }
        return squareValue
    }
})


/**
 * @description
 *
 * CG.Button represents a simple button class that can handle click, mouseover and callback functionality.
 *
 * @class CG.Button
 * @extends CG.Sprite
 *
 */
CG.Sprite.extend('Button', {
    /**
     * Options:
     * image {string} imgpath, image object or atlasimage object to use
     * position {CG.Point}
     * text {string}
     * font {CG.Font}
     * callback {function}
     *
     @example
     var s = new CG.Button({
           image: '../images/demo.png',
           position: new CG.Point(200,200),
           text: 'MyButton',
           font: heiti,
           callback: callbackFunction
         })
     *
     *
     * @method init
     * @constructor
     * @param options {object}
     * @return {*}
     */
    init: function (options) {
        this._super()
        this.instanceOf = 'Button'

        if (options) {
            CG._extend(this, options)
            this.setImage(this.image)
        }

        /**
         @property font {CG.Font}
         */
        /**
         @property text {string}
         */
        /**
         @property callback {callback}
         */
        /**
         @property clickable {boolean}
         */
        this.clickable = true
        /**
         @property clicked {boolean}
         */
        this.clicked = false

        return this
    },
    update: function () {
        this.ifClicked()
        this.ifMouseOver()

        this.xhandle = (this.width * this.xscale / 2)
        this.yhandle = (this.height * this.yscale / 2)

        if (this.clicked) {
            if (this.callback) {
                this.clicked = false
                this.callback(this)
            }
        }
        this.updateDiff()
        this.updateMatrix()
    },
    draw: function () {
        if (this.visible == true) {

            Game.renderer.draw(this)

            this.font.drawText(this.text, this.position.x - (this.font.getTextWidth(this.text) / 2 >> 0), this.position.y - ((this.font.getFontSize() / 2) >> 0))


        }
    }
})


/**
 * @description
 *
 * CG.Menu
 *
 * @class CG.Menu
 * @extends CG.Class
 *
 */
CG.Class.extend('Menu', {
    /**
     * Options:
     * x {number}
     * y {number}
     * margin {number}
     *
     @example
     var m = new CG.Menu({
           x: 100,
           y: 100,
           margin: 10
         })
     *
     *
     * @method init
     * @constructor
     * @param options {object}
     * @return {*}
     */
    init: function (options) {
        CG._extend(this, {
            /**
             * @property x
             * @type {Number}
             */
            x: 0,
            /**
             * @property y
             * @type {Number}
             */
            y: 0,
            /**
             * @property margin
             * @type {Number}
             */
            margin: 0,
            /**
             * @property step
             * @type {*}
             */
            step: 0,
            /**
             * @property buttons
             * @type {Array}
             */
            buttons: []
        })

        if (options) {
            CG._extend(this, options)
            this.step = this.y
        }
        return this
    },
    /**
     * @method addButton
     *
     * @param {button} button
     */
    addButton: function (button) {
        this.buttons.push(button)
    },
    /**
     * @method update
     */
    update: function () {
        this.buttons.forEach(function (button) {
            button.update()
        })
    },
    /**
     * @method draw
     */
    draw: function () {
        this.buttons.forEach(function (button) {
            button.position.x = this.x
            button.position.y = this.step
            button.draw()
            this.step += button.height
            this.step += this.margin
        }, this)
        this.step = this.y
    }
})


/**
 * @description
 *
 * CG.MediaAsset preloader.
 *
 * @class CG.MediaAsset
 * @extends Class
 *
 */

CG.Class.extend('MediaAsset', {
    /**
     * @method init
     * @constructor
     * @param obj {object} the game object CG.Game
     */
    init:function (obj) {
        /**
         * @property obj
         * @type {CG.Game}
         */
        this.obj = obj
        /**
         * @property ready
         * @type {CG.Game}
         * @protected
         */
        this.ready = false
        /**
         * @property progress
         * @type {Number}
         */
        this.progress = 0

        /**
         * @property images
         * @type {Array}
         */
        this.images = []
        this.currimage = 0

        /**
         * @property xmls
         * @type {Array}
         */
        this.xmls = []
        this.currxml = 0

        /**
         * @property jsons
         * @type {Array}
         */
        this.jsons = []
        this.currjson = 0

        /**
         * @property texts
         * @type {Array}
         */
        this.texts = []
        this.currtext = 0

        /**
         * @property fonts
         * @type {Array}
         */
        this.fonts = []
        this.currfont = 0

        this.assetcount = 0
        this.assetcurrent = 0

        //progress
        /**
         * @property width
         * @type {Number}
         */
        this.width = 300
        /**
         * @property height
         * @type {Number}
         */
        this.height = 20
        /**
         * @property radius
         * @type {Number}
         */
        this.radius = 10

        /**
         * @property linewidth
         * @type {Number}
         */
        this.linewidth = 8
        /**
         * @property bordercolor
         * @type {String}
         */
        this.bordercolor = 'white'
        /**
         * @property progresscolor
         * @type {String}
         */
        this.progresscolor = 'red'
        /**
         * @property shadowcolor
         * @type {String}
         */
        this.shadowcolor = '#222'
        /**
         * @property shadowblur
         * @type {Number}
         */
        this.shadowblur = 6
        /**
         * @property shadowoffsetx
         * @type {Number}
         */
        this.shadowoffsetx = 2
        /**
         * @property shadowoffsety
         * @type {Number}
         */
        this.shadowoffsety = 2

//return this
    },
    /**
     * @method addImage
     * @param path
     * @param name
     * @return {*}
     */
    addImage:function (path, name) {
        this.assetcount += 1
        this.images.push({
            name:name || '', //optional
            path:path,
            img:new Image(),
            type:'image'
        })
        return this
    },
    /**
     * @method addFont
     * @param path
     * @param name
     * @return {*}
     */
    addFont:function (path, name) {
        this.assetcount += 1
        this.fonts.push({
            name:name || '', //optional
            path:path,
            data:'',
            type:'font'
        })
        return this
    },
    /**
     * @method addXml
     * @param path
     * @param name
     * @return {*}
     */
    addXml:function (path, name) {
        this.assetcount += 1
        this.xmls.push({
            name:name || '', //optional
            path:path,
            data:'',
            type:'xml'
        })
        return this
    },
    /**
     * @method addJson
     * @param path
     * @param name
     * @return {*}
     */
    addJson:function (path, name) {
        this.assetcount += 1
        this.jsons.push({
            name:name || '', //optional
            path:path,
            data:'',
            src:'',
            type:'json'
        })
        return this
    },
    /**
     * @method addText
     * @param path
     * @param name
     * @return {*}
     */
    addText:function (path, name) {
        this.assetcount += 1
        this.texts.push({
            name:name || '', //optional
            path:path,
            data:'',
            type:'text'
        })
        return this
    },
    /**
     * @method getImageByName
     * @param name
     * @return {*}
     */
    getImageByName:function (name) {
        for (var i = 0, l = this.images.length; i < l; i++) {
            if (this.images[i].name == name) {
                if (this.images[i] instanceof CG.AtlasImage) {
                    return this.images[i]
                } else {
                    return this.images[i].img
                }
            }
        }
        throw new MediaAssetException('No image with this name in asset.')
    },
    /**
     * @method getImagesByName
     * @param name
     * @return {*}
     */
    getImagesByName:function (name) {
        var names = []
        for (var i = 0, l = this.images.length; i < l; i++) {
            if (this.images[i].name == name) {
                if (this.images[i] instanceof CG.AtlasImage) {
                    names.push(this.images[i])
                } else {
                    names.push(this.images[i].img)
                }
            }
        }
        if (names.length === 0) {
            throw new MediaAssetException('No image with this name in asset: ' + name)
        }
        return names
    },
    /**
     * @method getFontByName
     * @param name
     * @return {*}
     */
    getFontByName:function (name) {
        for (var i = 0, l = this.fonts.length; i < l; i++) {
            if (this.fonts[i].name == name) {
                return this.fonts[i]
            }
        }
        throw new MediaAssetException('No font with this name in asset: ' + name)
    },
    /**
     * @method getXmlByName
     * @param name
     * @return {*}
     */
    getXmlByName:function (name) {
        for (var i = 0, l = this.xmls.length; i < l; i++) {
            if (this.xmls[i].name == name) {
                return this.xmls[i]
            }
        }
        throw new MediaAssetException('No XML with this name in asset: ' + name)
    },
    /**
     * @method getJsonByName
     * @param name
     * @return {*}
     */
    getJsonByName:function (name) {
        for (var i = 0, l = this.jsons.length; i < l; i++) {
            if (this.jsons[i].name == name) {
                return this.jsons[i]
            }
        }
        throw new MediaAssetException('No JSON with this name in asset: ' + name)
    },
    /**
     * @method getTextByName
     * @param name
     * @return {*}
     */
    getTextByName:function (name) {
        for (var i = 0, l = this.jsons.length; i < l; i++) {
            if (this.texts[i].name == name) {
                return this.texts[i]
            }
        }
        throw new MediaAssetException('No Text with this name in asset: ' + name)
    },
    /**
     * @method startPreLoad
     */
    startPreLoad:function () {

        this.progress = 100 / this.assetcount * this.assetcurrent
        this.progressScreen()

        if (this.currimage < this.images.length) {
            //BUG last image is not preloading
            this.images[this.currimage].img.onload = function () {
                console.log('image loaded: ' + this.images[this.currimage].path)
                this.currimage += 1
                this.assetcurrent += 1
                this.startPreLoad()
            }.bind(this)
            this.images[this.currimage].img.onerror = function () {
                throw new MediaAssetException('error, cant load image: ' + this.images[this.currimage].path)
            }.bind(this)
            this.images[this.currimage].img.src = this.images[this.currimage].path
        } else if (this.currfont < this.fonts.length) {
            this.fonts[this.currfont].data = loadString(this.fonts[this.currfont].path)
            console.log('font loaded: ' + this.fonts[this.currfont].path)
            this.currfont += 1
            this.assetcurrent += 1
            this.startPreLoad()
        } else if (this.currxml < this.xmls.length) {
            this.xmls[this.currxml].data = loadString(this.xmls[this.currxml].path)
            console.log('xml loaded: ' + this.xmls[this.currxml].path)
            this.currxml += 1
            this.assetcurrent += 1
            this.startPreLoad()
        } else if (this.currjson < this.jsons.length) {
            var src = loadString(this.jsons[this.currjson].path)
            this.jsons[this.currjson].data = JSON.parse(src)
            this.jsons[this.currjson].src = src
            console.log('json loaded: ' + this.jsons[this.currjson].path)
            this.currjson += 1
            this.assetcurrent += 1
            this.startPreLoad()
        } else if (this.currtext < this.texts.length) {
            this.texts[this.currtext].data = loadString(this.texts[this.currtext].path)
            console.log('text loaded: ' + this.texts[this.currtext].path)
            this.currtext += 1
            this.assetcurrent += 1
            this.startPreLoad()
        } else if (this.currimage == this.images.length &&
            this.assetcount == this.assetcurrent) {
            this.ready = true
            this.obj.create()
        }
    },
    /**
     * @method progressScreen
     * @description render a progress screen to the canvas
     */
    progressScreen:function () {
        var x = (this.obj.bound.width - this.width) / 2
        var y = (this.obj.bound.height - this.height) / 2
//        if (this.image) {
//            Game.ctx.drawImage(this.image, 0, 0, this.image.width, this.image.height)
//        } else {
//            Game.ctx.clearRect(0, 0, Game.bound.width, Game.bound.height)
//        }
        this.obj.ctx.save()

        this.obj.ctx.fillStyle = this.progresscolor;
        this.obj.ctx.fillRect((this.obj.bound.width - this.width) / 2, (this.obj.bound.height - this.height) / 2, this.width / 100 * this.progress, this.height);

        this.obj.ctx.strokeStyle = this.bordercolor
        this.obj.ctx.shadowColor = this.shadowcolor
        this.obj.ctx.shadowBlur = this.shadowblur
        this.obj.ctx.shadowOffsetX = this.shadowoffsetx
        this.obj.ctx.shadowOffsetY = this.shadowoffsety
        this.obj.ctx.beginPath();
        this.obj.ctx.moveTo(x + this.radius, y);
        this.obj.ctx.lineTo(x + this.width - (1 * this.radius), y)
        this.obj.ctx.arcTo(x + this.width, y, x + this.width, y + this.radius, this.radius)
        this.obj.ctx.arcTo(x + this.width, this.radius * 2 + y, x + this.width - (1 * this.radius), this.radius * 2 + y, this.radius)
        this.obj.ctx.lineTo(x + this.radius, 2 * this.radius + y)
        this.obj.ctx.arcTo(x, 2 * this.radius + y, x, y, this.radius)
        this.obj.ctx.arcTo(x, y, 2 * this.radius + x, y, this.radius)
        this.obj.ctx.lineWidth = this.linewidth
        this.obj.ctx.stroke()
        this.obj.ctx.restore()
    }
})

function MediaAssetException(msg) {
    this.msg = msg
    console.log(this.msg)
}



/**
 * @description
 *
 * CG.Font supports loading and drawing font files (EZ GUI Text format) from Glyph Designer,
 * (Hiero works also but need some modifications of the exported files)
 @example
 //create font object
 small = new CG.Font().loadFont(Game.asset.getFontByName('small'))

 //draw text to canvas
 small.drawText('Foo bar!', xpos, ypos)
 *
 * @class CG.Font
 * @extends CG.Entity
 */
CG.Entity.extend('Font', {
    /**
     * @method init
     * @constructor
     * @return {*}
     */
    init: function () {
        this.instanceOf = 'Font'
        /**
         @property atlas {Image}
         */
        this.atlas = new Image()
        /**
         @property initText {string}
         */
        this.fontFile = ''
        /**
         @property chars {Array}
         */
        this.chars = new Array(256)
        /**
         @property x {Array}
         */
        this.x = new Array(256)
        /**
         @property y {Array}
         */
        this.y = new Array(256)
        /**
         @property width {Array}
         */
        this.width = new Array(256)
        /**
         @property height {Array}
         */
        this.height = new Array(256)
        /**
         @property xoff {Array}
         */
        this.xoff = new Array(256)
        /**
         @property yoff {Array}
         */
        this.yoff = new Array(256)
        /**
         @property xadv {Array}
         */
        this.xadv = new Array(256)
        /**
         @property lineHeight {Number}
         */
        this.lineHeight = 0
        /**
         @property face {string}
         */
        this.face = ''
        /**
         @property size {Number}
         */
        this.size = 0
        /**
         @property bold {Number}
         */
        this.bold = 0
        /**
         @property italic {Number}
         */
        this.italic = 0

        /**
         @property base {Number}
         */
        this.base = 0
        /**
         @property scaleW {Number}
         */
        this.scaleW = 0
        /**
         @property scaleH {Number}
         */
        this.scaleH = 0
        /**
         @property text {String}
         */
        this.text = ''
        /**
         @property currentX {Number}
         */
        this.currentX = 0
        /**
         @property currentY {Number}
         */
        this.currentY = 0
        return this
    },
    /**
     * @method update
     */
    update: function () {
        throw {
            name: 'Font Error',
            message: 'TODO, not defined yet.'
        }
    },
    /**
     * @method draw
     */
    draw: function () {
        throw {
            name: 'Font Error',
            message: 'TODO, not defined yet.'
        }
    },
    /**
     * @description draw the given text to the canvas
     * @method draw
     * @param text {string} the text to draw
     * @param xpos {Number} the x position
     * @param ypos {Number} the y position
     */
    drawText: function (text, xpos, ypos) {

        this.text = text
        this.currentX = xpos
        this.currentY = ypos

        Game.renderer.draw(this)

    },

    /**
     * @description get the line height of the current font
     * @method getLineHeight
     * @return lineheight {Number}
     */
    getLineHeight: function () {
        return this.lineHeight
    },

    /**
     * @description get the font size of the current font
     * @method getFontSize
     * @return size {Number} font size
     */
    getFontSize: function () {
        return this.size
    },

    /**
     * @description get the width of the given text
     * @method getTextWidth
     * @param text {string} the string to calculate the width
     * @return textwidth {Number}
     */
    getTextWidth: function (text) {
        var textwidth = 0
        var c = 0
        for (var i = 0, l = text.length; i < l; i++) {
            textwidth += this.xadv[text.charCodeAt(i)]
        }
        return textwidth
    },

    /**
     * Options:
     * font {string} path or mediaasset object with data
     *
     @example
     gill = new CG.Font().loadFont({
        font: this.asset.getFontByName('gill')
     })
     *
     * @description loadFont - load and parse the given fontfile
     * @method loadFont
     * @param {object} options
     */
    loadFont: function (options) {
        idnum = 0

        if (options) {
            CG._extend(this, options)
        }

        if (typeof this.font == 'string') {
            this.fontFile = loadString(this.font)
        } else {
            this.fontFile = this.font.data
        }

        var lines = this.fontFile.split('\n')
        for (l in lines) {
            line = lines[l].trim()

            if (line.startsWith('info') || line == '') {
                var infodata = line.split(' ')
                for (i in infodata) {
                    var info = infodata[i]
                    if (info.startsWith('face=')) {
                        var face = info.split("=")
                        this.face = face[1].split('"').join('')
                    }
                    if (info.startsWith('size=')) {
                        var size = info.split("=")
                        this.size = parseInt(size[1])
                    }
                    if (info.startsWith('bold=')) {
                        var bold = info.split("=")
                        this.bold = parseInt(bold[1])
                    }
                    if (info.startsWith('italic=')) {
                        var italic = info.split("=")
                        this.italic = parseInt(italic[1])
                    }
                }
            }
            if (line.startsWith('padding')) {
                continue
            }
            if (line.startsWith('common')) {
                var commondata = line.split(' ')
                for (c in commondata) {
                    var common = commondata[c]
                    if (common.startsWith('lineHeight=')) {
                        var lnh = common.split("=")
                        this.lineHeight = parseInt(lnh[1])
                    }
                    if (common.startsWith('base=')) {
                        var base = common.split("=")
                        this.base = parseInt(base[1])
                    }
                    if (common.startsWith('scaleW=')) {
                        var scaleW = common.split("=")
                        this.scaleW = parseInt(scaleW[1])
                    }
                    if (common.startsWith('scaleH=')) {
                        var scaleH = common.split("=")
                        this.scaleH = parseInt(scaleH[1])
                    }
                }
            }
            if (line.startsWith('page')) {
                var pagedata = line.split(' ')
                for (p in pagedata) {
                    data = pagedata[p]
                    if (data.startsWith('file=')) {
                        var fn = data.split('=')
                        this.atlas.src = 'media/font/' + fn[1].split('"').join('')
                    }

                }
            }
            if (line.startsWith('chars')) {
                continue
            }
            if (line.startsWith('char')) {
                var linedata = line.split(' ')
                for (l in linedata) {
                    ld = linedata[l]
                    if (ld.startsWith('id=')) {
                        var idc = ld.split('=')
                        idnum = parseInt(idc[1])
                    }
                    if (ld.startsWith('x=')) {
                        var xc = ld.split('=')
                        this.x[idnum] = parseInt(xc[1])
                    }
                    if (ld.startsWith('y=')) {
                        var yc = ld.split('=')
                        this.y[idnum] = parseInt(yc[1])
                    }
                    if (ld.startsWith('width=')) {
                        var wc = ld.split('=')
                        this.width[idnum] = parseInt(wc[1])
                    }
                    if (ld.startsWith('height=')) {
                        var hc = ld.split('=')
                        this.height[idnum] = parseInt(hc[1])
                    }
                    if (ld.startsWith('xoffset=')) {
                        var xoc = ld.split('=')
                        this.xoff[idnum] = parseInt(xoc[1])
                    }
                    if (ld.startsWith('yoffset=')) {
                        var yoc = ld.split('=')
                        this.yoff[idnum] = parseInt(yoc[1])
                    }
                    if (ld.startsWith('xadvance=')) {
                        var advc = ld.split('=')
                        this.xadv[idnum] = parseInt(advc[1])
                    }
                }
            }
        }
        return this
    }
})


/**
 * @description
 *
 * Future plans:
 * CG.Text => support for different text drawing modes like textblock, text alignment, text ticker or scroller.
 *
 * @class CG.Text
 * @extends CG.Entity
 */
CG.Entity.extend('Text', {
    /**
     * Options:
     * font {object}
     *
     @example
     var t = new CG.Text({
           font: abdi // the font object (CG.Font) to use
         })
     *
     * @method init
     * @param options
     * @constructor
     * @return {*}
     */

    init: function (options) {
        this.instanceOf = 'Text'

        if (options) {
            CG._extend(this, options)
        }

        /**
         @property font {CG.Font}
         */

        /**
         * @property text {string}
         */
        this.text = ''

        /**
         * @property textcurrent {string}
         */
        this.textcurrent = ''

        /**
         * @property x {number} the x position
         */
        this.x = 0

        /**
         * @property y {number} the y position
         */
        this.y = 0

        /**
         * @property width {number} width of textbox
         */
        this.width = 0

        /**
         * @property height {number} height of textbox
         */
        this.height = 0

        /**
         * @property textAlign {string} alignment of text
         */
        this.textAlign = 'left' //left, right, centered

        return this
    },
    initAsTextblock: function (font) {

        return this
    },
    initAsScroller: function () {

    },
    initAsTicker: function () {

    },
    /**
     * @method setText
     * @param text
     * @returns {*}
     */
    setText: function (text) {
        this.text = text
        return this
    },
    /**
     * @method update
     */
    update: function () {

    },
    /**
     * @method draw
     */
    draw: function () {

    }
})/**
 * @description
 *
 * CG.Director the top instance for CG.Screens, CG.Layers, CG.Sprites and so on in the control hierarchy.
 * Its main purpose is to collect CG.Screens under its hood and support some basic screen fading features.
 @example
 //create top level CG.Director object
 var director = new CG.Director()

 //create a CG.Screen
 var mainscreen = new CG.Screen('mainscreen')

 //create a CG.Layer
 var mainlayer = new CG.Layer('mainlayer')

 //create a demo CG.Sprite
 var demosprite = new CG.Sprite(Game.asset.getImageByName('spritegfx'), new CG.Point(400, 240))

 //add/attach the demo sprite to the layer
 mainlayer.addElement(back)

 //add/attach mainscreen and mainlayer to the director
 director.addScreen(mainscreen.addLayer(mainlayer))

 * @class CG.Director
 * @extends Class
 */
CG.Class.extend('Director', {
    /**
     * @method init
     * @constructor
     * @return {*}
     */
    init: function () {
        CG._extend(this, {
            /**
             * @property screens
             * @type {Array}
             */
            screens: [],
            /**
             * @property activescreen
             * @type {Number}
             */
            activescreen: 0,
            /**
             * @property nextscreen
             * @type {Number}
             */
            nextscreen: 0,
            /**
             * @property duration
             * @type {Number}
             */
            duration: 20,
            /**
             * @property stepx
             * @type {number}
             */
            stepx: 40,
            /**
             * @property stepy
             * @type {number}
             */
            stepy: 30,
            /**
             * @property alpha
             * @type {Number}
             */
            alpha: 0,
            /**
             * @property mode
             * @type {String}
             */
            mode: 'fade',      //fade or scale
            /**
             * @property direction
             * @type {String}
             */
            direction: CG.RIGHT,      //CG.LEFT, CG.RIGHT, CG.UP, CG.DOWN
            /**
             * @property color
             * @type {String}
             */
            color: 'rgb(0,0,0)'
        })
        return this
    },
    /**
     * @method update
     */
    update: function () {
        //handle screen fading
        switch (this.mode) {
            case 'scale':
                if (this.nextscreen != this.activescreen) {
                    this.screens[this.activescreen].xscale -= 0.4 / this.duration
                    this.screens[this.activescreen].yscale -= 0.4 / this.duration
                } else if (this.nextscreen == this.activescreen) {
                    this.screens[this.activescreen].xscale += 0.4 / this.duration
                    this.screens[this.activescreen].yscale += 0.4 / this.duration
                }

                if (this.screens[this.activescreen].xscale >= 1) {
                    this.screens[this.activescreen].xscale = this.screens[this.activescreen].yscale = 1
                    this.screens[this.nextscreen].xscale = this.screens[this.nextscreen].yscale = 1
                }

                if (this.screens[this.activescreen].xscale <= 0) {
                    this.screens[this.activescreen].xscale = this.screens[this.activescreen].yscale = 1
                    this.screens[this.nextscreen].xscale = this.screens[this.nextscreen].yscale = 0
                    this.activescreen = this.nextscreen
                }
                //this.screens[this.nextscreen].update()
                break

            case 'fade':
                // the fade is bound to the alpha value in the draw method
                if (this.nextscreen != this.activescreen && this.alpha < 1) {
                    this.alpha += 1 / this.duration
                } else if (this.nextscreen == this.activescreen && this.alpha != 0) {
                    this.alpha -= 1 / this.duration
                }
                if (this.alpha >= 1) {
                    this.activescreen = this.nextscreen
                    this.alpha = 1
                }
                if (this.alpha < 0) {
                    this.alpha = 0
                }
                break

            case 'slide':
                if (this.nextscreen != this.activescreen) {
                    switch (this.direction) {
                        case CG.UP:
                            this.screens[this.activescreen].position.y -= this.stepy
                            this.screens[this.nextscreen].position.y -= this.stepy
                            if (this.screens[this.nextscreen].position.y < 0) {
                                this.resetScreens()
                                this.activescreen = this.nextscreen
                            }
                            break
                        case CG.DOWN:
                            this.screens[this.activescreen].position.y += this.stepy
                            this.screens[this.nextscreen].position.y += this.stepy
                            if (this.screens[this.nextscreen].position.y > 0) {
                                this.resetScreens()
                                this.activescreen = this.nextscreen
                            }
                            break
                        case CG.LEFT:
                            this.screens[this.activescreen].position.x -= this.stepx
                            this.screens[this.nextscreen].position.x -= this.stepx
                            if (this.screens[this.nextscreen].position.x < 0) {
                                this.resetScreens()
                                this.activescreen = this.nextscreen
                            }
                            break
                        case CG.RIGHT:
                            this.screens[this.activescreen].position.x += this.stepx
                            this.screens[this.nextscreen].position.x += this.stepx
                            if (this.screens[this.nextscreen].position.x > 0) {
                                this.resetScreens()
                                this.activescreen = this.nextscreen
                            }
                            break
                    }
                    //this.screens[this.nextscreen].update()
                }
                break
        }
        this.screens[this.activescreen].update()
    },
    /**
     * @method draw
     */
    draw: function () {
        //draw active screen
        this.screens[this.activescreen].draw()

        //draw nextscreen for slide mode
        if (this.screens[this.nextscreen].position.x != 0 || this.screens[this.nextscreen].position.y != 0) {
            this.screens[this.nextscreen].draw()
        }

        //draw fading layer => why not use the screens itself with alpha without additional rect?
        if (this.alpha > 0) {
            Game.b_ctx.save()
            Game.b_ctx.globalAlpha = this.alpha
            Game.b_ctx.fillStyle = this.color
            Game.b_ctx.fillRect(0, 0, Game.bound.width, Game.bound.height)
            Game.b_ctx.restore()
        }
    },
    /**
     * @method nextScreen
     @example
     //tell the director class to fade to next screen with scale mode
     Game.director.nextScreen('gamescreen', 'scale', 10);

     //tell the director class to fade to next screen
     Game.director.nextScreen('settingsscreen', 'fade', 10);
     *
     * @param {string} screenname to define nextscreen for fading
     * @param {string} mode mode for transition
     * @param {Number} duration the duration for fading
     */
    nextScreen: function (screenname, mode, duration) {
        var nextscreen = this.getIndexOfScreen(screenname)

        if (nextscreen != this.activescreen) {
            this.resetScreens()
            this.mode = mode
            this.duration = duration
            this.stepx = Game.canvas.width / this.duration >> 0
            this.stepy = Game.canvas.height / this.duration >> 0
            this.nextscreen = nextscreen

            if (this.mode === 'scale') {
                this.alpha = 0
            } else if (this.mode === 'fade') {
                // hmm ;o) ?
            } else if (this.mode === 'slide') {
                switch (this.direction) {
                    case CG.UP:
                        this.screens[this.nextscreen].position.y += CG.canvas.height
                        break
                    case CG.DOWN:
                        this.screens[this.nextscreen].position.y -= CG.canvas.height
                        break
                    case CG.LEFT:
                        this.screens[this.nextscreen].position.x += CG.canvas.width
                        break
                    case CG.RIGHT:
                    default:
                        this.screens[this.nextscreen].position.x -= CG.canvas.width
                        break
                }
            }
        }
        return this
    },
    resetScreens: function () {
        this.screens[this.activescreen].position = new CG.Point(0, 0)
        this.screens[this.nextscreen].position = new CG.Point(0, 0)
        return this
    },
    /**
     * @method addScreen
     *
     * @param {CG.Screen} screen to add to the screen list
     */
    addScreen: function (screen) {
        this.screens.push(screen)
        return this
    },
    /**
     * @method getScreenByName
     *
     * @param {string} screenname to find screen by name
     * @return {false/CG.Screen} returns false or the screen object
     */
    getScreenByName: function (screenname) {
        for (var i = 0, l = this.screens.length; i < l; i++) {
            if (this.screens[i].name == screenname) {
                return this.screens[i]
            }
        }
        return false
    },

    /**
     * @method getIndexOfScreen
     *
     * @param {string} screenname to find index of screen in screen array
     * @return {false/Number} return false or index number of the screen
     */
    getIndexOfScreen: function (screenname) {
        for (var i = 0, l = this.screens.length; i < l; i++) {
            if (this.screens[i].name == screenname) {
                return i
            }
        }
        return false
    },

    /**
     * @method getActiveScreenName
     *
     * @return {string} the name of the active screen
     */
    getActiveScreenName: function () {
        return this.screens[this.activescreen].name
    },
    setDirection: function (direction) {
        this.direction = direction
        return this
    }
})/**
 * @description
 *
 * CG.Screen is a child of CG.Director and a container to collect/group CG.Layers and/or CG.B2DWorld
 *
 * @class CG.Screen
 * @extends CG.Class
 *
 * @param {string} screenname the name of the screen
 */
CG.Class.extend('Screen', {
    /**
     * Options:
     * name {string}
     *
     @example
     var s = new CG.Screen({
           name: 'menuscreen'
         })
     *
     * @constructor
     * @method init
     * @param options
     * @return {*}
     */
    init: function (options) {
        CG._extend(this, {
            /**
             * @property name
             * @type {string}
             */
            name: '',
            /**
             * @property position
             * @type {CG.Point}
             */
            position: new CG.Point(0, 0),
            /**
             * @property xscale
             * @type {Number}
             */
            xscale: 1,
            /**
             * @property yscale
             * @type {Number}
             */
            yscale: 1,
            /**
             * @property layers
             * @type {Array}
             */
            layers: []
        })

        if (options) {
            CG._extend(this, options)
        }

        return this
    },
    create: function () {

    },
    /**
     * @method update
     */
    update: function () {
        for (var i = 0, l = this.layers.length; i < l; i++) {
            this.layers[i].update()
        }
    },
    /**
     * @method draw
     */
    draw: function () {
        Game.b_ctx.save()
        if (this.xscale !== 1 || this.yscale !== 1) {
            Game.b_ctx.translate((Game.width - (Game.width * this.xscale)) / 2, (Game.height - (Game.height * this.yscale)) / 2)
            Game.b_ctx.scale(this.xscale, this.yscale)
        } else {
            Game.b_ctx.translate(this.position.x, this.position.y)
        }
        for (var i = 0, l = this.layers.length; i < l; i++) {
            this.layers[i].draw()
        }

        Game.b_ctx.restore()
    },

    /**
     * @description add a CG.Layer object to the layer array
     * @method addLayer
     * @param {layer} layer to add
     */
    addLayer: function (layer) {
        this.layers.push(layer)
        return this
    },

    /**
     * @description find CG.Layer by name
     * @method getLayerByName
     * @param {string} layername find layer by name
     * @return {boolean/layer}
     */
    getLayerByName: function (layername) {
        for (var i = 0, l = this.layers.length; i < l; i++) {
            if (this.layers[i].name == layername) {
                return this.layers[i]
            }
        }
        return false
    }
})


/**
 * @description
 *
 * CG.Layer is a child of CG.Screen and a container to collect/group sprites, buttons, menus, emitters and animations
 *
 * @class CG.Layer
 * @extends CG.Class
 */
CG.Class.extend('Layer', {
    /**
     * Options:
     * name {string}
     *
     @example
     var l = new CG.Layer({
           name: 'layerback'
         })
     *
     * @constructor
     * @method init
     * @param options {object}
     * @return {*}
     */
    init: function (options) {
        CG._extend(this, {
            /**
             * @property name
             * @type {String}
             */
            name: '',
            /**
             * @property visible
             * @type {Boolean}
             */
            visible: true,
            /**
             * @property elements
             * @type {Array}
             */
            elements: [],
            /**
             * @property elementsToDelete
             * @type {Array}
             * @protected
             */
            elementsToDelete: []
        })

        if (options) {
            CG._extend(this, options)
        }

        return this
    },
    /**
     * @method update
     */
    update: function () {
        if (this.visible == true) {
//            this.elements.forEach(function (element, index) {
//                element.update()
//                if (element.status == 1) {
//                    this.elementsToDelete.push(index)
//                }
//            }, this)

            for (var i = 0, l = this.elements.length; i < l; i++) {
                this.elements[i].update()
                if (this.elements[i].status == 1) {
                    this.elementsToDelete.push(this.elements[i])
                }
            }

            if (this.elementsToDelete.length > 0) {
                this._deleteElements()
            }
        }
    },
    /**
     * @method draw
     */
    draw: function () {
        if (this.visible == true) {

            //TODO ? place for CanvasRenderer ?

//            this.elements.forEach(function (element) {
//                element.draw()
//            }, this)


            for (var i = 0, l = this.elements.length; i < l; i++) {
                this.elements[i].draw()
            }


        }
    },
    _deleteElements: function () {
        this.elementsToDelete.reverse()
        this.elementsToDelete.forEach(this._deleteElement, this)
        this.elementsToDelete = []
    },
    _deleteElement: function (elementToDelete) {
        this.elements.splice(elementToDelete, 1)
    },

    /**
     * @description Add new element to the layer. This could be a CG.Sprite, CG.Animation, CG.Button and so on. Every thing that has a update and draw method ;o)
     * @method addElement
     * @param {obj} element to add to elements array
     */
    addElement: function (element) {
        this.elements.push(element)
        return this
    },

    /**
     * @description Find element by name (the first one)
     * @method getElementByName
     * @param {string} elementname name of element to find in element array
     * @return {false/object} returns false or the searched object
     */
    getElementByName: function (elementname) {
        for (var i = 0, l = this.elements.length; i < l; i++) {
            if (this.elements[i].name == elementname) {
                return this.elements[i]
            }
        }
        return false
    },

    /**
     * @description Find elements by name (if they have the same name ;o)
     * @method getElementsByName
     * @param {string} elementname name of element to find in element array
     * @return {array} returns a array of objects
     */
    getElementsByName: function (elementname) {
        elements = []
        for (var i = 0, l = this.elements.length; i < l; i++) {
            if (this.elements[i].name == elementname) {
                elements.push(this.elements[i])
            }
        }
        return elements
    }
})



/**
 * @description
 *
 * CG.MapTileLayer
 *
 * @class CG.MapTileLayer
 * @extends Class
 */
CG.Class.extend('MapTileLayer', {
    /**
     * @constructor
     * @method init
     * @return {*}
     */
    init:function () {
        /**
         * @property width
         * @type {Number}
         */
        this.width = 0
        /**
         * @property height
         * @type {Number}
         */
        this.height = 0
        /**
         * @property visible
         * @type {Boolean}
         */
        this.visible = true
        /**
         * @property opacity
         * @type {Number}
         */
        this.opacity = 1
        /**
         * @property tiles
         * @type {Array}
         */
        this.tiles = []
        return this
    }
})


/**
 * @description
 *
 * CG.MapTileProperties
 *
 * @class CG.MapTileProperties
 * @extends Class
 */
CG.Class.extend('MapTileProperties', {
    /**
     * @method init
     * @constructor
     * @return {*}
     */
    init:function () {
        /**
         * @property animated
         * @type {Boolean}
         */
        this.animated = false
        /**
         * @property animDelay
         * @type {Number}
         */
        this.animDelay = 0
        /**
         * @property animDirection
         * @type {Number}
         */
        this.animDirection = 0 // >0 = forward, <0 = backward, 0 = paused
        /**
         * @property animNext
         * @type {Number}
         */
        this.animNext = 0
        /**
         * @property delayTimer
         * @type {Number}
         */
        this.delayTimer = 0
        return this
    }
})


/**
 * @description
 *
 * CG.MapPoint. Support now for name, gid and x/y-position values. No tilemap properties at the moment.
 *
 * @class CG.MapPoint
 * @extends CG.Class
 *
 */
CG.Class.extend('MapPoint', {
    /**
     * @method init
     * @constructor
     * @param position {point} position point
     * @param mapoffset {point} mapoffset reference to the current map position
     * @param name {string} name of the tile
     * @param gid {Number} gid number of tilemap editor
     * @return {*}
     */
    init:function (position, mapoffset, name, gid) {
        /**
         * @property initposition
         * @type {CG.Point}
         */
        this.initposition = position || new CG.Point(0, 0)
        /**
         * @property mapoffset
         * @type {CG.Point}
         */
        this.mapoffset = mapoffset || new CG.Point(0, 0)
        /**
         * @property gid
         * @type {Number}
         */
        this.gid = gid
        /**
         * @property name
         * @type {*}
         */
        this.name = name
        /**
         * @property position
         * @type {CG.Point}
         */
        this.position = new CG.Point(position.x, position.y) //for reference use
        return this
    },

    update:function () {
        this.position.x = this.initposition.x - this.mapoffset.x
        this.position.y = this.initposition.y - this.mapoffset.y
    }
})


/**
 * @description
 *
 * CG.MapArea. Support now for name and the bound values.
 *
 * @class CG.MapArea
 * @extends CG.Class
 */
CG.Class.extend('MapArea', {
    /**
     * @constructor
     * @method init
     * @param bound {CG.Bound} bound of area
     * @param mapoffset {CG.Point} mapoffset reference to the current map position
     * @param name {string} name of the group
     * @param type {false/string} type (a property) of area for collision detection or what ever ;o)
     * @return {*}
     */
    init:function (bound, mapoffset, name, type) {
        /**
         * @property initbound
         * @type {CG.Bound}
         */
        this.initbound = bound || new CG.Bound(0, 0, 0, 0)
        /**
         * @property mapoffset
         * @type {CG.Point}
         */
        this.mapoffset = mapoffset || new CG.Point(0, 0)
        /**
         * @property name
         * @type {String}
         */
        this.name = name
        /**
         * @property type
         * @type {String}
         */
        this.type = type || false       //false, inner or outer

        /**
         * @property bound
         * @type {CG.Bound}
         */
        this.bound = new CG.Bound(bound.x, bound.y, bound.width, bound.height)
        return this
    },

    update:function () {
        this.bound.x = this.initbound.x - this.mapoffset.x
        this.bound.y = this.initbound.y - this.mapoffset.y
    }
})


/**
 * @description
 *
 * CG.Map supports loading and rendering maps from the editor Tiled.
 * XML and JSON file types are supported.
 * XML => supported tiled encodings are csv and xml (see settings!). base64, base64(gzip) and base64(zlib) are not supported!
 *
 * Supported types of the object layer are:
 * - object/group (rectangle?)
 * - tile element, reference point is bottom/CG.LEFT
 *
 * These object layer types are used to generate Point and Bound objects and can be used to position sprites, what ever in the map.
 *
 * @class CG.Map
 * @extends CG.Entity
 *
 * TODO spacing and margin ?
 * TODO own buffer for drawing => split screen possible?
 * TODO update & draw method 50%
 *
 */
CG.Entity.extend('Map', {
    /**
     * @method init
     * @constructor
     * @param width {Number} width of the map
     * @param height {Number} height of the map
     * @param mapname {string} mapname
     * @return {*}
     */
    init:function (width, height, mapname) {
        this._super(mapname)
        this.instanceOf = 'Map'

        /**
         * @property elements
         * @type {Array}
         */
        this.elements = [] //how handle elements in maps? experimental collision detection at the moment with only one
        //point and areas from tilemap editor
        //using as references for external objects in layers?
        //how to handle the relative position to the position of the map?

        /**
         * @property points
         * @type {Array}
         */
        this.points = [] // position points (tiles) of tilemap editor => position point and type?
        /**
         * @property areas
         * @type {Array}
         */
        this.areas = [] // group objects e.g. area for objects of tilemap editor => bound and type?
        /**
         * @property position
         * @type {CG.Point}
         */
        this.position = new CG.Point(0, 0) // needed as relative point for points and areas
        /**
         * @property changemap
         * @type {String}
         */
        this.changemap = ''
        /**
         * @description
         *
         * If set to true the map is being updated with method updateAnimation.
         * See also method description of updateAnimation!
         *
         * @property animated
         * @type {Boolean}
         */
        this.animated = false //performance eater if true ;o(
        /**
         * @property animDelayFactor
         * @type {Number}
         */
        this.animDelayFactor = 20
        /**
         * @property atlas
         * @type {Image}
         */
        this.atlas = new Image()
        /**
         * @property atlaswidth
         * @type {Number}
         */
        this.atlaswidth = 0
        /**
         * @property atlasheight
         * @type {Number}
         */
        this.atlasheight = 0
        /**
         * @property atlastranscol
         * @type {String}
         */
        this.atlastranscol = '' //
        //ejecta and cocoonjs has no DOMParser!
        if (typeof ejecta === 'undefined' && !navigator.isCocoonJS) {
            /**
             * @property xml
             * @type {String}
             */
            this.xml = ''
            /**
             * @property parser
             * @type {DOMParser}
             */
            this.parser = new DOMParser()
            /**
             * @property xmlDoc
             * @type {String}
             */
            this.xmlDoc = ''
        }
        /**
         * @property json
         * @type {Object}
         */
        this.json = {}
        /**
         * @description
         *
         * The tiled layer are parsed into separate layers
         *
         * @property layers
         * @type {Array}
         */
        this.layers = [] //can contain maptilelayer or objectlayer
        /**
         * @description
         *
         * Defines the layer to draw:
         * all - for all layers
         * name - the name of layer to draw
         * index - array index of layer
         *
         * @property renderlayer
         * @type {String}
         */
        this.renderlayer = 'all' //render layer: all for all layers, name of layer or array index for example 0 ;o)
        /**
         * @property tileproperties
         * @type {Array}
         */
        this.tileproperties = [] //properties of the tiles
        /**
         * @property orientation
         * @type {String}
         */
        this.orientation = ''
        /**
         * @property width
         * @type {Number}
         */
        this.width = 0
        /**
         * @property height
         * @type {Number}
         */
        this.height = 0
        /**
         * @property tilewidth
         * @type {Number}
         */
        this.tilewidth = 0
        /**
         * @property tileheight
         * @type {Number}
         */
        this.tileheight = 0
        /**
         * @property tileset
         * @type {Object}
         */
        this.tileset = {
            tilewidth:0,
            tileheight:0,
            offsetx:0,
            offsety:0,
            spacing:0,
            margin:0
        }
        /**
         * @property xspeed
         * @type {Number}
         */
        this.xspeed = 0
        /**
         * @property yspeed
         * @type {Number}
         */
        this.yspeed = 0
        /**
         * @property xscale
         * @type {Number}
         */
        this.xscale = 1
        /**
         * @property yscale
         * @type {Number}
         */
        this.yscale = 1
        /**
         * @property alpha
         * @type {Number}
         */
        this.alpha = 1
        /**
         * @property wrapX
         * @deprecated
         * @type {Boolean}
         */
        this.wrapX = false //stuff from diddy?
        /**
         * @property wrapY
         * @deprecated
         * @type {Boolean}
         */
        this.wrapY = false //stuff from diddy?
        /**
         * @property layertocheck
         * @type {Number}
         */
        this.layertocheck = 0 //as default use layer 0 for collision detection
        return this
    },
    /**
     * @description
     *
     * Load and parse an xml tilemap file. It can handle the tiled XML and CSV format.
     * All other formats are not supported!
     *
     * @method loadMapXml
     * @param xmlfile {string/object} xmlfile path or mediaasset object with data of tiled map xml
     */
    loadMapXml:function (xmlfile) {
        this.changemap = ''
        this.animated = false
        this.layers = []

        //from asset
        if (typeof xmlfile == 'string') {
            this.xml = loadString(xmlfile)
        } else {
            this.xml = xmlfile.data
        }
        this.removeJsonData()

        this.xmlDoc = this.parser.parseFromString(this.xml, 'text/xml')

        //get map
        var tilemap = map.xmlDoc.getElementsByTagName('map')[0]
        this.orientation = tilemap.getAttribute('orientation')
        this.width = parseInt(tilemap.getAttribute('width'))
        this.height = parseInt(tilemap.getAttribute('height'))
        this.tilewidth = parseInt(tilemap.getAttribute('tilewidth'))
        this.tileheight = parseInt(tilemap.getAttribute('tileheight'))

        var childcount = tilemap.childElementCount

        //tilemap.firstElementChild.nextElementSibling.nextElementSibling
        var element = tilemap.firstElementChild
        for (i = 0; i < childcount; i++) {
            console.log('>' + element.nodeName)
            switch (element.nodeName) {
                case 'tileset':
                    //read tileset settings
                    //only one tileset for the moment
                    this.tileset.tilewidth = parseInt(element.getAttribute('tilewidth'))
                    this.tileset.tileheight = parseInt(element.getAttribute('tileheight'))
                    if (element.getAttribute('spacing')) {
                        this.tileset.spacing = parseInt(element.getAttribute('spacing'))
                    }
                    if (element.getAttribute('margin')) {
                        this.tileset.margin = parseInt(element.getAttribute('margin'))
                    }
                    if (element.getElementsByTagName('tileoffset')[0]) {
                        this.tileset.offsetx = parseInt(element.getElementsByTagName('tileoffset')[0].getAttribute('x'))
                        this.tileset.offsety = parseInt(element.getElementsByTagName('tileoffset')[0].getAttribute('y'))
                    }
                    var image = element.getElementsByTagName('image')[0]
                    this.atlas.src = 'media/map/' + image.getAttribute('source')

                    this.atlaswidth = parseInt(image.getAttribute('width'))
                    this.atlasheight = parseInt(image.getAttribute('height'))
                    this.atlastranscol = image.getAttribute('trans')

                    break
                case 'layer':
                    //get tilemap data of layer
                    var tl = new CG.MapTileLayer()
                    data = element.getElementsByTagName('data')[0]

                    if (data.getAttribute('encoding') == 'csv') {
                        tl.tiles = data.textContent.replace(/(\r\n|\n|\r)/gm, '').split(',')
                        console.log('map encoding csv [layer ' + i + ']')
                    } else if (data.getAttribute('encoding') == 'base64' && data.getAttribute('compression') == 'gzip') {
                        throw 'base64 gzip compressed map format not supported at the moment'
                    } else if (data.getAttribute('encoding') == 'base64' && data.getAttribute('compression') == 'zlib') {
                        throw 'base64 zlib compressed map format not supported at the moment'
                    } else if (data.getAttribute('encoding') == 'base64') {
                        throw 'base64 map format not supported at the moment'
                    } else {
                        console.log('map encoding xml [layer ' + i + ']')
                        var tiles = element.getElementsByTagName('tile')
                        for (x in tiles) {
                            if (x < tiles.length) {
                                tl.tiles[x] = parseInt(tiles[x].getAttribute('gid'))
                            }
                        }
                    }

                    tl.name = element.getAttribute('name')
                    tl.width = parseInt(element.getAttribute('width'))
                    tl.height = parseInt(element.getAttribute('height'))
                    if (element.getAttribute('opacity')) {
                        tl.opacity = parseFloat(element.getAttribute('opacity'))
                    }
                    if (element.getAttribute('visible') === '0') {
                        tl.visible = false
                    }
                    this.layers.push(tl)
                    break
                case 'objectgroup':
                    //get tilemap data of grouplayer
                    console.log('grouplayer found')
                    var objects = element.getElementsByTagName('object')
                    for (o in objects) {
                        if (o < objects.length) {
                            var obj = objects[o]
                            var name = obj.getAttribute('name')
                            if (obj.getAttribute('gid')) {
                                //tile as object/point
                                this.points.push(
                                    new CG.MapPoint(
                                        new CG.Point(
                                            parseInt(obj.getAttribute('x')), parseInt(obj.getAttribute('y'))), this.position, obj.getAttribute('name'), parseInt(obj.getAttribute('gid'))))
                                console.log('tile as oject found: ' + name)
                                console.log(obj)
                            } else if (obj.getAttribute('width')) {
                                type = false
                                properties = obj.getElementsByTagName('property')
                                console.log(properties.length)
                                for (var p = 0, l = properties.length; p < l; p++) {
                                    if (properties[p].getAttribute('name') == 'type') {
                                        type = properties[p].getAttribute('value')
                                    }
                                }

                                //object group
                                this.areas.push(
                                    new CG.MapArea(
                                        new CG.Bound(
                                            parseInt(obj.getAttribute('x')), parseInt(obj.getAttribute('y')), parseInt(obj.getAttribute('width')), parseInt(obj.getAttribute('height'))), this.position, obj.getAttribute('name'), type))
                                console.log('group object found: ' + name)
                                console.log(obj)
                            } else if (obj.getElementsByTagName('polygon').length > 0) {
                                console.log('polygon found: ' + name)
                            } else if (obj.getElementsByTagName('polyline').length > 0) {
                                console.log('polyline found: ' + name)
                            }
                        }
                    }
                    break

            }
            element = element.nextElementSibling
        }


        //get tile properties
        this.tileproperties = Array(parseInt((this.atlaswidth / this.tilewidth)) * parseInt((this.atlasheight / this.tileheight)))
        var tiles = map.xmlDoc.getElementsByTagName('tileset')[0].getElementsByTagName('tile')
        var time = new Date().getTime()
        for (i in tiles) {
            var tprop = new CG.MapTileProperties()
            var tile = tiles[i]

            if (i < this.tileproperties.length) {
                var id = tile.getAttribute('id')
                var properties = tile.getElementsByTagName('properties')[0].getElementsByTagName('property')
                for (p in properties) {
                    if (p < properties.length) {
                        var tp = properties[p]
                        var elem = tp.getAttribute('name')
                        var value = tp.getAttribute('value')
                        if (elem == 'name') {
                            tprop.name = value
                        } else if (elem == 'anim_delay') {
                            tprop.animDelay = parseInt(value)
                            tprop.delayTimer = time
                            this.animated = true
                        } else if (elem == 'anim_direction') {
                            tprop.animDirection = parseInt(value)
                        } else if (elem == 'anim_next') {
                            tprop.animNext = parseInt(value)
                            tprop.animated = true
                        }
                    }
                }
                this.tileproperties[id] = tprop
            }
        }
        return this
    },

    /**
     * @description
     *
     * Load and parse an tilemap json file. Use the tiled json export.
     * Hopefully the json format has the same functionality as the xml loader ;o)
     *
     * @method loadMapJson
     * @param jsonfile {string/object} jsonfile path or mediaasset object with data of tiled map xml
     */
    loadMapJson:function (jsonfile) {
        this.changemap = ''
        this.animated = false
        this.layers = []

        //from asset
        if (typeof jsonfile == 'string') {
            this.json = JSON.parse(loadString(jsonfile))
        } else {
            this.json = jsonfile.data
        }

        this.removeXmlData()

        //get map
        this.orientation = this.json.orientation
        this.width = this.json.width
        this.height = this.json.height
        this.tilewidth = this.json.tilewidth
        this.tileheight = this.json.tileheight

        //tilesets
        for (i = 0, l = this.json.layers.length; i < l; i++) {
            switch (this.json.layers[i].type) {
                case 'tilelayer':
                    //get tilemap data of layer
                    var tl = new CG.MapTileLayer()
                    tl.tiles = this.json.layers[i].data
                    tl.name = this.json.layers[i].name
                    tl.width = this.json.layers[i].width
                    tl.height = this.json.layers[i].height
                    tl.opacity = this.json.layers[i].opacity
                    tl.visible = this.json.layers[i].visible
                    this.layers.push(tl)
                    break
                case 'objectgroup':
                    //get tilemap data of grouplayer
                    console.log('grouplayer found')
                    var objects = this.json.layers[i].objects
                    for (o in objects) {
                        if (o < objects.length) {
                            var obj = objects[o]
                            var name = obj.name
                            if (obj.gid) {
                                //tile as object/point
                                this.points.push(
                                    new CG.MapPoint(
                                        new CG.Point(
                                            parseInt(obj.x), parseInt(obj.y)), this.position, obj.name, parseInt(obj.gid)))

                                console.log('tile as oject found: ' + name)
                                console.log(obj)
                            } else if (obj.width) {
                                //object group
                                this.areas.push(
                                    new CG.MapArea(
                                        new CG.Bound(
                                            parseInt(obj.x), parseInt(obj.y), parseInt(obj.width), parseInt(obj.height)), this.position, obj.name, obj.properties.type))

                                console.log('group object found: ' + name)
                                console.log(obj)
                            } else if (obj.polygon) {
                                console.log('polygon found: ' + name)
                            } else if (obj.polyline) {
                                console.log('polyline found: ' + name)
                            }
                        }
                    }
                    break

            }
        }


        //get tile properties
        this.atlas.src = 'media/map/' + this.json.tilesets[0].image

        this.atlaswidth = this.json.tilesets[0].imagewidth
        this.atlasheight = this.json.tilesets[0].imageheight
        this.atlastranscol = this.json.tilesets[0].transparentcolor

        this.tileproperties = Array(parseInt((this.atlaswidth / this.tilewidth)) * parseInt((this.atlasheight / this.tileheight)))
        var tiles = this.json.tilesets[0].tileproperties

        var time = new Date().getTime()

        for (id in tiles) {
            var tprop = new CG.MapTileProperties()
            var tile = tiles[id]
            tprop.name = tile.name
            tprop.animDelay = parseInt(tile.anim_delay)
            tprop.delayTimer = (tprop.animDelay > 0) ? time : 0
            tprop.animated = (tprop.animDelay > 0) ? true : false
            tprop.animNext = parseInt(tile.anim_next)
            if (tprop.animDelay > 0) {
                this.animated = true
            }
            tprop.animDirection = parseInt(tile.anim_direction)
            this.tileproperties[id] = tprop

        }
        return this
    },


    /**
     * @description
     *
     * This is the main method for map drawing. Orthogonal maps works very well. Isometric maps are not well implemented yet.
     *
     * @method drawMap
     *
     * @param sx {Number} sx top left coord for canvas drawing
     * @param sy {Number} sy top left coord for canvas drawing
     * @param bx {Number} bx top left x coord of bound in tilemap
     * @param by {Number} by top left y coord of bound in tilemap
     * @param bw {Number} bw width of bound in tilemap
     * @param bh {Number} bh height of bound in tilemap
     * @param callback {callback} callback for collision handling - callback(obj,maptileproperties)
     */
    drawMap:function (sx, sy, bx, by, bw, bh, callback) {
        this.position.x = bx
        this.position.y = by

        this.bx = bx || this.bx || 0
        this.by = by || this.by || 0
        this.bw = bw || Game.bound.width
        this.bh = bh || Game.bound.height
        this.sx = sx || this.sx || 0
        this.sy = sy || this.sy || 0
        this.callback = callback || false

        //for renderer
        this.rx = 0
        this.ry = 0
        this.cx = 0
        this.cy = 0
        this.xpos = 0
        this.ypos = 0
        this.layer = 0

        //update all points an areas
        this.updatePointsAndAreas()

        if (this.changemap != '') {
            this.loadMap(this.changemap)
        }
        if (this.visible) {
            this.updateAnimation()
            if (this.layers.length > 0) {
                for (this.layer = 0, l = this.layers.length; this.layer < l; this.layer++) {
                    var tl = this.layers[this.layer]
                    //render control, render by name, layer number or 'all''
                    if (this.renderlayer == tl.name || this.renderlayer == this.layer || this.renderlayer == 'all') {
                        // MAP ORTHOGONAL
                        if (this.orientation == 'orthogonal' && tl.visible == true) {
                            modx = (this.bx * this.xscale) % this.tilewidth
                            mody = (this.by * this.yscale) % this.tileheight
                            y = this.by
                            my = parseFloat(this.by) / parseFloat(this.tileheight) >> 0

                            var tmpy = (this.by + this.bh + this.tileheight)
                            while (y < tmpy) {
                                x = this.bx //- this.tilewidth
                                mx = parseFloat(this.bx) / parseFloat(this.tilewidth) >> 0

                                var tmpx = (this.bx + this.bw + this.tilewidth)
                                while (x < tmpx) {
                                    if ((this.wrapX || (mx >= 0 && mx < this.width)) && (this.wrapY || (my >= 0 && my < this.height))) {
                                        mx2 = mx
                                        my2 = my

                                        while (mx2 < 0) {
                                            mx2 += this.width
                                        }

                                        while (mx2 >= this.width) {
                                            mx2 -= this.width
                                        }

                                        while (my2 < 0) {
                                            my2 += this.height
                                        }

                                        while (my2 >= this.height) {
                                            my2 -= this.height
                                        }

                                        gid = tl.tiles[mx2 + my2 * tl.width] - 1

                                        if (gid >= 0) {
                                            if (modx < 0) {
                                                modx += this.tilewidth
                                            }
                                            if (mody < 0) {
                                                mody += this.tileheight
                                            }
                                            this.rx = x - modx - this.bx
                                            this.ry = y - mody - this.by


                                            //time for collision detection?
                                            //limit to specific tilemap layer?
                                            //collision depending on bounds and direction (xspeed/yspeed)?
                                            //include some layer functionality here and render some sprites between map layers?
                                            if (this.elements.length > 0 && this.layertocheck == l) {
                                                for (var o = 0, l = this.elements.length; o < l; o++) {
                                                    if (this.checkMapCollision(this.elements[0], this.rx, this.ry)) {
                                                        this.callback(this.elements[o], this.tileproperties[gid])
                                                    }
                                                }
                                            }


                                            //margin/spacing?
                                            this.cx = (gid % (this.atlaswidth / this.tilewidth)) * this.tilewidth
                                            this.cy = Math.floor(this.tilewidth * gid / this.atlaswidth) * this.tileheight

                                            Game.renderer.draw(this)

                                        }
                                    }
                                    x = x + this.tilewidth
                                    mx += 1
                                }
                                y = y + this.tileheight
                                my += 1
                            }
                        }
                        // MAP ISOMETRIC
                        else if (this.orientation == 'isometric') {
                            var t = tl.width + tl.height
                            for (var y = 0; y < t; y++) {
                                var ry = y
                                var rx = 0
                                while (ry >= tl.height) {
                                    ry -= 1
                                    rx += 1
                                }


                                while (ry >= 0 && rx < tl.width) {
                                    var gid = tl.tiles[rx + ry * tl.width]
                                    this.rx = (rx - ry - 1) * this.tilewidth / 2 - bx
                                    this.ry = (rx + ry + 1) * this.tileheight / 2 - by
                                    if (this.rx > -this.tileset.tilewidth && this.rx < bw && this.ry > -this.tileset.tileheight && this.ry < bh) {
                                        if (gid > 0) {
                                            this.cx = ((gid - 1) % (this.atlaswidth / this.tilewidth)) * this.tilewidth
                                            this.cy = Math.floor(this.tilewidth * (gid - 1) / this.atlaswidth) * this.tileset.tileheight

                                            Game.renderer.draw(this)

                                        }
                                    }
                                    ry -= 1
                                    rx += 1
                                }
                            }
                        }
                    }
                }
            }
        }
    },

    /**
     * @description
     *
     * Update all areas and points elements.
     *
     * @method updatePointsAndAreas
     */
    updatePointsAndAreas:function () {
        this.points.forEach(function (point, index) {
            point.update()
        }, this)
        this.areas.forEach(function (area, index) {
            area.update()
        }, this)
    },


    /**
     * @description
     *
     * Get all point(s) with the given name in the points
     *
     * @method getPointsByName
     *
     * @param name {string} name of the points to return
     * @return {false/array} returns false or an array with point(s)
     */
    getPointsByName:function (name) {
        points = []
        for (var i = 0, l = this.points.length; i < l; i++) {
            if (this.points[i].name === name) {
                points.push(this.points[i])
            }
        }
        if (points.length > 0) {
            return points
        }
        return false
    },

    /**
     * @description
     *
     * Get all areas with the given name
     *
     * @method getAreasByName
     *
     * @param name {string} name of the area(s) to return
     * @return {false/array} returns false or an array with area(s)
     */
    getAreasByName:function (name) {
        areas = []
        for (var i = 0, l = this.areas.length; i < l; i++) {
            if (this.areas[i].name === name) {
                areas.push(this.areas[i])
            }
        }
        if (areas.length > 0) {
            return areas
        }
        return false
    },


    /**
     * @description
     *
     * Defines layer drawing, See property options
     *
     * @method setLayerToRender
     *
     * @param mixed {mixed} mixed define the map layer(s) to render 'all' (string) for all layers, array index (integer) for layer to render or 'name' (string) of layer to render'
     */
    setLayerToRender:function (mixed) {
        this.renderlayer = mixed
        return this
    },

    /**
     * @description
     *
     * The update method is not complete yet and only experimental.
     * At the final stage the methods updateAnimation and updatePointsAndAreas have to be called from here!
     * Then also a map class can be added to a layer as an element for auto update/draw from Game.director!
     *
     * @method update
     */
    update:function () {
        //TODO automatic movement of map or other stuff?
        this.bx += this.xspeed
        this.by += this.yspeed
        if (this.getBounds().width - Game.bound.width < this.bx) {
            this.xspeed = this.xspeed * -1
        }
        if (this.bx < 0) {
            this.xspeed = this.xspeed * -1
        }
        if (this.getBounds().height - Game.bound.height < this.by) {
            this.yspeed = this.yspeed * -1
        }
        if (this.by < 0) {
            this.yspeed = this.yspeed * -1
        }
        return this
    },

    // just calls drawMap ;o)
    draw:function () {
        this.drawMap(this.bx, this.by, this.bw, this.bh, this.sx, this.sy, this.callback)
        return this
    },

    /**
     * @description
     *
     * Get the bounds of the map
     *
     * @method getBounds
     */
    getBounds:function () {
        return {
            width:this.width * this.tilewidth,
            height:this.height * this.tileheight
        }
    },

    /**
     * @description
     *
     * Updates all tilemap properties of the map.
     *
     * Supported custom tiled map properties for now are (see also tilemap examples):
     * anim_delay       => time to used to display an switch to next tile
     * anim_direction   => direction for next tile 1 = jump forward, -1 = jump back
     * anim_next        => defines the offset
     *
     * With this tile properties it is possible to define tilemap animations.
     * These must be defined in the tilemap property window with key/value pairs
     *
     * @method updateAnimation
     */
    updateAnimation:function () {
        // update if map is visible
        if (this.visible && this.animated) {
            if (this.layers.length > 0) {
                for (var layer = 0, l = this.layers.length; layer < l; layer++) {
                    var newtime = new Date().getTime()
                    for (t = 0; t < this.layers[layer].tiles.length; t++) {
                        var tile = this.layers[layer].tiles[t]
                        if (tile > 0) {
                            try {
                                var tprop = this.tileproperties[tile - 1]
                                if (tprop.animated && tprop.animDirection != 0) {
                                    if (newtime > (tprop.delayTimer + (tprop.animDelay / this.animDelayFactor))) {
                                        switch (tprop.animDirection) {
                                            case 1:
                                                this.layers[layer].tiles[t] += tprop.animNext
                                                this.tileproperties[tile - 1 + tprop.animNext].delayTimer = newtime
                                                break
                                            case -1:
                                                this.layers[layer].tiles[t] -= tprop.animNext
                                                this.tileproperties[tile - 1 - tprop.animNext].delayTimer = newtime
                                                break
                                            default:
                                                break
                                        }
                                    }
                                }
                            } catch (e) {

                            }
                        }
                    }
                }
            }
        }
    },

    /**
     * @description
     *
     * Adds a object to the element array, used at the moment for collision detection to tilemap.
     *
     * @method addElement
     *
     * @param {obj} element to to add to elements array
     */
    addElement:function (element) {
        this.elements.push(element)
        return this
    },

    /**
     * @description
     * Checks if the attached element collides with an tile of the tilemap
     *
     * @method checkMapCollision
     *
     * @param {obj} element to check for
     * @param {Number} rx current rx of rendermap method
     * @param {Number} ry current ry of rendermap method
     *
     * @return {boolean} returns true or false
     */
    checkMapCollision:function (element, rx, ry) {
        //TODO return detailed collision object or offsets instead of true?
        if (element.boundingradius > 0) {
            //circular collision
            var xr = element.boundingradius / 2 * element.xscale
            var yr = element.boundingradius / 2 * element.yscale
            if (element.position.x + xr >= rx && element.position.x - xr <= rx + this.tilewidth && element.position.y + yr >= ry && element.position.y - yr <= ry + this.tileheight) {
                return true
            }
        } else {
            //bounding collision
            var xw = element.width / 2 * element.xscale
            var yh = element.height / 2 * element.yscale
            if (element.position.x + xw >= rx && element.position.x - xw <= rx + this.tilewidth && element.position.y + yh >= ry && element.position.y - yh <= ry + this.tileheight) {
                return true
            }
        }
        return false
    },

    /**
     * @description
     * Checks if a external object(s) collides with the areas of the tiled map.
     * This can be elements from an layer or the map itself.
     *
     * @method checkElementsToAreasCollision
     *
     * @param {Array} objarray to check for a areas collision
     * @param {Callback} callback what should happen
     */
    checkElementsToAreasCollision:function (objarray, callback) {
        for (var o = 0, ol = objarray.length; o < ol; o++) {

            obj = objarray[o].checkCollision(this.areas, callback)
        }
        return this
    },
    /**
     * @description removes the json data of the map object
     * @method removeJsonData
     */
    removeJsonData:function () {
        this.json = {}
        return this
    },
    /**
     * @description removes the xml data of the map object
     * @method removeXmlData
     */
    removeXmlData:function () {
        this.xml = ''
        //this.parser = new DOMParser()
        this.xmlDoc = ''
        return this
    }
})


/**
 * @description
 *
 * CG.Sequence container to collect/group CG.Translation objects
 *
 * @class CG.Sequence
 * @extends Class
 */
CG.Class.extend('Sequence', {
    /**
     * @constructor
     * @method init
     * @return {*}
     */
    init: function () {
        /**
         * @property current
         * @type {Number}
         */
        this.current = 0
        /**
         * @property loop
         * @type {Boolean}
         */
        this.loop = false
        /**
         * @property translations
         * @type {Array}
         */
        this.translations = []
        return this
    },
    /**
     * @description add a translation object to the sequence array
     * @method addTranslation
     * @param translationObj {translation} the translation object to add
     * @return {*}
     */
    addTranslation: function (translationObj) {
        this.translations.push(translationObj)
        return this
    },
    /**
     * @method update
     */
    update: function (callback) {
        if (this.current < this.translations.length) {
            if (this.translations[this.current].finished === false) {
                this.translations[this.current].update()
            } else {
                this.current += 1
            }
        } else {
            if (this.loop) {
                this.reset()
            } else {
                //callback?
            }
        }
    },
    /**
     * @method draw
     */
    draw: function () {

    },
    /**
     * @method reset
     */
    reset: function () {
        for (var i = 0, l = this.translations.length; i < l; i++) {
            this.translations[i].reset()
        }
        this.current = 0
        return this
    }
})


/**
 * @description
 *
 * CG.Translate moving a object
 *
 * @class CG.Translate
 * @extends CG.Class
 */
CG.Class.extend('Translate', {
    /**
     * @constructor
     * @method init
     * @return {*}
     */
    init: function () {
        /**
         * @property type
         * @type {String}
         */
        this.type = ''
        /**
         * @property tx
         * @type {Number}
         */
        this.tx = 0 //translated x value for the object
        /**
         * @property ty
         * @type {Number}
         */
        this.ty = 0 //translated y value for the object
        /**
         * @property x1
         * @type {Number}
         */
        this.x1 = 0
        /**
         * @property y1
         * @type {Number}
         */
        this.y1 = 0
        /**
         * @property x2
         * @type {Number}
         */
        this.x2 = 0
        /**
         * @property y2
         * @type {Number}
         */
        this.y2 = 0
        /**
         * @property bx
         * @type {Number}
         */
        this.bx = 0 //bézier x
        /**
         * @property by
         * @type {Number}
         */
        this.by = 0 //bézier y
        /**
         * @property object
         * @type {Object}
         */
        this.object = {}
        /**
         * @property r1
         * @type {Number}
         */
        this.r1 = 0
        /**
         * @property r2
         * @type {Number}
         */
        this.r2 = 0
        /**
         * @property startangle
         * @type {Number}
         */
        this.startangle = 0
        /**
         * @property angle
         * @type {Number}
         */
        this.angle = 0
        /**
         * @property speed
         * @type {Number}
         */
        this.speed = 0
        /**
         * @property steps
         * @type {Number}
         */
        this.steps = 0
        /**
         * @property step
         * @type {Number}
         */
        this.step = 0
        /**
         * @property positions
         * @type {Array}
         */
        this.positions = []
        /**
         * @property finished
         * @type {Boolean}
         */
        this.finished = false
        return this
    },
    /**
     * Options:
     * object {object}
     * steps {number}
     * startpoint {CG.Point}
     * endpoint {CG.Point}
     *
     @example
     var t = new CG.Translate()
     t.initTween({
        object: Sprite,
        steps: 10,
        startpoint: new CG.Point(10, 10),
        endpoint: new CG.Point(320, 160)
     })
     *
     * 
     * @method initTween
     *
     * @param options {Object}
     * @return {this}
     */
    initTween: function (options) {
        this.type = 'tween'

        if (options) {
            CG._extend(this, options)
        }

        this.x1 = this.startpoint.x
        this.y1 = this.startpoint.y
        this.x2 = this.endpoint.x
        this.y2 = this.endpoint.y

        var xstep = (this.x2 - this.x1) / this.steps
        var ystep = (this.y2 - this.y1) / this.steps
        var tx = this.x1 >> 0   //replace parseInt
        var ty = this.y1 >> 0   //replace parseInt
        //precalc positions and push to array
        for (var i = 0; i <= this.steps; i++) {
            this.positions.push(new CG.Point(tx, ty))
            tx += xstep
            ty += ystep
        }
        return this
    },

    /**
     * Options:
     * object {object}
     * centerpoint {CG.Point}
     * radius1 {number}
     * radius {number}
     * startangle {number}
     * rotation {number}
     *
     @example
     var t = new CG.Translate()
     t.initOval({
        object: spr1,
        centerpoint: new CG.Point(320, 160),
        radius1: 50,
        radius2: 50,
        startangle: 90,
        rotation: 5
     })
     * 
     * @method initOval
     * @param options {Object}
     * @return {this}
     */
    initOval: function (options) {
        this.type = 'oval'

        if (options) {
            CG._extend(this, options)
        }

        this.x1 = this.centerpoint.x
        this.y1 = this.centerpoint.y
        this.r1 = this.radius1
        this.r2 = this.radius2
        this.speed = this.rotation

        return this
    },

    /**
     * Options:
     * object {object}
     * steps {number}
     * startpoint {CG.Point}
     * endpoint {CG.Point}
     * control1 {CG.Point}
     * control2 {CG.Point}
     *
     @example
     var t = new CG.Translate()
     t.initBezier({
        object: spr1,
        steps: 10,
        startpoint: new CG.Point(320, 160),
        endpoint: new CG.Point(0, 10),
        control1: new CG.Point(340, 180),
        control2: new CG.Point(0, 0)
     })
     *
     * @description initBezier
     * http://13thparallel.com/archive/bezier-curves/
     *
     * @method initBezier
     *
     * @param options {Object}
     * @return {this}
     */
    initBezier: function (options) {
        this.type = 'bezier'

        if (options) {
            CG._extend(this, options)
        }

        this.start = this.endpoint
        this.end = this.startpoint

        if (this.control2 == 'undefined' && this.control1 == 'undefined') {
            this.control2 = new CG.Point(this.start.x + 3 * (this.end.x - this.start.x) / 4, this.start.y + 3 * (this.end.y - this.start.y) / 4);
        } else {
            this.control2 = this.control2 || this.control1
        }
        this.control1 = this.control1 || new CG.Point(this.start.x + (this.end.x - this.start.x) / 4, this.start.y + (this.end.y - this.start.y) / 4)

        b1 = function (t) {
            return (t * t * t)
        }
        b2 = function (t) {
            return (3 * t * t * (1 - t))
        }
        b3 = function (t) {
            return (3 * t * (1 - t) * (1 - t))
        }
        b4 = function (t) {
            return ((1 - t) * (1 - t) * (1 - t))
        }

        for (var i = 0; i <= this.steps; i++) {
            percent = (1 / this.steps) * i;
            var pos = new CG.Point();
            pos.x = this.start.x * b1(percent) + this.control1.x * b2(percent) + this.control2.x * b3(percent) + this.end.x * b4(percent)
            pos.y = this.start.y * b1(percent) + this.control1.y * b2(percent) + this.control2.y * b3(percent) + this.end.y * b4(percent)
            this.positions.push(pos)
        }

        return this
    },
    /**
     * @method update
     */
    update: function () {
        var obj = this.object
        switch (this.type) {
            case 'bezier':
            case 'tween':
                if (this.step < this.steps) {
                    obj.position.x = obj.position._x = this.positions[this.step].x
                    obj.position.y = obj.position._y = this.positions[this.step].y
                    this.step += 1
                } else {
                    this.finished = true
                }
                break
            case 'oval':
                var rad = this.startangle * CG.Const_PI_180
                this.tx = this.x1 - (this.r1 * Math.cos(rad))
                this.ty = this.y1 - (this.r2 * Math.sin(rad))
                this.startangle += this.speed

                if (this.startangle > 360) {
                    this.startangle = 0 + (this.startangle - 360)
                }

                obj.position.x = obj.position._x = this.tx >> 0  //replace parseInt
                obj.position.y = obj.position._y = this.ty >> 0  //replace parseInt
                break
            default:
                break
        }
    },
    /**
     * @method draw
     */
    draw: function () {
    },
    /**
     * @method reset
     */
    reset: function () {
        this.step = 0
        this.finished = false
    }

})

/*
 function drawBezier() {
 var C1 = new coord(objDragger[0].x(), objDragger[0].y());
 var C2 = new coord(objDragger[1].x(), objDragger[1].y());
 var C3 = new coord(objDragger[2].x(), objDragger[2].y());
 var C4 = new coord(objDragger[3].x(), objDragger[3].y());

 for(var i=0; i<numPixels; i++) {
 percent = (1/numPixels) * i;
 var pos = getBezier(percent, C1, C2, C3, C4);
 objPixels[i].moveTo(pos.x, pos.y);
 }
 }


 //====================================================================================
 // getBezier() - calculates a given position along a Bezier curve specified by 2,3 or
 //               4 control points.
 //====================================================================================

 //Bezier functions:
 B1 = function(t) { return (t*t*t); }
 B2 = function(t) { return (3*t*t*(1-t)); }
 B3 = function(t) { return (3*t*(1-t)*(1-t)); }
 B4 = function(t) { return ((1-t)*(1-t)*(1-t)); }

 //coordinate constructor
 coord = function (x,y) { if(!x) var x=0; if(!y) var y=0; return {x: x, y: y}; }

 //Finds the coordinates of a point at a certain stage through a bezier curve
 function getBezier(percent,startPos,endPos,control1,control2) {
 //if there aren't any extra control points plot a straight line, if there is only 1
 //make 2nd point same as 1st

 if(!control2 && !control1) var control2 = new coord(startPos.x + 3*(endPos.x-startPos.x)/4, startPos.y + 3*(endPos.y-startPos.y)/4);
 if(!control2) var control2 = control1;
 if(!control1) var control1 = new coord(startPos.x + (endPos.x-startPos.x)/4, startPos.y + (endPos.y-startPos.y)/4);

 var pos = new coord();
 pos.x = startPos.x * B1(percent) + control1.x * B2(percent) + control2.x * B3(percent) + endPos.x * B4(percent);
 pos.y = startPos.y * B1(percent) + control1.y * B2(percent) + control2.y * B3(percent) + endPos.y * B4(percent);

 return pos;
 }
 */


/**
 * @description
 *
 * CG.Morph to manipulate objects in size and so on.
 *
 * @class CG.Morph
 * @extends CG.Class
 *
 */
CG.Class.extend('Morph', {
    /**
     * Options:
     * mode {string}
     * min {number}
     * max {number}
     * speed {number}
     *
     @example
     var e = new CG.Entity({
           name: 'player',
           position: new CG.Point(100,100)
         })
     *
     * @method init
     * @constructor
     * @param options {object}
     */
    init: function (options) {
        CG._extend(this, {
            /**
             * @property mode
             * @type {String}
             */
            mode: '',
            /**
             * @property min
             * @type {Number}
             */
            min: 0,
            /**
             * @property max
             * @type {Number}
             */
            max: 0,
            /**
             * @property speed
             * @type {Number}
             */
            speed: 0,
            /**
             * @property angle
             * @type {Number}
             */
            angle: 0,
            /**
             * @property rad
             * @type {Number}
             */
            rad: 0,
            /**
             * @property _val
             * @type {Number}
             * @protected
             */
            _val: 0
        })

        if (options) {
            CG._extend(this, options)
            this.rad = this.max - this.min
        }

        return this
    },
    update: function () {
        switch (this.mode) {
            case 'sinus':
                var rad = this.angle * CG.Const_PI_180
                this._val = this.rad * Math.sin(rad)
                if (this._val < 0) {
                    this._val = this._val * -1
                }
                this.angle += this.speed

                if (this.angle > 360) {
                    this.angle = 0 + (this.angle - 360)
                }
                break
        }
        return this
    },
    draw: function () {

    },
    /**
     * @method getVal
     *
     * @return {float}
     */
    getVal: function () {
        return this._val
    }
})



/**
 * @description
 *
 * CG.Particle
 *
 * @class CG.Particle
 * @extends CG.Sprite
 *
 */

CG.Sprite.extend('Particle', {
    /**
     * Options:
     * image {string} imgpath, image object or atlasimage object to use
     *
     @example
     var s = new CG.Particle({
           image: '../images/demo.png'
         })
     *
     * @constructor
     * @method init
     * @param image {mixed} image imgpath, image object or atlasimage object to use for the particle
     */
    init: function (options) {
        this._super()
        this.instanceOf = 'Particle'

        if (options) {
            CG._extend(this, options)
            this.setImage(this.image)
        }

        /**
         * @property position
         * @type {CG.Point}
         */
        this.position = new CG.Point(0,0)
        /**
         * @property lifetime
         * @type {Number}
         */
        this.lifetime = 100
        /**
         * @property currtime
         * @type {Number}
         */
        this.currtime = this.lifetime
        /**
         * @property aging
         * @type {Number}
         */
        this.aging = 1
        /**
         * @property fadeout
         * @type {Boolean}
         */
        this.fadeout = false
        /**
         * @property gravity
         * @type {Number}
         */
        this.gravity = 0
    },
    update: function () {
        if (this.visible) {
            if (this.fadeout) {
                this.alpha = this.currtime / this.lifetime
                if (this.alpha <= 0) {
                    this.visible = false
                }
            }
            this.currtime -= this.aging
            if (this.currtime < 0) {
                this.visible = false
            }

            this.position.x += this.xspeed
            this.position.y += this.yspeed
            this.yspeed += this.gravity
            this.rotation += this.rotationspeed
            this.xhandle = (this.width * this.xscale / 2)
            this.yhandle = (this.height * this.yscale / 2)

            this.updateDiff()
            this.updateMatrix()
        }
    },
    draw: function () {
        if (this.visible) {

            Game.renderer.draw(this)

        }
    }
})


/**
 * @description
 *
 * CG.Emitter that handles . . . particles.
 *
 * @class CG.Emitter
 * @extends CG.Entity
 *
 * @param {point} position of emitter
 */
CG.Entity.extend('Emitter', {
    /**
     * @method init
     *
     * Options:
     * position {CG.Point}
     *
     @example
     var e = new CG.Emitter({
           position: new CG.Point(100,100)
         })
     *
     * @constructor
     * @param position {CG.Point}
     * @return {*}
     */
    init: function (options) {
        this._super()

        CG._extend(this, {
            /**
             * @property particle
             * @type {Array}
             */
            particles: [],     //Particle pool delegated by emitter
            /**
             * @property maxparticles
             * @type {Number}
             */
            maxparticles: 50,
            /**
             * @property creationtime
             * @type {Number}
             */
            creationtime: 100, //time when next particle would be generated/reanimated
            /**
             * @property currenttime
             * @type {Number}
             */
            currenttime: 0,    //current counter
            /**
             * @property creationspeed
             * @type {Number}
             */
            creationspeed: 50, //increase for currenttime
            /**
             * @property gravity
             * @type {Number}
             */
            gravity: 0.05,
            /**
             * @property image
             * @type {null}
             */
            image: null,       //Image of the particle
            /**
             * @property type
             * @type {String}
             */
            type: '',          //point, corona, plate
            /**
             * @property position
             * @type {CG.Point}
             */
            position: {x: 0, y: 0, _x: 0, _y: 0},

            /**
             * @property rotation
             * @type {Number}
             */
            rotation: 0,       //rotation of plate emitter
            /**
             * @property width
             * @type {Number}
             */
            width: 200,        //width of line and rectangle emitter
            /**
             * @property height
             * @type {Number}
             */
            height: 200,       //width of rectangle emitter
            /**
             * @property radius
             * @type {Number}
             */
            radius: 0,         //radius for corona emitter
            /**
             * @property pspeed
             * @type {Number}
             */
            pspeed: 10,        //particle speed
            /**
             * @property protation
             * @type {Number}
             */
            protation: 0,
            /**
             * @property pdirection
             * @type {Number}
             */
            pdirection: 0,     //particle direction UP, DOWN, CG.LEFT, RIGHT
            /**
             * @property plifetime
             * @type {Number}
             */
            plifetime: 100,    //particle lifetime
            /**
             * @property paging
             * @type {Number}
             */
            paging: 1,         //particle aging
            /**
             * @property pfadeout
             * @type {Boolean}
             */
            pfadeout: false   //particle fadeout
        })

        if (options) {
            CG._extend(this, options)
            this.position._x = this.position.x
            this.position._y = this.position.y
        }

        return this
    },
    /*
     * Objective-C style initialisation of all emitter types
     */

    /**
     * @method initAsPoint
     *
     * @param {mixed} image path, image or atlasimage to use for the particle
     */
    initAsPoint: function (image) {
        this.image = image
        this.type = 'point'
        return this
    },


    /**
     * @method initAsExplosion
     *
     * @param {mixed} image path, image or atlasimage to use for the particle
     * @param {Number} min value for particle speed
     * @param {Number} max value for particle speed
     */
    initAsExplosion: function (image, min, max) {
        this.image = image
        this.type = 'explosion'
        this.min = min
        this.max = max
        return this
    },

    /**
     * @method initAsCorona
     *
     * @param {mixed} image path, image or atlasimage to use for the particle
     * @param {Number} radius of the corona emitter
     */
    initAsCorona: function (image, radius) {
        this.image = image
        this.type = 'corona'
        this.radius = radius || 0
        return this
    },

    /**
     * @method initAsLine
     *
     * @param {mixed} image path, image or atlasimage to use for the particle
     * @param {Number} width of the plate emitter
     * @param {Number} direction (defined constants) of the plate emitter
     */
    initAsLine: function (image, width, direction) {
        this.image = image
        this.width = width || 200
        this.pdirection = direction || CG.UP
        this.type = 'line'
        return this
    },

    /**
     * @method initAsRectangle
     *
     * @param {mixed} image path, image or atlasimage to use for the particle
     * @param {Number} width of the plate emitter
     * @param {Number} height (defined constants) of the plate emitter
     */
    initAsRectangle: function (image, width, height) {
        this.image = image
        this.width = width || 200
        this.height = height || 200
        this.type = 'rectangle'
        return this
    },
    /**
     * @method createParticle
     * @return {*}
     */
    createParticle: function () {
        particle = new CG.Particle({image: this.image})
        return particle
    },

    /**
     * @method initParticle
     *
     * @param {particle} particle particle object
     */
    initParticle: function (particle) {
        if (this.pfadeout) {
            particle.fadeout = true
        }
        particle.gravity = this.gravity     //set particle gravity to emitter gravity
        particle.alpha = 1                  //set alpha back to 1
        particle.visible = true             //make particle visible again
        particle.lifetime = this.plifetime  //reset lifetime
        particle.currtime = this.plifetime
        particle.rotationspeed = this.protation
        switch (this.type) {
            case 'corona':
                var rad = this.getRandom(0, 359) * CG.Const_PI_180

                particle.position.x = this.getX() - (this.radius * Math.cos(rad))
                particle.position.y = this.getY() - (this.radius * Math.sin(rad))

                angl = Math.atan2(particle.position.x - this.getX(), particle.position.y - this.getY()) * CG.Const_180_PI

                particle.xspeed = this.pspeed * Math.sin(angl * CG.Const_PI_180)
                particle.yspeed = this.pspeed * Math.cos(angl * CG.Const_PI_180)

                break
            case 'rectangle':
                //random value in rectangle
                rndx = this.getRandom(this.width / 2 * -1, this.width / 2)
                rndy = this.getRandom(this.height / 2 * -1, this.height / 2)

                particle.position.x = this.position._x - rndx
                particle.position.y = this.position._y - rndy
                particle.xspeed = 0
                particle.yspeed = 0

                break
            case 'line':
                //random value on plate line
                rnd = this.getRandom(this.width / 2 * -1, this.width / 2)

                //handle directions of line emitter
                switch (this.pdirection) {
                    default:
                    case CG.UP:
                        particle.xspeed = 0
                        particle.yspeed = this.pspeed * -1
                        particle.position.x = rnd + this.getX()
                        particle.position.y = this.position._y
                        break
                    case CG.DOWN:
                        particle.xspeed = 0
                        particle.yspeed = this.pspeed
                        particle.position.x = rnd + this.getX()
                        particle.position.y = this.position._y
                        break
                    case CG.LEFT:
                        particle.xspeed = this.pspeed * -1
                        particle.yspeed = 0
                        particle.position.x = this.position._x
                        particle.position.y = rnd + this.getY()
                        break
                    case CG.RIGHT:
                        particle.xspeed = this.pspeed
                        particle.yspeed = 0
                        particle.position.x = this.position._x
                        particle.position.y = rnd + this.getY()
                        break
                }
                break
            case 'explosion':
                particle.position.x = this.position._x
                particle.position.y = this.position._y

                particle.xspeed = this.getRandom(this.min, this.max)
                particle.yspeed = this.getRandom(this.min, this.max)
                break
            case 'point':
            default:
                particle.xspeed = 0
                particle.yspeed = 0
                particle.position.x = this.position._x
                particle.position.y = this.position._y
                break
        }
        return particle
    },
    /**
     * @method update
     */

    update: function () {
        if (this.visible) {
            this.currenttime += this.creationspeed
            //particle lifetime
            if (this.currenttime >= this.creationtime) {
                this.currenttime = 0
                if (this.particles.length < this.maxparticles) {
                    this.particles.push(this.initParticle(this.createParticle()))
                }
                else {
                    particle = this.searchInvisibleParticle()   //search inactive particle in 'pool''
                    this.initParticle(particle)
                    this.particles.sort(function (obj1, obj2) {
                            return obj1.currtime - obj2.currtime
                        }
                    )
                }
            }


            for (var i = 0, l = this.particles.length; i < l; i++) {
                this.particles[i].update()
            }
            return this
        }
    },
    /**
     * @method draw
     */
    draw: function () {
        if (this.visible) {
            for (var i = 0, l = this.particles.length; i < l; i++) {
                this.particles[i].draw()
            }
            return this
        }
    },
    /**
     * @description Each emitter has its own particle pool to prevent object deletion/creation. This method searches an inactive/invisible particle
     * @method searchInvisibleParticle
     */
    searchInvisibleParticle: function () {
        for (var i = 0, l = this.particles.length; i < l; i++) {
            if (this.particles[i].visible == false) {
                return this.particles[i]
            }
        }
        return this
    },

    /**
     * @method setEmitterPosition
     *
     * @param {CG.Point} position of the emitter
     */
    setEmitterPosition: function (position) {
        this.position = position
        return this
    },

    /**
     * @method  setName
     *
     * @param {string} name of the object for search with layerobject.getElementByName(name)
     */
    setName: function (name) {
        this.name = name
        return this
    },

    /**
     * @method setCreationTime
     *
     * @param {Number} creationtime
     */
    setCreationTime: function (creationtime) {
        this.creationtime = creationtime
        return this
    },
    /**
     * @method setMaxParticles
     *
     * @param {Number} maxparticle
     */
    setMaxParticles: function (maxparticle) {
        this.maxparticles = maxparticle
        return this
    },
    /**
     * @method setGravity
     *
     * @param {float} gravity for all emitter controlled particles
     */
    setGravity: function (gravity) {
        this.gravity = gravity
        return this
    },

    /**
     * @method setParticleSpeed
     *
     * @param {Number} speed set the speed of the particles
     */
    setParticleSpeed: function (speed) {
        this.pspeed = speed
        return this
    },

    /**
     * @method setProtation
     *
     * @param {mixed} rotation set the rotation of the particles
     */
    setProtation: function (rotation) {
        this.protation = rotation
        return this
    },

    /**
     * @method setPLifetime
     *
     * @param {Number} plifetime set the lifetime of the particles
     */
    setPLifetime: function (plifetime) {
        this.plifetime = plifetime
        return this
    },

    /**
     * @method activateFadeout
     * @description Activate fadeout of the particles depending on lifetime
     */
    activateFadeout: function () {
        this.pfadeout = true
        return this
    },

    /**
     * @method deactivateFadeout
     * @description Deactivate fadeout of the particles depending on lifetime
     */
    deactivateFadeout: function () {
        this.pfadeout = false
        return this
    },

    /**
     * @method getRandom
     *
     * @param {mixed} min value for random number
     * @param {mixed} max value for random number
     */
    getRandom: function (min, max) {
        return Math.random() * (max - min + 1) + min >> 0
    },

    /**
     * @method getX
     */
    getX: function () {
        return this.position._x
    },

    /**
     * @method getY
     */
    getY: function () {
        return this.position._y
    }
})


var COMPILED = !0, goog = goog || {};
goog.global = this;
goog.DEBUG = !1;
goog.LOCALE = "en";
goog.TRUSTED_SITE = !0;
goog.provide = function(a) {
    if (!COMPILED) {
        if (goog.isProvided_(a))
            throw Error('Namespace "' + a + '" already declared.');
        delete goog.implicitNamespaces_[a];
        for (var b = a; (b = b.substring(0, b.lastIndexOf("."))) && !goog.getObjectByName(b); )
            goog.implicitNamespaces_[b] = !0
    }
    goog.exportPath_(a)
};
goog.setTestOnly = function(a) {
    if (COMPILED && !goog.DEBUG)
        throw a = a || "", Error("Importing test-only code into non-debug environment" + a ? ": " + a : ".");
};
COMPILED || (goog.isProvided_ = function(a) {
    return!goog.implicitNamespaces_[a] && !!goog.getObjectByName(a)
}, goog.implicitNamespaces_ = {});
goog.exportPath_ = function(a, b, c) {
    a = a.split(".");
    c = c || goog.global;
    a[0]in c || !c.execScript || c.execScript("var " + a[0]);
    for (var e; a.length && (e = a.shift()); )
        !a.length && goog.isDef(b) ? c[e] = b : c = c[e] ? c[e] : c[e] = {}
};
goog.getObjectByName = function(a, b) {
    for (var c = a.split("."), e = b || goog.global, d; d = c.shift(); )
        if (goog.isDefAndNotNull(e[d]))
            e = e[d];
        else
            return null;
    return e
};
goog.globalize = function(a, b) {
    var c = b || goog.global, e;
    for (e in a)
        c[e] = a[e]
};
goog.addDependency = function(a, b, c) {
    if (!COMPILED) {
        var e;
        a = a.replace(/\\/g, "/");
        for (var d = goog.dependencies_, f = 0; e = b[f]; f++)
            d.nameToPath[e] = a, a in d.pathToNames || (d.pathToNames[a] = {}), d.pathToNames[a][e] = !0;
        for (e = 0; b = c[e]; e++)
            a in d.requires || (d.requires[a] = {}), d.requires[a][b] = !0
    }
};
goog.ENABLE_DEBUG_LOADER = !0;
goog.require = function(a) {
    if (!COMPILED && !goog.isProvided_(a)) {
        if (goog.ENABLE_DEBUG_LOADER) {
            var b = goog.getPathFromDeps_(a);
            if (b) {
                goog.included_[b] = !0;
                goog.writeScripts_();
                return
            }
        }
        a = "goog.require could not find: " + a;
        goog.global.console && goog.global.console.error(a);
        throw Error(a);
    }
};
goog.basePath = "";
goog.nullFunction = function() {
};
goog.identityFunction = function(a, b) {
    return a
};
goog.abstractMethod = function() {
    throw Error("unimplemented abstract method");
};
goog.addSingletonGetter = function(a) {
    a.getInstance = function() {
        if (a.instance_)
            return a.instance_;
        goog.DEBUG && (goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = a);
        return a.instance_ = new a
    }
};
goog.instantiatedSingletons_ = [];
!COMPILED && goog.ENABLE_DEBUG_LOADER && (goog.included_ = {}, goog.dependencies_ = {pathToNames: {}, nameToPath: {}, requires: {}, visited: {}, written: {}}, goog.inHtmlDocument_ = function() {
    var a = goog.global.document;
    return"undefined" != typeof a && "write"in a
}, goog.findBasePath_ = function() {
    if (goog.global.CLOSURE_BASE_PATH)
        goog.basePath = goog.global.CLOSURE_BASE_PATH;
    else if (goog.inHtmlDocument_())
        for (var a = goog.global.document.getElementsByTagName("script"), b = a.length - 1; 0 <= b; --b) {
            var c = a[b].src, e = c.lastIndexOf("?"), e =
                    -1 == e ? c.length : e;
            if ("base.js" == c.substr(e - 7, 7)) {
                goog.basePath = c.substr(0, e - 7);
                break
            }
        }
}, goog.importScript_ = function(a) {
    var b = goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_;
    !goog.dependencies_.written[a] && b(a) && (goog.dependencies_.written[a] = !0)
}, goog.writeScriptTag_ = function(a) {
    if (goog.inHtmlDocument_()) {
        var b = goog.global.document;
        if ("complete" == b.readyState) {
            if (/\bdeps.js$/.test(a))
                return!1;
            throw Error('Cannot write "' + a + '" after document load');
        }
        b.write('<script type="text/javascript" src="' +
                a + '">\x3c/script>');
        return!0
    }
    return!1
}, goog.writeScripts_ = function() {
    function a(d) {
        if (!(d in e.written)) {
            if (!(d in e.visited) && (e.visited[d] = !0, d in e.requires))
                for (var g in e.requires[d])
                    if (!goog.isProvided_(g))
                        if (g in e.nameToPath)
                            a(e.nameToPath[g]);
                        else
                            throw Error("Undefined nameToPath for " + g);
            d in c || (c[d] = !0, b.push(d))
        }
    }
    var b = [], c = {}, e = goog.dependencies_, d;
    for (d in goog.included_)
        e.written[d] || a(d);
    for (d = 0; d < b.length; d++)
        if (b[d])
            goog.importScript_(goog.basePath + b[d]);
        else
            throw Error("Undefined script input");
}, goog.getPathFromDeps_ = function(a) {
    return a in goog.dependencies_.nameToPath ? goog.dependencies_.nameToPath[a] : null
}, goog.findBasePath_(), goog.global.CLOSURE_NO_DEPS || goog.importScript_(goog.basePath + "deps.js"));
goog.typeOf = function(a) {
    var b = typeof a;
    if ("object" == b)
        if (a) {
            if (a instanceof Array)
                return"array";
            if (a instanceof Object)
                return b;
            var c = Object.prototype.toString.call(a);
            if ("[object Window]" == c)
                return"object";
            if ("[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("splice"))
                return"array";
            if ("[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("call"))
                return"function"
        } else
            return"null";
    else if ("function" == b && "undefined" == typeof a.call)
        return"object";
    return b
};
goog.isDef = function(a) {
    return void 0 !== a
};
goog.isNull = function(a) {
    return null === a
};
goog.isDefAndNotNull = function(a) {
    return null != a
};
goog.isArray = function(a) {
    return"array" == goog.typeOf(a)
};
goog.isArrayLike = function(a) {
    var b = goog.typeOf(a);
    return"array" == b || "object" == b && "number" == typeof a.length
};
goog.isDateLike = function(a) {
    return goog.isObject(a) && "function" == typeof a.getFullYear
};
goog.isString = function(a) {
    return"string" == typeof a
};
goog.isBoolean = function(a) {
    return"boolean" == typeof a
};
goog.isNumber = function(a) {
    return"number" == typeof a
};
goog.isFunction = function(a) {
    return"function" == goog.typeOf(a)
};
goog.isObject = function(a) {
    var b = typeof a;
    return"object" == b && null != a || "function" == b
};
goog.getUid = function(a) {
    return a[goog.UID_PROPERTY_] || (a[goog.UID_PROPERTY_] = ++goog.uidCounter_)
};
goog.removeUid = function(a) {
    "removeAttribute"in a && a.removeAttribute(goog.UID_PROPERTY_);
    try {
        delete a[goog.UID_PROPERTY_]
    } catch (b) {
    }
};
goog.UID_PROPERTY_ = "closure_uid_" + (1E9 * Math.random() >>> 0);
goog.uidCounter_ = 0;
goog.getHashCode = goog.getUid;
goog.removeHashCode = goog.removeUid;
goog.cloneObject = function(a) {
    var b = goog.typeOf(a);
    if ("object" == b || "array" == b) {
        if (a.clone)
            return a.clone();
        var b = "array" == b ? [] : {}, c;
        for (c in a)
            b[c] = goog.cloneObject(a[c]);
        return b
    }
    return a
};
goog.bindNative_ = function(a, b, c) {
    return a.call.apply(a.bind, arguments)
};
goog.bindJs_ = function(a, b, c) {
    if (!a)
        throw Error();
    if (2 < arguments.length) {
        var e = Array.prototype.slice.call(arguments, 2);
        return function() {
            var c = Array.prototype.slice.call(arguments);
            Array.prototype.unshift.apply(c, e);
            return a.apply(b, c)
        }
    }
    return function() {
        return a.apply(b, arguments)
    }
};
goog.bind = function(a, b, c) {
    Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? goog.bind = goog.bindNative_ : goog.bind = goog.bindJs_;
    return goog.bind.apply(null, arguments)
};
goog.partial = function(a, b) {
    var c = Array.prototype.slice.call(arguments, 1);
    return function() {
        var b = Array.prototype.slice.call(arguments);
        b.unshift.apply(b, c);
        return a.apply(this, b)
    }
};
goog.mixin = function(a, b) {
    for (var c in b)
        a[c] = b[c]
};
goog.now = goog.TRUSTED_SITE && Date.now || function() {
    return+new Date
};
goog.globalEval = function(a) {
    if (goog.global.execScript)
        goog.global.execScript(a, "JavaScript");
    else if (goog.global.eval)
        if (null == goog.evalWorksForGlobals_ && (goog.global.eval("var _et_ = 1;"), "undefined" != typeof goog.global._et_ ? (delete goog.global._et_, goog.evalWorksForGlobals_ = !0) : goog.evalWorksForGlobals_ = !1), goog.evalWorksForGlobals_)
            goog.global.eval(a);
        else {
            var b = goog.global.document, c = b.createElement("script");
            c.type = "text/javascript";
            c.defer = !1;
            c.appendChild(b.createTextNode(a));
            b.body.appendChild(c);
            b.body.removeChild(c)
        }
    else
        throw Error("goog.globalEval not available");
};
goog.evalWorksForGlobals_ = null;
goog.getCssName = function(a, b) {
    var c = function(a) {
        return goog.cssNameMapping_[a] || a
    }, e = function(a) {
        a = a.split("-");
        for (var b = [], e = 0; e < a.length; e++)
            b.push(c(a[e]));
        return b.join("-")
    }, e = goog.cssNameMapping_ ? "BY_WHOLE" == goog.cssNameMappingStyle_ ? c : e : function(a) {
        return a
    };
    return b ? a + "-" + e(b) : e(a)
};
goog.setCssNameMapping = function(a, b) {
    goog.cssNameMapping_ = a;
    goog.cssNameMappingStyle_ = b
};
!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING && (goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING);
goog.getMsg = function(a, b) {
    var c = b || {}, e;
    for (e in c) {
        var d = ("" + c[e]).replace(/\$/g, "$$$$");
        a = a.replace(RegExp("\\{\\$" + e + "\\}", "gi"), d)
    }
    return a
};
goog.getMsgWithFallback = function(a, b) {
    return a
};
goog.exportSymbol = function(a, b, c) {
    goog.exportPath_(a, b, c)
};
goog.exportProperty = function(a, b, c) {
    a[b] = c
};
goog.inherits = function(a, b) {
    function c() {
    }
    c.prototype = b.prototype;
    a.superClass_ = b.prototype;
    a.prototype = new c;
    a.prototype.constructor = a
};
goog.base = function(a, b, c) {
    var e = arguments.callee.caller;
    if (e.superClass_)
        return e.superClass_.constructor.apply(a, Array.prototype.slice.call(arguments, 1));
    for (var d = Array.prototype.slice.call(arguments, 2), f = !1, g = a.constructor; g; g = g.superClass_ && g.superClass_.constructor)
        if (g.prototype[b] === e)
            f = !0;
        else if (f)
            return g.prototype[b].apply(a, d);
    if (a[b] === e)
        return a.constructor.prototype[b].apply(a, d);
    throw Error("goog.base called from a method of one name to a method of a different name");
};
goog.scope = function(a) {
    a.call(goog.global)
};
goog.debug = {};
goog.debug.Error = function(a) {
    Error.captureStackTrace ? Error.captureStackTrace(this, goog.debug.Error) : this.stack = Error().stack || "";
    a && (this.message = String(a))
};
goog.inherits(goog.debug.Error, Error);
goog.debug.Error.prototype.name = "CustomError";
goog.string = {};
goog.string.Unicode = {NBSP: "\u00a0"};
goog.string.startsWith = function(a, b) {
    return 0 == a.lastIndexOf(b, 0)
};
goog.string.endsWith = function(a, b) {
    var c = a.length - b.length;
    return 0 <= c && a.indexOf(b, c) == c
};
goog.string.caseInsensitiveStartsWith = function(a, b) {
    return 0 == goog.string.caseInsensitiveCompare(b, a.substr(0, b.length))
};
goog.string.caseInsensitiveEndsWith = function(a, b) {
    return 0 == goog.string.caseInsensitiveCompare(b, a.substr(a.length - b.length, b.length))
};
goog.string.subs = function(a, b) {
    for (var c = 1; c < arguments.length; c++) {
        var e = String(arguments[c]).replace(/\$/g, "$$$$");
        a = a.replace(/\%s/, e)
    }
    return a
};
goog.string.collapseWhitespace = function(a) {
    return a.replace(/[\s\xa0]+/g, " ").replace(/^\s+|\s+$/g, "")
};
goog.string.isEmpty = function(a) {
    return/^[\s\xa0]*$/.test(a)
};
goog.string.isEmptySafe = function(a) {
    return goog.string.isEmpty(goog.string.makeSafe(a))
};
goog.string.isBreakingWhitespace = function(a) {
    return!/[^\t\n\r ]/.test(a)
};
goog.string.isAlpha = function(a) {
    return!/[^a-zA-Z]/.test(a)
};
goog.string.isNumeric = function(a) {
    return!/[^0-9]/.test(a)
};
goog.string.isAlphaNumeric = function(a) {
    return!/[^a-zA-Z0-9]/.test(a)
};
goog.string.isSpace = function(a) {
    return" " == a
};
goog.string.isUnicodeChar = function(a) {
    return 1 == a.length && " " <= a && "~" >= a || "\u0080" <= a && "\ufffd" >= a
};
goog.string.stripNewlines = function(a) {
    return a.replace(/(\r\n|\r|\n)+/g, " ")
};
goog.string.canonicalizeNewlines = function(a) {
    return a.replace(/(\r\n|\r|\n)/g, "\n")
};
goog.string.normalizeWhitespace = function(a) {
    return a.replace(/\xa0|\s/g, " ")
};
goog.string.normalizeSpaces = function(a) {
    return a.replace(/\xa0|[ \t]+/g, " ")
};
goog.string.collapseBreakingSpaces = function(a) {
    return a.replace(/[\t\r\n ]+/g, " ").replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, "")
};
goog.string.trim = function(a) {
    return a.replace(/^[\s\xa0]+|[\s\xa0]+$/g, "")
};
goog.string.trimLeft = function(a) {
    return a.replace(/^[\s\xa0]+/, "")
};
goog.string.trimRight = function(a) {
    return a.replace(/[\s\xa0]+$/, "")
};
goog.string.caseInsensitiveCompare = function(a, b) {
    var c = String(a).toLowerCase(), e = String(b).toLowerCase();
    return c < e ? -1 : c == e ? 0 : 1
};
goog.string.numerateCompareRegExp_ = /(\.\d+)|(\d+)|(\D+)/g;
goog.string.numerateCompare = function(a, b) {
    if (a == b)
        return 0;
    if (!a)
        return-1;
    if (!b)
        return 1;
    for (var c = a.toLowerCase().match(goog.string.numerateCompareRegExp_), e = b.toLowerCase().match(goog.string.numerateCompareRegExp_), d = Math.min(c.length, e.length), f = 0; f < d; f++) {
        var g = c[f], h = e[f];
        if (g != h)
            return c = parseInt(g, 10), !isNaN(c) && (e = parseInt(h, 10), !isNaN(e) && c - e) ? c - e : g < h ? -1 : 1
    }
    return c.length != e.length ? c.length - e.length : a < b ? -1 : 1
};
goog.string.urlEncode = function(a) {
    return encodeURIComponent(String(a))
};
goog.string.urlDecode = function(a) {
    return decodeURIComponent(a.replace(/\+/g, " "))
};
goog.string.newLineToBr = function(a, b) {
    return a.replace(/(\r\n|\r|\n)/g, b ? "<br />" : "<br>")
};
goog.string.htmlEscape = function(a, b) {
    if (b)
        return a.replace(goog.string.amperRe_, "&amp;").replace(goog.string.ltRe_, "&lt;").replace(goog.string.gtRe_, "&gt;").replace(goog.string.quotRe_, "&quot;");
    if (!goog.string.allRe_.test(a))
        return a;
    -1 != a.indexOf("&") && (a = a.replace(goog.string.amperRe_, "&amp;"));
    -1 != a.indexOf("<") && (a = a.replace(goog.string.ltRe_, "&lt;"));
    -1 != a.indexOf(">") && (a = a.replace(goog.string.gtRe_, "&gt;"));
    -1 != a.indexOf('"') && (a = a.replace(goog.string.quotRe_, "&quot;"));
    return a
};
goog.string.amperRe_ = /&/g;
goog.string.ltRe_ = /</g;
goog.string.gtRe_ = />/g;
goog.string.quotRe_ = /\"/g;
goog.string.allRe_ = /[&<>\"]/;
goog.string.unescapeEntities = function(a) {
    return goog.string.contains(a, "&") ? "document"in goog.global ? goog.string.unescapeEntitiesUsingDom_(a) : goog.string.unescapePureXmlEntities_(a) : a
};
goog.string.unescapeEntitiesUsingDom_ = function(a) {
    var b = {"&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"'}, c = document.createElement("div");
    return a.replace(goog.string.HTML_ENTITY_PATTERN_, function(a, d) {
        var f = b[a];
        if (f)
            return f;
        if ("#" == d.charAt(0)) {
            var g = Number("0" + d.substr(1));
            isNaN(g) || (f = String.fromCharCode(g))
        }
        f || (c.innerHTML = a + " ", f = c.firstChild.nodeValue.slice(0, -1));
        return b[a] = f
    })
};
goog.string.unescapePureXmlEntities_ = function(a) {
    return a.replace(/&([^;]+);/g, function(a, c) {
        switch (c) {
            case "amp":
                return"&";
            case "lt":
                return"<";
            case "gt":
                return">";
            case "quot":
                return'"';
            default:
                if ("#" == c.charAt(0)) {
                    var e = Number("0" + c.substr(1));
                    if (!isNaN(e))
                        return String.fromCharCode(e)
                }
                return a
            }
    })
};
goog.string.HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g;
goog.string.whitespaceEscape = function(a, b) {
    return goog.string.newLineToBr(a.replace(/  /g, " &#160;"), b)
};
goog.string.stripQuotes = function(a, b) {
    for (var c = b.length, e = 0; e < c; e++) {
        var d = 1 == c ? b : b.charAt(e);
        if (a.charAt(0) == d && a.charAt(a.length - 1) == d)
            return a.substring(1, a.length - 1)
    }
    return a
};
goog.string.truncate = function(a, b, c) {
    c && (a = goog.string.unescapeEntities(a));
    a.length > b && (a = a.substring(0, b - 3) + "...");
    c && (a = goog.string.htmlEscape(a));
    return a
};
goog.string.truncateMiddle = function(a, b, c, e) {
    c && (a = goog.string.unescapeEntities(a));
    if (e && a.length > b) {
        e > b && (e = b);
        var d = a.length - e;
        a = a.substring(0, b - e) + "..." + a.substring(d)
    } else
        a.length > b && (e = Math.floor(b / 2), d = a.length - e, a = a.substring(0, e + b % 2) + "..." + a.substring(d));
    c && (a = goog.string.htmlEscape(a));
    return a
};
goog.string.specialEscapeChars_ = {"\x00": "\\0", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "\t": "\\t", "\x0B": "\\x0B", '"': '\\"', "\\": "\\\\"};
goog.string.jsEscapeCache_ = {"'": "\\'"};
goog.string.quote = function(a) {
    a = String(a);
    if (a.quote)
        return a.quote();
    for (var b = ['"'], c = 0; c < a.length; c++) {
        var e = a.charAt(c), d = e.charCodeAt(0);
        b[c + 1] = goog.string.specialEscapeChars_[e] || (31 < d && 127 > d ? e : goog.string.escapeChar(e))
    }
    b.push('"');
    return b.join("")
};
goog.string.escapeString = function(a) {
    for (var b = [], c = 0; c < a.length; c++)
        b[c] = goog.string.escapeChar(a.charAt(c));
    return b.join("")
};
goog.string.escapeChar = function(a) {
    if (a in goog.string.jsEscapeCache_)
        return goog.string.jsEscapeCache_[a];
    if (a in goog.string.specialEscapeChars_)
        return goog.string.jsEscapeCache_[a] = goog.string.specialEscapeChars_[a];
    var b = a, c = a.charCodeAt(0);
    if (31 < c && 127 > c)
        b = a;
    else {
        if (256 > c) {
            if (b = "\\x", 16 > c || 256 < c)
                b += "0"
        } else
            b = "\\u", 4096 > c && (b += "0");
        b += c.toString(16).toUpperCase()
    }
    return goog.string.jsEscapeCache_[a] = b
};
goog.string.toMap = function(a) {
    for (var b = {}, c = 0; c < a.length; c++)
        b[a.charAt(c)] = !0;
    return b
};
goog.string.contains = function(a, b) {
    return-1 != a.indexOf(b)
};
goog.string.countOf = function(a, b) {
    return a && b ? a.split(b).length - 1 : 0
};
goog.string.removeAt = function(a, b, c) {
    var e = a;
    0 <= b && (b < a.length && 0 < c) && (e = a.substr(0, b) + a.substr(b + c, a.length - b - c));
    return e
};
goog.string.remove = function(a, b) {
    var c = RegExp(goog.string.regExpEscape(b), "");
    return a.replace(c, "")
};
goog.string.removeAll = function(a, b) {
    var c = RegExp(goog.string.regExpEscape(b), "g");
    return a.replace(c, "")
};
goog.string.regExpEscape = function(a) {
    return String(a).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08")
};
goog.string.repeat = function(a, b) {
    return Array(b + 1).join(a)
};
goog.string.padNumber = function(a, b, c) {
    a = goog.isDef(c) ? a.toFixed(c) : String(a);
    c = a.indexOf(".");
    -1 == c && (c = a.length);
    return goog.string.repeat("0", Math.max(0, b - c)) + a
};
goog.string.makeSafe = function(a) {
    return null == a ? "" : String(a)
};
goog.string.buildString = function(a) {
    return Array.prototype.join.call(arguments, "")
};
goog.string.getRandomString = function() {
    return Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ goog.now()).toString(36)
};
goog.string.compareVersions = function(a, b) {
    for (var c = 0, e = goog.string.trim(String(a)).split("."), d = goog.string.trim(String(b)).split("."), f = Math.max(e.length, d.length), g = 0; 0 == c && g < f; g++) {
        var h = e[g] || "", l = d[g] || "", k = RegExp("(\\d*)(\\D*)", "g"), m = RegExp("(\\d*)(\\D*)", "g");
        do {
            var n = k.exec(h) || ["", "", ""], p = m.exec(l) || ["", "", ""];
            if (0 == n[0].length && 0 == p[0].length)
                break;
            var c = 0 == n[1].length ? 0 : parseInt(n[1], 10), q = 0 == p[1].length ? 0 : parseInt(p[1], 10), c = goog.string.compareElements_(c, q) || goog.string.compareElements_(0 ==
                    n[2].length, 0 == p[2].length) || goog.string.compareElements_(n[2], p[2])
        } while (0 == c)
    }
    return c
};
goog.string.compareElements_ = function(a, b) {
    return a < b ? -1 : a > b ? 1 : 0
};
goog.string.HASHCODE_MAX_ = 4294967296;
goog.string.hashCode = function(a) {
    for (var b = 0, c = 0; c < a.length; ++c)
        b = 31 * b + a.charCodeAt(c), b %= goog.string.HASHCODE_MAX_;
    return b
};
goog.string.uniqueStringCounter_ = 2147483648 * Math.random() | 0;
goog.string.createUniqueString = function() {
    return"goog_" + goog.string.uniqueStringCounter_++
};
goog.string.toNumber = function(a) {
    var b = Number(a);
    return 0 == b && goog.string.isEmpty(a) ? NaN : b
};
goog.string.toCamelCase = function(a) {
    return String(a).replace(/\-([a-z])/g, function(a, c) {
        return c.toUpperCase()
    })
};
goog.string.toSelectorCase = function(a) {
    return String(a).replace(/([A-Z])/g, "-$1").toLowerCase()
};
goog.string.toTitleCase = function(a, b) {
    var c = goog.isString(b) ? goog.string.regExpEscape(b) : "\\s";
    return a.replace(RegExp("(^" + (c ? "|[" + c + "]+" : "") + ")([a-z])", "g"), function(a, b, c) {
        return b + c.toUpperCase()
    })
};
goog.string.parseInt = function(a) {
    isFinite(a) && (a = String(a));
    return goog.isString(a) ? /^\s*-?0x/i.test(a) ? parseInt(a, 16) : parseInt(a, 10) : NaN
};
goog.asserts = {};
goog.asserts.ENABLE_ASSERTS = goog.DEBUG;
goog.asserts.AssertionError = function(a, b) {
    b.unshift(a);
    goog.debug.Error.call(this, goog.string.subs.apply(null, b));
    b.shift();
    this.messagePattern = a
};
goog.inherits(goog.asserts.AssertionError, goog.debug.Error);
goog.asserts.AssertionError.prototype.name = "AssertionError";
goog.asserts.doAssertFailure_ = function(a, b, c, e) {
    var d = "Assertion failed";
    if (c)
        var d = d + (": " + c), f = e;
    else
        a && (d += ": " + a, f = b);
    throw new goog.asserts.AssertionError("" + d, f || []);
};
goog.asserts.assert = function(a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !a && goog.asserts.doAssertFailure_("", null, b, Array.prototype.slice.call(arguments, 2));
    return a
};
goog.asserts.fail = function(a, b) {
    if (goog.asserts.ENABLE_ASSERTS)
        throw new goog.asserts.AssertionError("Failure" + (a ? ": " + a : ""), Array.prototype.slice.call(arguments, 1));
};
goog.asserts.assertNumber = function(a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isNumber(a) && goog.asserts.doAssertFailure_("Expected number but got %s: %s.", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));
    return a
};
goog.asserts.assertString = function(a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isString(a) && goog.asserts.doAssertFailure_("Expected string but got %s: %s.", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));
    return a
};
goog.asserts.assertFunction = function(a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isFunction(a) && goog.asserts.doAssertFailure_("Expected function but got %s: %s.", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));
    return a
};
goog.asserts.assertObject = function(a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isObject(a) && goog.asserts.doAssertFailure_("Expected object but got %s: %s.", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));
    return a
};
goog.asserts.assertArray = function(a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isArray(a) && goog.asserts.doAssertFailure_("Expected array but got %s: %s.", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));
    return a
};
goog.asserts.assertBoolean = function(a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isBoolean(a) && goog.asserts.doAssertFailure_("Expected boolean but got %s: %s.", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));
    return a
};
goog.asserts.assertInstanceof = function(a, b, c, e) {
    !goog.asserts.ENABLE_ASSERTS || a instanceof b || goog.asserts.doAssertFailure_("instanceof check failed.", null, c, Array.prototype.slice.call(arguments, 3));
    return a
};
goog.string.format = function(a, b) {
    var c = Array.prototype.slice.call(arguments), e = c.shift();
    if ("undefined" == typeof e)
        throw Error("[goog.string.format] Template required");
    return e.replace(/%([0\-\ \+]*)(\d+)?(\.(\d+))?([%sfdiu])/g, function(a, b, e, h, l, k, m, n) {
        if ("%" == k)
            return"%";
        var p = c.shift();
        if ("undefined" == typeof p)
            throw Error("[goog.string.format] Not enough arguments");
        arguments[0] = p;
        return goog.string.format.demuxes_[k].apply(null, arguments)
    })
};
goog.string.format.demuxes_ = {};
goog.string.format.demuxes_.s = function(a, b, c, e, d, f, g, h) {
    return isNaN(c) || "" == c || a.length >= c ? a : a = -1 < b.indexOf("-", 0) ? a + goog.string.repeat(" ", c - a.length) : goog.string.repeat(" ", c - a.length) + a
};
goog.string.format.demuxes_.f = function(a, b, c, e, d, f, g, h) {
    e = a.toString();
    isNaN(d) || "" == d || (e = a.toFixed(d));
    f = 0 > a ? "-" : 0 <= b.indexOf("+") ? "+" : 0 <= b.indexOf(" ") ? " " : "";
    0 <= a && (e = f + e);
    if (isNaN(c) || e.length >= c)
        return e;
    e = isNaN(d) ? Math.abs(a).toString() : Math.abs(a).toFixed(d);
    a = c - e.length - f.length;
    0 <= b.indexOf("-", 0) ? e = f + e + goog.string.repeat(" ", a) : (b = 0 <= b.indexOf("0", 0) ? "0" : " ", e = f + goog.string.repeat(b, a) + e);
    return e
};
goog.string.format.demuxes_.d = function(a, b, c, e, d, f, g, h) {
    return goog.string.format.demuxes_.f(parseInt(a, 10), b, c, e, 0, f, g, h)
};
goog.string.format.demuxes_.i = goog.string.format.demuxes_.d;
goog.string.format.demuxes_.u = goog.string.format.demuxes_.d;
var box2d = {b2Settings: {}};
Object.defineProperty || (Object.defineProperty = function(a, b, c) {
    Object.__defineGetter__ && ("get"in c ? a.__defineGetter__(b, c.get) : "value"in c && a.__defineGetter__(b, c.value));
    Object.__defineSetter__ && ("set"in c ? a.__defineSetter__(b, c.set) : "value"in c && a.__defineSetter__(b, c.value))
});
box2d.DEBUG = !1;
goog.exportSymbol("box2d.DEBUG", box2d.DEBUG);
box2d.ENABLE_ASSERTS = box2d.DEBUG;
goog.exportSymbol("box2d.ENABLE_ASSERTS", box2d.ENABLE_ASSERTS);
box2d.b2Assert = function(a, b, c) {
    if (box2d.DEBUG && !a)
        debugger
};
goog.exportSymbol("box2d.b2Assert", box2d.b2Assert);
box2d.b2_maxFloat = 1E37;
goog.exportSymbol("box2d.b2_maxFloat", box2d.b2_maxFloat);
box2d.b2_epsilon = 1E-5;
goog.exportSymbol("box2d.b2_epsilon", box2d.b2_epsilon);
box2d.b2_epsilon_sq = box2d.b2_epsilon * box2d.b2_epsilon;
goog.exportSymbol("box2d.b2_epsilon_sq", box2d.b2_epsilon_sq);
box2d.b2_pi = Math.PI;
goog.exportSymbol("box2d.b2_pi", box2d.b2_pi);
box2d.b2_maxManifoldPoints = 2;
goog.exportSymbol("box2d.b2_maxManifoldPoints", box2d.b2_maxManifoldPoints);
box2d.b2_maxPolygonVertices = 8;
goog.exportSymbol("box2d.b2_maxPolygonVertices", box2d.b2_maxPolygonVertices);
box2d.b2_aabbExtension = 0.1;
goog.exportSymbol("box2d.b2_aabbExtension", box2d.b2_aabbExtension);
box2d.b2_aabbMultiplier = 2;
goog.exportSymbol("box2d.b2_aabbMultiplier", box2d.b2_aabbMultiplier);
box2d.b2_linearSlop = 0.008;
goog.exportSymbol("box2d.b2_linearSlop", box2d.b2_linearSlop);
box2d.b2_angularSlop = 2 / 180 * box2d.b2_pi;
goog.exportSymbol("box2d.b2_angularSlop", box2d.b2_angularSlop);
box2d.b2_polygonRadius = 2 * box2d.b2_linearSlop;
goog.exportSymbol("box2d.b2_polygonRadius", box2d.b2_polygonRadius);
box2d.b2_maxSubSteps = 8;
goog.exportSymbol("box2d.b2_maxSubSteps", box2d.b2_maxSubSteps);
box2d.b2_maxTOIContacts = 32;
goog.exportSymbol("box2d.b2_maxTOIContacts", box2d.b2_maxTOIContacts);
box2d.b2_velocityThreshold = 1;
goog.exportSymbol("box2d.b2_velocityThreshold", box2d.b2_velocityThreshold);
box2d.b2_maxLinearCorrection = 0.2;
goog.exportSymbol("box2d.b2_maxLinearCorrection", box2d.b2_maxLinearCorrection);
box2d.b2_maxAngularCorrection = 8 / 180 * box2d.b2_pi;
goog.exportSymbol("box2d.b2_maxAngularCorrection", box2d.b2_maxAngularCorrection);
box2d.b2_maxTranslation = 2;
goog.exportSymbol("box2d.b2_maxTranslation", box2d.b2_maxTranslation);
box2d.b2_maxTranslationSquared = box2d.b2_maxTranslation * box2d.b2_maxTranslation;
goog.exportSymbol("box2d.b2_maxTranslationSquared", box2d.b2_maxTranslationSquared);
box2d.b2_maxRotation = 0.5 * box2d.b2_pi;
goog.exportSymbol("box2d.b2_maxRotation", box2d.b2_maxRotation);
box2d.b2_maxRotationSquared = box2d.b2_maxRotation * box2d.b2_maxRotation;
goog.exportSymbol("box2d.b2_maxRotationSquared", box2d.b2_maxRotationSquared);
box2d.b2_baumgarte = 0.2;
goog.exportSymbol("box2d.b2_baumgarte", box2d.b2_baumgarte);
box2d.b2_toiBaumgarte = 0.75;
goog.exportSymbol("box2d.b2_toiBaumgarte", box2d.b2_toiBaumgarte);
box2d.b2_timeToSleep = 0.5;
goog.exportSymbol("box2d.b2_timeToSleep", box2d.b2_timeToSleep);
box2d.b2_linearSleepTolerance = 0.01;
goog.exportSymbol("box2d.b2_linearSleepTolerance", box2d.b2_linearSleepTolerance);
box2d.b2_angularSleepTolerance = 2 / 180 * box2d.b2_pi;
goog.exportSymbol("box2d.b2_angularSleepTolerance", box2d.b2_angularSleepTolerance);
box2d.b2Alloc = function(a) {
    return null
};
goog.exportSymbol("box2d.b2Alloc", box2d.b2Alloc);
box2d.b2Free = function(a) {
};
goog.exportSymbol("box2d.b2Free", box2d.b2Free);
box2d.b2Log = function(a, b) {
    var c = Array.prototype.slice.call(arguments), c = goog.string.format.apply(null, c.slice(0));
    goog.global.console.log(c)
};
goog.exportSymbol("box2d.b2Log", box2d.b2Log);
box2d.b2Version = function(a, b, c) {
    this.major = a || 0;
    this.minor = b || 0;
    this.revision = c || 0
};
goog.exportSymbol("box2d.b2Version", box2d.b2Version);
box2d.b2Version.prototype.major = 0;
goog.exportProperty(box2d.b2Version.prototype, "major", box2d.b2Version.prototype.major);
box2d.b2Version.prototype.minor = 0;
goog.exportProperty(box2d.b2Version.prototype, "minor", box2d.b2Version.prototype.minor);
box2d.b2Version.prototype.revision = 0;
goog.exportProperty(box2d.b2Version.prototype, "revision", box2d.b2Version.prototype.revision);
box2d.b2Version.prototype.toString = function() {
    return this.major + "." + this.minor + "." + this.revision
};
goog.exportProperty(box2d.b2Version.prototype, "toString", box2d.b2Version.prototype.toString);
box2d.b2_version = new box2d.b2Version(2, 3, 0);
goog.exportSymbol("box2d.b2_version", box2d.b2_version);
box2d.b2_changelist = 254;
goog.exportSymbol("box2d.b2_changelist", box2d.b2_changelist);
box2d.b2ParseInt = function(a) {
    return parseInt(a, 10)
};
goog.exportSymbol("box2d.b2ParseInt", box2d.b2ParseInt);
box2d.b2ParseUInt = function(a) {
    return box2d.b2Abs(parseInt(a, 10))
};
goog.exportSymbol("box2d.b2ParseUInt", box2d.b2ParseUInt);
box2d.b2MakeArray = function(a, b) {
    void 0 === a && (a = 0);
    var c = Array(a);
    if (void 0 !== b)
        for (var e = 0; e < a; ++e)
            c[e] = b(e);
    return c
};
goog.exportSymbol("box2d.b2MakeArray", box2d.b2MakeArray);
box2d.b2MakeNumberArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return 0
    })
};
goog.exportSymbol("box2d.b2MakeNumberArray", box2d.b2MakeNumberArray);
box2d.b2Math = {};
box2d.b2_pi_over_180 = box2d.b2_pi / 180;
goog.exportSymbol("box2d.b2_pi_over_180", box2d.b2_pi_over_180);
box2d.b2_180_over_pi = 180 / box2d.b2_pi;
goog.exportSymbol("box2d.b2_180_over_pi", box2d.b2_180_over_pi);
box2d.b2_two_pi = 2 * box2d.b2_pi;
goog.exportSymbol("box2d.b2_two_pi", box2d.b2_two_pi);
box2d.b2Abs = function(a) {
    return 0 > a ? -a : a
};
goog.exportSymbol("box2d.b2Abs", box2d.b2Abs);
box2d.b2Min = function(a, b) {
    return a < b ? a : b
};
goog.exportSymbol("box2d.b2Min", box2d.b2Min);
box2d.b2Max = function(a, b) {
    return a > b ? a : b
};
goog.exportSymbol("box2d.b2Max", box2d.b2Max);
box2d.b2Clamp = function(a, b, c) {
    return a < b ? b : a > c ? c : a
};
goog.exportSymbol("box2d.b2Clamp", box2d.b2Clamp);
box2d.b2Swap = function(a, b) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1);
    var c = a[0];
    a[0] = b[0];
    b[0] = c
};
goog.exportSymbol("box2d.b2Swap", box2d.b2Swap);
box2d.b2IsValid = function(a) {
    return isFinite(a)
};
goog.exportSymbol("box2d.b2IsValid", box2d.b2IsValid);
box2d.b2Sq = function(a) {
    return a * a
};
goog.exportSymbol("box2d.b2Sq", box2d.b2Sq);
box2d.b2InvSqrt = function(a) {
    return 1 / Math.sqrt(a)
};
goog.exportSymbol("box2d.b2InvSqrt", box2d.b2InvSqrt);
box2d.b2Sqrt = function(a) {
    return Math.sqrt(a)
};
goog.exportSymbol("box2d.b2Sqrt", box2d.b2Sqrt);
box2d.b2Pow = function(a, b) {
    return Math.pow(a, b)
};
goog.exportSymbol("box2d.b2Pow", box2d.b2Pow);
box2d.b2DegToRad = function(a) {
    return a * box2d.b2_pi_over_180
};
goog.exportSymbol("box2d.b2DegToRad", box2d.b2DegToRad);
box2d.b2RadToDeg = function(a) {
    return a * box2d.b2_180_over_pi
};
goog.exportSymbol("box2d.b2RadToDeg", box2d.b2RadToDeg);
box2d.b2Cos = function(a) {
    return Math.cos(a)
};
goog.exportSymbol("box2d.b2Cos", box2d.b2Cos);
box2d.b2Sin = function(a) {
    return Math.sin(a)
};
goog.exportSymbol("box2d.b2Sin", box2d.b2Sin);
box2d.b2Acos = function(a) {
    return Math.acos(a)
};
goog.exportSymbol("box2d.b2Acos", box2d.b2Acos);
box2d.b2Asin = function(a) {
    return Math.asin(a)
};
goog.exportSymbol("box2d.b2Asin", box2d.b2Asin);
box2d.b2Atan2 = function(a, b) {
    return Math.atan2(a, b)
};
goog.exportSymbol("box2d.b2Atan2", box2d.b2Atan2);
box2d.b2NextPowerOfTwo = function(a) {
    a |= a >> 1 & 2147483647;
    a |= a >> 2 & 1073741823;
    a |= a >> 4 & 268435455;
    a |= a >> 8 & 16777215;
    return(a | a >> 16 & 65535) + 1
};
goog.exportSymbol("box2d.b2NextPowerOfTwo", box2d.b2NextPowerOfTwo);
box2d.b2IsPowerOfTwo = function(a) {
    return 0 < a && 0 == (a & a - 1)
};
goog.exportSymbol("box2d.b2IsPowerOfTwo", box2d.b2IsPowerOfTwo);
box2d.b2Random = function() {
    return 2 * Math.random() - 1
};
goog.exportSymbol("box2d.b2Random", box2d.b2Random);
box2d.b2RandomRange = function(a, b) {
    return(b - a) * Math.random() + a
};
goog.exportSymbol("box2d.b2RandomRange", box2d.b2RandomRange);
box2d.b2Vec2 = function(a, b) {
    this.x = a || 0;
    this.y = b || 0
};
goog.exportSymbol("box2d.b2Vec2", box2d.b2Vec2);
box2d.b2Vec2.prototype.x = 0;
goog.exportProperty(box2d.b2Vec2.prototype, "x", box2d.b2Vec2.prototype.x);
box2d.b2Vec2.prototype.y = 0;
goog.exportProperty(box2d.b2Vec2.prototype, "y", box2d.b2Vec2.prototype.y);
box2d.b2Vec2_zero = new box2d.b2Vec2;
goog.exportSymbol("box2d.b2Vec2_zero", box2d.b2Vec2_zero);
box2d.b2Vec2.ZERO = new box2d.b2Vec2;
goog.exportProperty(box2d.b2Vec2, "ZERO", box2d.b2Vec2.ZERO);
box2d.b2Vec2.UNITX = new box2d.b2Vec2(1, 0);
goog.exportProperty(box2d.b2Vec2, "UNITX", box2d.b2Vec2.UNITX);
box2d.b2Vec2.UNITY = new box2d.b2Vec2(0, 1);
goog.exportProperty(box2d.b2Vec2, "UNITY", box2d.b2Vec2.UNITY);
box2d.b2Vec2.s_t0 = new box2d.b2Vec2;
goog.exportProperty(box2d.b2Vec2, "s_t0", box2d.b2Vec2.s_t0);
box2d.b2Vec2.s_t1 = new box2d.b2Vec2;
goog.exportProperty(box2d.b2Vec2, "s_t1", box2d.b2Vec2.s_t1);
box2d.b2Vec2.s_t2 = new box2d.b2Vec2;
goog.exportProperty(box2d.b2Vec2, "s_t2", box2d.b2Vec2.s_t2);
box2d.b2Vec2.s_t3 = new box2d.b2Vec2;
goog.exportProperty(box2d.b2Vec2, "s_t3", box2d.b2Vec2.s_t3);
box2d.b2Vec2.MakeArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return new box2d.b2Vec2
    })
};
goog.exportProperty(box2d.b2Vec2, "MakeArray", box2d.b2Vec2.MakeArray);
box2d.b2Vec2.prototype.Clone = function() {
    return new box2d.b2Vec2(this.x, this.y)
};
goog.exportProperty(box2d.b2Vec2.prototype, "Clone", box2d.b2Vec2.prototype.Clone);
box2d.b2Vec2.prototype.SetZero = function() {
    this.y = this.x = 0;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SetZero", box2d.b2Vec2.prototype.SetZero);
box2d.b2Vec2.prototype.SetXY = function(a, b) {
    this.x = a;
    this.y = b;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SetXY", box2d.b2Vec2.prototype.SetXY);
box2d.b2Vec2.prototype.Copy = function(a) {
    this.x = a.x;
    this.y = a.y;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "Copy", box2d.b2Vec2.prototype.Copy);
box2d.b2Vec2.prototype.SelfAdd = function(a) {
    this.x += a.x;
    this.y += a.y;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfAdd", box2d.b2Vec2.prototype.SelfAdd);
box2d.b2Vec2.prototype.SelfAddXY = function(a, b) {
    this.x += a;
    this.y += b;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfAddXY", box2d.b2Vec2.prototype.SelfAddXY);
box2d.b2Vec2.prototype.SelfSub = function(a) {
    this.x -= a.x;
    this.y -= a.y;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfSub", box2d.b2Vec2.prototype.SelfSub);
box2d.b2Vec2.prototype.SelfSubXY = function(a, b) {
    this.x -= a;
    this.y -= b;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfSubXY", box2d.b2Vec2.prototype.SelfSubXY);
box2d.b2Vec2.prototype.SelfMul = function(a) {
    this.x *= a;
    this.y *= a;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfMul", box2d.b2Vec2.prototype.SelfMul);
box2d.b2Vec2.prototype.SelfMulAdd = function(a, b) {
    this.x += a * b.x;
    this.y += a * b.y;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfMulAdd", box2d.b2Vec2.prototype.SelfMulAdd);
box2d.b2Vec2.prototype.SelfMulSub = function(a, b) {
    this.x -= a * b.x;
    this.y -= a * b.y;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfMulSub", box2d.b2Vec2.prototype.SelfMulSub);
box2d.b2Vec2.prototype.Dot = function(a) {
    return this.x * a.x + this.y * a.y
};
goog.exportProperty(box2d.b2Vec2.prototype, "Dot", box2d.b2Vec2.prototype.Dot);
box2d.b2Vec2.prototype.Cross = function(a) {
    return this.x * a.y - this.y * a.x
};
goog.exportProperty(box2d.b2Vec2.prototype, "Cross", box2d.b2Vec2.prototype.Cross);
box2d.b2Vec2.prototype.GetLength = function() {
    var a = this.x, b = this.y;
    return Math.sqrt(a * a + b * b)
};
goog.exportProperty(box2d.b2Vec2.prototype, "GetLength", box2d.b2Vec2.prototype.GetLength);
box2d.b2Vec2.prototype.GetLengthSquared = function() {
    var a = this.x, b = this.y;
    return a * a + b * b
};
goog.exportProperty(box2d.b2Vec2.prototype, "GetLengthSquared", box2d.b2Vec2.prototype.GetLengthSquared);
box2d.b2Vec2.prototype.Normalize = function() {
    var a = this.GetLength();
    if (a >= box2d.b2_epsilon) {
        var b = 1 / a;
        this.x *= b;
        this.y *= b
    }
    return a
};
goog.exportProperty(box2d.b2Vec2.prototype, "Normalize", box2d.b2Vec2.prototype.Normalize);
box2d.b2Vec2.prototype.SelfNormalize = function() {
    var a = this.GetLength();
    a >= box2d.b2_epsilon && (a = 1 / a, this.x *= a, this.y *= a);
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfNormalize", box2d.b2Vec2.prototype.SelfNormalize);
box2d.b2Vec2.prototype.SelfRotate = function(a, b) {
    var c = this.x, e = this.y;
    this.x = a * c - b * e;
    this.y = b * c + a * e;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfRotate", box2d.b2Vec2.prototype.SelfRotate);
box2d.b2Vec2.prototype.SelfRotateRadians = function(a) {
    return this.SelfRotate(Math.cos(a), Math.sin(a))
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfRotateRadians", box2d.b2Vec2.prototype.SelfRotateRadians);
box2d.b2Vec2.prototype.SelfRotateDegrees = function(a) {
    return this.SelfRotateRadians(box2d.b2DegToRad(a))
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfRotateDegrees", box2d.b2Vec2.prototype.SelfRotateDegrees);
box2d.b2Vec2.prototype.IsValid = function() {
    return isFinite(this.x) && isFinite(this.y)
};
goog.exportProperty(box2d.b2Vec2.prototype, "IsValid", box2d.b2Vec2.prototype.IsValid);
box2d.b2Vec2.prototype.SelfCrossVS = function(a) {
    var b = this.x;
    this.x = a * this.y;
    this.y = -a * b;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfCrossVS", box2d.b2Vec2.prototype.SelfCrossVS);
box2d.b2Vec2.prototype.SelfCrossSV = function(a) {
    var b = this.x;
    this.x = -a * this.y;
    this.y = a * b;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfCrossSV", box2d.b2Vec2.prototype.SelfCrossSV);
box2d.b2Vec2.prototype.SelfMinV = function(a) {
    this.x = box2d.b2Min(this.x, a.x);
    this.y = box2d.b2Min(this.y, a.y);
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfMinV", box2d.b2Vec2.prototype.SelfMinV);
box2d.b2Vec2.prototype.SelfMaxV = function(a) {
    this.x = box2d.b2Max(this.x, a.x);
    this.y = box2d.b2Max(this.y, a.y);
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfMaxV", box2d.b2Vec2.prototype.SelfMaxV);
box2d.b2Vec2.prototype.SelfAbs = function() {
    this.x = box2d.b2Abs(this.x);
    this.y = box2d.b2Abs(this.y);
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfAbs", box2d.b2Vec2.prototype.SelfAbs);
box2d.b2Vec2.prototype.SelfNeg = function() {
    this.x = -this.x;
    this.y = -this.y;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfNeg", box2d.b2Vec2.prototype.SelfNeg);
box2d.b2Vec2.prototype.SelfSkew = function() {
    var a = this.x;
    this.x = -this.y;
    this.y = a;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfSkew", box2d.b2Vec2.prototype.SelfSkew);
box2d.b2AbsV = function(a, b) {
    b.x = box2d.b2Abs(a.x);
    b.y = box2d.b2Abs(a.y);
    return b
};
goog.exportSymbol("box2d.b2AbsV", box2d.b2AbsV);
box2d.b2MinV = function(a, b, c) {
    c.x = box2d.b2Min(a.x, b.x);
    c.y = box2d.b2Min(a.y, b.y);
    return c
};
goog.exportSymbol("box2d.b2MinV", box2d.b2MinV);
box2d.b2MaxV = function(a, b, c) {
    c.x = box2d.b2Max(a.x, b.x);
    c.y = box2d.b2Max(a.y, b.y);
    return c
};
goog.exportSymbol("box2d.b2MaxV", box2d.b2MaxV);
box2d.b2ClampV = function(a, b, c, e) {
    e.x = box2d.b2Clamp(a.x, b.x, c.x);
    e.y = box2d.b2Clamp(a.y, b.y, c.y);
    return e
};
goog.exportSymbol("box2d.b2ClampV", box2d.b2ClampV);
box2d.b2RotateV = function(a, b, c, e) {
    var d = a.x;
    a = a.y;
    e.x = b * d - c * a;
    e.y = c * d + b * a;
    return e
};
goog.exportSymbol("box2d.b2RotateV", box2d.b2RotateV);
box2d.b2RotateRadiansV = function(a, b, c) {
    return box2d.b2RotateV(a, Math.cos(b), Math.sin(b), c)
};
goog.exportSymbol("box2d.b2RotateRadiansV", box2d.b2RotateRadiansV);
box2d.b2RotateDegreesV = function(a, b, c) {
    return box2d.b2RotateRadiansV(a, box2d.b2DegToRad(b), c)
};
goog.exportSymbol("box2d.b2RotateDegreesV", box2d.b2RotateDegreesV);
box2d.b2DotVV = function(a, b) {
    return a.x * b.x + a.y * b.y
};
goog.exportSymbol("box2d.b2DotVV", box2d.b2DotVV);
box2d.b2CrossVV = function(a, b) {
    return a.x * b.y - a.y * b.x
};
goog.exportSymbol("box2d.b2CrossVV", box2d.b2CrossVV);
box2d.b2CrossVS = function(a, b, c) {
    var e = a.x;
    c.x = b * a.y;
    c.y = -b * e;
    return c
};
goog.exportSymbol("box2d.b2CrossVS", box2d.b2CrossVS);
box2d.b2CrossVOne = function(a, b) {
    var c = a.x;
    b.x = a.y;
    b.y = -c;
    return b
};
goog.exportSymbol("box2d.b2CrossVOne", box2d.b2CrossVOne);
box2d.b2CrossSV = function(a, b, c) {
    var e = b.x;
    c.x = -a * b.y;
    c.y = a * e;
    return c
};
goog.exportSymbol("box2d.b2CrossSV", box2d.b2CrossSV);
box2d.b2CrossOneV = function(a, b) {
    var c = a.x;
    b.x = -a.y;
    b.y = c;
    return b
};
goog.exportSymbol("box2d.b2CrossOneV", box2d.b2CrossOneV);
box2d.b2AddVV = function(a, b, c) {
    c.x = a.x + b.x;
    c.y = a.y + b.y;
    return c
};
goog.exportSymbol("box2d.b2AddVV", box2d.b2AddVV);
box2d.b2SubVV = function(a, b, c) {
    c.x = a.x - b.x;
    c.y = a.y - b.y;
    return c
};
goog.exportSymbol("box2d.b2SubVV", box2d.b2SubVV);
box2d.b2MulSV = function(a, b, c) {
    c.x = b.x * a;
    c.y = b.y * a;
    return c
};
goog.exportSymbol("box2d.b2MulSV", box2d.b2MulSV);
box2d.b2AddVMulSV = function(a, b, c, e) {
    e.x = a.x + b * c.x;
    e.y = a.y + b * c.y;
    return e
};
goog.exportSymbol("box2d.b2AddVMulSV", box2d.b2AddVMulSV);
box2d.b2SubVMulSV = function(a, b, c, e) {
    e.x = a.x - b * c.x;
    e.y = a.y - b * c.y;
    return e
};
goog.exportSymbol("box2d.b2SubVMulSV", box2d.b2SubVMulSV);
box2d.b2AddVCrossSV = function(a, b, c, e) {
    var d = c.x;
    e.x = a.x - b * c.y;
    e.y = a.y + b * d;
    return e
};
goog.exportSymbol("box2d.b2AddVCrossSV", box2d.b2AddVCrossSV);
box2d.b2MidVV = function(a, b, c) {
    c.x = 0.5 * (a.x + b.x);
    c.y = 0.5 * (a.y + b.y);
    return c
};
goog.exportSymbol("box2d.b2MidVV", box2d.b2MidVV);
box2d.b2ExtVV = function(a, b, c) {
    c.x = 0.5 * (b.x - a.x);
    c.y = 0.5 * (b.y - a.y);
    return c
};
goog.exportSymbol("box2d.b2ExtVV", box2d.b2ExtVV);
box2d.b2IsEqualToV = function(a, b) {
    return a.x == b.x && a.y == b.y
};
goog.exportSymbol("box2d.b2IsEqualToV", box2d.b2IsEqualToV);
box2d.b2DistanceVV = function(a, b) {
    var c = a.x - b.x, e = a.y - b.y;
    return Math.sqrt(c * c + e * e)
};
goog.exportSymbol("box2d.b2DistanceVV", box2d.b2DistanceVV);
box2d.b2DistanceSquaredVV = function(a, b) {
    var c = a.x - b.x, e = a.y - b.y;
    return c * c + e * e
};
goog.exportSymbol("box2d.b2DistanceSquaredVV", box2d.b2DistanceSquaredVV);
box2d.b2NegV = function(a, b) {
    b.x = -a.x;
    b.y = -a.y;
    return b
};
goog.exportSymbol("box2d.b2NegV", box2d.b2NegV);
box2d.b2Vec3 = function(a, b, c) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = c || 0
};
goog.exportSymbol("box2d.b2Vec3", box2d.b2Vec3);
box2d.b2Vec3.prototype.x = 0;
goog.exportProperty(box2d.b2Vec3.prototype, "x", box2d.b2Vec3.prototype.x);
box2d.b2Vec3.prototype.y = 0;
goog.exportProperty(box2d.b2Vec3.prototype, "y", box2d.b2Vec3.prototype.y);
box2d.b2Vec3.prototype.z = 0;
goog.exportProperty(box2d.b2Vec3.prototype, "z", box2d.b2Vec3.prototype.z);
box2d.b2Vec3.ZERO = new box2d.b2Vec3;
goog.exportProperty(box2d.b2Vec3, "ZERO", box2d.b2Vec3.ZERO);
box2d.b2Vec3.s_t0 = new box2d.b2Vec3;
goog.exportProperty(box2d.b2Vec3, "s_t0", box2d.b2Vec3.s_t0);
box2d.b2Vec3.prototype.Clone = function() {
    return new box2d.b2Vec3(this.x, this.y, this.z)
};
goog.exportProperty(box2d.b2Vec3.prototype, "Clone", box2d.b2Vec3.prototype.Clone);
box2d.b2Vec3.prototype.SetZero = function() {
    this.z = this.y = this.x = 0;
    return this
};
goog.exportProperty(box2d.b2Vec3.prototype, "SetZero", box2d.b2Vec3.prototype.SetZero);
box2d.b2Vec3.prototype.SetXYZ = function(a, b, c) {
    this.x = a;
    this.y = b;
    this.z = c;
    return this
};
goog.exportProperty(box2d.b2Vec3.prototype, "SetXYZ", box2d.b2Vec3.prototype.SetXYZ);
box2d.b2Vec3.prototype.Copy = function(a) {
    this.x = a.x;
    this.y = a.y;
    this.z = a.z;
    return this
};
goog.exportProperty(box2d.b2Vec3.prototype, "Copy", box2d.b2Vec3.prototype.Copy);
box2d.b2Vec3.prototype.SelfNeg = function() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this
};
goog.exportProperty(box2d.b2Vec3.prototype, "SelfNeg", box2d.b2Vec3.prototype.SelfNeg);
box2d.b2Vec3.prototype.SelfAdd = function(a) {
    this.x += a.x;
    this.y += a.y;
    this.z += a.z;
    return this
};
goog.exportProperty(box2d.b2Vec3.prototype, "SelfAdd", box2d.b2Vec3.prototype.SelfAdd);
box2d.b2Vec3.prototype.SelfAddXYZ = function(a, b, c) {
    this.x += a;
    this.y += b;
    this.z += c;
    return this
};
goog.exportProperty(box2d.b2Vec3.prototype, "SelfAddXYZ", box2d.b2Vec3.prototype.SelfAddXYZ);
box2d.b2Vec3.prototype.SelfSub = function(a) {
    this.x -= a.x;
    this.y -= a.y;
    this.z -= a.z;
    return this
};
goog.exportProperty(box2d.b2Vec3.prototype, "SelfSub", box2d.b2Vec3.prototype.SelfSub);
box2d.b2Vec3.prototype.SelfSubXYZ = function(a, b, c) {
    this.x -= a;
    this.y -= b;
    this.z -= c;
    return this
};
goog.exportProperty(box2d.b2Vec3.prototype, "SelfSubXYZ", box2d.b2Vec3.prototype.SelfSubXYZ);
box2d.b2Vec3.prototype.SelfMul = function(a) {
    this.x *= a;
    this.y *= a;
    this.z *= a;
    return this
};
goog.exportProperty(box2d.b2Vec3.prototype, "SelfMul", box2d.b2Vec3.prototype.SelfMul);
box2d.b2DotV3V3 = function(a, b) {
    return a.x * b.x + a.y * b.y + a.z * b.z
};
goog.exportSymbol("box2d.b2DotV3V3", box2d.b2DotV3V3);
box2d.b2CrossV3V3 = function(a, b, c) {
    var e = a.x, d = a.y;
    a = a.z;
    var f = b.x, g = b.y;
    b = b.z;
    c.x = d * b - a * g;
    c.y = a * f - e * b;
    c.z = e * g - d * f;
    return c
};
goog.exportSymbol("box2d.b2CrossV3V3", box2d.b2CrossV3V3);
box2d.b2Mat22 = function() {
    this.ex = new box2d.b2Vec2(1, 0);
    this.ey = new box2d.b2Vec2(0, 1)
};
goog.exportSymbol("box2d.b2Mat22", box2d.b2Mat22);
box2d.b2Mat22.prototype.ex = null;
goog.exportProperty(box2d.b2Mat22.prototype, "ex", box2d.b2Mat22.prototype.ex);
box2d.b2Mat22.prototype.ey = null;
goog.exportProperty(box2d.b2Mat22.prototype, "ey", box2d.b2Mat22.prototype.ey);
box2d.b2Mat22.IDENTITY = new box2d.b2Mat22;
goog.exportProperty(box2d.b2Mat22, "IDENTITY", box2d.b2Mat22.IDENTITY);
box2d.b2Mat22.prototype.Clone = function() {
    return(new box2d.b2Mat22).Copy(this)
};
goog.exportProperty(box2d.b2Mat22.prototype, "Clone", box2d.b2Mat22.prototype.Clone);
box2d.b2Mat22.FromVV = function(a, b) {
    return(new box2d.b2Mat22).SetVV(a, b)
};
goog.exportProperty(box2d.b2Mat22, "FromVV", box2d.b2Mat22.FromVV);
box2d.b2Mat22.FromSSSS = function(a, b, c, e) {
    return(new box2d.b2Mat22).SetSSSS(a, b, c, e)
};
goog.exportProperty(box2d.b2Mat22, "FromSSSS", box2d.b2Mat22.FromSSSS);
box2d.b2Mat22.FromAngleRadians = function(a) {
    return(new box2d.b2Mat22).SetAngleRadians(a)
};
goog.exportProperty(box2d.b2Mat22, "FromAngleRadians", box2d.b2Mat22.FromAngleRadians);
box2d.b2Mat22.prototype.SetSSSS = function(a, b, c, e) {
    this.ex.SetXY(a, c);
    this.ey.SetXY(b, e);
    return this
};
goog.exportProperty(box2d.b2Mat22.prototype, "SetSSSS", box2d.b2Mat22.prototype.SetSSSS);
box2d.b2Mat22.prototype.SetVV = function(a, b) {
    this.ex.Copy(a);
    this.ey.Copy(b);
    return this
};
goog.exportProperty(box2d.b2Mat22.prototype, "SetVV", box2d.b2Mat22.prototype.SetVV);
box2d.b2Mat22.prototype.SetAngle = function(a) {
    var b = Math.cos(a);
    a = Math.sin(a);
    this.ex.SetXY(b, a);
    this.ey.SetXY(-a, b);
    return this
};
goog.exportProperty(box2d.b2Mat22.prototype, "SetAngle", box2d.b2Mat22.prototype.SetAngle);
box2d.b2Mat22.prototype.SetAngleRadians = box2d.b2Mat22.prototype.SetAngle;
box2d.b2Mat22.prototype.SetAngleDegrees = function(a) {
    return this.SetAngle(box2d.b2DegToRad(a))
};
box2d.b2Mat22.prototype.Copy = function(a) {
    this.ex.Copy(a.ex);
    this.ey.Copy(a.ey);
    return this
};
goog.exportProperty(box2d.b2Mat22.prototype, "Copy", box2d.b2Mat22.prototype.Copy);
box2d.b2Mat22.prototype.SetIdentity = function() {
    this.ex.SetXY(1, 0);
    this.ey.SetXY(0, 1);
    return this
};
goog.exportProperty(box2d.b2Mat22.prototype, "SetIdentity", box2d.b2Mat22.prototype.SetIdentity);
box2d.b2Mat22.prototype.SetZero = function() {
    this.ex.SetZero();
    this.ey.SetZero();
    return this
};
goog.exportProperty(box2d.b2Mat22.prototype, "SetZero", box2d.b2Mat22.prototype.SetZero);
box2d.b2Mat22.prototype.GetAngle = function() {
    return Math.atan2(this.ex.y, this.ex.x)
};
goog.exportProperty(box2d.b2Mat22.prototype, "GetAngle", box2d.b2Mat22.prototype.GetAngle);
box2d.b2Mat22.prototype.GetAngleRadians = box2d.b2Mat22.prototype.GetAngle;
box2d.b2Mat22.prototype.GetInverse = function(a) {
    var b = this.ex.x, c = this.ey.x, e = this.ex.y, d = this.ey.y, f = b * d - c * e;
    0 != f && (f = 1 / f);
    a.ex.x = f * d;
    a.ey.x = -f * c;
    a.ex.y = -f * e;
    a.ey.y = f * b;
    return a
};
goog.exportProperty(box2d.b2Mat22.prototype, "GetInverse", box2d.b2Mat22.prototype.GetInverse);
box2d.b2Mat22.prototype.Solve = function(a, b, c) {
    var e = this.ex.x, d = this.ey.x, f = this.ex.y, g = this.ey.y, h = e * g - d * f;
    0 != h && (h = 1 / h);
    c.x = h * (g * a - d * b);
    c.y = h * (e * b - f * a);
    return c
};
goog.exportProperty(box2d.b2Mat22.prototype, "Solve", box2d.b2Mat22.prototype.Solve);
box2d.b2Mat22.prototype.SelfAbs = function() {
    this.ex.SelfAbs();
    this.ey.SelfAbs();
    return this
};
goog.exportProperty(box2d.b2Mat22.prototype, "SelfAbs", box2d.b2Mat22.prototype.SelfAbs);
box2d.b2Mat22.prototype.SelfInv = function() {
    return this.GetInverse(this)
};
goog.exportProperty(box2d.b2Mat22.prototype, "SelfInv", box2d.b2Mat22.prototype.SelfInv);
box2d.b2Mat22.prototype.SelfAddM = function(a) {
    this.ex.SelfAdd(a.ex);
    this.ey.SelfAdd(a.ey);
    return this
};
goog.exportProperty(box2d.b2Mat22.prototype, "SelfAddM", box2d.b2Mat22.prototype.SelfAddM);
box2d.b2Mat22.prototype.SelfSubM = function(a) {
    this.ex.SelfSub(a.ex);
    this.ey.SelfSub(a.ey);
    return this
};
goog.exportProperty(box2d.b2Mat22.prototype, "SelfSubM", box2d.b2Mat22.prototype.SelfSubM);
box2d.b2AbsM = function(a, b) {
    var c = a.ex, e = a.ey;
    b.ex.x = box2d.b2Abs(c.x);
    b.ex.y = box2d.b2Abs(c.y);
    b.ey.x = box2d.b2Abs(e.x);
    b.ey.y = box2d.b2Abs(e.y);
    return b
};
goog.exportSymbol("box2d.b2AbsM", box2d.b2AbsM);
box2d.b2MulMV = function(a, b, c) {
    var e = a.ex;
    a = a.ey;
    var d = b.x;
    b = b.y;
    c.x = e.x * d + a.x * b;
    c.y = e.y * d + a.y * b;
    return c
};
goog.exportSymbol("box2d.b2MulMV", box2d.b2MulMV);
box2d.b2MulTMV = function(a, b, c) {
    var e = a.ex;
    a = a.ey;
    var d = b.x;
    b = b.y;
    c.x = e.x * d + e.y * b;
    c.y = a.x * d + a.y * b;
    return c
};
goog.exportSymbol("box2d.b2MulTMV", box2d.b2MulTMV);
box2d.b2AddMM = function(a, b, c) {
    var e = a.ex;
    a = a.ey;
    var d = b.ex;
    b = b.ey;
    c.ex.x = e.x + d.x;
    c.ex.y = e.y + d.y;
    c.ey.x = a.x + b.x;
    c.ey.y = a.y + b.y;
    return c
};
goog.exportSymbol("box2d.b2AddMM", box2d.b2AddMM);
box2d.b2MulMM = function(a, b, c) {
    var e = a.ex.x, d = a.ex.y, f = a.ey.x;
    a = a.ey.y;
    var g = b.ex.x, h = b.ex.y, l = b.ey.x;
    b = b.ey.y;
    c.ex.x = e * g + f * h;
    c.ex.y = d * g + a * h;
    c.ey.x = e * l + f * b;
    c.ey.y = d * l + a * b;
    return c
};
goog.exportSymbol("box2d.b2MulMM", box2d.b2MulMM);
box2d.b2MulTMM = function(a, b, c) {
    var e = a.ex.x, d = a.ex.y, f = a.ey.x;
    a = a.ey.y;
    var g = b.ex.x, h = b.ex.y, l = b.ey.x;
    b = b.ey.y;
    c.ex.x = e * g + d * h;
    c.ex.y = f * g + a * h;
    c.ey.x = e * l + d * b;
    c.ey.y = f * l + a * b;
    return c
};
goog.exportSymbol("box2d.b2MulTMM", box2d.b2MulTMM);
box2d.b2Mat33 = function() {
    this.ex = new box2d.b2Vec3(1, 0, 0);
    this.ey = new box2d.b2Vec3(0, 1, 0);
    this.ez = new box2d.b2Vec3(0, 0, 1)
};
goog.exportSymbol("box2d.b2Mat33", box2d.b2Mat33);
box2d.b2Mat33.prototype.ex = null;
goog.exportProperty(box2d.b2Mat33.prototype, "ex", box2d.b2Mat33.prototype.ex);
box2d.b2Mat33.prototype.ey = null;
goog.exportProperty(box2d.b2Mat33.prototype, "ey", box2d.b2Mat33.prototype.ey);
box2d.b2Mat33.prototype.ez = null;
goog.exportProperty(box2d.b2Mat33.prototype, "ez", box2d.b2Mat33.prototype.ez);
box2d.b2Mat33.IDENTITY = new box2d.b2Mat33;
goog.exportProperty(box2d.b2Mat33, "IDENTITY", box2d.b2Mat33.IDENTITY);
box2d.b2Mat33.prototype.Clone = function() {
    return(new box2d.b2Mat33).Copy(this)
};
goog.exportProperty(box2d.b2Mat33.prototype, "Clone", box2d.b2Mat33.prototype.Clone);
box2d.b2Mat33.prototype.SetVVV = function(a, b, c) {
    this.ex.Copy(a);
    this.ey.Copy(b);
    this.ez.Copy(c);
    return this
};
goog.exportProperty(box2d.b2Mat33.prototype, "SetVVV", box2d.b2Mat33.prototype.SetVVV);
box2d.b2Mat33.prototype.Copy = function(a) {
    this.ex.Copy(a.ex);
    this.ey.Copy(a.ey);
    this.ez.Copy(a.ez);
    return this
};
goog.exportProperty(box2d.b2Mat33.prototype, "Copy", box2d.b2Mat33.prototype.Copy);
box2d.b2Mat33.prototype.SetIdentity = function() {
    this.ex.SetXYZ(1, 0, 0);
    this.ey.SetXYZ(0, 1, 0);
    this.ez.SetXYZ(0, 0, 1);
    return this
};
goog.exportProperty(box2d.b2Mat33.prototype, "SetIdentity", box2d.b2Mat33.prototype.SetIdentity);
box2d.b2Mat33.prototype.SetZero = function() {
    this.ex.SetZero();
    this.ey.SetZero();
    this.ez.SetZero();
    return this
};
goog.exportProperty(box2d.b2Mat33.prototype, "SetZero", box2d.b2Mat33.prototype.SetZero);
box2d.b2Mat33.prototype.SelfAddM = function(a) {
    this.ex.SelfAdd(a.ex);
    this.ey.SelfAdd(a.ey);
    this.ez.SelfAdd(a.ez);
    return this
};
goog.exportProperty(box2d.b2Mat33.prototype, "SelfAddM", box2d.b2Mat33.prototype.SelfAddM);
box2d.b2Mat33.prototype.Solve33 = function(a, b, c, e) {
    var d = this.ex.x, f = this.ex.y, g = this.ex.z, h = this.ey.x, l = this.ey.y, k = this.ey.z, m = this.ez.x, n = this.ez.y, p = this.ez.z, q = d * (l * p - k * n) + f * (k * m - h * p) + g * (h * n - l * m);
    0 != q && (q = 1 / q);
    e.x = q * (a * (l * p - k * n) + b * (k * m - h * p) + c * (h * n - l * m));
    e.y = q * (d * (b * p - c * n) + f * (c * m - a * p) + g * (a * n - b * m));
    e.z = q * (d * (l * c - k * b) + f * (k * a - h * c) + g * (h * b - l * a));
    return e
};
goog.exportProperty(box2d.b2Mat33.prototype, "Solve33", box2d.b2Mat33.prototype.Solve33);
box2d.b2Mat33.prototype.Solve22 = function(a, b, c) {
    var e = this.ex.x, d = this.ey.x, f = this.ex.y, g = this.ey.y, h = e * g - d * f;
    0 != h && (h = 1 / h);
    c.x = h * (g * a - d * b);
    c.y = h * (e * b - f * a);
    return c
};
goog.exportProperty(box2d.b2Mat33.prototype, "Solve22", box2d.b2Mat33.prototype.Solve22);
box2d.b2Mat33.prototype.GetInverse22 = function(a) {
    var b = this.ex.x, c = this.ey.x, e = this.ex.y, d = this.ey.y, f = b * d - c * e;
    0 != f && (f = 1 / f);
    a.ex.x = f * d;
    a.ey.x = -f * c;
    a.ex.z = 0;
    a.ex.y = -f * e;
    a.ey.y = f * b;
    a.ey.z = 0;
    a.ez.x = 0;
    a.ez.y = 0;
    a.ez.z = 0
};
goog.exportProperty(box2d.b2Mat33.prototype, "GetInverse22", box2d.b2Mat33.prototype.GetInverse22);
box2d.b2Mat33.prototype.GetSymInverse33 = function(a) {
    var b = box2d.b2DotV3V3(this.ex, box2d.b2CrossV3V3(this.ey, this.ez, box2d.b2Vec3.s_t0));
    0 != b && (b = 1 / b);
    var c = this.ex.x, e = this.ey.x, d = this.ez.x, f = this.ey.y, g = this.ez.y, h = this.ez.z;
    a.ex.x = b * (f * h - g * g);
    a.ex.y = b * (d * g - e * h);
    a.ex.z = b * (e * g - d * f);
    a.ey.x = a.ex.y;
    a.ey.y = b * (c * h - d * d);
    a.ey.z = b * (d * e - c * g);
    a.ez.x = a.ex.z;
    a.ez.y = a.ey.z;
    a.ez.z = b * (c * f - e * e)
};
goog.exportProperty(box2d.b2Mat33.prototype, "GetSymInverse33", box2d.b2Mat33.prototype.GetSymInverse33);
box2d.b2MulM33V3 = function(a, b, c) {
    var e = b.x, d = b.y;
    b = b.z;
    c.x = a.ex.x * e + a.ey.x * d + a.ez.x * b;
    c.y = a.ex.y * e + a.ey.y * d + a.ez.y * b;
    c.z = a.ex.z * e + a.ey.z * d + a.ez.z * b;
    return c
};
goog.exportSymbol("box2d.b2MulM33V3", box2d.b2MulM33V3);
box2d.b2MulM33XYZ = function(a, b, c, e, d) {
    d.x = a.ex.x * b + a.ey.x * c + a.ez.x * e;
    d.y = a.ex.y * b + a.ey.y * c + a.ez.y * e;
    d.z = a.ex.z * b + a.ey.z * c + a.ez.z * e;
    return d
};
goog.exportSymbol("box2d.b2MulM33XYZ", box2d.b2MulM33XYZ);
box2d.b2MulM33V2 = function(a, b, c) {
    var e = b.x;
    b = b.y;
    c.x = a.ex.x * e + a.ey.x * b;
    c.y = a.ex.y * e + a.ey.y * b;
    return c
};
goog.exportSymbol("box2d.b2MulM33V2", box2d.b2MulM33V2);
box2d.b2MulM33XY = function(a, b, c, e) {
    e.x = a.ex.x * b + a.ey.x * c;
    e.y = a.ex.y * b + a.ey.y * c;
    return e
};
goog.exportSymbol("box2d.b2MulM33XY", box2d.b2MulM33XY);
box2d.b2Rot = function(a) {
    a && (this.angle = a, this.s = Math.sin(a), this.c = Math.cos(a))
};
goog.exportSymbol("box2d.b2Rot", box2d.b2Rot);
box2d.b2Rot.prototype.angle = 0;
goog.exportProperty(box2d.b2Rot.prototype, "angle", box2d.b2Rot.prototype.angle);
box2d.b2Rot.prototype.s = 0;
goog.exportProperty(box2d.b2Rot.prototype, "s", box2d.b2Rot.prototype.s);
box2d.b2Rot.prototype.c = 1;
goog.exportProperty(box2d.b2Rot.prototype, "c", box2d.b2Rot.prototype.c);
box2d.b2Rot.IDENTITY = new box2d.b2Rot;
goog.exportProperty(box2d.b2Rot, "IDENTITY", box2d.b2Rot.IDENTITY);
box2d.b2Rot.prototype.Clone = function() {
    return(new box2d.b2Rot).Copy(this)
};
goog.exportProperty(box2d.b2Rot.prototype, "Clone", box2d.b2Rot.prototype.Clone);
box2d.b2Rot.prototype.Copy = function(a) {
    this.angle = a.angle;
    this.s = a.s;
    this.c = a.c;
    return this
};
goog.exportProperty(box2d.b2Rot.prototype, "Copy", box2d.b2Rot.prototype.Copy);
box2d.b2Rot.prototype.SetAngle = function(a) {
    this.angle != a && (this.angle = a, this.s = Math.sin(a), this.c = Math.cos(a));
    return this
};
goog.exportProperty(box2d.b2Rot.prototype, "SetAngle", box2d.b2Rot.prototype.SetAngle);
box2d.b2Rot.prototype.SetAngleRadians = box2d.b2Rot.prototype.SetAngle;
box2d.b2Rot.prototype.SetAngleDegrees = function(a) {
    return this.SetAngle(box2d.b2DegToRad(a))
};
box2d.b2Rot.prototype.SetIdentity = function() {
    this.s = this.angle = 0;
    this.c = 1;
    return this
};
goog.exportProperty(box2d.b2Rot.prototype, "SetIdentity", box2d.b2Rot.prototype.SetIdentity);
box2d.b2Rot.prototype.GetAngle = function() {
    return this.angle
};
goog.exportProperty(box2d.b2Rot.prototype, "GetAngle", box2d.b2Rot.prototype.GetAngle);
box2d.b2Rot.prototype.GetAngleRadians = box2d.b2Rot.prototype.GetAngle;
box2d.b2Rot.prototype.GetAngleDegrees = function() {
    return box2d.b2RadToDeg(this.GetAngle())
};
box2d.b2Rot.prototype.GetXAxis = function(a) {
    a.x = this.c;
    a.y = this.s;
    return a
};
goog.exportProperty(box2d.b2Rot.prototype, "GetXAxis", box2d.b2Rot.prototype.GetXAxis);
box2d.b2Rot.prototype.GetYAxis = function(a) {
    a.x = -this.s;
    a.y = this.c;
    return a
};
goog.exportProperty(box2d.b2Rot.prototype, "GetYAxis", box2d.b2Rot.prototype.GetYAxis);
box2d.b2MulRR = function(a, b, c) {
    var e = a.c;
    a = a.s;
    var d = b.c;
    b = b.s;
    c.s = a * d + e * b;
    c.c = e * d - a * b;
    return c
};
goog.exportSymbol("box2d.b2MulRR", box2d.b2MulRR);
box2d.b2MulTRR = function(a, b, c) {
    var e = a.c;
    a = a.s;
    var d = b.c;
    b = b.s;
    c.s = e * b - a * d;
    c.c = e * d + a * b;
    return c
};
goog.exportSymbol("box2d.b2MulTRR", box2d.b2MulTRR);
box2d.b2MulRV = function(a, b, c) {
    var e = a.c;
    a = a.s;
    var d = b.x;
    b = b.y;
    c.x = e * d - a * b;
    c.y = a * d + e * b;
    return c
};
goog.exportSymbol("box2d.b2MulRV", box2d.b2MulRV);
box2d.b2MulTRV = function(a, b, c) {
    var e = a.c;
    a = a.s;
    var d = b.x;
    b = b.y;
    c.x = e * d + a * b;
    c.y = -a * d + e * b;
    return c
};
goog.exportSymbol("box2d.b2MulTRV", box2d.b2MulTRV);
box2d.b2Transform = function() {
    this.p = new box2d.b2Vec2;
    this.q = new box2d.b2Rot
};
goog.exportSymbol("box2d.b2Transform", box2d.b2Transform);
box2d.b2Transform.prototype.p = null;
goog.exportProperty(box2d.b2Transform.prototype, "p", box2d.b2Transform.prototype.p);
box2d.b2Transform.prototype.q = null;
goog.exportProperty(box2d.b2Transform.prototype, "q", box2d.b2Transform.prototype.q);
box2d.b2Transform.IDENTITY = new box2d.b2Transform;
goog.exportProperty(box2d.b2Transform, "IDENTITY", box2d.b2Transform.IDENTITY);
box2d.b2Transform.prototype.Clone = function() {
    return(new box2d.b2Transform).Copy(this)
};
goog.exportProperty(box2d.b2Transform.prototype, "Clone", box2d.b2Transform.prototype.Clone);
box2d.b2Transform.prototype.Copy = function(a) {
    this.p.Copy(a.p);
    this.q.Copy(a.q);
    return this
};
goog.exportProperty(box2d.b2Transform.prototype, "Copy", box2d.b2Transform.prototype.Copy);
box2d.b2Transform.prototype.SetIdentity = function() {
    this.p.SetZero();
    this.q.SetIdentity();
    return this
};
goog.exportProperty(box2d.b2Transform.prototype, "SetIdentity", box2d.b2Transform.prototype.SetIdentity);
box2d.b2Transform.prototype.SetPositionRotation = function(a, b) {
    this.p.Copy(a);
    this.q.Copy(b);
    return this
};
goog.exportProperty(box2d.b2Transform.prototype, "SetPositionRotation", box2d.b2Transform.prototype.SetPositionRotation);
box2d.b2Transform.prototype.SetPositionAngleRadians = function(a, b) {
    this.p.Copy(a);
    this.q.SetAngleRadians(b);
    return this
};
goog.exportProperty(box2d.b2Transform.prototype, "SetPositionAngleRadians", box2d.b2Transform.prototype.SetPositionAngleRadians);
box2d.b2Transform.prototype.SetPosition = function(a) {
    this.p.Copy(a);
    return this
};
goog.exportProperty(box2d.b2Transform.prototype, "SetPosition", box2d.b2Transform.prototype.SetPosition);
box2d.b2Transform.prototype.SetPositionXY = function(a, b) {
    this.p.SetXY(a, b);
    return this
};
goog.exportProperty(box2d.b2Transform.prototype, "SetPositionXY", box2d.b2Transform.prototype.SetPositionXY);
box2d.b2Transform.prototype.SetRotation = function(a) {
    this.q.Copy(a);
    return this
};
goog.exportProperty(box2d.b2Transform.prototype, "SetRotation", box2d.b2Transform.prototype.SetRotation);
box2d.b2Transform.prototype.SetRotationAngleRadians = function(a) {
    this.q.SetAngleRadians(a);
    return this
};
goog.exportProperty(box2d.b2Transform.prototype, "SetRotationAngleRadians", box2d.b2Transform.prototype.SetRotationAngleRadians);
box2d.b2Transform.prototype.GetPosition = function() {
    return this.p
};
goog.exportProperty(box2d.b2Transform.prototype, "GetPosition", box2d.b2Transform.prototype.GetPosition);
box2d.b2Transform.prototype.GetRotation = function() {
    return this.q
};
goog.exportProperty(box2d.b2Transform.prototype, "GetRotation", box2d.b2Transform.prototype.GetRotation);
box2d.b2Transform.prototype.GetRotationAngle = function() {
    return this.q.GetAngle()
};
goog.exportProperty(box2d.b2Transform.prototype, "GetRotationAngle", box2d.b2Transform.prototype.GetRotationAngle);
box2d.b2Transform.prototype.GetRotationAngleRadians = box2d.b2Transform.prototype.GetRotationAngle;
box2d.b2Transform.prototype.GetAngle = function() {
    return this.q.GetAngle()
};
goog.exportProperty(box2d.b2Transform.prototype, "GetAngle", box2d.b2Transform.prototype.GetAngle);
box2d.b2Transform.prototype.GetAngleRadians = box2d.b2Transform.prototype.GetAngle;
box2d.b2MulXV = function(a, b, c) {
    var e = a.q.c, d = a.q.s, f = b.x;
    b = b.y;
    c.x = e * f - d * b + a.p.x;
    c.y = d * f + e * b + a.p.y;
    return c
};
goog.exportSymbol("box2d.b2MulXV", box2d.b2MulXV);
box2d.b2MulTXV = function(a, b, c) {
    var e = a.q.c, d = a.q.s, f = b.x - a.p.x;
    a = b.y - a.p.y;
    c.x = e * f + d * a;
    c.y = -d * f + e * a;
    return c
};
goog.exportSymbol("box2d.b2MulTXV", box2d.b2MulTXV);
box2d.b2MulXX = function(a, b, c) {
    box2d.b2MulRR(a.q, b.q, c.q);
    box2d.b2AddVV(box2d.b2MulRV(a.q, b.p, c.p), a.p, c.p);
    return c
};
goog.exportSymbol("box2d.b2MulXX", box2d.b2MulXX);
box2d.b2MulTXX = function(a, b, c) {
    box2d.b2MulTRR(a.q, b.q, c.q);
    box2d.b2MulTRV(a.q, box2d.b2SubVV(b.p, a.p, c.p), c.p);
    return c
};
goog.exportSymbol("box2d.b2MulTXX", box2d.b2MulTXX);
box2d.b2Sweep = function() {
    this.localCenter = new box2d.b2Vec2;
    this.c0 = new box2d.b2Vec2;
    this.c = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2Sweep", box2d.b2Sweep);
box2d.b2Sweep.prototype.localCenter = null;
goog.exportProperty(box2d.b2Sweep.prototype, "localCenter", box2d.b2Sweep.prototype.localCenter);
box2d.b2Sweep.prototype.c0 = null;
goog.exportProperty(box2d.b2Sweep.prototype, "c0", box2d.b2Sweep.prototype.c0);
box2d.b2Sweep.prototype.c = null;
goog.exportProperty(box2d.b2Sweep.prototype, "c", box2d.b2Sweep.prototype.c);
box2d.b2Sweep.prototype.a0 = 0;
goog.exportProperty(box2d.b2Sweep.prototype, "a0", box2d.b2Sweep.prototype.a0);
box2d.b2Sweep.prototype.a = 0;
goog.exportProperty(box2d.b2Sweep.prototype, "a", box2d.b2Sweep.prototype.a);
box2d.b2Sweep.prototype.alpha0 = 0;
goog.exportProperty(box2d.b2Sweep.prototype, "alpha0", box2d.b2Sweep.prototype.alpha0);
box2d.b2Sweep.prototype.Clone = function() {
    return(new box2d.b2Sweep).Copy(this)
};
goog.exportProperty(box2d.b2Sweep.prototype, "Clone", box2d.b2Sweep.prototype.Clone);
box2d.b2Sweep.prototype.Copy = function(a) {
    this.localCenter.Copy(a.localCenter);
    this.c0.Copy(a.c0);
    this.c.Copy(a.c);
    this.a0 = a.a0;
    this.a = a.a;
    this.alpha0 = a.alpha0;
    return this
};
goog.exportProperty(box2d.b2Sweep.prototype, "Copy", box2d.b2Sweep.prototype.Copy);
box2d.b2Sweep.prototype.GetTransform = function(a, b) {
    var c = 1 - b;
    a.p.x = c * this.c0.x + b * this.c.x;
    a.p.y = c * this.c0.y + b * this.c.y;
    a.q.SetAngleRadians(c * this.a0 + b * this.a);
    a.p.SelfSub(box2d.b2MulRV(a.q, this.localCenter, box2d.b2Vec2.s_t0));
    return a
};
goog.exportProperty(box2d.b2Sweep.prototype, "GetTransform", box2d.b2Sweep.prototype.GetTransform);
box2d.b2Sweep.prototype.Advance = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(1 > this.alpha0);
    var b = (a - this.alpha0) / (1 - this.alpha0), c = 1 - b;
    this.c0.x = c * this.c0.x + b * this.c.x;
    this.c0.y = c * this.c0.y + b * this.c.y;
    this.a0 = c * this.a0 + b * this.a;
    this.alpha0 = a
};
goog.exportProperty(box2d.b2Sweep.prototype, "Advance", box2d.b2Sweep.prototype.Advance);
box2d.b2Sweep.prototype.Normalize = function() {
    var a = box2d.b2_two_pi * Math.floor(this.a0 / box2d.b2_two_pi);
    this.a0 -= a;
    this.a -= a
};
goog.exportProperty(box2d.b2Sweep.prototype, "Normalize", box2d.b2Sweep.prototype.Normalize);
box2d.b2ControllerEdge = function() {
};
goog.exportSymbol("box2d.b2ControllerEdge", box2d.b2ControllerEdge);
box2d.b2ControllerEdge.prototype.controller = null;
goog.exportProperty(box2d.b2ControllerEdge.prototype, "controller", box2d.b2ControllerEdge.prototype.controller);
box2d.b2ControllerEdge.prototype.body = null;
goog.exportProperty(box2d.b2ControllerEdge.prototype, "body", box2d.b2ControllerEdge.prototype.body);
box2d.b2ControllerEdge.prototype.prevBody = null;
goog.exportProperty(box2d.b2ControllerEdge.prototype, "prevBody", box2d.b2ControllerEdge.prototype.prevBody);
box2d.b2ControllerEdge.prototype.nextBody = null;
goog.exportProperty(box2d.b2ControllerEdge.prototype, "nextBody", box2d.b2ControllerEdge.prototype.nextBody);
box2d.b2ControllerEdge.prototype.prevController = null;
goog.exportProperty(box2d.b2ControllerEdge.prototype, "prevController", box2d.b2ControllerEdge.prototype.prevController);
box2d.b2ControllerEdge.prototype.nextController = null;
goog.exportProperty(box2d.b2ControllerEdge.prototype, "nextController", box2d.b2ControllerEdge.prototype.nextController);
box2d.b2Controller = function() {
};
goog.exportSymbol("box2d.b2Controller", box2d.b2Controller);
box2d.b2Controller.prototype.m_world = null;
goog.exportProperty(box2d.b2Controller.prototype, "m_world", box2d.b2Controller.prototype.m_world);
box2d.b2Controller.prototype.m_bodyList = null;
goog.exportProperty(box2d.b2Controller.prototype, "m_bodyList", box2d.b2Controller.prototype.m_bodyList);
box2d.b2Controller.prototype.m_bodyCount = 0;
goog.exportProperty(box2d.b2Controller.prototype, "m_bodyCount", box2d.b2Controller.prototype.m_bodyCount);
box2d.b2Controller.prototype.m_prev = null;
goog.exportProperty(box2d.b2Controller.prototype, "m_prev", box2d.b2Controller.prototype.m_prev);
box2d.b2Controller.prototype.m_next = null;
goog.exportProperty(box2d.b2Controller.prototype, "m_next", box2d.b2Controller.prototype.m_next);
box2d.b2Controller.prototype.Step = function(a) {
};
goog.exportProperty(box2d.b2Controller.prototype, "Step", box2d.b2Controller.prototype.Step);
box2d.b2Controller.prototype.Draw = function(a) {
};
goog.exportProperty(box2d.b2Controller.prototype, "Draw", box2d.b2Controller.prototype.Draw);
box2d.b2Controller.prototype.GetNext = function() {
    return this.m_next
};
goog.exportProperty(box2d.b2Controller.prototype, "GetNext", box2d.b2Controller.prototype.GetNext);
box2d.b2Controller.prototype.GetPrev = function() {
    return this.m_prev
};
goog.exportProperty(box2d.b2Controller.prototype, "GetPrev", box2d.b2Controller.prototype.GetPrev);
box2d.b2Controller.prototype.GetWorld = function() {
    return this.m_world
};
goog.exportProperty(box2d.b2Controller.prototype, "GetWorld", box2d.b2Controller.prototype.GetWorld);
box2d.b2Controller.prototype.GetBodyList = function() {
    return this.m_bodyList
};
goog.exportProperty(box2d.b2Controller.prototype, "GetBodyList", box2d.b2Controller.prototype.GetBodyList);
box2d.b2Controller.prototype.AddBody = function(a) {
    var b = new box2d.b2ControllerEdge;
    b.body = a;
    b.controller = this;
    b.nextBody = this.m_bodyList;
    b.prevBody = null;
    this.m_bodyList && (this.m_bodyList.prevBody = b);
    this.m_bodyList = b;
    ++this.m_bodyCount;
    b.nextController = a.m_controllerList;
    b.prevController = null;
    a.m_controllerList && (a.m_controllerList.prevController = b);
    a.m_controllerList = b;
    ++a.m_controllerCount
};
goog.exportProperty(box2d.b2Controller.prototype, "AddBody", box2d.b2Controller.prototype.AddBody);
box2d.b2Controller.prototype.RemoveBody = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < this.m_bodyCount);
    for (var b = this.m_bodyList; b && b.body != a; )
        b = b.nextBody;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(null != b);
    b.prevBody && (b.prevBody.nextBody = b.nextBody);
    b.nextBody && (b.nextBody.prevBody = b.prevBody);
    this.m_bodyList == b && (this.m_bodyList = b.nextBody);
    --this.m_bodyCount;
    b.nextController && (b.nextController.prevController = b.prevController);
    b.prevController && (b.prevController.nextController = b.nextController);
    a.m_controllerList == b && (a.m_controllerList = b.nextController);
    --a.m_controllerCount
};
goog.exportProperty(box2d.b2Controller.prototype, "RemoveBody", box2d.b2Controller.prototype.RemoveBody);
box2d.b2Controller.prototype.Clear = function() {
    for (; this.m_bodyList; )
        this.RemoveBody(this.m_bodyList.body);
    this.m_bodyCount = 0
};
goog.exportProperty(box2d.b2Controller.prototype, "Clear", box2d.b2Controller.prototype.Clear);
box2d.b2ConstantAccelController = function() {
    box2d.b2Controller.call(this);
    this.A = new box2d.b2Vec2(0, 0)
};
goog.inherits(box2d.b2ConstantAccelController, box2d.b2Controller);
goog.exportSymbol("box2d.b2ConstantAccelController", box2d.b2ConstantAccelController);
box2d.b2ConstantAccelController.prototype.A = null;
goog.exportProperty(box2d.b2ConstantAccelController.prototype, "A", box2d.b2ConstantAccelController.prototype.A);
box2d.b2ConstantAccelController.prototype.Step = function(a) {
    a = box2d.b2MulSV(a.dt, this.A, box2d.b2ConstantAccelController.prototype.Step.s_dtA);
    for (var b = this.m_bodyList; b; b = b.nextBody) {
        var c = b.body;
        c.IsAwake() && c.SetLinearVelocity(box2d.b2AddVV(c.GetLinearVelocity(), a, box2d.b2Vec2.s_t0))
    }
};
goog.exportProperty(box2d.b2ConstantAccelController.prototype, "Step", box2d.b2ConstantAccelController.prototype.Step);
box2d.b2ConstantAccelController.prototype.Step.s_dtA = new box2d.b2Vec2;
box2d.b2JointType = {e_unknownJoint: 0, e_revoluteJoint: 1, e_prismaticJoint: 2, e_distanceJoint: 3, e_pulleyJoint: 4, e_mouseJoint: 5, e_gearJoint: 6, e_wheelJoint: 7, e_weldJoint: 8, e_frictionJoint: 9, e_ropeJoint: 10, e_motorJoint: 11, e_areaJoint: 12};
goog.exportSymbol("box2d.b2JointType", box2d.b2JointType);
goog.exportProperty(box2d.b2JointType, "e_unknownJoint", box2d.b2JointType.e_unknownJoint);
goog.exportProperty(box2d.b2JointType, "e_revoluteJoint", box2d.b2JointType.e_revoluteJoint);
goog.exportProperty(box2d.b2JointType, "e_prismaticJoint", box2d.b2JointType.e_prismaticJoint);
goog.exportProperty(box2d.b2JointType, "e_distanceJoint", box2d.b2JointType.e_distanceJoint);
goog.exportProperty(box2d.b2JointType, "e_pulleyJoint", box2d.b2JointType.e_pulleyJoint);
goog.exportProperty(box2d.b2JointType, "e_mouseJoint", box2d.b2JointType.e_mouseJoint);
goog.exportProperty(box2d.b2JointType, "e_gearJoint", box2d.b2JointType.e_gearJoint);
goog.exportProperty(box2d.b2JointType, "e_wheelJoint", box2d.b2JointType.e_wheelJoint);
goog.exportProperty(box2d.b2JointType, "e_weldJoint", box2d.b2JointType.e_weldJoint);
goog.exportProperty(box2d.b2JointType, "e_frictionJoint", box2d.b2JointType.e_frictionJoint);
goog.exportProperty(box2d.b2JointType, "e_ropeJoint", box2d.b2JointType.e_ropeJoint);
goog.exportProperty(box2d.b2JointType, "e_motorJoint", box2d.b2JointType.e_motorJoint);
goog.exportProperty(box2d.b2JointType, "e_areaJoint", box2d.b2JointType.e_areaJoint);
box2d.b2LimitState = {e_inactiveLimit: 0, e_atLowerLimit: 1, e_atUpperLimit: 2, e_equalLimits: 3};
goog.exportSymbol("box2d.b2LimitState", box2d.b2LimitState);
goog.exportProperty(box2d.b2LimitState, "e_inactiveLimit", box2d.b2LimitState.e_inactiveLimit);
goog.exportProperty(box2d.b2LimitState, "e_atLowerLimit", box2d.b2LimitState.e_atLowerLimit);
goog.exportProperty(box2d.b2LimitState, "e_atUpperLimit", box2d.b2LimitState.e_atUpperLimit);
goog.exportProperty(box2d.b2LimitState, "e_equalLimits", box2d.b2LimitState.e_equalLimits);
box2d.b2Jacobian = function() {
    this.linear = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2Jacobian", box2d.b2Jacobian);
box2d.b2Jacobian.prototype.linear = null;
goog.exportProperty(box2d.b2Jacobian.prototype, "linear", box2d.b2Jacobian.prototype.linear);
box2d.b2Jacobian.prototype.angularA = 0;
goog.exportProperty(box2d.b2Jacobian.prototype, "angularA", box2d.b2Jacobian.prototype.angularA);
box2d.b2Jacobian.prototype.angularB = 0;
goog.exportProperty(box2d.b2Jacobian.prototype, "angularB", box2d.b2Jacobian.prototype.angularB);
box2d.b2Jacobian.prototype.SetZero = function() {
    this.linear.SetZero();
    this.angularB = this.angularA = 0;
    return this
};
goog.exportProperty(box2d.b2Jacobian.prototype, "SetZero", box2d.b2Jacobian.prototype.SetZero);
box2d.b2Jacobian.prototype.Set = function(a, b, c) {
    this.linear.Copy(a);
    this.angularA = b;
    this.angularB = c;
    return this
};
goog.exportProperty(box2d.b2Jacobian.prototype, "Set", box2d.b2Jacobian.prototype.Set);
box2d.b2JointEdge = function() {
};
goog.exportSymbol("box2d.b2JointEdge", box2d.b2JointEdge);
box2d.b2JointEdge.prototype.other = null;
goog.exportProperty(box2d.b2JointEdge.prototype, "other", box2d.b2JointEdge.prototype.other);
box2d.b2JointEdge.prototype.joint = null;
goog.exportProperty(box2d.b2JointEdge.prototype, "joint", box2d.b2JointEdge.prototype.joint);
box2d.b2JointEdge.prototype.prev = null;
goog.exportProperty(box2d.b2JointEdge.prototype, "prev", box2d.b2JointEdge.prototype.prev);
box2d.b2JointEdge.prototype.next = null;
goog.exportProperty(box2d.b2JointEdge.prototype, "next", box2d.b2JointEdge.prototype.next);
box2d.b2JointDef = function(a) {
    this.type = a
};
goog.exportSymbol("box2d.b2JointDef", box2d.b2JointDef);
box2d.b2JointDef.prototype.type = box2d.b2JointType.e_unknownJoint;
goog.exportProperty(box2d.b2JointDef.prototype, "type", box2d.b2JointDef.prototype.type);
box2d.b2JointDef.prototype.userData = null;
goog.exportProperty(box2d.b2JointDef.prototype, "userData", box2d.b2JointDef.prototype.userData);
box2d.b2JointDef.prototype.bodyA = null;
goog.exportProperty(box2d.b2JointDef.prototype, "bodyA", box2d.b2JointDef.prototype.bodyA);
box2d.b2JointDef.prototype.bodyB = null;
goog.exportProperty(box2d.b2JointDef.prototype, "bodyB", box2d.b2JointDef.prototype.bodyB);
box2d.b2JointDef.prototype.collideConnected = !1;
goog.exportProperty(box2d.b2JointDef.prototype, "collideConnected", box2d.b2JointDef.prototype.collideConnected);
box2d.b2Joint = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.bodyA != a.bodyB);
    this.m_type = a.type;
    this.m_edgeA = new box2d.b2JointEdge;
    this.m_edgeB = new box2d.b2JointEdge;
    this.m_bodyA = a.bodyA;
    this.m_bodyB = a.bodyB;
    this.m_collideConnected = a.collideConnected;
    this.m_userData = a.userData
};
goog.exportSymbol("box2d.b2Joint", box2d.b2Joint);
box2d.b2Joint.prototype.m_type = box2d.b2JointType.e_unknownJoint;
goog.exportProperty(box2d.b2Joint.prototype, "m_type", box2d.b2Joint.prototype.m_type);
box2d.b2Joint.prototype.m_prev = null;
goog.exportProperty(box2d.b2Joint.prototype, "m_prev", box2d.b2Joint.prototype.m_prev);
box2d.b2Joint.prototype.m_next = null;
goog.exportProperty(box2d.b2Joint.prototype, "m_next", box2d.b2Joint.prototype.m_next);
box2d.b2Joint.prototype.m_edgeA = null;
goog.exportProperty(box2d.b2Joint.prototype, "m_edgeA", box2d.b2Joint.prototype.m_edgeA);
box2d.b2Joint.prototype.m_edgeB = null;
goog.exportProperty(box2d.b2Joint.prototype, "m_edgeB", box2d.b2Joint.prototype.m_edgeB);
box2d.b2Joint.prototype.m_bodyA = null;
goog.exportProperty(box2d.b2Joint.prototype, "m_bodyA", box2d.b2Joint.prototype.m_bodyA);
box2d.b2Joint.prototype.m_bodyB = null;
goog.exportProperty(box2d.b2Joint.prototype, "m_bodyB", box2d.b2Joint.prototype.m_bodyB);
box2d.b2Joint.prototype.m_index = 0;
goog.exportProperty(box2d.b2Joint.prototype, "m_index", box2d.b2Joint.prototype.m_index);
box2d.b2Joint.prototype.m_islandFlag = !1;
goog.exportProperty(box2d.b2Joint.prototype, "m_islandFlag", box2d.b2Joint.prototype.m_islandFlag);
box2d.b2Joint.prototype.m_collideConnected = !1;
goog.exportProperty(box2d.b2Joint.prototype, "m_collideConnected", box2d.b2Joint.prototype.m_collideConnected);
box2d.b2Joint.prototype.m_userData = null;
goog.exportProperty(box2d.b2Joint.prototype, "m_userData", box2d.b2Joint.prototype.m_userData);
box2d.b2Joint.prototype.GetAnchorA = function(a) {
    return a.SetZero()
};
goog.exportProperty(box2d.b2Joint.prototype, "GetAnchorA", box2d.b2Joint.prototype.GetAnchorA);
box2d.b2Joint.prototype.GetAnchorB = function(a) {
    return a.SetZero()
};
goog.exportProperty(box2d.b2Joint.prototype, "GetAnchorB", box2d.b2Joint.prototype.GetAnchorB);
box2d.b2Joint.prototype.GetReactionForce = function(a, b) {
    return b.SetZero()
};
goog.exportProperty(box2d.b2Joint.prototype, "GetReactionForce", box2d.b2Joint.prototype.GetReactionForce);
box2d.b2Joint.prototype.GetReactionTorque = function(a) {
    return 0
};
goog.exportProperty(box2d.b2Joint.prototype, "GetReactionTorque", box2d.b2Joint.prototype.GetReactionTorque);
box2d.b2Joint.prototype.InitVelocityConstraints = function(a) {
};
goog.exportProperty(box2d.b2Joint.prototype, "InitVelocityConstraints", box2d.b2Joint.prototype.InitVelocityConstraints);
box2d.b2Joint.prototype.SolveVelocityConstraints = function(a) {
};
goog.exportProperty(box2d.b2Joint.prototype, "SolveVelocityConstraints", box2d.b2Joint.prototype.SolveVelocityConstraints);
box2d.b2Joint.prototype.SolvePositionConstraints = function(a) {
    return!1
};
goog.exportProperty(box2d.b2Joint.prototype, "SolvePositionConstraints", box2d.b2Joint.prototype.SolvePositionConstraints);
box2d.b2Joint.prototype.GetType = function() {
    return this.m_type
};
goog.exportProperty(box2d.b2Joint.prototype, "GetType", box2d.b2Joint.prototype.GetType);
box2d.b2Joint.prototype.GetBodyA = function() {
    return this.m_bodyA
};
goog.exportProperty(box2d.b2Joint.prototype, "GetBodyA", box2d.b2Joint.prototype.GetBodyA);
box2d.b2Joint.prototype.GetBodyB = function() {
    return this.m_bodyB
};
goog.exportProperty(box2d.b2Joint.prototype, "GetBodyB", box2d.b2Joint.prototype.GetBodyB);
box2d.b2Joint.prototype.GetNext = function() {
    return this.m_next
};
goog.exportProperty(box2d.b2Joint.prototype, "GetNext", box2d.b2Joint.prototype.GetNext);
box2d.b2Joint.prototype.GetUserData = function() {
    return this.m_userData
};
goog.exportProperty(box2d.b2Joint.prototype, "GetUserData", box2d.b2Joint.prototype.GetUserData);
box2d.b2Joint.prototype.SetUserData = function(a) {
    this.m_userData = a
};
goog.exportProperty(box2d.b2Joint.prototype, "SetUserData", box2d.b2Joint.prototype.SetUserData);
box2d.b2Joint.prototype.GetCollideConnected = function() {
    return this.m_collideConnected
};
goog.exportProperty(box2d.b2Joint.prototype, "GetCollideConnected", box2d.b2Joint.prototype.GetCollideConnected);
box2d.b2Joint.prototype.Dump = function() {
    box2d.DEBUG && box2d.b2Log("// Dump is not supported for this joint type.\n")
};
goog.exportProperty(box2d.b2Joint.prototype, "Dump", box2d.b2Joint.prototype.Dump);
box2d.b2Joint.prototype.IsActive = function() {
    return this.m_bodyA.IsActive() && this.m_bodyB.IsActive()
};
goog.exportProperty(box2d.b2Joint.prototype, "IsActive", box2d.b2Joint.prototype.IsActive);
box2d.b2Joint.prototype.ShiftOrigin = function(a) {
};
goog.exportProperty(box2d.b2Joint.prototype, "ShiftOrigin", box2d.b2Joint.prototype.ShiftOrigin);
box2d.b2RevoluteJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_revoluteJoint);
    this.localAnchorA = new box2d.b2Vec2(0, 0);
    this.localAnchorB = new box2d.b2Vec2(0, 0)
};
goog.inherits(box2d.b2RevoluteJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2RevoluteJointDef", box2d.b2RevoluteJointDef);
box2d.b2RevoluteJointDef.prototype.localAnchorA = null;
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "localAnchorA", box2d.b2RevoluteJointDef.prototype.localAnchorA);
box2d.b2RevoluteJointDef.prototype.localAnchorB = null;
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "localAnchorB", box2d.b2RevoluteJointDef.prototype.localAnchorB);
box2d.b2RevoluteJointDef.prototype.referenceAngle = 0;
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "referenceAngle", box2d.b2RevoluteJointDef.prototype.referenceAngle);
box2d.b2RevoluteJointDef.prototype.enableLimit = !1;
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "enableLimit", box2d.b2RevoluteJointDef.prototype.enableLimit);
box2d.b2RevoluteJointDef.prototype.lowerAngle = 0;
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "lowerAngle", box2d.b2RevoluteJointDef.prototype.lowerAngle);
box2d.b2RevoluteJointDef.prototype.upperAngle = 0;
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "upperAngle", box2d.b2RevoluteJointDef.prototype.upperAngle);
box2d.b2RevoluteJointDef.prototype.enableMotor = !1;
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "enableMotor", box2d.b2RevoluteJointDef.prototype.enableMotor);
box2d.b2RevoluteJointDef.prototype.motorSpeed = 0;
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "motorSpeed", box2d.b2RevoluteJointDef.prototype.motorSpeed);
box2d.b2RevoluteJointDef.prototype.maxMotorTorque = 0;
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "maxMotorTorque", box2d.b2RevoluteJointDef.prototype.maxMotorTorque);
box2d.b2RevoluteJointDef.prototype.Initialize = function(a, b, c) {
    this.bodyA = a;
    this.bodyB = b;
    this.bodyA.GetLocalPoint(c, this.localAnchorA);
    this.bodyB.GetLocalPoint(c, this.localAnchorB);
    this.referenceAngle = this.bodyB.GetAngleRadians() - this.bodyA.GetAngleRadians()
};
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "Initialize", box2d.b2RevoluteJointDef.prototype.Initialize);
box2d.b2RevoluteJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_localAnchorA = new box2d.b2Vec2;
    this.m_localAnchorB = new box2d.b2Vec2;
    this.m_impulse = new box2d.b2Vec3;
    this.m_rA = new box2d.b2Vec2;
    this.m_rB = new box2d.b2Vec2;
    this.m_localCenterA = new box2d.b2Vec2;
    this.m_localCenterB = new box2d.b2Vec2;
    this.m_mass = new box2d.b2Mat33;
    this.m_qA = new box2d.b2Rot;
    this.m_qB = new box2d.b2Rot;
    this.m_lalcA = new box2d.b2Vec2;
    this.m_lalcB = new box2d.b2Vec2;
    this.m_K = new box2d.b2Mat22;
    this.m_localAnchorA.Copy(a.localAnchorA);
    this.m_localAnchorB.Copy(a.localAnchorB);
    this.m_referenceAngle = a.referenceAngle;
    this.m_impulse.SetZero();
    this.m_motorImpulse = 0;
    this.m_lowerAngle = a.lowerAngle;
    this.m_upperAngle = a.upperAngle;
    this.m_maxMotorTorque = a.maxMotorTorque;
    this.m_motorSpeed = a.motorSpeed;
    this.m_enableLimit = a.enableLimit;
    this.m_enableMotor = a.enableMotor;
    this.m_limitState = box2d.b2LimitState.e_inactiveLimit
};
goog.inherits(box2d.b2RevoluteJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2RevoluteJoint", box2d.b2RevoluteJoint);
box2d.b2RevoluteJoint.prototype.m_localAnchorA = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_localAnchorA", box2d.b2RevoluteJoint.prototype.m_localAnchorA);
box2d.b2RevoluteJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_localAnchorB", box2d.b2RevoluteJoint.prototype.m_localAnchorB);
box2d.b2RevoluteJoint.prototype.m_impulse = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_impulse", box2d.b2RevoluteJoint.prototype.m_impulse);
box2d.b2RevoluteJoint.prototype.m_motorImpulse = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_motorImpulse", box2d.b2RevoluteJoint.prototype.m_motorImpulse);
box2d.b2RevoluteJoint.prototype.m_enableMotor = !1;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_enableMotor", box2d.b2RevoluteJoint.prototype.m_enableMotor);
box2d.b2RevoluteJoint.prototype.m_maxMotorTorque = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_maxMotorTorque", box2d.b2RevoluteJoint.prototype.m_maxMotorTorque);
box2d.b2RevoluteJoint.prototype.m_motorSpeed = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_motorSpeed", box2d.b2RevoluteJoint.prototype.m_motorSpeed);
box2d.b2RevoluteJoint.prototype.m_enableLimit = !1;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_enableLimit", box2d.b2RevoluteJoint.prototype.m_enableLimit);
box2d.b2RevoluteJoint.prototype.m_referenceAngle = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_referenceAngle", box2d.b2RevoluteJoint.prototype.m_referenceAngle);
box2d.b2RevoluteJoint.prototype.m_lowerAngle = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_lowerAngle", box2d.b2RevoluteJoint.prototype.m_lowerAngle);
box2d.b2RevoluteJoint.prototype.m_upperAngle = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_upperAngle", box2d.b2RevoluteJoint.prototype.m_upperAngle);
box2d.b2RevoluteJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_indexA", box2d.b2RevoluteJoint.prototype.m_indexA);
box2d.b2RevoluteJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_indexB", box2d.b2RevoluteJoint.prototype.m_indexB);
box2d.b2RevoluteJoint.prototype.m_rA = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_rA", box2d.b2RevoluteJoint.prototype.m_rA);
box2d.b2RevoluteJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_rB", box2d.b2RevoluteJoint.prototype.m_rB);
box2d.b2RevoluteJoint.prototype.m_localCenterA = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_localCenterA", box2d.b2RevoluteJoint.prototype.m_localCenterA);
box2d.b2RevoluteJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_localCenterB", box2d.b2RevoluteJoint.prototype.m_localCenterB);
box2d.b2RevoluteJoint.prototype.m_invMassA = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_invMassA", box2d.b2RevoluteJoint.prototype.m_invMassA);
box2d.b2RevoluteJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_invMassB", box2d.b2RevoluteJoint.prototype.m_invMassB);
box2d.b2RevoluteJoint.prototype.m_invIA = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_invIA", box2d.b2RevoluteJoint.prototype.m_invIA);
box2d.b2RevoluteJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_invIB", box2d.b2RevoluteJoint.prototype.m_invIB);
box2d.b2RevoluteJoint.prototype.m_mass = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_mass", box2d.b2RevoluteJoint.prototype.m_mass);
box2d.b2RevoluteJoint.prototype.m_motorMass = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_motorMass", box2d.b2RevoluteJoint.prototype.m_motorMass);
box2d.b2RevoluteJoint.prototype.m_limitState = box2d.b2LimitState.e_inactiveLimit;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_limitState", box2d.b2RevoluteJoint.prototype.m_limitState);
box2d.b2RevoluteJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_qA", box2d.b2RevoluteJoint.prototype.m_qA);
box2d.b2RevoluteJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_qB", box2d.b2RevoluteJoint.prototype.m_qB);
box2d.b2RevoluteJoint.prototype.m_lalcA = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_lalcA", box2d.b2RevoluteJoint.prototype.m_lalcA);
box2d.b2RevoluteJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_lalcB", box2d.b2RevoluteJoint.prototype.m_lalcB);
box2d.b2RevoluteJoint.prototype.m_K = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_K", box2d.b2RevoluteJoint.prototype.m_K);
box2d.b2RevoluteJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassA = this.m_bodyA.m_invMass;
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIA = this.m_bodyA.m_invI;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = a.positions[this.m_indexA].a, c = a.velocities[this.m_indexA].v, e = a.velocities[this.m_indexA].w,
            d = a.positions[this.m_indexB].a, f = a.velocities[this.m_indexB].v, g = a.velocities[this.m_indexB].w, h = this.m_qA.SetAngleRadians(b), l = this.m_qB.SetAngleRadians(d);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    box2d.b2MulRV(h, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    box2d.b2MulRV(l, this.m_lalcB, this.m_rB);
    var h = this.m_invMassA, l = this.m_invMassB, k = this.m_invIA, m = this.m_invIB, n = 0 == k + m;
    this.m_mass.ex.x = h + l + this.m_rA.y * this.m_rA.y * k + this.m_rB.y *
            this.m_rB.y * m;
    this.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * k - this.m_rB.y * this.m_rB.x * m;
    this.m_mass.ez.x = -this.m_rA.y * k - this.m_rB.y * m;
    this.m_mass.ex.y = this.m_mass.ey.x;
    this.m_mass.ey.y = h + l + this.m_rA.x * this.m_rA.x * k + this.m_rB.x * this.m_rB.x * m;
    this.m_mass.ez.y = this.m_rA.x * k + this.m_rB.x * m;
    this.m_mass.ex.z = this.m_mass.ez.x;
    this.m_mass.ey.z = this.m_mass.ez.y;
    this.m_mass.ez.z = k + m;
    this.m_motorMass = k + m;
    0 < this.m_motorMass && (this.m_motorMass = 1 / this.m_motorMass);
    if (!1 == this.m_enableMotor || n)
        this.m_motorImpulse = 0;
    this.m_enableLimit && !1 == n ? (b = d - b - this.m_referenceAngle, box2d.b2Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * box2d.b2_angularSlop ? this.m_limitState = box2d.b2LimitState.e_equalLimits : b <= this.m_lowerAngle ? (this.m_limitState != box2d.b2LimitState.e_atLowerLimit && (this.m_impulse.z = 0), this.m_limitState = box2d.b2LimitState.e_atLowerLimit) : b >= this.m_upperAngle ? (this.m_limitState != box2d.b2LimitState.e_atUpperLimit && (this.m_impulse.z = 0), this.m_limitState = box2d.b2LimitState.e_atUpperLimit) : (this.m_limitState = box2d.b2LimitState.e_inactiveLimit,
            this.m_impulse.z = 0)) : this.m_limitState = box2d.b2LimitState.e_inactiveLimit;
    a.step.warmStarting ? (this.m_impulse.SelfMul(a.step.dtRatio), this.m_motorImpulse *= a.step.dtRatio, b = box2d.b2RevoluteJoint.prototype.InitVelocityConstraints.s_P.SetXY(this.m_impulse.x, this.m_impulse.y), c.SelfMulSub(h, b), e -= k * (box2d.b2CrossVV(this.m_rA, b) + this.m_motorImpulse + this.m_impulse.z), f.SelfMulAdd(l, b), g += m * (box2d.b2CrossVV(this.m_rB, b) + this.m_motorImpulse + this.m_impulse.z)) : (this.m_impulse.SetZero(), this.m_motorImpulse =
            0);
    a.velocities[this.m_indexA].w = e;
    a.velocities[this.m_indexB].w = g
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "InitVelocityConstraints", box2d.b2RevoluteJoint.prototype.InitVelocityConstraints);
box2d.b2RevoluteJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.velocities[this.m_indexB].v, d = a.velocities[this.m_indexB].w, f = this.m_invMassA, g = this.m_invMassB, h = this.m_invIA, l = this.m_invIB, k = 0 == h + l;
    if (this.m_enableMotor && this.m_limitState != box2d.b2LimitState.e_equalLimits && !1 == k) {
        var m = d - c - this.m_motorSpeed, m = -this.m_motorMass * m, n = this.m_motorImpulse, p = a.step.dt * this.m_maxMotorTorque;
        this.m_motorImpulse = box2d.b2Clamp(this.m_motorImpulse +
                m, -p, p);
        m = this.m_motorImpulse - n;
        c -= h * m;
        d += l * m
    }
    this.m_enableLimit && this.m_limitState != box2d.b2LimitState.e_inactiveLimit && !1 == k ? (k = box2d.b2SubVV(box2d.b2AddVCrossSV(e, d, this.m_rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(b, c, this.m_rA, box2d.b2Vec2.s_t1), box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot1), m = this.m_mass.Solve33(k.x, k.y, d - c, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse3).SelfNeg(), this.m_limitState == box2d.b2LimitState.e_equalLimits ? this.m_impulse.SelfAdd(m) :
            this.m_limitState == box2d.b2LimitState.e_atLowerLimit ? (n = this.m_impulse.z + m.z, 0 > n ? (n = -k.x + this.m_impulse.z * this.m_mass.ez.x, k = -k.y + this.m_impulse.z * this.m_mass.ez.y, k = this.m_mass.Solve22(n, k, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_reduced), m.x = k.x, m.y = k.y, m.z = -this.m_impulse.z, this.m_impulse.x += k.x, this.m_impulse.y += k.y, this.m_impulse.z = 0) : this.m_impulse.SelfAdd(m)) : this.m_limitState == box2d.b2LimitState.e_atUpperLimit && (n = this.m_impulse.z + m.z, 0 < n ? (n = -k.x + this.m_impulse.z * this.m_mass.ez.x,
            k = -k.y + this.m_impulse.z * this.m_mass.ez.y, k = this.m_mass.Solve22(n, k, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_reduced), m.x = k.x, m.y = k.y, m.z = -this.m_impulse.z, this.m_impulse.x += k.x, this.m_impulse.y += k.y, this.m_impulse.z = 0) : this.m_impulse.SelfAdd(m)), k = box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_P.SetXY(m.x, m.y), b.SelfMulSub(f, k), c -= h * (box2d.b2CrossVV(this.m_rA, k) + m.z), e.SelfMulAdd(g, k), d += l * (box2d.b2CrossVV(this.m_rB, k) + m.z)) : (m = box2d.b2SubVV(box2d.b2AddVCrossSV(e, d, this.m_rB,
            box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(b, c, this.m_rA, box2d.b2Vec2.s_t1), box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot), m = this.m_mass.Solve22(-m.x, -m.y, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse2), this.m_impulse.x += m.x, this.m_impulse.y += m.y, b.SelfMulSub(f, m), c -= h * box2d.b2CrossVV(this.m_rA, m), e.SelfMulAdd(g, m), d += l * box2d.b2CrossVV(this.m_rB, m));
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = d
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "SolveVelocityConstraints", box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints);
box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2;
box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot1 = new box2d.b2Vec2;
box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse3 = new box2d.b2Vec3;
box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_reduced = new box2d.b2Vec2;
box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse2 = new box2d.b2Vec2;
box2d.b2RevoluteJoint.prototype.SolvePositionConstraints = function(a) {
    var b = a.positions[this.m_indexA].c, c = a.positions[this.m_indexA].a, e = a.positions[this.m_indexB].c, d = a.positions[this.m_indexB].a, f = this.m_qA.SetAngleRadians(c), g = this.m_qB.SetAngleRadians(d), h = 0, l = 0, l = 0 == this.m_invIA + this.m_invIB;
    if (this.m_enableLimit && this.m_limitState != box2d.b2LimitState.e_inactiveLimit && !1 == l) {
        var k = d - c - this.m_referenceAngle, l = 0;
        this.m_limitState == box2d.b2LimitState.e_equalLimits ? (k = box2d.b2Clamp(k - this.m_lowerAngle,
                -box2d.b2_maxAngularCorrection, box2d.b2_maxAngularCorrection), l = -this.m_motorMass * k, h = box2d.b2Abs(k)) : this.m_limitState == box2d.b2LimitState.e_atLowerLimit ? (k -= this.m_lowerAngle, h = -k, k = box2d.b2Clamp(k + box2d.b2_angularSlop, -box2d.b2_maxAngularCorrection, 0), l = -this.m_motorMass * k) : this.m_limitState == box2d.b2LimitState.e_atUpperLimit && (h = k -= this.m_upperAngle, k = box2d.b2Clamp(k - box2d.b2_angularSlop, 0, box2d.b2_maxAngularCorrection), l = -this.m_motorMass * k);
        c -= this.m_invIA * l;
        d += this.m_invIB * l
    }
    f.SetAngleRadians(c);
    g.SetAngleRadians(d);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    f = box2d.b2MulRV(f, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var g = box2d.b2MulRV(g, this.m_lalcB, this.m_rB), k = box2d.b2SubVV(box2d.b2AddVV(e, g, box2d.b2Vec2.s_t0), box2d.b2AddVV(b, f, box2d.b2Vec2.s_t1), box2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_C), l = k.GetLength(), m = this.m_invMassA, n = this.m_invMassB, p = this.m_invIA, q = this.m_invIB, r = this.m_K;
    r.ex.x = m + n +
            p * f.y * f.y + q * g.y * g.y;
    r.ex.y = -p * f.x * f.y - q * g.x * g.y;
    r.ey.x = r.ex.y;
    r.ey.y = m + n + p * f.x * f.x + q * g.x * g.x;
    k = r.Solve(k.x, k.y, box2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_impulse).SelfNeg();
    b.SelfMulSub(m, k);
    c -= p * box2d.b2CrossVV(f, k);
    e.SelfMulAdd(n, k);
    d += q * box2d.b2CrossVV(g, k);
    a.positions[this.m_indexA].a = c;
    a.positions[this.m_indexB].a = d;
    return l <= box2d.b2_linearSlop && h <= box2d.b2_angularSlop
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "SolvePositionConstraints", box2d.b2RevoluteJoint.prototype.SolvePositionConstraints);
box2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_C = new box2d.b2Vec2;
box2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_impulse = new box2d.b2Vec2;
box2d.b2RevoluteJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, a)
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetAnchorA", box2d.b2RevoluteJoint.prototype.GetAnchorA);
box2d.b2RevoluteJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetAnchorB", box2d.b2RevoluteJoint.prototype.GetAnchorB);
box2d.b2RevoluteJoint.prototype.GetReactionForce = function(a, b) {
    return b.SetXY(a * this.m_impulse.x, a * this.m_impulse.y)
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetReactionForce", box2d.b2RevoluteJoint.prototype.GetReactionForce);
box2d.b2RevoluteJoint.prototype.GetReactionTorque = function(a) {
    return a * this.m_impulse.z
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetReactionTorque", box2d.b2RevoluteJoint.prototype.GetReactionTorque);
box2d.b2RevoluteJoint.prototype.GetLocalAnchorA = function(a) {
    return a.Copy(this.m_localAnchorA)
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetLocalAnchorA", box2d.b2RevoluteJoint.prototype.GetLocalAnchorA);
box2d.b2RevoluteJoint.prototype.GetLocalAnchorB = function(a) {
    return a.Copy(this.m_localAnchorB)
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetLocalAnchorB", box2d.b2RevoluteJoint.prototype.GetLocalAnchorB);
box2d.b2RevoluteJoint.prototype.GetReferenceAngle = function() {
    return this.m_referenceAngle
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetReferenceAngle", box2d.b2RevoluteJoint.prototype.GetReferenceAngle);
box2d.b2RevoluteJoint.prototype.GetJointAngleRadians = function() {
    return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetJointAngleRadians", box2d.b2RevoluteJoint.prototype.GetJointAngleRadians);
box2d.b2RevoluteJoint.prototype.GetJointSpeed = function() {
    return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetJointSpeed", box2d.b2RevoluteJoint.prototype.GetJointSpeed);
box2d.b2RevoluteJoint.prototype.IsMotorEnabled = function() {
    return this.m_enableMotor
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "IsMotorEnabled", box2d.b2RevoluteJoint.prototype.IsMotorEnabled);
box2d.b2RevoluteJoint.prototype.EnableMotor = function(a) {
    this.m_enableMotor != a && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor = a)
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "EnableMotor", box2d.b2RevoluteJoint.prototype.EnableMotor);
box2d.b2RevoluteJoint.prototype.GetMotorTorque = function(a) {
    return a * this.m_motorImpulse
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetMotorTorque", box2d.b2RevoluteJoint.prototype.GetMotorTorque);
box2d.b2RevoluteJoint.prototype.GetMotorSpeed = function() {
    return this.m_motorSpeed
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetMotorSpeed", box2d.b2RevoluteJoint.prototype.GetMotorSpeed);
box2d.b2RevoluteJoint.prototype.SetMaxMotorTorque = function(a) {
    this.m_maxMotorTorque = a
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "SetMaxMotorTorque", box2d.b2RevoluteJoint.prototype.SetMaxMotorTorque);
box2d.b2RevoluteJoint.prototype.GetMaxMotorTorque = function() {
    return this.m_maxMotorTorque
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetMaxMotorTorque", box2d.b2RevoluteJoint.prototype.GetMaxMotorTorque);
box2d.b2RevoluteJoint.prototype.IsLimitEnabled = function() {
    return this.m_enableLimit
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "IsLimitEnabled", box2d.b2RevoluteJoint.prototype.IsLimitEnabled);
box2d.b2RevoluteJoint.prototype.EnableLimit = function(a) {
    a != this.m_enableLimit && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableLimit = a, this.m_impulse.z = 0)
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "EnableLimit", box2d.b2RevoluteJoint.prototype.EnableLimit);
box2d.b2RevoluteJoint.prototype.GetLowerLimit = function() {
    return this.m_lowerAngle
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetLowerLimit", box2d.b2RevoluteJoint.prototype.GetLowerLimit);
box2d.b2RevoluteJoint.prototype.GetUpperLimit = function() {
    return this.m_upperAngle
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetUpperLimit", box2d.b2RevoluteJoint.prototype.GetUpperLimit);
box2d.b2RevoluteJoint.prototype.SetLimits = function(a, b) {
    if (a != this.m_lowerAngle || b != this.m_upperAngle)
        this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_impulse.z = 0, this.m_lowerAngle = a, this.m_upperAngle = b
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "SetLimits", box2d.b2RevoluteJoint.prototype.SetLimits);
box2d.b2RevoluteJoint.prototype.SetMotorSpeed = function(a) {
    this.m_motorSpeed != a && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = a)
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "SetMotorSpeed", box2d.b2RevoluteJoint.prototype.SetMotorSpeed);
box2d.b2RevoluteJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2RevoluteJointDef*/ var jd = new box2d.b2RevoluteJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
        box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n",
                this.m_localAnchorB.x, this.m_localAnchorB.y);
        box2d.b2Log("  jd.referenceAngle = %.15f;\n", this.m_referenceAngle);
        box2d.b2Log("  jd.enableLimit = %s;\n", this.m_enableLimit ? "true" : "false");
        box2d.b2Log("  jd.lowerAngle = %.15f;\n", this.m_lowerAngle);
        box2d.b2Log("  jd.upperAngle = %.15f;\n", this.m_upperAngle);
        box2d.b2Log("  jd.enableMotor = %s;\n", this.m_enableMotor ? "true" : "false");
        box2d.b2Log("  jd.motorSpeed = %.15f;\n", this.m_motorSpeed);
        box2d.b2Log("  jd.maxMotorTorque = %.15f;\n", this.m_maxMotorTorque);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "Dump", box2d.b2RevoluteJoint.prototype.Dump);
box2d.b2PrismaticJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_prismaticJoint);
    this.localAnchorA = new box2d.b2Vec2;
    this.localAnchorB = new box2d.b2Vec2;
    this.localAxisA = new box2d.b2Vec2(1, 0)
};
goog.inherits(box2d.b2PrismaticJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2PrismaticJointDef", box2d.b2PrismaticJointDef);
box2d.b2PrismaticJointDef.prototype.localAnchorA = null;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "localAnchorA", box2d.b2PrismaticJointDef.prototype.localAnchorA);
box2d.b2PrismaticJointDef.prototype.localAnchorB = null;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "localAnchorB", box2d.b2PrismaticJointDef.prototype.localAnchorB);
box2d.b2PrismaticJointDef.prototype.localAxisA = null;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "localAxisA", box2d.b2PrismaticJointDef.prototype.localAxisA);
box2d.b2PrismaticJointDef.prototype.referenceAngle = 0;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "referenceAngle", box2d.b2PrismaticJointDef.prototype.referenceAngle);
box2d.b2PrismaticJointDef.prototype.enableLimit = !1;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "enableLimit", box2d.b2PrismaticJointDef.prototype.enableLimit);
box2d.b2PrismaticJointDef.prototype.lowerTranslation = 0;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "lowerTranslation", box2d.b2PrismaticJointDef.prototype.lowerTranslation);
box2d.b2PrismaticJointDef.prototype.upperTranslation = 0;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "upperTranslation", box2d.b2PrismaticJointDef.prototype.upperTranslation);
box2d.b2PrismaticJointDef.prototype.enableMotor = !1;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "enableMotor", box2d.b2PrismaticJointDef.prototype.enableMotor);
box2d.b2PrismaticJointDef.prototype.maxMotorForce = 0;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "maxMotorForce", box2d.b2PrismaticJointDef.prototype.maxMotorForce);
box2d.b2PrismaticJointDef.prototype.motorSpeed = 0;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "motorSpeed", box2d.b2PrismaticJointDef.prototype.motorSpeed);
box2d.b2PrismaticJointDef.prototype.Initialize = function(a, b, c, e) {
    this.bodyA = a;
    this.bodyB = b;
    this.bodyA.GetLocalPoint(c, this.localAnchorA);
    this.bodyB.GetLocalPoint(c, this.localAnchorB);
    this.bodyA.GetLocalVector(e, this.localAxisA);
    this.referenceAngle = this.bodyB.GetAngleRadians() - this.bodyA.GetAngleRadians()
};
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "Initialize", box2d.b2PrismaticJointDef.prototype.Initialize);
box2d.b2PrismaticJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_localAnchorA = a.localAnchorA.Clone();
    this.m_localAnchorB = a.localAnchorB.Clone();
    this.m_localXAxisA = a.localAxisA.Clone().SelfNormalize();
    this.m_localYAxisA = box2d.b2CrossOneV(this.m_localXAxisA, new box2d.b2Vec2);
    this.m_referenceAngle = a.referenceAngle;
    this.m_impulse = new box2d.b2Vec3(0, 0, 0);
    this.m_lowerTranslation = a.lowerTranslation;
    this.m_upperTranslation = a.upperTranslation;
    this.m_maxMotorForce = a.maxMotorForce;
    this.m_motorSpeed = a.motorSpeed;
    this.m_enableLimit = a.enableLimit;
    this.m_enableMotor = a.enableMotor;
    this.m_localCenterA = new box2d.b2Vec2;
    this.m_localCenterB = new box2d.b2Vec2;
    this.m_axis = new box2d.b2Vec2(0, 0);
    this.m_perp = new box2d.b2Vec2(0, 0);
    this.m_K = new box2d.b2Mat33;
    this.m_K3 = new box2d.b2Mat33;
    this.m_K2 = new box2d.b2Mat22;
    this.m_qA = new box2d.b2Rot;
    this.m_qB = new box2d.b2Rot;
    this.m_lalcA = new box2d.b2Vec2;
    this.m_lalcB = new box2d.b2Vec2;
    this.m_rA = new box2d.b2Vec2;
    this.m_rB = new box2d.b2Vec2
};
goog.inherits(box2d.b2PrismaticJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2PrismaticJoint", box2d.b2PrismaticJoint);
box2d.b2PrismaticJoint.prototype.m_localAnchorA = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_localAnchorA", box2d.b2PrismaticJoint.prototype.m_localAnchorA);
box2d.b2PrismaticJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_localAnchorB", box2d.b2PrismaticJoint.prototype.m_localAnchorB);
box2d.b2PrismaticJoint.prototype.m_localXAxisA = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_localXAxisA", box2d.b2PrismaticJoint.prototype.m_localXAxisA);
box2d.b2PrismaticJoint.prototype.m_localYAxisA = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_localYAxisA", box2d.b2PrismaticJoint.prototype.m_localYAxisA);
box2d.b2PrismaticJoint.prototype.m_referenceAngle = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_referenceAngle", box2d.b2PrismaticJoint.prototype.m_referenceAngle);
box2d.b2PrismaticJoint.prototype.m_impulse = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_impulse", box2d.b2PrismaticJoint.prototype.m_impulse);
box2d.b2PrismaticJoint.prototype.m_motorImpulse = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_motorImpulse", box2d.b2PrismaticJoint.prototype.m_motorImpulse);
box2d.b2PrismaticJoint.prototype.m_lowerTranslation = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_lowerTranslation", box2d.b2PrismaticJoint.prototype.m_lowerTranslation);
box2d.b2PrismaticJoint.prototype.m_upperTranslation = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_upperTranslation", box2d.b2PrismaticJoint.prototype.m_upperTranslation);
box2d.b2PrismaticJoint.prototype.m_maxMotorForce = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_maxMotorForce", box2d.b2PrismaticJoint.prototype.m_maxMotorForce);
box2d.b2PrismaticJoint.prototype.m_motorSpeed = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_motorSpeed", box2d.b2PrismaticJoint.prototype.m_motorSpeed);
box2d.b2PrismaticJoint.prototype.m_enableLimit = !1;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_enableLimit", box2d.b2PrismaticJoint.prototype.m_enableLimit);
box2d.b2PrismaticJoint.prototype.m_enableMotor = !1;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_enableMotor", box2d.b2PrismaticJoint.prototype.m_enableMotor);
box2d.b2PrismaticJoint.prototype.m_limitState = box2d.b2LimitState.e_inactiveLimit;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_limitState", box2d.b2PrismaticJoint.prototype.m_limitState);
box2d.b2PrismaticJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_indexA", box2d.b2PrismaticJoint.prototype.m_indexA);
box2d.b2PrismaticJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_indexB", box2d.b2PrismaticJoint.prototype.m_indexB);
box2d.b2PrismaticJoint.prototype.m_localCenterA = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_localCenterA", box2d.b2PrismaticJoint.prototype.m_localCenterA);
box2d.b2PrismaticJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_localCenterB", box2d.b2PrismaticJoint.prototype.m_localCenterB);
box2d.b2PrismaticJoint.prototype.m_invMassA = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_invMassA", box2d.b2PrismaticJoint.prototype.m_invMassA);
box2d.b2PrismaticJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_invMassB", box2d.b2PrismaticJoint.prototype.m_invMassB);
box2d.b2PrismaticJoint.prototype.m_invIA = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_invIA", box2d.b2PrismaticJoint.prototype.m_invIA);
box2d.b2PrismaticJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_invIB", box2d.b2PrismaticJoint.prototype.m_invIB);
box2d.b2PrismaticJoint.prototype.m_axis = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_axis", box2d.b2PrismaticJoint.prototype.m_axis);
box2d.b2PrismaticJoint.prototype.m_perp = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_perp", box2d.b2PrismaticJoint.prototype.m_perp);
box2d.b2PrismaticJoint.prototype.m_s1 = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_s1", box2d.b2PrismaticJoint.prototype.m_s1);
box2d.b2PrismaticJoint.prototype.m_s2 = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_s2", box2d.b2PrismaticJoint.prototype.m_s2);
box2d.b2PrismaticJoint.prototype.m_a1 = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_a1", box2d.b2PrismaticJoint.prototype.m_a1);
box2d.b2PrismaticJoint.prototype.m_a2 = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_a2", box2d.b2PrismaticJoint.prototype.m_a2);
box2d.b2PrismaticJoint.prototype.m_K = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_K", box2d.b2PrismaticJoint.prototype.m_K);
box2d.b2PrismaticJoint.prototype.m_K3 = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_K3", box2d.b2PrismaticJoint.prototype.m_K3);
box2d.b2PrismaticJoint.prototype.m_K2 = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_K2", box2d.b2PrismaticJoint.prototype.m_K2);
box2d.b2PrismaticJoint.prototype.m_motorMass = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_motorMass", box2d.b2PrismaticJoint.prototype.m_motorMass);
box2d.b2PrismaticJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_qA", box2d.b2PrismaticJoint.prototype.m_qA);
box2d.b2PrismaticJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_qB", box2d.b2PrismaticJoint.prototype.m_qB);
box2d.b2PrismaticJoint.prototype.m_lalcA = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_lalcA", box2d.b2PrismaticJoint.prototype.m_lalcA);
box2d.b2PrismaticJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_lalcB", box2d.b2PrismaticJoint.prototype.m_lalcB);
box2d.b2PrismaticJoint.prototype.m_rA = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_rA", box2d.b2PrismaticJoint.prototype.m_rA);
box2d.b2PrismaticJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_rB", box2d.b2PrismaticJoint.prototype.m_rB);
box2d.b2PrismaticJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassA = this.m_bodyA.m_invMass;
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIA = this.m_bodyA.m_invI;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = a.positions[this.m_indexA].c, c = a.velocities[this.m_indexA].v, e = a.velocities[this.m_indexA].w,
            d = a.positions[this.m_indexB].c, f = a.positions[this.m_indexB].a, g = a.velocities[this.m_indexB].v, h = a.velocities[this.m_indexB].w, l = this.m_qA.SetAngleRadians(a.positions[this.m_indexA].a), f = this.m_qB.SetAngleRadians(f);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    var k = box2d.b2MulRV(l, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var m = box2d.b2MulRV(f, this.m_lalcB, this.m_rB), n = box2d.b2AddVV(box2d.b2SubVV(d, b, box2d.b2Vec2.s_t0), box2d.b2SubVV(m,
            k, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_d), b = this.m_invMassA, d = this.m_invMassB, f = this.m_invIA, p = this.m_invIB;
    box2d.b2MulRV(l, this.m_localXAxisA, this.m_axis);
    this.m_a1 = box2d.b2CrossVV(box2d.b2AddVV(n, k, box2d.b2Vec2.s_t0), this.m_axis);
    this.m_a2 = box2d.b2CrossVV(m, this.m_axis);
    this.m_motorMass = b + d + f * this.m_a1 * this.m_a1 + p * this.m_a2 * this.m_a2;
    0 < this.m_motorMass && (this.m_motorMass = 1 / this.m_motorMass);
    box2d.b2MulRV(l, this.m_localYAxisA, this.m_perp);
    this.m_s1 = box2d.b2CrossVV(box2d.b2AddVV(n,
            k, box2d.b2Vec2.s_t0), this.m_perp);
    this.m_s2 = box2d.b2CrossVV(m, this.m_perp);
    this.m_K.ex.x = b + d + f * this.m_s1 * this.m_s1 + p * this.m_s2 * this.m_s2;
    this.m_K.ex.y = f * this.m_s1 + p * this.m_s2;
    this.m_K.ex.z = f * this.m_s1 * this.m_a1 + p * this.m_s2 * this.m_a2;
    this.m_K.ey.x = this.m_K.ex.y;
    this.m_K.ey.y = f + p;
    0 == this.m_K.ey.y && (this.m_K.ey.y = 1);
    this.m_K.ey.z = f * this.m_a1 + p * this.m_a2;
    this.m_K.ez.x = this.m_K.ex.z;
    this.m_K.ez.y = this.m_K.ey.z;
    this.m_K.ez.z = b + d + f * this.m_a1 * this.m_a1 + p * this.m_a2 * this.m_a2;
    this.m_enableLimit ? (l = box2d.b2DotVV(this.m_axis,
            n), box2d.b2Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * box2d.b2_linearSlop ? this.m_limitState = box2d.b2LimitState.e_equalLimits : l <= this.m_lowerTranslation ? this.m_limitState != box2d.b2LimitState.e_atLowerLimit && (this.m_limitState = box2d.b2LimitState.e_atLowerLimit, this.m_impulse.z = 0) : l >= this.m_upperTranslation ? this.m_limitState != box2d.b2LimitState.e_atUpperLimit && (this.m_limitState = box2d.b2LimitState.e_atUpperLimit, this.m_impulse.z = 0) : (this.m_limitState = box2d.b2LimitState.e_inactiveLimit, this.m_impulse.z =
            0)) : (this.m_limitState = box2d.b2LimitState.e_inactiveLimit, this.m_impulse.z = 0);
    !1 == this.m_enableMotor && (this.m_motorImpulse = 0);
    a.step.warmStarting ? (this.m_impulse.SelfMul(a.step.dtRatio), this.m_motorImpulse *= a.step.dtRatio, l = box2d.b2AddVV(box2d.b2MulSV(this.m_impulse.x, this.m_perp, box2d.b2Vec2.s_t0), box2d.b2MulSV(this.m_motorImpulse + this.m_impulse.z, this.m_axis, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_P), k = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse +
            this.m_impulse.z) * this.m_a1, m = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2, c.SelfMulSub(b, l), e -= f * k, g.SelfMulAdd(d, l), h += p * m) : (this.m_impulse.SetZero(), this.m_motorImpulse = 0);
    a.velocities[this.m_indexA].w = e;
    a.velocities[this.m_indexB].w = h
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "InitVelocityConstraints", box2d.b2PrismaticJoint.prototype.InitVelocityConstraints);
box2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_d = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.velocities[this.m_indexB].v, d = a.velocities[this.m_indexB].w, f = this.m_invMassA, g = this.m_invMassB, h = this.m_invIA, l = this.m_invIB;
    if (this.m_enableMotor && this.m_limitState != box2d.b2LimitState.e_equalLimits) {
        var k = box2d.b2DotVV(this.m_axis, box2d.b2SubVV(e, b, box2d.b2Vec2.s_t0)) + this.m_a2 * d - this.m_a1 * c, k = this.m_motorMass * (this.m_motorSpeed - k), m = this.m_motorImpulse,
                n = a.step.dt * this.m_maxMotorForce;
        this.m_motorImpulse = box2d.b2Clamp(this.m_motorImpulse + k, -n, n);
        k = this.m_motorImpulse - m;
        m = box2d.b2MulSV(k, this.m_axis, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P);
        n = k * this.m_a1;
        k *= this.m_a2;
        b.SelfMulSub(f, m);
        c -= h * n;
        e.SelfMulAdd(g, m);
        d += l * k
    }
    var n = box2d.b2DotVV(this.m_perp, box2d.b2SubVV(e, b, box2d.b2Vec2.s_t0)) + this.m_s2 * d - this.m_s1 * c, p = d - c;
    this.m_enableLimit && this.m_limitState != box2d.b2LimitState.e_inactiveLimit ? (k = box2d.b2DotVV(this.m_axis, box2d.b2SubVV(e,
            b, box2d.b2Vec2.s_t0)) + this.m_a2 * d - this.m_a1 * c, m = box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f1.Copy(this.m_impulse), k = this.m_K.Solve33(-n, -p, -k, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df3), this.m_impulse.SelfAdd(k), this.m_limitState == box2d.b2LimitState.e_atLowerLimit ? this.m_impulse.z = box2d.b2Max(this.m_impulse.z, 0) : this.m_limitState == box2d.b2LimitState.e_atUpperLimit && (this.m_impulse.z = box2d.b2Min(this.m_impulse.z, 0)), n = this.m_K.Solve22(-n - (this.m_impulse.z - m.z) *
            this.m_K.ez.x, -p - (this.m_impulse.z - m.z) * this.m_K.ez.y, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f2r), n.x += m.x, n.y += m.y, this.m_impulse.x = n.x, this.m_impulse.y = n.y, k.x = this.m_impulse.x - m.x, k.y = this.m_impulse.y - m.y, k.z = this.m_impulse.z - m.z, m = box2d.b2AddVV(box2d.b2MulSV(k.x, this.m_perp, box2d.b2Vec2.s_t0), box2d.b2MulSV(k.z, this.m_axis, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P), n = k.x * this.m_s1 + k.y + k.z * this.m_a1, k = k.x * this.m_s2 + k.y + k.z * this.m_a2) : (k =
            this.m_K.Solve22(-n, -p, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df2), this.m_impulse.x += k.x, this.m_impulse.y += k.y, m = box2d.b2MulSV(k.x, this.m_perp, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P), n = k.x * this.m_s1 + k.y, k = k.x * this.m_s2 + k.y);
    b.SelfMulSub(f, m);
    c -= h * n;
    e.SelfMulAdd(g, m);
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = d + l * k
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "SolveVelocityConstraints", box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints);
box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f2r = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f1 = new box2d.b2Vec3;
box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df3 = new box2d.b2Vec3;
box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df2 = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.SolvePositionConstraints = function(a) {
    var b = a.positions[this.m_indexA].c, c = a.positions[this.m_indexA].a, e = a.positions[this.m_indexB].c, d = a.positions[this.m_indexB].a, f = this.m_qA.SetAngleRadians(c), g = this.m_qB.SetAngleRadians(d), h = this.m_invMassA, l = this.m_invMassB, k = this.m_invIA, m = this.m_invIB, n = box2d.b2MulRV(f, this.m_lalcA, this.m_rA), p = box2d.b2MulRV(g, this.m_lalcB, this.m_rB), q = box2d.b2SubVV(box2d.b2AddVV(e, p, box2d.b2Vec2.s_t0), box2d.b2AddVV(b, n, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_d),
            r = box2d.b2MulRV(f, this.m_localXAxisA, this.m_axis), t = box2d.b2CrossVV(box2d.b2AddVV(q, n, box2d.b2Vec2.s_t0), r), g = box2d.b2CrossVV(p, r), f = box2d.b2MulRV(f, this.m_localYAxisA, this.m_perp), s = box2d.b2CrossVV(box2d.b2AddVV(q, n, box2d.b2Vec2.s_t0), f), u = box2d.b2CrossVV(p, f), v = box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse, y = box2d.b2DotVV(f, q), D = d - c - this.m_referenceAngle, n = box2d.b2Abs(y), p = box2d.b2Abs(D), x = !1, w = 0;
    this.m_enableLimit && (q = box2d.b2DotVV(r, q), box2d.b2Abs(this.m_upperTranslation -
            this.m_lowerTranslation) < 2 * box2d.b2_linearSlop ? (w = box2d.b2Clamp(q, -box2d.b2_maxLinearCorrection, box2d.b2_maxLinearCorrection), n = box2d.b2Max(n, box2d.b2Abs(q)), x = !0) : q <= this.m_lowerTranslation ? (w = box2d.b2Clamp(q - this.m_lowerTranslation + box2d.b2_linearSlop, -box2d.b2_maxLinearCorrection, 0), n = box2d.b2Max(n, this.m_lowerTranslation - q), x = !0) : q >= this.m_upperTranslation && (w = box2d.b2Clamp(q - this.m_upperTranslation - box2d.b2_linearSlop, 0, box2d.b2_maxLinearCorrection), n = box2d.b2Max(n, q - this.m_upperTranslation),
            x = !0));
    if (x) {
        var q = k * s + m * u, C = k * s * t + m * u * g, x = k + m;
        0 == x && (x = 1);
        var A = k * t + m * g, E = h + l + k * t * t + m * g * g, B = this.m_K3;
        B.ex.SetXYZ(h + l + k * s * s + m * u * u, q, C);
        B.ey.SetXYZ(q, x, A);
        B.ez.SetXYZ(C, A, E);
        v = B.Solve33(-y, -D, -w, v)
    } else
        q = k * s + m * u, x = k + m, 0 == x && (x = 1), w = this.m_K2, w.ex.SetXY(h + l + k * s * s + m * u * u, q), w.ey.SetXY(q, x), y = w.Solve(-y, -D, box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse1), v.x = y.x, v.y = y.y, v.z = 0;
    r = box2d.b2AddVV(box2d.b2MulSV(v.x, f, box2d.b2Vec2.s_t0), box2d.b2MulSV(v.z, r, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_P);
    t = v.x * s + v.y + v.z * t;
    g = v.x * u + v.y + v.z * g;
    b.SelfMulSub(h, r);
    c -= k * t;
    e.SelfMulAdd(l, r);
    a.positions[this.m_indexA].a = c;
    a.positions[this.m_indexB].a = d + m * g;
    return n <= box2d.b2_linearSlop && p <= box2d.b2_angularSlop
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "SolvePositionConstraints", box2d.b2PrismaticJoint.prototype.SolvePositionConstraints);
box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_d = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse = new box2d.b2Vec3;
box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse1 = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, a)
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetAnchorA", box2d.b2PrismaticJoint.prototype.GetAnchorA);
box2d.b2PrismaticJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetAnchorB", box2d.b2PrismaticJoint.prototype.GetAnchorB);
box2d.b2PrismaticJoint.prototype.GetReactionForce = function(a, b) {
    return b.SetXY(a * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), a * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y))
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetReactionForce", box2d.b2PrismaticJoint.prototype.GetReactionForce);
box2d.b2PrismaticJoint.prototype.GetReactionTorque = function(a) {
    return a * this.m_impulse.y
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetReactionTorque", box2d.b2PrismaticJoint.prototype.GetReactionTorque);
box2d.b2PrismaticJoint.prototype.GetLocalAnchorA = function(a) {
    return a.Copy(this.m_localAnchorA)
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetLocalAnchorA", box2d.b2PrismaticJoint.prototype.GetLocalAnchorA);
box2d.b2PrismaticJoint.prototype.GetLocalAnchorB = function(a) {
    return a.Copy(this.m_localAnchorB)
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetLocalAnchorB", box2d.b2PrismaticJoint.prototype.GetLocalAnchorB);
box2d.b2PrismaticJoint.prototype.GetLocalAxisA = function(a) {
    return a.Copy(this.m_localXAxisA)
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetLocalAxisA", box2d.b2PrismaticJoint.prototype.GetLocalAxisA);
box2d.b2PrismaticJoint.prototype.GetReferenceAngle = function() {
    return this.m_referenceAngle
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetReferenceAngle", box2d.b2PrismaticJoint.prototype.GetReferenceAngle);
box2d.b2PrismaticJoint.prototype.GetJointTranslation = function() {
    var a = this.m_bodyA.GetWorldPoint(this.m_localAnchorA, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pA), b = this.m_bodyB.GetWorldPoint(this.m_localAnchorB, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pB), a = box2d.b2SubVV(b, a, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_d), b = this.m_bodyA.GetWorldVector(this.m_localXAxisA, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_axis);
    return box2d.b2DotVV(a, b)
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetJointTranslation", box2d.b2PrismaticJoint.prototype.GetJointTranslation);
box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pA = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pB = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_d = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_axis = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.GetJointSpeed = function() {
    var a = this.m_bodyA, b = this.m_bodyB;
    box2d.b2SubVV(this.m_localAnchorA, a.m_sweep.localCenter, this.m_lalcA);
    var c = box2d.b2MulRV(a.m_xf.q, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, b.m_sweep.localCenter, this.m_lalcB);
    var e = box2d.b2MulRV(b.m_xf.q, this.m_lalcB, this.m_rB), d = box2d.b2AddVV(a.m_sweep.c, c, box2d.b2Vec2.s_t0), f = box2d.b2AddVV(b.m_sweep.c, e, box2d.b2Vec2.s_t1), d = box2d.b2SubVV(f, d, box2d.b2Vec2.s_t2), f = a.GetWorldVector(this.m_localXAxisA,
            this.m_axis), g = a.m_linearVelocity, h = b.m_linearVelocity, a = a.m_angularVelocity, b = b.m_angularVelocity;
    return box2d.b2DotVV(d, box2d.b2CrossSV(a, f, box2d.b2Vec2.s_t0)) + box2d.b2DotVV(f, box2d.b2SubVV(box2d.b2AddVCrossSV(h, b, e, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(g, a, c, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t0))
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetJointSpeed", box2d.b2PrismaticJoint.prototype.GetJointSpeed);
box2d.b2PrismaticJoint.prototype.IsLimitEnabled = function() {
    return this.m_enableLimit
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "IsLimitEnabled", box2d.b2PrismaticJoint.prototype.IsLimitEnabled);
box2d.b2PrismaticJoint.prototype.EnableLimit = function(a) {
    a != this.m_enableLimit && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableLimit = a, this.m_impulse.z = 0)
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "EnableLimit", box2d.b2PrismaticJoint.prototype.EnableLimit);
box2d.b2PrismaticJoint.prototype.GetLowerLimit = function() {
    return this.m_lowerTranslation
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetLowerLimit", box2d.b2PrismaticJoint.prototype.GetLowerLimit);
box2d.b2PrismaticJoint.prototype.GetUpperLimit = function() {
    return this.m_upperTranslation
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetUpperLimit", box2d.b2PrismaticJoint.prototype.GetUpperLimit);
box2d.b2PrismaticJoint.prototype.SetLimits = function(a, b) {
    if (a != this.m_lowerTranslation || b != this.m_upperTranslation)
        this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_lowerTranslation = a, this.m_upperTranslation = b, this.m_impulse.z = 0
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "SetLimits", box2d.b2PrismaticJoint.prototype.SetLimits);
box2d.b2PrismaticJoint.prototype.IsMotorEnabled = function() {
    return this.m_enableMotor
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "IsMotorEnabled", box2d.b2PrismaticJoint.prototype.IsMotorEnabled);
box2d.b2PrismaticJoint.prototype.EnableMotor = function(a) {
    this.m_bodyA.SetAwake(!0);
    this.m_bodyB.SetAwake(!0);
    this.m_enableMotor = a
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "EnableMotor", box2d.b2PrismaticJoint.prototype.EnableMotor);
box2d.b2PrismaticJoint.prototype.SetMotorSpeed = function(a) {
    this.m_bodyA.SetAwake(!0);
    this.m_bodyB.SetAwake(!0);
    this.m_motorSpeed = a
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "SetMotorSpeed", box2d.b2PrismaticJoint.prototype.SetMotorSpeed);
box2d.b2PrismaticJoint.prototype.GetMotorSpeed = function() {
    return this.m_motorSpeed
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetMotorSpeed", box2d.b2PrismaticJoint.prototype.GetMotorSpeed);
box2d.b2PrismaticJoint.prototype.SetMaxMotorForce = function(a) {
    this.m_bodyA.SetAwake(!0);
    this.m_bodyB.SetAwake(!0);
    this.m_maxMotorForce = a
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "SetMaxMotorForce", box2d.b2PrismaticJoint.prototype.SetMaxMotorForce);
box2d.b2PrismaticJoint.prototype.GetMaxMotorForce = function() {
    return this.m_maxMotorForce
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetMaxMotorForce", box2d.b2PrismaticJoint.prototype.GetMaxMotorForce);
box2d.b2PrismaticJoint.prototype.GetMotorForce = function(a) {
    return a * this.m_motorImpulse
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetMotorForce", box2d.b2PrismaticJoint.prototype.GetMotorForce);
box2d.b2PrismaticJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2PrismaticJointDef*/ var jd = new box2d.b2PrismaticJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
        box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n",
                this.m_localAnchorB.x, this.m_localAnchorB.y);
        box2d.b2Log("  jd.localAxisA.SetXY(%.15f, %.15f);\n", this.m_localXAxisA.x, this.m_localXAxisA.y);
        box2d.b2Log("  jd.referenceAngle = %.15f;\n", this.m_referenceAngle);
        box2d.b2Log("  jd.enableLimit = %s;\n", this.m_enableLimit ? "true" : "false");
        box2d.b2Log("  jd.lowerTranslation = %.15f;\n", this.m_lowerTranslation);
        box2d.b2Log("  jd.upperTranslation = %.15f;\n", this.m_upperTranslation);
        box2d.b2Log("  jd.enableMotor = %s;\n", this.m_enableMotor ? "true" : "false");
        box2d.b2Log("  jd.motorSpeed = %.15f;\n", this.m_motorSpeed);
        box2d.b2Log("  jd.maxMotorForce = %.15f;\n", this.m_maxMotorForce);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "Dump", box2d.b2PrismaticJoint.prototype.Dump);
box2d.b2GearJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_gearJoint)
};
goog.inherits(box2d.b2GearJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2GearJointDef", box2d.b2GearJointDef);
box2d.b2GearJointDef.prototype.joint1 = null;
goog.exportProperty(box2d.b2GearJointDef.prototype, "joint1", box2d.b2GearJointDef.prototype.joint1);
box2d.b2GearJointDef.prototype.joint2 = null;
goog.exportProperty(box2d.b2GearJointDef.prototype, "joint2", box2d.b2GearJointDef.prototype.joint2);
box2d.b2GearJointDef.prototype.ratio = 1;
goog.exportProperty(box2d.b2GearJointDef.prototype, "ratio", box2d.b2GearJointDef.prototype.ratio);
box2d.b2GearJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_joint1 = a.joint1;
    this.m_joint2 = a.joint2;
    this.m_localAnchorA = new box2d.b2Vec2;
    this.m_localAnchorB = new box2d.b2Vec2;
    this.m_localAnchorC = new box2d.b2Vec2;
    this.m_localAnchorD = new box2d.b2Vec2;
    this.m_localAxisC = new box2d.b2Vec2;
    this.m_localAxisD = new box2d.b2Vec2;
    this.m_lcA = new box2d.b2Vec2;
    this.m_lcB = new box2d.b2Vec2;
    this.m_lcC = new box2d.b2Vec2;
    this.m_lcD = new box2d.b2Vec2;
    this.m_JvAC = new box2d.b2Vec2;
    this.m_JvBD = new box2d.b2Vec2;
    this.m_qA =
            new box2d.b2Rot;
    this.m_qB = new box2d.b2Rot;
    this.m_qC = new box2d.b2Rot;
    this.m_qD = new box2d.b2Rot;
    this.m_lalcA = new box2d.b2Vec2;
    this.m_lalcB = new box2d.b2Vec2;
    this.m_lalcC = new box2d.b2Vec2;
    this.m_lalcD = new box2d.b2Vec2;
    this.m_typeA = this.m_joint1.GetType();
    this.m_typeB = this.m_joint2.GetType();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_typeA == box2d.b2JointType.e_revoluteJoint || this.m_typeA == box2d.b2JointType.e_prismaticJoint);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_typeB == box2d.b2JointType.e_revoluteJoint ||
            this.m_typeB == box2d.b2JointType.e_prismaticJoint);
    var b, c;
    this.m_bodyC = this.m_joint1.GetBodyA();
    this.m_bodyA = this.m_joint1.GetBodyB();
    b = this.m_bodyA.m_xf;
    var e = this.m_bodyA.m_sweep.a;
    c = this.m_bodyC.m_xf;
    var d = this.m_bodyC.m_sweep.a;
    this.m_typeA == box2d.b2JointType.e_revoluteJoint ? (c = a.joint1, this.m_localAnchorC.Copy(c.m_localAnchorA), this.m_localAnchorA.Copy(c.m_localAnchorB), this.m_referenceAngleA = c.m_referenceAngle, this.m_localAxisC.SetZero(), b = e - d - this.m_referenceAngleA) : (d = a.joint1, this.m_localAnchorC.Copy(d.m_localAnchorA),
            this.m_localAnchorA.Copy(d.m_localAnchorB), this.m_referenceAngleA = d.m_referenceAngle, this.m_localAxisC.Copy(d.m_localXAxisA), e = this.m_localAnchorC, b = box2d.b2MulTRV(c.q, box2d.b2AddVV(box2d.b2MulRV(b.q, this.m_localAnchorA, box2d.b2Vec2.s_t0), box2d.b2SubVV(b.p, c.p, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), b = box2d.b2DotVV(box2d.b2SubVV(b, e, box2d.b2Vec2.s_t0), this.m_localAxisC));
    this.m_bodyD = this.m_joint2.GetBodyA();
    this.m_bodyB = this.m_joint2.GetBodyB();
    c = this.m_bodyB.m_xf;
    var d = this.m_bodyB.m_sweep.a,
            e = this.m_bodyD.m_xf, f = this.m_bodyD.m_sweep.a;
    this.m_typeB == box2d.b2JointType.e_revoluteJoint ? (c = a.joint2, this.m_localAnchorD.Copy(c.m_localAnchorA), this.m_localAnchorB.Copy(c.m_localAnchorB), this.m_referenceAngleB = c.m_referenceAngle, this.m_localAxisD.SetZero(), c = d - f - this.m_referenceAngleB) : (d = a.joint2, this.m_localAnchorD.Copy(d.m_localAnchorA), this.m_localAnchorB.Copy(d.m_localAnchorB), this.m_referenceAngleB = d.m_referenceAngle, this.m_localAxisD.Copy(d.m_localXAxisA), d = this.m_localAnchorD, c = box2d.b2MulTRV(e.q,
            box2d.b2AddVV(box2d.b2MulRV(c.q, this.m_localAnchorB, box2d.b2Vec2.s_t0), box2d.b2SubVV(c.p, e.p, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), c = box2d.b2DotVV(box2d.b2SubVV(c, d, box2d.b2Vec2.s_t0), this.m_localAxisD));
    this.m_ratio = a.ratio;
    this.m_constant = b + this.m_ratio * c;
    this.m_impulse = 0
};
goog.inherits(box2d.b2GearJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2GearJoint", box2d.b2GearJoint);
box2d.b2GearJoint.prototype.m_joint1 = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_joint1", box2d.b2GearJoint.prototype.m_joint1);
box2d.b2GearJoint.prototype.m_joint2 = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_joint2", box2d.b2GearJoint.prototype.m_joint2);
box2d.b2GearJoint.prototype.m_typeA = box2d.b2JointType.e_unknownJoint;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_typeA", box2d.b2GearJoint.prototype.m_typeA);
box2d.b2GearJoint.prototype.m_typeB = box2d.b2JointType.e_unknownJoint;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_typeB", box2d.b2GearJoint.prototype.m_typeB);
box2d.b2GearJoint.prototype.m_bodyC = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_bodyC", box2d.b2GearJoint.prototype.m_bodyC);
box2d.b2GearJoint.prototype.m_bodyD = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_bodyD", box2d.b2GearJoint.prototype.m_bodyD);
box2d.b2GearJoint.prototype.m_localAnchorA = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_localAnchorA", box2d.b2GearJoint.prototype.m_localAnchorA);
box2d.b2GearJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_localAnchorB", box2d.b2GearJoint.prototype.m_localAnchorB);
box2d.b2GearJoint.prototype.m_localAnchorC = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_localAnchorC", box2d.b2GearJoint.prototype.m_localAnchorC);
box2d.b2GearJoint.prototype.m_localAnchorD = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_localAnchorD", box2d.b2GearJoint.prototype.m_localAnchorD);
box2d.b2GearJoint.prototype.m_localAxisC = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_localAxisC", box2d.b2GearJoint.prototype.m_localAxisC);
box2d.b2GearJoint.prototype.m_localAxisD = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_localAxisD", box2d.b2GearJoint.prototype.m_localAxisD);
box2d.b2GearJoint.prototype.m_referenceAngleA = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_referenceAngleA", box2d.b2GearJoint.prototype.m_referenceAngleA);
box2d.b2GearJoint.prototype.m_referenceAngleB = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_referenceAngleB", box2d.b2GearJoint.prototype.m_referenceAngleB);
box2d.b2GearJoint.prototype.m_constant = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_constant", box2d.b2GearJoint.prototype.m_constant);
box2d.b2GearJoint.prototype.m_ratio = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_ratio", box2d.b2GearJoint.prototype.m_ratio);
box2d.b2GearJoint.prototype.m_impulse = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_impulse", box2d.b2GearJoint.prototype.m_impulse);
box2d.b2GearJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_indexA", box2d.b2GearJoint.prototype.m_indexA);
box2d.b2GearJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_indexB", box2d.b2GearJoint.prototype.m_indexB);
box2d.b2GearJoint.prototype.m_indexC = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_indexC", box2d.b2GearJoint.prototype.m_indexC);
box2d.b2GearJoint.prototype.m_indexD = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_indexD", box2d.b2GearJoint.prototype.m_indexD);
box2d.b2GearJoint.prototype.m_lcA = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_lcA", box2d.b2GearJoint.prototype.m_lcA);
box2d.b2GearJoint.prototype.m_lcB = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_lcB", box2d.b2GearJoint.prototype.m_lcB);
box2d.b2GearJoint.prototype.m_lcC = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_lcC", box2d.b2GearJoint.prototype.m_lcC);
box2d.b2GearJoint.prototype.m_lcD = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_lcD", box2d.b2GearJoint.prototype.m_lcD);
box2d.b2GearJoint.prototype.m_mA = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_mA", box2d.b2GearJoint.prototype.m_mA);
box2d.b2GearJoint.prototype.m_mB = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_mB", box2d.b2GearJoint.prototype.m_mB);
box2d.b2GearJoint.prototype.m_mC = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_mC", box2d.b2GearJoint.prototype.m_mC);
box2d.b2GearJoint.prototype.m_mD = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_mD", box2d.b2GearJoint.prototype.m_mD);
box2d.b2GearJoint.prototype.m_iA = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_iA", box2d.b2GearJoint.prototype.m_iA);
box2d.b2GearJoint.prototype.m_iB = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_iB", box2d.b2GearJoint.prototype.m_iB);
box2d.b2GearJoint.prototype.m_iC = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_iC", box2d.b2GearJoint.prototype.m_iC);
box2d.b2GearJoint.prototype.m_iD = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_iD", box2d.b2GearJoint.prototype.m_iD);
box2d.b2GearJoint.prototype.m_JvAC = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_JvAC", box2d.b2GearJoint.prototype.m_JvAC);
box2d.b2GearJoint.prototype.m_JvBD = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_JvBD", box2d.b2GearJoint.prototype.m_JvBD);
box2d.b2GearJoint.prototype.m_JwA = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_JwA", box2d.b2GearJoint.prototype.m_JwA);
box2d.b2GearJoint.prototype.m_JwB = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_JwB", box2d.b2GearJoint.prototype.m_JwB);
box2d.b2GearJoint.prototype.m_JwC = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_JwC", box2d.b2GearJoint.prototype.m_JwC);
box2d.b2GearJoint.prototype.m_JwD = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_JwD", box2d.b2GearJoint.prototype.m_JwD);
box2d.b2GearJoint.prototype.m_mass = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_mass", box2d.b2GearJoint.prototype.m_mass);
box2d.b2GearJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_qA", box2d.b2GearJoint.prototype.m_qA);
box2d.b2GearJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_qB", box2d.b2GearJoint.prototype.m_qB);
box2d.b2GearJoint.prototype.m_qC = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_qC", box2d.b2GearJoint.prototype.m_qC);
box2d.b2GearJoint.prototype.m_qD = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_qD", box2d.b2GearJoint.prototype.m_qD);
box2d.b2GearJoint.prototype.m_lalcA = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_lalcA", box2d.b2GearJoint.prototype.m_lalcA);
box2d.b2GearJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_lalcB", box2d.b2GearJoint.prototype.m_lalcB);
box2d.b2GearJoint.prototype.m_lalcC = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_lalcC", box2d.b2GearJoint.prototype.m_lalcC);
box2d.b2GearJoint.prototype.m_lalcD = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_lalcD", box2d.b2GearJoint.prototype.m_lalcD);
box2d.b2GearJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_indexC = this.m_bodyC.m_islandIndex;
    this.m_indexD = this.m_bodyD.m_islandIndex;
    this.m_lcA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_lcB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_lcC.Copy(this.m_bodyC.m_sweep.localCenter);
    this.m_lcD.Copy(this.m_bodyD.m_sweep.localCenter);
    this.m_mA = this.m_bodyA.m_invMass;
    this.m_mB = this.m_bodyB.m_invMass;
    this.m_mC =
            this.m_bodyC.m_invMass;
    this.m_mD = this.m_bodyD.m_invMass;
    this.m_iA = this.m_bodyA.m_invI;
    this.m_iB = this.m_bodyB.m_invI;
    this.m_iC = this.m_bodyC.m_invI;
    this.m_iD = this.m_bodyD.m_invI;
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.positions[this.m_indexB].a, d = a.velocities[this.m_indexB].v, f = a.velocities[this.m_indexB].w, g = a.positions[this.m_indexC].a, h = a.velocities[this.m_indexC].v, l = a.velocities[this.m_indexC].w, k = a.positions[this.m_indexD].a, m = a.velocities[this.m_indexD].v, n = a.velocities[this.m_indexD].w,
            p = this.m_qA.SetAngleRadians(a.positions[this.m_indexA].a), e = this.m_qB.SetAngleRadians(e), q = this.m_qC.SetAngleRadians(g), g = this.m_qD.SetAngleRadians(k);
    this.m_mass = 0;
    this.m_typeA == box2d.b2JointType.e_revoluteJoint ? (this.m_JvAC.SetZero(), this.m_JwC = this.m_JwA = 1, this.m_mass += this.m_iA + this.m_iC) : (k = box2d.b2MulRV(q, this.m_localAxisC, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_u), box2d.b2SubVV(this.m_localAnchorC, this.m_lcC, this.m_lalcC), q = box2d.b2MulRV(q, this.m_lalcC, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rC),
            box2d.b2SubVV(this.m_localAnchorA, this.m_lcA, this.m_lalcA), p = box2d.b2MulRV(p, this.m_lalcA, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rA), this.m_JvAC.Copy(k), this.m_JwC = box2d.b2CrossVV(q, k), this.m_JwA = box2d.b2CrossVV(p, k), this.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA);
    this.m_typeB == box2d.b2JointType.e_revoluteJoint ? (this.m_JvBD.SetZero(), this.m_JwD = this.m_JwB = this.m_ratio, this.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD)) : (k =
            box2d.b2MulRV(g, this.m_localAxisD, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_u), box2d.b2SubVV(this.m_localAnchorD, this.m_lcD, this.m_lalcD), p = box2d.b2MulRV(g, this.m_lalcD, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rD), box2d.b2SubVV(this.m_localAnchorB, this.m_lcB, this.m_lalcB), e = box2d.b2MulRV(e, this.m_lalcB, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rB), box2d.b2MulSV(this.m_ratio, k, this.m_JvBD), this.m_JwD = this.m_ratio * box2d.b2CrossVV(p, k), this.m_JwB = this.m_ratio * box2d.b2CrossVV(e,
            k), this.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB);
    this.m_mass = 0 < this.m_mass ? 1 / this.m_mass : 0;
    a.step.warmStarting ? (b.SelfMulAdd(this.m_mA * this.m_impulse, this.m_JvAC), c += this.m_iA * this.m_impulse * this.m_JwA, d.SelfMulAdd(this.m_mB * this.m_impulse, this.m_JvBD), f += this.m_iB * this.m_impulse * this.m_JwB, h.SelfMulSub(this.m_mC * this.m_impulse, this.m_JvAC), l -= this.m_iC * this.m_impulse * this.m_JwC, m.SelfMulSub(this.m_mD * this.m_impulse, this.m_JvBD),
            n -= this.m_iD * this.m_impulse * this.m_JwD) : this.m_impulse = 0;
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = f;
    a.velocities[this.m_indexC].w = l;
    a.velocities[this.m_indexD].w = n
};
box2d.b2GearJoint.prototype.InitVelocityConstraints.s_u = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rA = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rB = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rC = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rD = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.velocities[this.m_indexB].v, d = a.velocities[this.m_indexB].w, f = a.velocities[this.m_indexC].v, g = a.velocities[this.m_indexC].w, h = a.velocities[this.m_indexD].v, l = a.velocities[this.m_indexD].w, k = box2d.b2DotVV(this.m_JvAC, box2d.b2SubVV(b, f, box2d.b2Vec2.s_t0)) + box2d.b2DotVV(this.m_JvBD, box2d.b2SubVV(e, h, box2d.b2Vec2.s_t0)), k = k + (this.m_JwA * c - this.m_JwC * g + (this.m_JwB * d - this.m_JwD *
            l)), k = -this.m_mass * k;
    this.m_impulse += k;
    b.SelfMulAdd(this.m_mA * k, this.m_JvAC);
    c += this.m_iA * k * this.m_JwA;
    e.SelfMulAdd(this.m_mB * k, this.m_JvBD);
    d += this.m_iB * k * this.m_JwB;
    f.SelfMulSub(this.m_mC * k, this.m_JvAC);
    g -= this.m_iC * k * this.m_JwC;
    h.SelfMulSub(this.m_mD * k, this.m_JvBD);
    l -= this.m_iD * k * this.m_JwD;
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = d;
    a.velocities[this.m_indexC].w = g;
    a.velocities[this.m_indexD].w = l
};
box2d.b2GearJoint.prototype.SolvePositionConstraints = function(a) {
    var b = a.positions[this.m_indexA].c, c = a.positions[this.m_indexA].a, e = a.positions[this.m_indexB].c, d = a.positions[this.m_indexB].a, f = a.positions[this.m_indexC].c, g = a.positions[this.m_indexC].a, h = a.positions[this.m_indexD].c, l = a.positions[this.m_indexD].a, k = this.m_qA.SetAngleRadians(c), m = this.m_qB.SetAngleRadians(d), n = this.m_qC.SetAngleRadians(g), p = this.m_qD.SetAngleRadians(l), q = this.m_JvAC, r = this.m_JvBD, t, s, u = 0;
    if (this.m_typeA == box2d.b2JointType.e_revoluteJoint)
        q.SetZero(),
                k = t = 1, u += this.m_iA + this.m_iC, n = c - g - this.m_referenceAngleA;
    else {
        s = box2d.b2MulRV(n, this.m_localAxisC, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_u);
        t = box2d.b2MulRV(n, this.m_lalcC, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rC);
        var v = box2d.b2MulRV(k, this.m_lalcA, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rA);
        q.Copy(s);
        k = box2d.b2CrossVV(t, s);
        t = box2d.b2CrossVV(v, s);
        u += this.m_mC + this.m_mA + this.m_iC * k * k + this.m_iA * t * t;
        s = this.m_lalcC;
        n = box2d.b2MulTRV(n, box2d.b2AddVV(v, box2d.b2SubVV(b,
                f, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0);
        n = box2d.b2DotVV(box2d.b2SubVV(n, s, box2d.b2Vec2.s_t0), this.m_localAxisC)
    }
    if (this.m_typeB == box2d.b2JointType.e_revoluteJoint)
        r.SetZero(), m = s = this.m_ratio, u += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD), p = d - l - this.m_referenceAngleB;
    else {
        s = box2d.b2MulRV(p, this.m_localAxisD, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_u);
        var y = box2d.b2MulRV(p, this.m_lalcD, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rD), v = box2d.b2MulRV(m,
                this.m_lalcB, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rB);
        box2d.b2MulSV(this.m_ratio, s, r);
        m = this.m_ratio * box2d.b2CrossVV(y, s);
        s = this.m_ratio * box2d.b2CrossVV(v, s);
        u += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * m * m + this.m_iB * s * s;
        y = this.m_lalcD;
        p = box2d.b2MulTRV(p, box2d.b2AddVV(v, box2d.b2SubVV(e, h, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0);
        p = box2d.b2DotVV(box2d.b2SubVV(p, y, box2d.b2Vec2.s_t0), this.m_localAxisD)
    }
    p = n + this.m_ratio * p - this.m_constant;
    n = 0;
    0 < u && (n = -p /
            u);
    b.SelfMulAdd(this.m_mA * n, q);
    c += this.m_iA * n * t;
    e.SelfMulAdd(this.m_mB * n, r);
    d += this.m_iB * n * s;
    f.SelfMulSub(this.m_mC * n, q);
    g -= this.m_iC * n * k;
    h.SelfMulSub(this.m_mD * n, r);
    l -= this.m_iD * n * m;
    a.positions[this.m_indexA].a = c;
    a.positions[this.m_indexB].a = d;
    a.positions[this.m_indexC].a = g;
    a.positions[this.m_indexD].a = l;
    return 0 < box2d.b2_linearSlop
};
goog.exportProperty(box2d.b2GearJoint.prototype, "SolvePositionConstraints", box2d.b2GearJoint.prototype.SolvePositionConstraints);
box2d.b2GearJoint.prototype.SolvePositionConstraints.s_u = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rA = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rB = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rC = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rD = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, a)
};
goog.exportProperty(box2d.b2GearJoint.prototype, "GetAnchorA", box2d.b2GearJoint.prototype.GetAnchorA);
box2d.b2GearJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2GearJoint.prototype, "GetAnchorB", box2d.b2GearJoint.prototype.GetAnchorB);
box2d.b2GearJoint.prototype.GetReactionForce = function(a, b) {
    return box2d.b2MulSV(a * this.m_impulse, this.m_JvAC, b)
};
goog.exportProperty(box2d.b2GearJoint.prototype, "GetReactionForce", box2d.b2GearJoint.prototype.GetReactionForce);
box2d.b2GearJoint.prototype.GetReactionTorque = function(a) {
    return a * this.m_impulse * this.m_JwA
};
goog.exportProperty(box2d.b2GearJoint.prototype, "GetReactionTorque", box2d.b2GearJoint.prototype.GetReactionTorque);
box2d.b2GearJoint.prototype.GetJoint1 = function() {
    return this.m_joint1
};
goog.exportProperty(box2d.b2GearJoint.prototype, "GetJoint1", box2d.b2GearJoint.prototype.GetJoint1);
box2d.b2GearJoint.prototype.GetJoint2 = function() {
    return this.m_joint2
};
goog.exportProperty(box2d.b2GearJoint.prototype, "GetJoint2", box2d.b2GearJoint.prototype.GetJoint2);
box2d.b2GearJoint.prototype.GetRatio = function() {
    return this.m_ratio
};
goog.exportProperty(box2d.b2GearJoint.prototype, "GetRatio", box2d.b2GearJoint.prototype.GetRatio);
box2d.b2GearJoint.prototype.SetRatio = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a));
    this.m_ratio = a
};
goog.exportProperty(box2d.b2GearJoint.prototype, "SetRatio", box2d.b2GearJoint.prototype.SetRatio);
box2d.b2GearJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex, c = this.m_joint1.m_index, e = this.m_joint2.m_index;
        box2d.b2Log("  /*box2d.b2GearJointDef*/ var jd = new box2d.b2GearJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.joint1 = joints[%d];\n", c);
        box2d.b2Log("  jd.joint2 = joints[%d];\n",
                e);
        box2d.b2Log("  jd.ratio = %.15f;\n", this.m_ratio);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
};
goog.exportProperty(box2d.b2GearJoint.prototype, "Dump", box2d.b2GearJoint.prototype.Dump);
box2d.b2DistanceProxy = function() {
    this.m_buffer = box2d.b2Vec2.MakeArray(2)
};
goog.exportSymbol("box2d.b2DistanceProxy", box2d.b2DistanceProxy);
box2d.b2DistanceProxy.prototype.m_buffer = null;
goog.exportProperty(box2d.b2DistanceProxy.prototype, "m_buffer", box2d.b2DistanceProxy.prototype.m_buffer);
box2d.b2DistanceProxy.prototype.m_vertices = null;
goog.exportProperty(box2d.b2DistanceProxy.prototype, "m_vertices", box2d.b2DistanceProxy.prototype.m_vertices);
box2d.b2DistanceProxy.prototype.m_count = 0;
goog.exportProperty(box2d.b2DistanceProxy.prototype, "m_count", box2d.b2DistanceProxy.prototype.m_count);
box2d.b2DistanceProxy.prototype.m_radius = 0;
goog.exportProperty(box2d.b2DistanceProxy.prototype, "m_radius", box2d.b2DistanceProxy.prototype.m_radius);
box2d.b2DistanceProxy.prototype.Reset = function() {
    this.m_vertices = null;
    this.m_radius = this.m_count = 0;
    return this
};
goog.exportProperty(box2d.b2DistanceProxy.prototype, "Reset", box2d.b2DistanceProxy.prototype.Reset);
box2d.b2DistanceProxy.prototype.SetShape = function(a, b) {
    a.SetupDistanceProxy(this, b)
};
goog.exportProperty(box2d.b2DistanceProxy.prototype, "SetShape", box2d.b2DistanceProxy.prototype.SetShape);
box2d.b2DistanceProxy.prototype.GetSupport = function(a) {
    for (var b = 0, c = box2d.b2DotVV(this.m_vertices[0], a), e = 1; e < this.m_count; ++e) {
        var d = box2d.b2DotVV(this.m_vertices[e], a);
        d > c && (b = e, c = d)
    }
    return b
};
goog.exportProperty(box2d.b2DistanceProxy.prototype, "GetSupport", box2d.b2DistanceProxy.prototype.GetSupport);
box2d.b2DistanceProxy.prototype.GetSupportVertex = function(a, b) {
    for (var c = 0, e = box2d.b2DotVV(this.m_vertices[0], a), d = 1; d < this.m_count; ++d) {
        var f = box2d.b2DotVV(this.m_vertices[d], a);
        f > e && (c = d, e = f)
    }
    return b.Copy(this.m_vertices[c])
};
goog.exportProperty(box2d.b2DistanceProxy.prototype, "GetSupportVertex", box2d.b2DistanceProxy.prototype.GetSupportVertex);
box2d.b2DistanceProxy.prototype.GetVertexCount = function() {
    return this.m_count
};
goog.exportProperty(box2d.b2DistanceProxy.prototype, "GetVertexCount", box2d.b2DistanceProxy.prototype.GetVertexCount);
box2d.b2DistanceProxy.prototype.GetVertex = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= a && a < this.m_count);
    return this.m_vertices[a]
};
goog.exportProperty(box2d.b2DistanceProxy.prototype, "GetVertex", box2d.b2DistanceProxy.prototype.GetVertex);
box2d.b2SimplexCache = function() {
    this.indexA = box2d.b2MakeNumberArray(3);
    this.indexB = box2d.b2MakeNumberArray(3)
};
goog.exportSymbol("box2d.b2SimplexCache", box2d.b2SimplexCache);
box2d.b2SimplexCache.prototype.metric = 0;
goog.exportProperty(box2d.b2SimplexCache.prototype, "metric", box2d.b2SimplexCache.prototype.metric);
box2d.b2SimplexCache.prototype.count = 0;
goog.exportProperty(box2d.b2SimplexCache.prototype, "count", box2d.b2SimplexCache.prototype.count);
box2d.b2SimplexCache.prototype.indexA = null;
goog.exportProperty(box2d.b2SimplexCache.prototype, "indexA", box2d.b2SimplexCache.prototype.indexA);
box2d.b2SimplexCache.prototype.indexB = null;
goog.exportProperty(box2d.b2SimplexCache.prototype, "indexB", box2d.b2SimplexCache.prototype.indexB);
box2d.b2SimplexCache.prototype.Reset = function() {
    this.count = this.metric = 0;
    return this
};
goog.exportProperty(box2d.b2SimplexCache.prototype, "Reset", box2d.b2SimplexCache.prototype.Reset);
box2d.b2DistanceInput = function() {
    this.proxyA = new box2d.b2DistanceProxy;
    this.proxyB = new box2d.b2DistanceProxy;
    this.transformA = new box2d.b2Transform;
    this.transformB = new box2d.b2Transform
};
goog.exportSymbol("box2d.b2DistanceInput", box2d.b2DistanceInput);
box2d.b2DistanceInput.prototype.proxyA = null;
goog.exportProperty(box2d.b2DistanceInput.prototype, "proxyA", box2d.b2DistanceInput.prototype.proxyA);
box2d.b2DistanceInput.prototype.proxyB = null;
goog.exportProperty(box2d.b2DistanceInput.prototype, "proxyB", box2d.b2DistanceInput.prototype.proxyB);
box2d.b2DistanceInput.prototype.transformA = null;
goog.exportProperty(box2d.b2DistanceInput.prototype, "transformA", box2d.b2DistanceInput.prototype.transformA);
box2d.b2DistanceInput.prototype.transformB = null;
goog.exportProperty(box2d.b2DistanceInput.prototype, "transformB", box2d.b2DistanceInput.prototype.transformB);
box2d.b2DistanceInput.prototype.useRadii = !1;
goog.exportProperty(box2d.b2DistanceInput.prototype, "useRadii", box2d.b2DistanceInput.prototype.useRadii);
box2d.b2DistanceInput.prototype.Reset = function() {
    this.proxyA.Reset();
    this.proxyB.Reset();
    this.transformA.SetIdentity();
    this.transformB.SetIdentity();
    this.useRadii = !1;
    return this
};
goog.exportProperty(box2d.b2DistanceInput.prototype, "Reset", box2d.b2DistanceInput.prototype.Reset);
box2d.b2DistanceOutput = function() {
    this.pointA = new box2d.b2Vec2;
    this.pointB = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2DistanceOutput", box2d.b2DistanceOutput);
box2d.b2DistanceOutput.prototype.pointA = null;
goog.exportProperty(box2d.b2DistanceOutput.prototype, "pointA", box2d.b2DistanceOutput.prototype.pointA);
box2d.b2DistanceOutput.prototype.pointB = null;
goog.exportProperty(box2d.b2DistanceOutput.prototype, "pointB", box2d.b2DistanceOutput.prototype.pointB);
box2d.b2DistanceOutput.prototype.distance = 0;
goog.exportProperty(box2d.b2DistanceOutput.prototype, "distance", box2d.b2DistanceOutput.prototype.distance);
box2d.b2DistanceOutput.prototype.iterations = 0;
goog.exportProperty(box2d.b2DistanceOutput.prototype, "iterations", box2d.b2DistanceOutput.prototype.iterations);
box2d.b2DistanceOutput.prototype.Reset = function() {
    this.pointA.SetZero();
    this.pointB.SetZero();
    this.iterations = this.distance = 0;
    return this
};
goog.exportProperty(box2d.b2DistanceOutput.prototype, "Reset", box2d.b2DistanceOutput.prototype.Reset);
box2d.b2_gjkCalls = 0;
goog.exportSymbol("box2d.b2_gjkCalls", box2d.b2_gjkCalls);
box2d.b2_gjkIters = 0;
goog.exportSymbol("box2d.b2_gjkIters", box2d.b2_gjkIters);
box2d.b2_gjkMaxIters = 0;
goog.exportSymbol("box2d.b2_gjkMaxIters", box2d.b2_gjkMaxIters);
box2d.b2SimplexVertex = function() {
    this.wA = new box2d.b2Vec2;
    this.wB = new box2d.b2Vec2;
    this.w = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2SimplexVertex", box2d.b2SimplexVertex);
box2d.b2SimplexVertex.prototype.wA = null;
goog.exportProperty(box2d.b2SimplexVertex.prototype, "wA", box2d.b2SimplexVertex.prototype.wA);
box2d.b2SimplexVertex.prototype.wB = null;
goog.exportProperty(box2d.b2SimplexVertex.prototype, "wB", box2d.b2SimplexVertex.prototype.wB);
box2d.b2SimplexVertex.prototype.w = null;
goog.exportProperty(box2d.b2SimplexVertex.prototype, "w", box2d.b2SimplexVertex.prototype.w);
box2d.b2SimplexVertex.prototype.a = 0;
goog.exportProperty(box2d.b2SimplexVertex.prototype, "a", box2d.b2SimplexVertex.prototype.a);
box2d.b2SimplexVertex.prototype.indexA = 0;
goog.exportProperty(box2d.b2SimplexVertex.prototype, "indexA", box2d.b2SimplexVertex.prototype.indexA);
box2d.b2SimplexVertex.prototype.indexB = 0;
goog.exportProperty(box2d.b2SimplexVertex.prototype, "indexB", box2d.b2SimplexVertex.prototype.indexB);
box2d.b2SimplexVertex.prototype.Copy = function(a) {
    this.wA.Copy(a.wA);
    this.wB.Copy(a.wB);
    this.w.Copy(a.w);
    this.a = a.a;
    this.indexA = a.indexA;
    this.indexB = a.indexB;
    return this
};
goog.exportProperty(box2d.b2SimplexVertex.prototype, "Copy", box2d.b2SimplexVertex.prototype.Copy);
box2d.b2Simplex = function() {
    this.m_v1 = new box2d.b2SimplexVertex;
    this.m_v2 = new box2d.b2SimplexVertex;
    this.m_v3 = new box2d.b2SimplexVertex;
    this.m_vertices = Array(3);
    this.m_vertices[0] = this.m_v1;
    this.m_vertices[1] = this.m_v2;
    this.m_vertices[2] = this.m_v3
};
goog.exportSymbol("box2d.b2Simplex", box2d.b2Simplex);
box2d.b2Simplex.prototype.m_v1 = null;
goog.exportProperty(box2d.b2Simplex.prototype, "m_v1", box2d.b2Simplex.prototype.m_v1);
box2d.b2Simplex.prototype.m_v2 = null;
goog.exportProperty(box2d.b2Simplex.prototype, "m_v2", box2d.b2Simplex.prototype.m_v2);
box2d.b2Simplex.prototype.m_v3 = null;
goog.exportProperty(box2d.b2Simplex.prototype, "m_v3", box2d.b2Simplex.prototype.m_v3);
box2d.b2Simplex.prototype.m_vertices = null;
goog.exportProperty(box2d.b2Simplex.prototype, "m_vertices", box2d.b2Simplex.prototype.m_vertices);
box2d.b2Simplex.prototype.m_count = 0;
goog.exportProperty(box2d.b2Simplex.prototype, "m_count", box2d.b2Simplex.prototype.m_count);
box2d.b2Simplex.prototype.ReadCache = function(a, b, c, e, d) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= a.count && 3 >= a.count);
    this.m_count = a.count;
    for (var f = this.m_vertices, g = 0; g < this.m_count; ++g) {
        var h = f[g];
        h.indexA = a.indexA[g];
        h.indexB = a.indexB[g];
        var l = b.GetVertex(h.indexA), k = e.GetVertex(h.indexB);
        box2d.b2MulXV(c, l, h.wA);
        box2d.b2MulXV(d, k, h.wB);
        box2d.b2SubVV(h.wB, h.wA, h.w);
        h.a = 0
    }
    1 < this.m_count && (a = a.metric, g = this.GetMetric(), g < 0.5 * a || 2 * a < g || g < box2d.b2_epsilon) && (this.m_count = 0);
    0 == this.m_count && (h = f[0],
            h.indexA = 0, h.indexB = 0, l = b.GetVertex(0), k = e.GetVertex(0), box2d.b2MulXV(c, l, h.wA), box2d.b2MulXV(d, k, h.wB), box2d.b2SubVV(h.wB, h.wA, h.w), this.m_count = h.a = 1)
};
goog.exportProperty(box2d.b2Simplex.prototype, "ReadCache", box2d.b2Simplex.prototype.ReadCache);
box2d.b2Simplex.prototype.WriteCache = function(a) {
    a.metric = this.GetMetric();
    a.count = this.m_count;
    for (var b = this.m_vertices, c = 0; c < this.m_count; ++c)
        a.indexA[c] = b[c].indexA, a.indexB[c] = b[c].indexB
};
goog.exportProperty(box2d.b2Simplex.prototype, "WriteCache", box2d.b2Simplex.prototype.WriteCache);
box2d.b2Simplex.prototype.GetSearchDirection = function(a) {
    switch (this.m_count) {
        case 1:
            return box2d.b2NegV(this.m_v1.w, a);
        case 2:
            var b = box2d.b2SubVV(this.m_v2.w, this.m_v1.w, a);
            return 0 < box2d.b2CrossVV(b, box2d.b2NegV(this.m_v1.w, box2d.b2Vec2.s_t0)) ? box2d.b2CrossOneV(b, a) : box2d.b2CrossVOne(b, a);
        default:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), a.SetZero()
        }
};
goog.exportProperty(box2d.b2Simplex.prototype, "GetSearchDirection", box2d.b2Simplex.prototype.GetSearchDirection);
box2d.b2Simplex.prototype.GetClosestPoint = function(a) {
    switch (this.m_count) {
        case 0:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), a.SetZero();
        case 1:
            return a.Copy(this.m_v1.w);
        case 2:
            return a.SetXY(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
        case 3:
            return a.SetZero();
        default:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), a.SetZero()
        }
};
goog.exportProperty(box2d.b2Simplex.prototype, "GetClosestPoint", box2d.b2Simplex.prototype.GetClosestPoint);
box2d.b2Simplex.prototype.GetWitnessPoints = function(a, b) {
    switch (this.m_count) {
        case 0:
            box2d.ENABLE_ASSERTS && box2d.b2Assert(!1);
            break;
        case 1:
            a.Copy(this.m_v1.wA);
            b.Copy(this.m_v1.wB);
            break;
        case 2:
            a.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;
            a.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;
            b.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;
            b.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
            break;
        case 3:
            b.x = a.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x +
                    this.m_v3.a * this.m_v3.wA.x;
            b.y = a.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
            break;
        default:
            box2d.ENABLE_ASSERTS && box2d.b2Assert(!1)
        }
};
goog.exportProperty(box2d.b2Simplex.prototype, "GetWitnessPoints", box2d.b2Simplex.prototype.GetWitnessPoints);
box2d.b2Simplex.prototype.GetMetric = function() {
    switch (this.m_count) {
        case 0:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), 0;
        case 1:
            return 0;
        case 2:
            return box2d.b2DistanceVV(this.m_v1.w, this.m_v2.w);
        case 3:
            return box2d.b2CrossVV(box2d.b2SubVV(this.m_v2.w, this.m_v1.w, box2d.b2Vec2.s_t0), box2d.b2SubVV(this.m_v3.w, this.m_v1.w, box2d.b2Vec2.s_t1));
        default:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), 0
        }
};
goog.exportProperty(box2d.b2Simplex.prototype, "GetMetric", box2d.b2Simplex.prototype.GetMetric);
box2d.b2Simplex.prototype.Solve2 = function() {
    var a = this.m_v1.w, b = this.m_v2.w, c = box2d.b2SubVV(b, a, box2d.b2Simplex.s_e12), a = -box2d.b2DotVV(a, c);
    0 >= a ? this.m_count = this.m_v1.a = 1 : (b = box2d.b2DotVV(b, c), 0 >= b ? (this.m_count = this.m_v2.a = 1, this.m_v1.Copy(this.m_v2)) : (c = 1 / (b + a), this.m_v1.a = b * c, this.m_v2.a = a * c, this.m_count = 2))
};
goog.exportProperty(box2d.b2Simplex.prototype, "Solve2", box2d.b2Simplex.prototype.Solve2);
box2d.b2Simplex.prototype.Solve3 = function() {
    var a = this.m_v1.w, b = this.m_v2.w, c = this.m_v3.w, e = box2d.b2SubVV(b, a, box2d.b2Simplex.s_e12), d = box2d.b2DotVV(a, e), f = box2d.b2DotVV(b, e), d = -d, g = box2d.b2SubVV(c, a, box2d.b2Simplex.s_e13), h = box2d.b2DotVV(a, g), l = box2d.b2DotVV(c, g), h = -h, k = box2d.b2SubVV(c, b, box2d.b2Simplex.s_e23), m = box2d.b2DotVV(b, k), k = box2d.b2DotVV(c, k), m = -m, g = box2d.b2CrossVV(e, g), e = g * box2d.b2CrossVV(b, c), c = g * box2d.b2CrossVV(c, a), a = g * box2d.b2CrossVV(a, b);
    0 >= d && 0 >= h ? this.m_count = this.m_v1.a = 1 : 0 < f &&
            0 < d && 0 >= a ? (l = 1 / (f + d), this.m_v1.a = f * l, this.m_v2.a = d * l, this.m_count = 2) : 0 < l && 0 < h && 0 >= c ? (f = 1 / (l + h), this.m_v1.a = l * f, this.m_v3.a = h * f, this.m_count = 2, this.m_v2.Copy(this.m_v3)) : 0 >= f && 0 >= m ? (this.m_count = this.m_v2.a = 1, this.m_v1.Copy(this.m_v2)) : 0 >= l && 0 >= k ? (this.m_count = this.m_v3.a = 1, this.m_v1.Copy(this.m_v3)) : 0 < k && 0 < m && 0 >= e ? (f = 1 / (k + m), this.m_v2.a = k * f, this.m_v3.a = m * f, this.m_count = 2, this.m_v1.Copy(this.m_v3)) : (f = 1 / (e + c + a), this.m_v1.a = e * f, this.m_v2.a = c * f, this.m_v3.a = a * f, this.m_count = 3)
};
goog.exportProperty(box2d.b2Simplex.prototype, "Solve3", box2d.b2Simplex.prototype.Solve3);
box2d.b2Simplex.s_e12 = new box2d.b2Vec2;
box2d.b2Simplex.s_e13 = new box2d.b2Vec2;
box2d.b2Simplex.s_e23 = new box2d.b2Vec2;
box2d.b2Distance = function(a, b, c) {
    ++box2d.b2_gjkCalls;
    var e = c.proxyA, d = c.proxyB, f = c.transformA, g = c.transformB, h = box2d.b2Distance.s_simplex;
    h.ReadCache(b, e, f, d, g);
    for (var l = h.m_vertices, k = box2d.b2Distance.s_saveA, m = box2d.b2Distance.s_saveB, n = 0, p = 0; 20 > p; ) {
        for (var n = h.m_count, q = 0; q < n; ++q)
            k[q] = l[q].indexA, m[q] = l[q].indexB;
        switch (h.m_count) {
            case 1:
                break;
            case 2:
                h.Solve2();
                break;
            case 3:
                h.Solve3();
                break;
            default:
                box2d.ENABLE_ASSERTS && box2d.b2Assert(!1)
        }
        if (3 == h.m_count)
            break;
        var r = h.GetClosestPoint(box2d.b2Distance.s_p);
        r.GetLengthSquared();
        q = h.GetSearchDirection(box2d.b2Distance.s_d);
        if (q.GetLengthSquared() < box2d.b2_epsilon_sq)
            break;
        r = l[h.m_count];
        r.indexA = e.GetSupport(box2d.b2MulTRV(f.q, box2d.b2NegV(q, box2d.b2Vec2.s_t0), box2d.b2Distance.s_supportA));
        box2d.b2MulXV(f, e.GetVertex(r.indexA), r.wA);
        r.indexB = d.GetSupport(box2d.b2MulTRV(g.q, q, box2d.b2Distance.s_supportB));
        box2d.b2MulXV(g, d.GetVertex(r.indexB), r.wB);
        box2d.b2SubVV(r.wB, r.wA, r.w);
        ++p;
        ++box2d.b2_gjkIters;
        for (var t = !1, q = 0; q < n; ++q)
            if (r.indexA == k[q] && r.indexB ==
                    m[q]) {
                t = !0;
                break
            }
        if (t)
            break;
        ++h.m_count
    }
    box2d.b2_gjkMaxIters = box2d.b2Max(box2d.b2_gjkMaxIters, p);
    h.GetWitnessPoints(a.pointA, a.pointB);
    a.distance = box2d.b2DistanceVV(a.pointA, a.pointB);
    a.iterations = p;
    h.WriteCache(b);
    c.useRadii && (b = e.m_radius, d = d.m_radius, a.distance > b + d && a.distance > box2d.b2_epsilon ? (a.distance -= b + d, c = box2d.b2SubVV(a.pointB, a.pointA, box2d.b2Distance.s_normal), c.Normalize(), a.pointA.SelfMulAdd(b, c), a.pointB.SelfMulSub(d, c)) : (r = box2d.b2MidVV(a.pointA, a.pointB, box2d.b2Distance.s_p), a.pointA.Copy(r),
            a.pointB.Copy(r), a.distance = 0))
};
goog.exportSymbol("box2d.b2Distance", box2d.b2Distance);
box2d.b2Distance.s_simplex = new box2d.b2Simplex;
box2d.b2Distance.s_saveA = box2d.b2MakeNumberArray(3);
box2d.b2Distance.s_saveB = box2d.b2MakeNumberArray(3);
box2d.b2Distance.s_p = new box2d.b2Vec2;
box2d.b2Distance.s_d = new box2d.b2Vec2;
box2d.b2Distance.s_normal = new box2d.b2Vec2;
box2d.b2Distance.s_supportA = new box2d.b2Vec2;
box2d.b2Distance.s_supportB = new box2d.b2Vec2;
box2d.b2WeldJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_weldJoint);
    this.localAnchorA = new box2d.b2Vec2;
    this.localAnchorB = new box2d.b2Vec2
};
goog.inherits(box2d.b2WeldJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2WeldJointDef", box2d.b2WeldJointDef);
box2d.b2WeldJointDef.prototype.localAnchorA = null;
goog.exportProperty(box2d.b2WeldJointDef.prototype, "localAnchorA", box2d.b2WeldJointDef.prototype.localAnchorA);
box2d.b2WeldJointDef.prototype.localAnchorB = null;
goog.exportProperty(box2d.b2WeldJointDef.prototype, "localAnchorB", box2d.b2WeldJointDef.prototype.localAnchorB);
box2d.b2WeldJointDef.prototype.referenceAngle = 0;
goog.exportProperty(box2d.b2WeldJointDef.prototype, "referenceAngle", box2d.b2WeldJointDef.prototype.referenceAngle);
box2d.b2WeldJointDef.prototype.frequencyHz = 0;
goog.exportProperty(box2d.b2WeldJointDef.prototype, "frequencyHz", box2d.b2WeldJointDef.prototype.frequencyHz);
box2d.b2WeldJointDef.prototype.dampingRatio = 0;
goog.exportProperty(box2d.b2WeldJointDef.prototype, "dampingRatio", box2d.b2WeldJointDef.prototype.dampingRatio);
box2d.b2WeldJointDef.prototype.Initialize = function(a, b, c) {
    this.bodyA = a;
    this.bodyB = b;
    this.bodyA.GetLocalPoint(c, this.localAnchorA);
    this.bodyB.GetLocalPoint(c, this.localAnchorB);
    this.referenceAngle = this.bodyB.GetAngleRadians() - this.bodyA.GetAngleRadians()
};
goog.exportProperty(box2d.b2WeldJointDef.prototype, "Initialize", box2d.b2WeldJointDef.prototype.Initialize);
box2d.b2WeldJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_frequencyHz = a.frequencyHz;
    this.m_dampingRatio = a.dampingRatio;
    this.m_localAnchorA = a.localAnchorA.Clone();
    this.m_localAnchorB = a.localAnchorB.Clone();
    this.m_referenceAngle = a.referenceAngle;
    this.m_impulse = new box2d.b2Vec3(0, 0, 0);
    this.m_rA = new box2d.b2Vec2;
    this.m_rB = new box2d.b2Vec2;
    this.m_localCenterA = new box2d.b2Vec2;
    this.m_localCenterB = new box2d.b2Vec2;
    this.m_mass = new box2d.b2Mat33;
    this.m_qA = new box2d.b2Rot;
    this.m_qB = new box2d.b2Rot;
    this.m_lalcA =
            new box2d.b2Vec2;
    this.m_lalcB = new box2d.b2Vec2;
    this.m_K = new box2d.b2Mat33
};
goog.inherits(box2d.b2WeldJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2WeldJoint", box2d.b2WeldJoint);
box2d.b2WeldJoint.prototype.m_frequencyHz = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_frequencyHz", box2d.b2WeldJoint.prototype.m_frequencyHz);
box2d.b2WeldJoint.prototype.m_dampingRatio = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_dampingRatio", box2d.b2WeldJoint.prototype.m_dampingRatio);
box2d.b2WeldJoint.prototype.m_bias = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_bias", box2d.b2WeldJoint.prototype.m_bias);
box2d.b2WeldJoint.prototype.m_localAnchorA = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_localAnchorA", box2d.b2WeldJoint.prototype.m_localAnchorA);
box2d.b2WeldJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_localAnchorB", box2d.b2WeldJoint.prototype.m_localAnchorB);
box2d.b2WeldJoint.prototype.m_referenceAngle = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_referenceAngle", box2d.b2WeldJoint.prototype.m_referenceAngle);
box2d.b2WeldJoint.prototype.m_gamma = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_gamma", box2d.b2WeldJoint.prototype.m_gamma);
box2d.b2WeldJoint.prototype.m_impulse = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_impulse", box2d.b2WeldJoint.prototype.m_impulse);
box2d.b2WeldJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_indexA", box2d.b2WeldJoint.prototype.m_indexA);
box2d.b2WeldJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_indexB", box2d.b2WeldJoint.prototype.m_indexB);
box2d.b2WeldJoint.prototype.m_rA = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_rA", box2d.b2WeldJoint.prototype.m_rA);
box2d.b2WeldJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_rB", box2d.b2WeldJoint.prototype.m_rB);
box2d.b2WeldJoint.prototype.m_localCenterA = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_localCenterA", box2d.b2WeldJoint.prototype.m_localCenterA);
box2d.b2WeldJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_localCenterB", box2d.b2WeldJoint.prototype.m_localCenterB);
box2d.b2WeldJoint.prototype.m_invMassA = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_invMassA", box2d.b2WeldJoint.prototype.m_invMassA);
box2d.b2WeldJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_invMassB", box2d.b2WeldJoint.prototype.m_invMassB);
box2d.b2WeldJoint.prototype.m_invIA = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_invIA", box2d.b2WeldJoint.prototype.m_invIA);
box2d.b2WeldJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_invIB", box2d.b2WeldJoint.prototype.m_invIB);
box2d.b2WeldJoint.prototype.m_mass = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_mass", box2d.b2WeldJoint.prototype.m_mass);
box2d.b2WeldJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_qA", box2d.b2WeldJoint.prototype.m_qA);
box2d.b2WeldJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_qB", box2d.b2WeldJoint.prototype.m_qB);
box2d.b2WeldJoint.prototype.m_lalcA = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_lalcA", box2d.b2WeldJoint.prototype.m_lalcA);
box2d.b2WeldJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_lalcB", box2d.b2WeldJoint.prototype.m_lalcB);
box2d.b2WeldJoint.prototype.m_K = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_K", box2d.b2WeldJoint.prototype.m_K);
box2d.b2WeldJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassA = this.m_bodyA.m_invMass;
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIA = this.m_bodyA.m_invI;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = a.positions[this.m_indexA].a, c = a.velocities[this.m_indexA].v, e = a.velocities[this.m_indexA].w,
            d = a.positions[this.m_indexB].a, f = a.velocities[this.m_indexB].v, g = a.velocities[this.m_indexB].w, h = this.m_qA.SetAngleRadians(b), l = this.m_qB.SetAngleRadians(d);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    box2d.b2MulRV(h, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    box2d.b2MulRV(l, this.m_lalcB, this.m_rB);
    var h = this.m_invMassA, l = this.m_invMassB, k = this.m_invIA, m = this.m_invIB, n = this.m_K;
    n.ex.x = h + l + this.m_rA.y * this.m_rA.y * k + this.m_rB.y *
            this.m_rB.y * m;
    n.ey.x = -this.m_rA.y * this.m_rA.x * k - this.m_rB.y * this.m_rB.x * m;
    n.ez.x = -this.m_rA.y * k - this.m_rB.y * m;
    n.ex.y = n.ey.x;
    n.ey.y = h + l + this.m_rA.x * this.m_rA.x * k + this.m_rB.x * this.m_rB.x * m;
    n.ez.y = this.m_rA.x * k + this.m_rB.x * m;
    n.ex.z = n.ez.x;
    n.ey.z = n.ez.y;
    n.ez.z = k + m;
    if (0 < this.m_frequencyHz) {
        n.GetInverse22(this.m_mass);
        var n = k + m, p = 0 < n ? 1 / n : 0, b = d - b - this.m_referenceAngle, d = 2 * box2d.b2_pi * this.m_frequencyHz, q = p * d * d, r = a.step.dt;
        this.m_gamma = r * (2 * p * this.m_dampingRatio * d + r * q);
        this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma :
                0;
        this.m_bias = b * r * q * this.m_gamma;
        n += this.m_gamma;
        this.m_mass.ez.z = 0 != n ? 1 / n : 0
    } else
        n.GetSymInverse33(this.m_mass), this.m_bias = this.m_gamma = 0;
    a.step.warmStarting ? (this.m_impulse.SelfMul(a.step.dtRatio), n = box2d.b2WeldJoint.prototype.InitVelocityConstraints.s_P.SetXY(this.m_impulse.x, this.m_impulse.y), c.SelfMulSub(h, n), e -= k * (box2d.b2CrossVV(this.m_rA, n) + this.m_impulse.z), f.SelfMulAdd(l, n), g += m * (box2d.b2CrossVV(this.m_rB, n) + this.m_impulse.z)) : this.m_impulse.SetZero();
    a.velocities[this.m_indexA].w = e;
    a.velocities[this.m_indexB].w =
    g
};
box2d.b2WeldJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2WeldJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.velocities[this.m_indexB].v, d = a.velocities[this.m_indexB].w, f = this.m_invMassA, g = this.m_invMassB, h = this.m_invIA, l = this.m_invIB;
    if (0 < this.m_frequencyHz) {
        var k = -this.m_mass.ez.z * (d - c + this.m_bias + this.m_gamma * this.m_impulse.z);
        this.m_impulse.z += k;
        c -= h * k;
        d += l * k;
        k = box2d.b2SubVV(box2d.b2AddVCrossSV(e, d, this.m_rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(b, c, this.m_rA, box2d.b2Vec2.s_t1),
                box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_Cdot1);
        k = box2d.b2MulM33XY(this.m_mass, k.x, k.y, box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse1).SelfNeg();
        this.m_impulse.x += k.x;
        this.m_impulse.y += k.y;
        b.SelfMulSub(f, k);
        c -= h * box2d.b2CrossVV(this.m_rA, k);
        e.SelfMulAdd(g, k);
        d += l * box2d.b2CrossVV(this.m_rB, k)
    } else {
        var k = box2d.b2SubVV(box2d.b2AddVCrossSV(e, d, this.m_rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(b, c, this.m_rA, box2d.b2Vec2.s_t1), box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_Cdot1),
                m = box2d.b2MulM33XYZ(this.m_mass, k.x, k.y, d - c, box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse).SelfNeg();
        this.m_impulse.SelfAdd(m);
        k = box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_P.SetXY(m.x, m.y);
        b.SelfMulSub(f, k);
        c -= h * (box2d.b2CrossVV(this.m_rA, k) + m.z);
        e.SelfMulAdd(g, k);
        d += l * (box2d.b2CrossVV(this.m_rB, k) + m.z)
    }
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = d
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "SolveVelocityConstraints", box2d.b2WeldJoint.prototype.SolveVelocityConstraints);
box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_Cdot1 = new box2d.b2Vec2;
box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse1 = new box2d.b2Vec2;
box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse = new box2d.b2Vec3;
box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2WeldJoint.prototype.SolvePositionConstraints = function(a) {
    var b = a.positions[this.m_indexA].c, c = a.positions[this.m_indexA].a, e = a.positions[this.m_indexB].c, d = a.positions[this.m_indexB].a, f = this.m_qA.SetAngleRadians(c), g = this.m_qB.SetAngleRadians(d), h = this.m_invMassA, l = this.m_invMassB, k = this.m_invIA, m = this.m_invIB;
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    var n = box2d.b2MulRV(f, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var p = box2d.b2MulRV(g, this.m_lalcB, this.m_rB), q = this.m_K;
    q.ex.x = h + l + n.y * n.y * k + p.y * p.y * m;
    q.ey.x = -n.y * n.x * k - p.y * p.x * m;
    q.ez.x = -n.y * k - p.y * m;
    q.ex.y = q.ey.x;
    q.ey.y = h + l + n.x * n.x * k + p.x * p.x * m;
    q.ez.y = n.x * k + p.x * m;
    q.ex.z = q.ez.x;
    q.ey.z = q.ez.y;
    q.ez.z = k + m;
    if (0 < this.m_frequencyHz) {
        var r = box2d.b2SubVV(box2d.b2AddVV(e, p, box2d.b2Vec2.s_t0), box2d.b2AddVV(b, n, box2d.b2Vec2.s_t1), box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_C1), g = r.GetLength(), f = 0, q = q.Solve22(r.x, r.y, box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_P).SelfNeg();
        b.SelfMulSub(h, q);
        c -= k * box2d.b2CrossVV(n, q);
        e.SelfMulAdd(l, q);
        d += m * box2d.b2CrossVV(p, q)
    } else
        r = box2d.b2SubVV(box2d.b2AddVV(e, p, box2d.b2Vec2.s_t0), box2d.b2AddVV(b, n, box2d.b2Vec2.s_t1), box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_C1), n = d - c - this.m_referenceAngle, g = r.GetLength(), f = box2d.b2Abs(n), n = q.Solve33(r.x, r.y, n, box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_impulse).SelfNeg(), q = box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_P.SetXY(n.x, n.y), b.SelfMulSub(h, q), c -= k * (box2d.b2CrossVV(this.m_rA,
                q) + n.z), e.SelfMulAdd(l, q), d += m * (box2d.b2CrossVV(this.m_rB, q) + n.z);
    a.positions[this.m_indexA].a = c;
    a.positions[this.m_indexB].a = d;
    return g <= box2d.b2_linearSlop && f <= box2d.b2_angularSlop
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "SolvePositionConstraints", box2d.b2WeldJoint.prototype.SolvePositionConstraints);
box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_C1 = new box2d.b2Vec2;
box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2;
box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_impulse = new box2d.b2Vec3;
box2d.b2WeldJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, a)
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "GetAnchorA", box2d.b2WeldJoint.prototype.GetAnchorA);
box2d.b2WeldJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "GetAnchorB", box2d.b2WeldJoint.prototype.GetAnchorB);
box2d.b2WeldJoint.prototype.GetReactionForce = function(a, b) {
    return b.SetXY(a * this.m_impulse.x, a * this.m_impulse.y)
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "GetReactionForce", box2d.b2WeldJoint.prototype.GetReactionForce);
box2d.b2WeldJoint.prototype.GetReactionTorque = function(a) {
    return a * this.m_impulse.z
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "GetReactionTorque", box2d.b2WeldJoint.prototype.GetReactionTorque);
box2d.b2WeldJoint.prototype.GetLocalAnchorA = function(a) {
    return a.Copy(this.m_localAnchorA)
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "GetLocalAnchorA", box2d.b2WeldJoint.prototype.GetLocalAnchorA);
box2d.b2WeldJoint.prototype.GetLocalAnchorB = function(a) {
    return a.Copy(this.m_localAnchorB)
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "GetLocalAnchorB", box2d.b2WeldJoint.prototype.GetLocalAnchorB);
box2d.b2WeldJoint.prototype.GetReferenceAngle = function() {
    return this.m_referenceAngle
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "GetReferenceAngle", box2d.b2WeldJoint.prototype.GetReferenceAngle);
box2d.b2WeldJoint.prototype.SetFrequency = function(a) {
    this.m_frequencyHz = a
};
box2d.b2WeldJoint.prototype.GetFrequency = function() {
    return this.m_frequencyHz
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "GetFrequency", box2d.b2WeldJoint.prototype.GetFrequency);
box2d.b2WeldJoint.prototype.SetDampingRatio = function(a) {
    this.m_dampingRatio = a
};
box2d.b2WeldJoint.prototype.GetDampingRatio = function() {
    return this.m_dampingRatio
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "GetDampingRatio", box2d.b2WeldJoint.prototype.GetDampingRatio);
box2d.b2WeldJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2WeldJointDef*/ var jd = new box2d.b2WeldJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
        box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n",
                this.m_localAnchorB.x, this.m_localAnchorB.y);
        box2d.b2Log("  jd.referenceAngle = %.15f;\n", this.m_referenceAngle);
        box2d.b2Log("  jd.frequencyHz = %.15f;\n", this.m_frequencyHz);
        box2d.b2Log("  jd.dampingRatio = %.15f;\n", this.m_dampingRatio);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "Dump", box2d.b2WeldJoint.prototype.Dump);
box2d.b2RopeJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_ropeJoint);
    this.localAnchorA = new box2d.b2Vec2(-1, 0);
    this.localAnchorB = new box2d.b2Vec2(1, 0)
};
goog.inherits(box2d.b2RopeJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2RopeJointDef", box2d.b2RopeJointDef);
box2d.b2RopeJointDef.prototype.localAnchorA = null;
goog.exportProperty(box2d.b2RopeJointDef.prototype, "localAnchorA", box2d.b2RopeJointDef.prototype.localAnchorA);
box2d.b2RopeJointDef.prototype.localAnchorB = null;
goog.exportProperty(box2d.b2RopeJointDef.prototype, "localAnchorB", box2d.b2RopeJointDef.prototype.localAnchorB);
box2d.b2RopeJointDef.prototype.maxLength = 0;
goog.exportProperty(box2d.b2RopeJointDef.prototype, "maxLength", box2d.b2RopeJointDef.prototype.maxLength);
box2d.b2RopeJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_localAnchorA = a.localAnchorA.Clone();
    this.m_localAnchorB = a.localAnchorB.Clone();
    this.m_maxLength = a.maxLength;
    this.m_u = new box2d.b2Vec2;
    this.m_rA = new box2d.b2Vec2;
    this.m_rB = new box2d.b2Vec2;
    this.m_localCenterA = new box2d.b2Vec2;
    this.m_localCenterB = new box2d.b2Vec2;
    this.m_qA = new box2d.b2Rot;
    this.m_qB = new box2d.b2Rot;
    this.m_lalcA = new box2d.b2Vec2;
    this.m_lalcB = new box2d.b2Vec2
};
goog.inherits(box2d.b2RopeJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2RopeJoint", box2d.b2RopeJoint);
box2d.b2RopeJoint.prototype.m_localAnchorA = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_localAnchorA", box2d.b2RopeJoint.prototype.m_localAnchorA);
box2d.b2RopeJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_localAnchorB", box2d.b2RopeJoint.prototype.m_localAnchorB);
box2d.b2RopeJoint.prototype.m_maxLength = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_maxLength", box2d.b2RopeJoint.prototype.m_maxLength);
box2d.b2RopeJoint.prototype.m_length = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_length", box2d.b2RopeJoint.prototype.m_length);
box2d.b2RopeJoint.prototype.m_impulse = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_impulse", box2d.b2RopeJoint.prototype.m_impulse);
box2d.b2RopeJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_indexA", box2d.b2RopeJoint.prototype.m_indexA);
box2d.b2RopeJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_indexB", box2d.b2RopeJoint.prototype.m_indexB);
box2d.b2RopeJoint.prototype.m_u = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_u", box2d.b2RopeJoint.prototype.m_u);
box2d.b2RopeJoint.prototype.m_rA = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_rA", box2d.b2RopeJoint.prototype.m_rA);
box2d.b2RopeJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_rB", box2d.b2RopeJoint.prototype.m_rB);
box2d.b2RopeJoint.prototype.m_localCenterA = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_localCenterA", box2d.b2RopeJoint.prototype.m_localCenterA);
box2d.b2RopeJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_localCenterB", box2d.b2RopeJoint.prototype.m_localCenterB);
box2d.b2RopeJoint.prototype.m_invMassA = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_invMassA", box2d.b2RopeJoint.prototype.m_invMassA);
box2d.b2RopeJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_invMassB", box2d.b2RopeJoint.prototype.m_invMassB);
box2d.b2RopeJoint.prototype.m_invIA = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_invIA", box2d.b2RopeJoint.prototype.m_invIA);
box2d.b2RopeJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_invIB", box2d.b2RopeJoint.prototype.m_invIB);
box2d.b2RopeJoint.prototype.m_mass = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_mass", box2d.b2RopeJoint.prototype.m_mass);
box2d.b2RopeJoint.prototype.m_state = box2d.b2LimitState.e_inactiveLimit;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_state", box2d.b2RopeJoint.prototype.m_state);
box2d.b2RopeJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_qA", box2d.b2RopeJoint.prototype.m_qA);
box2d.b2RopeJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_qB", box2d.b2RopeJoint.prototype.m_qB);
box2d.b2RopeJoint.prototype.m_lalcA = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_lalcA", box2d.b2RopeJoint.prototype.m_lalcA);
box2d.b2RopeJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_lalcB", box2d.b2RopeJoint.prototype.m_lalcB);
box2d.b2RopeJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassA = this.m_bodyA.m_invMass;
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIA = this.m_bodyA.m_invI;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = a.positions[this.m_indexA].c, c = a.velocities[this.m_indexA].v, e = a.velocities[this.m_indexA].w,
            d = a.positions[this.m_indexB].c, f = a.positions[this.m_indexB].a, g = a.velocities[this.m_indexB].v, h = a.velocities[this.m_indexB].w, l = this.m_qA.SetAngleRadians(a.positions[this.m_indexA].a), f = this.m_qB.SetAngleRadians(f);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    box2d.b2MulRV(l, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    box2d.b2MulRV(f, this.m_lalcB, this.m_rB);
    this.m_u.Copy(d).SelfAdd(this.m_rB).SelfSub(b).SelfSub(this.m_rA);
    this.m_length =
            this.m_u.GetLength();
    this.m_state = 0 < this.m_length - this.m_maxLength ? box2d.b2LimitState.e_atUpperLimit : box2d.b2LimitState.e_inactiveLimit;
    this.m_length > box2d.b2_linearSlop ? (this.m_u.SelfMul(1 / this.m_length), b = box2d.b2CrossVV(this.m_rA, this.m_u), d = box2d.b2CrossVV(this.m_rB, this.m_u), b = this.m_invMassA + this.m_invIA * b * b + this.m_invMassB + this.m_invIB * d * d, this.m_mass = 0 != b ? 1 / b : 0, a.step.warmStarting ? (this.m_impulse *= a.step.dtRatio, b = box2d.b2MulSV(this.m_impulse, this.m_u, box2d.b2RopeJoint.prototype.InitVelocityConstraints.s_P),
            c.SelfMulSub(this.m_invMassA, b), e -= this.m_invIA * box2d.b2CrossVV(this.m_rA, b), g.SelfMulAdd(this.m_invMassB, b), h += this.m_invIB * box2d.b2CrossVV(this.m_rB, b)) : this.m_impulse = 0, a.velocities[this.m_indexA].w = e, a.velocities[this.m_indexB].w = h) : (this.m_u.SetZero(), this.m_impulse = this.m_mass = 0)
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "InitVelocityConstraints", box2d.b2RopeJoint.prototype.InitVelocityConstraints);
box2d.b2RopeJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2RopeJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.velocities[this.m_indexB].v, d = a.velocities[this.m_indexB].w, f = box2d.b2AddVCrossSV(b, c, this.m_rA, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpA), g = box2d.b2AddVCrossSV(e, d, this.m_rB, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpB), h = this.m_length - this.m_maxLength, f = box2d.b2DotVV(this.m_u, box2d.b2SubVV(g, f, box2d.b2Vec2.s_t0));
    0 > h && (f += a.step.inv_dt *
            h);
    h = -this.m_mass * f;
    f = this.m_impulse;
    this.m_impulse = box2d.b2Min(0, this.m_impulse + h);
    h = this.m_impulse - f;
    h = box2d.b2MulSV(h, this.m_u, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_P);
    b.SelfMulSub(this.m_invMassA, h);
    c -= this.m_invIA * box2d.b2CrossVV(this.m_rA, h);
    e.SelfMulAdd(this.m_invMassB, h);
    d += this.m_invIB * box2d.b2CrossVV(this.m_rB, h);
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = d
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "SolveVelocityConstraints", box2d.b2RopeJoint.prototype.SolveVelocityConstraints);
box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpA = new box2d.b2Vec2;
box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpB = new box2d.b2Vec2;
box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2RopeJoint.prototype.SolvePositionConstraints = function(a) {
    var b = a.positions[this.m_indexA].c, c = a.positions[this.m_indexA].a, e = a.positions[this.m_indexB].c, d = a.positions[this.m_indexB].a, f = this.m_qA.SetAngleRadians(c), g = this.m_qB.SetAngleRadians(d);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    f = box2d.b2MulRV(f, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var g = box2d.b2MulRV(g, this.m_lalcB, this.m_rB), h = this.m_u.Copy(e).SelfAdd(g).SelfSub(b).SelfSub(f),
            l = h.Normalize(), k = l - this.m_maxLength, k = box2d.b2Clamp(k, 0, box2d.b2_maxLinearCorrection), h = box2d.b2MulSV(-this.m_mass * k, h, box2d.b2RopeJoint.prototype.SolvePositionConstraints.s_P);
    b.SelfMulSub(this.m_invMassA, h);
    c -= this.m_invIA * box2d.b2CrossVV(f, h);
    e.SelfMulAdd(this.m_invMassB, h);
    d += this.m_invIB * box2d.b2CrossVV(g, h);
    a.positions[this.m_indexA].a = c;
    a.positions[this.m_indexB].a = d;
    return l - this.m_maxLength < box2d.b2_linearSlop
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "SolvePositionConstraints", box2d.b2RopeJoint.prototype.SolvePositionConstraints);
box2d.b2RopeJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2;
box2d.b2RopeJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, a)
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "GetAnchorA", box2d.b2RopeJoint.prototype.GetAnchorA);
box2d.b2RopeJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "GetAnchorB", box2d.b2RopeJoint.prototype.GetAnchorB);
box2d.b2RopeJoint.prototype.GetReactionForce = function(a, b) {
    return box2d.b2MulSV(a * this.m_impulse, this.m_u, b)
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "GetReactionForce", box2d.b2RopeJoint.prototype.GetReactionForce);
box2d.b2RopeJoint.prototype.GetReactionTorque = function(a) {
    return 0
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "GetReactionTorque", box2d.b2RopeJoint.prototype.GetReactionTorque);
box2d.b2RopeJoint.prototype.GetLocalAnchorA = function(a) {
    return a.Copy(this.m_localAnchorA)
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "GetLocalAnchorA", box2d.b2RopeJoint.prototype.GetLocalAnchorA);
box2d.b2RopeJoint.prototype.GetLocalAnchorB = function(a) {
    return a.Copy(this.m_localAnchorB)
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "GetLocalAnchorB", box2d.b2RopeJoint.prototype.GetLocalAnchorB);
box2d.b2RopeJoint.prototype.SetMaxLength = function(a) {
    this.m_maxLength = a
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "SetMaxLength", box2d.b2RopeJoint.prototype.SetMaxLength);
box2d.b2RopeJoint.prototype.GetMaxLength = function() {
    return this.m_maxLength
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "GetMaxLength", box2d.b2RopeJoint.prototype.GetMaxLength);
box2d.b2RopeJoint.prototype.GetLimitState = function() {
    return this.m_state
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "GetLimitState", box2d.b2RopeJoint.prototype.GetLimitState);
box2d.b2RopeJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2RopeJointDef*/ var jd = new box2d.b2RopeJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
        box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n",
                this.m_localAnchorB.x, this.m_localAnchorB.y);
        box2d.b2Log("  jd.maxLength = %.15f;\n", this.m_maxLength);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "Dump", box2d.b2RopeJoint.prototype.Dump);
box2d.b2GravityController = function() {
    box2d.b2Controller.call(this)
};
goog.inherits(box2d.b2GravityController, box2d.b2Controller);
goog.exportSymbol("box2d.b2GravityController", box2d.b2GravityController);
box2d.b2GravityController.prototype.G = 1;
goog.exportProperty(box2d.b2GravityController.prototype, "G", box2d.b2GravityController.prototype.G);
box2d.b2GravityController.prototype.invSqr = !0;
goog.exportProperty(box2d.b2GravityController.prototype, "invSqr", box2d.b2GravityController.prototype.invSqr);
box2d.b2GravityController.prototype.Step = function(a) {
    if (this.invSqr)
        for (a = this.m_bodyList; a; a = a.nextBody)
            for (var b = a.body, c = b.GetWorldCenter(), e = b.GetMass(), d = this.m_bodyList; d != a; d = d.nextBody) {
                var f = d.body, g = f.GetWorldCenter(), h = f.GetMass(), l = g.x - c.x, k = g.y - c.y, m = l * l + k * k;
                m < box2d.b2_epsilon || (l = box2d.b2GravityController.prototype.Step.s_f.SetXY(l, k), l.SelfMul(this.G / m / box2d.b2Sqrt(m) * e * h), b.IsAwake() && b.ApplyForce(l, c), f.IsAwake() && f.ApplyForce(l.SelfMul(-1), g))
            }
    else
        for (a = this.m_bodyList; a; a = a.nextBody)
            for (b =
                    a.body, c = b.GetWorldCenter(), e = b.GetMass(), d = this.m_bodyList; d != a; d = d.nextBody)
                f = d.body, g = f.GetWorldCenter(), h = f.GetMass(), l = g.x - c.x, k = g.y - c.y, m = l * l + k * k, m < box2d.b2_epsilon || (l = box2d.b2GravityController.prototype.Step.s_f.SetXY(l, k), l.SelfMul(this.G / m * e * h), b.IsAwake() && b.ApplyForce(l, c), f.IsAwake() && f.ApplyForce(l.SelfMul(-1), g))
};
goog.exportProperty(box2d.b2GravityController.prototype, "Step", box2d.b2GravityController.prototype.Step);
box2d.b2GravityController.prototype.Step.s_f = new box2d.b2Vec2;
box2d.b2Profile = function() {
};
goog.exportSymbol("box2d.b2Profile", box2d.b2Profile);
box2d.b2Profile.prototype.step = 0;
goog.exportProperty(box2d.b2Profile.prototype, "step", box2d.b2Profile.prototype.step);
box2d.b2Profile.prototype.collide = 0;
goog.exportProperty(box2d.b2Profile.prototype, "collide", box2d.b2Profile.prototype.collide);
box2d.b2Profile.prototype.solve = 0;
goog.exportProperty(box2d.b2Profile.prototype, "solve", box2d.b2Profile.prototype.solve);
box2d.b2Profile.prototype.solveInit = 0;
goog.exportProperty(box2d.b2Profile.prototype, "solveInit", box2d.b2Profile.prototype.solveInit);
box2d.b2Profile.prototype.solveVelocity = 0;
goog.exportProperty(box2d.b2Profile.prototype, "solveVelocity", box2d.b2Profile.prototype.solveVelocity);
box2d.b2Profile.prototype.solvePosition = 0;
goog.exportProperty(box2d.b2Profile.prototype, "solvePosition", box2d.b2Profile.prototype.solvePosition);
box2d.b2Profile.prototype.broadphase = 0;
goog.exportProperty(box2d.b2Profile.prototype, "broadphase", box2d.b2Profile.prototype.broadphase);
box2d.b2Profile.prototype.solveTOI = 0;
goog.exportProperty(box2d.b2Profile.prototype, "solveTOI", box2d.b2Profile.prototype.solveTOI);
box2d.b2Profile.prototype.Reset = function() {
    this.solveTOI = this.broadphase = this.solvePosition = this.solveVelocity = this.solveInit = this.solve = this.collide = this.step = 0;
    return this
};
goog.exportProperty(box2d.b2Profile.prototype, "Reset", box2d.b2Profile.prototype.Reset);
box2d.b2TimeStep = function() {
};
goog.exportSymbol("box2d.b2TimeStep", box2d.b2TimeStep);
box2d.b2TimeStep.prototype.dt = 0;
goog.exportProperty(box2d.b2TimeStep.prototype, "dt", box2d.b2TimeStep.prototype.dt);
box2d.b2TimeStep.prototype.inv_dt = 0;
goog.exportProperty(box2d.b2TimeStep.prototype, "inv_dt", box2d.b2TimeStep.prototype.inv_dt);
box2d.b2TimeStep.prototype.dtRatio = 0;
goog.exportProperty(box2d.b2TimeStep.prototype, "dtRatio", box2d.b2TimeStep.prototype.dtRatio);
box2d.b2TimeStep.prototype.velocityIterations = 0;
goog.exportProperty(box2d.b2TimeStep.prototype, "velocityIterations", box2d.b2TimeStep.prototype.velocityIterations);
box2d.b2TimeStep.prototype.positionIterations = 0;
goog.exportProperty(box2d.b2TimeStep.prototype, "positionIterations", box2d.b2TimeStep.prototype.positionIterations);
box2d.b2TimeStep.prototype.warmStarting = !1;
goog.exportProperty(box2d.b2TimeStep.prototype, "warmStarting", box2d.b2TimeStep.prototype.warmStarting);
box2d.b2TimeStep.prototype.Copy = function(a) {
    this.dt = a.dt;
    this.inv_dt = a.inv_dt;
    this.dtRatio = a.dtRatio;
    this.positionIterations = a.positionIterations;
    this.velocityIterations = a.velocityIterations;
    this.warmStarting = a.warmStarting;
    return this
};
goog.exportProperty(box2d.b2TimeStep.prototype, "Copy", box2d.b2TimeStep.prototype.Copy);
box2d.b2Position = function() {
    this.c = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2Position", box2d.b2Position);
box2d.b2Position.prototype.c = null;
goog.exportProperty(box2d.b2Position.prototype, "c", box2d.b2Position.prototype.c);
box2d.b2Position.prototype.a = 0;
goog.exportProperty(box2d.b2Position.prototype, "a", box2d.b2Position.prototype.a);
box2d.b2Position.MakeArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return new box2d.b2Position
    })
};
goog.exportProperty(box2d.b2Position, "MakeArray", box2d.b2Position.MakeArray);
box2d.b2Velocity = function() {
    this.v = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2Velocity", box2d.b2Velocity);
box2d.b2Velocity.prototype.v = null;
goog.exportProperty(box2d.b2Velocity.prototype, "v", box2d.b2Velocity.prototype.v);
box2d.b2Velocity.prototype.w = 0;
goog.exportProperty(box2d.b2Velocity.prototype, "w", box2d.b2Velocity.prototype.w);
box2d.b2Velocity.MakeArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return new box2d.b2Velocity
    })
};
goog.exportProperty(box2d.b2Velocity, "MakeArray", box2d.b2Velocity.MakeArray);
box2d.b2SolverData = function() {
    this.step = new box2d.b2TimeStep
};
goog.exportSymbol("box2d.b2SolverData", box2d.b2SolverData);
box2d.b2SolverData.prototype.step = null;
goog.exportProperty(box2d.b2SolverData.prototype, "step", box2d.b2SolverData.prototype.step);
box2d.b2SolverData.prototype.positions = null;
goog.exportProperty(box2d.b2SolverData.prototype, "positions", box2d.b2SolverData.prototype.positions);
box2d.b2SolverData.prototype.velocities = null;
goog.exportProperty(box2d.b2SolverData.prototype, "velocities", box2d.b2SolverData.prototype.velocities);
box2d.b2Collision = {};
box2d.b2ContactFeatureType = {e_vertex: 0, e_face: 1};
goog.exportSymbol("box2d.b2ContactFeatureType", box2d.b2ContactFeatureType);
goog.exportProperty(box2d.b2ContactFeatureType, "e_vertex", box2d.b2ContactFeatureType.e_vertex);
goog.exportProperty(box2d.b2ContactFeatureType, "e_face", box2d.b2ContactFeatureType.e_face);
box2d.b2ContactFeature = function(a) {
    this._id = a
};
goog.exportSymbol("box2d.b2ContactFeature", box2d.b2ContactFeature);
box2d.b2ContactFeature.prototype._id = null;
goog.exportProperty(box2d.b2ContactFeature.prototype, "_id", box2d.b2ContactFeature.prototype._id);
box2d.b2ContactFeature.prototype._indexA = 0;
goog.exportProperty(box2d.b2ContactFeature.prototype, "_indexA", box2d.b2ContactFeature.prototype._indexA);
box2d.b2ContactFeature.prototype._indexB = 0;
goog.exportProperty(box2d.b2ContactFeature.prototype, "_indexB", box2d.b2ContactFeature.prototype._indexB);
box2d.b2ContactFeature.prototype._typeA = 0;
goog.exportProperty(box2d.b2ContactFeature.prototype, "_typeA", box2d.b2ContactFeature.prototype._typeA);
box2d.b2ContactFeature.prototype._typeB = 0;
goog.exportProperty(box2d.b2ContactFeature.prototype, "_typeB", box2d.b2ContactFeature.prototype._typeB);
Object.defineProperty(box2d.b2ContactFeature.prototype, "indexA", {enumerable: !1, configurable: !0, get: function() {
        return this._indexA
    }, set: function(a) {
        this._indexA = a;
        this._id._key = this._id._key & 4294967040 | this._indexA & 255
    }});
Object.defineProperty(box2d.b2ContactFeature.prototype, "indexB", {enumerable: !1, configurable: !0, get: function() {
        return this._indexB
    }, set: function(a) {
        this._indexB = a;
        this._id._key = this._id._key & 4294902015 | this._indexB << 8 & 65280
    }});
Object.defineProperty(box2d.b2ContactFeature.prototype, "typeA", {enumerable: !1, configurable: !0, get: function() {
        return this._typeA
    }, set: function(a) {
        this._typeA = a;
        this._id._key = this._id._key & 4278255615 | this._typeA << 16 & 16711680
    }});
Object.defineProperty(box2d.b2ContactFeature.prototype, "typeB", {enumerable: !1, configurable: !0, get: function() {
        return this._typeB
    }, set: function(a) {
        this._typeB = a;
        this._id._key = this._id._key & 16777215 | this._typeB << 24 & 4278190080
    }});
box2d.b2ContactID = function() {
    this.cf = new box2d.b2ContactFeature(this)
};
goog.exportSymbol("box2d.b2ContactID", box2d.b2ContactID);
box2d.b2ContactID.prototype.cf = null;
goog.exportProperty(box2d.b2ContactID.prototype, "cf", box2d.b2ContactID.prototype.cf);
box2d.b2ContactID.prototype.key = 0;
goog.exportProperty(box2d.b2ContactID.prototype, "key", box2d.b2ContactID.prototype.key);
box2d.b2ContactID.prototype.Copy = function(a) {
    this.key = a.key;
    return this
};
goog.exportProperty(box2d.b2ContactID.prototype, "Copy", box2d.b2ContactID.prototype.Copy);
box2d.b2ContactID.prototype.Clone = function() {
    return(new box2d.b2ContactID).Copy(this)
};
goog.exportProperty(box2d.b2ContactID.prototype, "Clone", box2d.b2ContactID.prototype.Clone);
Object.defineProperty(box2d.b2ContactID.prototype, "key", {enumerable: !1, configurable: !0, get: function() {
        return this._key
    }, set: function(a) {
        this._key = a;
        this.cf._indexA = this._key & 255;
        this.cf._indexB = this._key >> 8 & 255;
        this.cf._typeA = this._key >> 16 & 255;
        this.cf._typeB = this._key >> 24 & 255
    }});
box2d.b2ManifoldPoint = function() {
    this.localPoint = new box2d.b2Vec2;
    this.id = new box2d.b2ContactID
};
goog.exportSymbol("box2d.b2ManifoldPoint", box2d.b2ManifoldPoint);
box2d.b2ManifoldPoint.prototype.localPoint = null;
goog.exportProperty(box2d.b2ManifoldPoint.prototype, "localPoint", box2d.b2ManifoldPoint.prototype.localPoint);
box2d.b2ManifoldPoint.prototype.normalImpulse = 0;
goog.exportProperty(box2d.b2ManifoldPoint.prototype, "normalImpulse", box2d.b2ManifoldPoint.prototype.normalImpulse);
box2d.b2ManifoldPoint.prototype.tangentImpulse = 0;
goog.exportProperty(box2d.b2ManifoldPoint.prototype, "tangentImpulse", box2d.b2ManifoldPoint.prototype.tangentImpulse);
box2d.b2ManifoldPoint.prototype.id = null;
goog.exportProperty(box2d.b2ManifoldPoint.prototype, "id", box2d.b2ManifoldPoint.prototype.id);
box2d.b2ManifoldPoint.MakeArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return new box2d.b2ManifoldPoint
    })
};
goog.exportProperty(box2d.b2ManifoldPoint, "MakeArray", box2d.b2ManifoldPoint.MakeArray);
box2d.b2ManifoldPoint.prototype.Reset = function() {
    this.localPoint.SetZero();
    this.tangentImpulse = this.normalImpulse = 0;
    this.id.key = 0
};
goog.exportProperty(box2d.b2ManifoldPoint.prototype, "Reset", box2d.b2ManifoldPoint.prototype.Reset);
box2d.b2ManifoldPoint.prototype.Copy = function(a) {
    this.localPoint.Copy(a.localPoint);
    this.normalImpulse = a.normalImpulse;
    this.tangentImpulse = a.tangentImpulse;
    this.id.Copy(a.id);
    return this
};
goog.exportProperty(box2d.b2ManifoldPoint.prototype, "Copy", box2d.b2ManifoldPoint.prototype.Copy);
box2d.b2ManifoldType = {e_unknown: -1, e_circles: 0, e_faceA: 1, e_faceB: 2};
goog.exportSymbol("box2d.b2ManifoldType", box2d.b2ManifoldType);
goog.exportProperty(box2d.b2ManifoldType, "e_unknown", box2d.b2ManifoldType.e_unknown);
goog.exportProperty(box2d.b2ManifoldType, "e_circles", box2d.b2ManifoldType.e_circles);
goog.exportProperty(box2d.b2ManifoldType, "e_faceA", box2d.b2ManifoldType.e_faceA);
goog.exportProperty(box2d.b2ManifoldType, "e_faceB", box2d.b2ManifoldType.e_faceB);
box2d.b2Manifold = function() {
    this.points = box2d.b2ManifoldPoint.MakeArray(box2d.b2_maxManifoldPoints);
    this.localNormal = new box2d.b2Vec2;
    this.localPoint = new box2d.b2Vec2;
    this.type = box2d.b2ManifoldType.e_unknown;
    this.pointCount = 0
};
goog.exportSymbol("box2d.b2Manifold", box2d.b2Manifold);
box2d.b2Manifold.prototype.points = null;
goog.exportProperty(box2d.b2Manifold.prototype, "points", box2d.b2Manifold.prototype.points);
box2d.b2Manifold.prototype.localNormal = null;
goog.exportProperty(box2d.b2Manifold.prototype, "localNormal", box2d.b2Manifold.prototype.localNormal);
box2d.b2Manifold.prototype.localPoint = null;
goog.exportProperty(box2d.b2Manifold.prototype, "localPoint", box2d.b2Manifold.prototype.localPoint);
box2d.b2Manifold.prototype.type = box2d.b2ManifoldType.e_unknown;
goog.exportProperty(box2d.b2Manifold.prototype, "type", box2d.b2Manifold.prototype.type);
box2d.b2Manifold.prototype.pointCount = 0;
goog.exportProperty(box2d.b2Manifold.prototype, "pointCount", box2d.b2Manifold.prototype.pointCount);
box2d.b2Manifold.prototype.Reset = function() {
    for (var a = 0, b = box2d.b2_maxManifoldPoints; a < b; ++a)
        this.points[a].Reset();
    this.localNormal.SetZero();
    this.localPoint.SetZero();
    this.type = box2d.b2ManifoldType.e_unknown;
    this.pointCount = 0
};
goog.exportProperty(box2d.b2Manifold.prototype, "Reset", box2d.b2Manifold.prototype.Reset);
box2d.b2Manifold.prototype.Copy = function(a) {
    this.pointCount = a.pointCount;
    for (var b = 0, c = box2d.b2_maxManifoldPoints; b < c; ++b)
        this.points[b].Copy(a.points[b]);
    this.localNormal.Copy(a.localNormal);
    this.localPoint.Copy(a.localPoint);
    this.type = a.type;
    return this
};
goog.exportProperty(box2d.b2Manifold.prototype, "Copy", box2d.b2Manifold.prototype.Copy);
box2d.b2Manifold.prototype.Clone = function() {
    return(new box2d.b2Manifold).Copy(this)
};
goog.exportProperty(box2d.b2Manifold.prototype, "Clone", box2d.b2Manifold.prototype.Clone);
box2d.b2WorldManifold = function() {
    this.normal = new box2d.b2Vec2;
    this.points = box2d.b2Vec2.MakeArray(box2d.b2_maxManifoldPoints)
};
goog.exportSymbol("box2d.b2WorldManifold", box2d.b2WorldManifold);
box2d.b2WorldManifold.prototype.normal = null;
goog.exportProperty(box2d.b2WorldManifold.prototype, "normal", box2d.b2WorldManifold.prototype.normal);
box2d.b2WorldManifold.prototype.points = null;
goog.exportProperty(box2d.b2WorldManifold.prototype, "points", box2d.b2WorldManifold.prototype.points);
box2d.b2WorldManifold.prototype.Initialize = function(a, b, c, e, d) {
    if (0 != a.pointCount)
        switch (a.type) {
            case box2d.b2ManifoldType.e_circles:
                this.normal.SetXY(1, 0);
                b = box2d.b2MulXV(b, a.localPoint, box2d.b2WorldManifold.prototype.Initialize.s_pointA);
                a = box2d.b2MulXV(e, a.points[0].localPoint, box2d.b2WorldManifold.prototype.Initialize.s_pointB);
                box2d.b2DistanceSquaredVV(b, a) > box2d.b2_epsilon_sq && box2d.b2SubVV(a, b, this.normal).SelfNormalize();
                var f = box2d.b2AddVMulSV(b, c, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cA),
                        g = box2d.b2SubVMulSV(a, d, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cB);
                box2d.b2MidVV(f, g, this.points[0]);
                break;
            case box2d.b2ManifoldType.e_faceA:
                box2d.b2MulRV(b.q, a.localNormal, this.normal);
                for (var h = box2d.b2MulXV(b, a.localPoint, box2d.b2WorldManifold.prototype.Initialize.s_planePoint), l = 0, k = a.pointCount; l < k; ++l) {
                    var m = box2d.b2MulXV(e, a.points[l].localPoint, box2d.b2WorldManifold.prototype.Initialize.s_clipPoint), f = c - box2d.b2DotVV(box2d.b2SubVV(m, h, box2d.b2Vec2.s_t0), this.normal), f = box2d.b2AddVMulSV(m,
                            f, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cA), g = box2d.b2SubVMulSV(m, d, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cB);
                    box2d.b2MidVV(f, g, this.points[l])
                }
                break;
            case box2d.b2ManifoldType.e_faceB:
                box2d.b2MulRV(e.q, a.localNormal, this.normal);
                h = box2d.b2MulXV(e, a.localPoint, box2d.b2WorldManifold.prototype.Initialize.s_planePoint);
                l = 0;
                for (k = a.pointCount; l < k; ++l)
                    m = box2d.b2MulXV(b, a.points[l].localPoint, box2d.b2WorldManifold.prototype.Initialize.s_clipPoint), f = d - box2d.b2DotVV(box2d.b2SubVV(m,
                            h, box2d.b2Vec2.s_t0), this.normal), g = box2d.b2AddVMulSV(m, f, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cB), f = box2d.b2SubVMulSV(m, c, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cA), box2d.b2MidVV(f, g, this.points[l]);
                this.normal.SelfNeg()
            }
};
goog.exportProperty(box2d.b2WorldManifold.prototype, "Initialize", box2d.b2WorldManifold.prototype.Initialize);
box2d.b2WorldManifold.prototype.Initialize.s_pointA = new box2d.b2Vec2;
box2d.b2WorldManifold.prototype.Initialize.s_pointB = new box2d.b2Vec2;
box2d.b2WorldManifold.prototype.Initialize.s_cA = new box2d.b2Vec2;
box2d.b2WorldManifold.prototype.Initialize.s_cB = new box2d.b2Vec2;
box2d.b2WorldManifold.prototype.Initialize.s_planePoint = new box2d.b2Vec2;
box2d.b2WorldManifold.prototype.Initialize.s_clipPoint = new box2d.b2Vec2;
box2d.b2PointState = {b2_nullState: 0, b2_addState: 1, b2_persistState: 2, b2_removeState: 3};
goog.exportSymbol("box2d.b2PointState", box2d.b2PointState);
goog.exportProperty(box2d.b2PointState, "b2_nullState   ", box2d.b2PointState.b2_nullState);
goog.exportProperty(box2d.b2PointState, "b2_addState    ", box2d.b2PointState.b2_addState);
goog.exportProperty(box2d.b2PointState, "b2_persistState", box2d.b2PointState.b2_persistState);
goog.exportProperty(box2d.b2PointState, "b2_removeState ", box2d.b2PointState.b2_removeState);
box2d.b2GetPointStates = function(a, b, c, e) {
    for (var d = 0, f = c.pointCount; d < f; ++d) {
        var g = c.points[d].id, g = g.key;
        a[d] = box2d.b2PointState.b2_removeState;
        for (var h = 0, l = e.pointCount; h < l; ++h)
            if (e.points[h].id.key == g) {
                a[d] = box2d.b2PointState.b2_persistState;
                break
            }
    }
    for (f = box2d.b2_maxManifoldPoints; d < f; ++d)
        a[d] = box2d.b2PointState.b2_nullState;
    d = 0;
    for (f = e.pointCount; d < f; ++d)
        for (g = e.points[d].id, g = g.key, b[d] = box2d.b2PointState.b2_addState, h = 0, l = c.pointCount; h < l; ++h)
            if (c.points[h].id.key == g) {
                b[d] = box2d.b2PointState.b2_persistState;
                break
            }
    for (f = box2d.b2_maxManifoldPoints; d < f; ++d)
        b[d] = box2d.b2PointState.b2_nullState
};
goog.exportSymbol("box2d.b2GetPointStates", box2d.b2GetPointStates);
box2d.b2ClipVertex = function() {
    this.v = new box2d.b2Vec2;
    this.id = new box2d.b2ContactID
};
goog.exportSymbol("box2d.b2ClipVertex", box2d.b2ClipVertex);
box2d.b2ClipVertex.prototype.v = null;
goog.exportProperty(box2d.b2ClipVertex.prototype, "v", box2d.b2ClipVertex.prototype.v);
box2d.b2ClipVertex.prototype.id = null;
goog.exportProperty(box2d.b2ClipVertex.prototype, "id", box2d.b2ClipVertex.prototype.id);
box2d.b2ClipVertex.MakeArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return new box2d.b2ClipVertex
    })
};
goog.exportProperty(box2d.b2ClipVertex, "MakeArray", box2d.b2ClipVertex.MakeArray);
box2d.b2ClipVertex.prototype.Copy = function(a) {
    this.v.Copy(a.v);
    this.id.Copy(a.id);
    return this
};
goog.exportProperty(box2d.b2ClipVertex.prototype, "Copy", box2d.b2ClipVertex.prototype.Copy);
box2d.b2RayCastInput = function() {
    this.p1 = new box2d.b2Vec2;
    this.p2 = new box2d.b2Vec2;
    this.maxFraction = 1
};
goog.exportSymbol("box2d.b2RayCastInput", box2d.b2RayCastInput);
box2d.b2RayCastInput.prototype.p1 = null;
goog.exportProperty(box2d.b2RayCastInput.prototype, "p1", box2d.b2RayCastInput.prototype.p1);
box2d.b2RayCastInput.prototype.p2 = null;
goog.exportProperty(box2d.b2RayCastInput.prototype, "p2", box2d.b2RayCastInput.prototype.p2);
box2d.b2RayCastInput.prototype.maxFraction = 1;
goog.exportProperty(box2d.b2RayCastInput.prototype, "maxFraction", box2d.b2RayCastInput.prototype.maxFraction);
box2d.b2RayCastInput.prototype.Copy = function(a) {
    this.p1.Copy(a.p1);
    this.p2.Copy(a.p2);
    this.maxFraction = a.maxFraction;
    return this
};
goog.exportProperty(box2d.b2RayCastInput.prototype, "Copy", box2d.b2RayCastInput.prototype.Copy);
box2d.b2RayCastOutput = function() {
    this.normal = new box2d.b2Vec2;
    this.fraction = 0
};
goog.exportSymbol("box2d.b2RayCastOutput", box2d.b2RayCastOutput);
box2d.b2RayCastOutput.prototype.normal = null;
goog.exportProperty(box2d.b2RayCastOutput.prototype, "normal", box2d.b2RayCastOutput.prototype.normal);
box2d.b2RayCastOutput.prototype.fraction = 0;
goog.exportProperty(box2d.b2RayCastOutput.prototype, "fraction", box2d.b2RayCastOutput.prototype.fraction);
box2d.b2RayCastOutput.prototype.Copy = function(a) {
    this.normal.Copy(a.normal);
    this.fraction = a.fraction;
    return this
};
goog.exportProperty(box2d.b2RayCastOutput.prototype, "Copy", box2d.b2RayCastOutput.prototype.Copy);
box2d.b2AABB = function() {
    this.lowerBound = new box2d.b2Vec2;
    this.upperBound = new box2d.b2Vec2;
    this.m_out_center = new box2d.b2Vec2;
    this.m_out_extent = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2AABB", box2d.b2AABB);
box2d.b2AABB.prototype.lowerBound = null;
goog.exportProperty(box2d.b2AABB.prototype, "lowerBound", box2d.b2AABB.prototype.lowerBound);
box2d.b2AABB.prototype.upperBound = null;
goog.exportProperty(box2d.b2AABB.prototype, "upperBound", box2d.b2AABB.prototype.upperBound);
box2d.b2AABB.prototype.m_out_center = null;
goog.exportProperty(box2d.b2AABB.prototype, "m_out_center", box2d.b2AABB.prototype.m_out_center);
box2d.b2AABB.prototype.m_out_extent = null;
goog.exportProperty(box2d.b2AABB.prototype, "m_out_extent", box2d.b2AABB.prototype.m_out_extent);
box2d.b2AABB.prototype.Copy = function(a) {
    this.lowerBound.Copy(a.lowerBound);
    this.upperBound.Copy(a.upperBound);
    return this
};
goog.exportProperty(box2d.b2AABB.prototype, "Copy", box2d.b2AABB.prototype.Copy);
box2d.b2AABB.prototype.IsValid = function() {
    var a = this.upperBound.y - this.lowerBound.y;
    return a = (a = 0 <= this.upperBound.x - this.lowerBound.x && 0 <= a) && this.lowerBound.IsValid() && this.upperBound.IsValid()
};
goog.exportProperty(box2d.b2AABB.prototype, "IsValid", box2d.b2AABB.prototype.IsValid);
box2d.b2AABB.prototype.GetCenter = function() {
    return box2d.b2MidVV(this.lowerBound, this.upperBound, this.m_out_center)
};
goog.exportProperty(box2d.b2AABB.prototype, "GetCenter", box2d.b2AABB.prototype.GetCenter);
box2d.b2AABB.prototype.GetExtents = function() {
    return box2d.b2ExtVV(this.lowerBound, this.upperBound, this.m_out_extent)
};
goog.exportProperty(box2d.b2AABB.prototype, "GetExtents", box2d.b2AABB.prototype.GetExtents);
box2d.b2AABB.prototype.GetPerimeter = function() {
    return 2 * (this.upperBound.x - this.lowerBound.x + (this.upperBound.y - this.lowerBound.y))
};
goog.exportProperty(box2d.b2AABB.prototype, "GetPerimeter", box2d.b2AABB.prototype.GetPerimeter);
box2d.b2AABB.prototype.Combine1 = function(a) {
    this.lowerBound.x = box2d.b2Min(this.lowerBound.x, a.lowerBound.x);
    this.lowerBound.y = box2d.b2Min(this.lowerBound.y, a.lowerBound.y);
    this.upperBound.x = box2d.b2Max(this.upperBound.x, a.upperBound.x);
    this.upperBound.y = box2d.b2Max(this.upperBound.y, a.upperBound.y);
    return this
};
goog.exportProperty(box2d.b2AABB.prototype, "Combine1", box2d.b2AABB.prototype.Combine1);
box2d.b2AABB.prototype.Combine2 = function(a, b) {
    this.lowerBound.x = box2d.b2Min(a.lowerBound.x, b.lowerBound.x);
    this.lowerBound.y = box2d.b2Min(a.lowerBound.y, b.lowerBound.y);
    this.upperBound.x = box2d.b2Max(a.upperBound.x, b.upperBound.x);
    this.upperBound.y = box2d.b2Max(a.upperBound.y, b.upperBound.y);
    return this
};
goog.exportProperty(box2d.b2AABB.prototype, "Combine2", box2d.b2AABB.prototype.Combine2);
box2d.b2AABB.Combine = function(a, b, c) {
    c.Combine2(a, b);
    return c
};
goog.exportProperty(box2d.b2AABB, "Combine", box2d.b2AABB.Combine);
box2d.b2AABB.prototype.Contains = function(a) {
    var b;
    return b = (b = (b = (b = this.lowerBound.x <= a.lowerBound.x) && this.lowerBound.y <= a.lowerBound.y) && a.upperBound.x <= this.upperBound.x) && a.upperBound.y <= this.upperBound.y
};
goog.exportProperty(box2d.b2AABB.prototype, "Contains", box2d.b2AABB.prototype.Contains);
box2d.b2AABB.prototype.RayCast = function(a, b) {
    var c = -box2d.b2_maxFloat, e = box2d.b2_maxFloat, d = b.p1.x, f = b.p1.y, g = b.p2.x - b.p1.x, h = b.p2.y - b.p1.y, l = box2d.b2Abs(g), k = box2d.b2Abs(h), m = a.normal;
    if (l < box2d.b2_epsilon) {
        if (d < this.lowerBound.x || this.upperBound.x < d)
            return!1
    } else if (l = 1 / g, g = (this.lowerBound.x - d) * l, d = (this.upperBound.x - d) * l, l = -1, g > d && (l = g, g = d, d = l, l = 1), g > c && (m.x = l, m.y = 0, c = g), e = box2d.b2Min(e, d), c > e)
        return!1;
    if (k < box2d.b2_epsilon) {
        if (f < this.lowerBound.y || this.upperBound.y < f)
            return!1
    } else if (l = 1 / h, g =
            (this.lowerBound.y - f) * l, d = (this.upperBound.y - f) * l, l = -1, g > d && (l = g, g = d, d = l, l = 1), g > c && (m.x = 0, m.y = l, c = g), e = box2d.b2Min(e, d), c > e)
        return!1;
    if (0 > c || b.maxFraction < c)
        return!1;
    a.fraction = c;
    return!0
};
goog.exportProperty(box2d.b2AABB.prototype, "RayCast", box2d.b2AABB.prototype.RayCast);
box2d.b2AABB.prototype.TestOverlap = function(a) {
    var b = a.lowerBound.y - this.upperBound.y, c = this.lowerBound.y - a.upperBound.y;
    return 0 < a.lowerBound.x - this.upperBound.x || 0 < b || 0 < this.lowerBound.x - a.upperBound.x || 0 < c ? !1 : !0
};
goog.exportProperty(box2d.b2AABB.prototype, "TestOverlap", box2d.b2AABB.prototype.TestOverlap);
box2d.b2TestOverlapAABB = function(a, b) {
    var c = b.lowerBound.y - a.upperBound.y, e = a.lowerBound.y - b.upperBound.y;
    return 0 < b.lowerBound.x - a.upperBound.x || 0 < c || 0 < a.lowerBound.x - b.upperBound.x || 0 < e ? !1 : !0
};
goog.exportSymbol("box2d.b2TestOverlapAABB", box2d.b2TestOverlapAABB);
box2d.b2ClipSegmentToLine = function(a, b, c, e, d) {
    var f = 0, g = b[0];
    b = b[1];
    var h = box2d.b2DotVV(c, g.v) - e;
    c = box2d.b2DotVV(c, b.v) - e;
    0 >= h && a[f++].Copy(g);
    0 >= c && a[f++].Copy(b);
    0 > h * c && (c = h / (h - c), e = a[f].v, e.x = g.v.x + c * (b.v.x - g.v.x), e.y = g.v.y + c * (b.v.y - g.v.y), a = a[f].id, a.cf.indexA = d, a.cf.indexB = g.id.cf.indexB, a.cf.typeA = box2d.b2ContactFeatureType.e_vertex, a.cf.typeB = box2d.b2ContactFeatureType.e_face, ++f);
    return f
};
goog.exportSymbol("box2d.b2ClipSegmentToLine", box2d.b2ClipSegmentToLine);
box2d.b2TestOverlapShape = function(a, b, c, e, d, f) {
    var g = box2d.b2TestOverlapShape.s_input.Reset();
    g.proxyA.SetShape(a, b);
    g.proxyB.SetShape(c, e);
    g.transformA.Copy(d);
    g.transformB.Copy(f);
    g.useRadii = !0;
    a = box2d.b2TestOverlapShape.s_simplexCache.Reset();
    a.count = 0;
    b = box2d.b2TestOverlapShape.s_output.Reset();
    box2d.b2Distance(b, a, g);
    return b.distance < 10 * box2d.b2_epsilon
};
goog.exportSymbol("box2d.b2TestOverlapShape", box2d.b2TestOverlapShape);
box2d.b2TestOverlapShape.s_input = new box2d.b2DistanceInput;
box2d.b2TestOverlapShape.s_simplexCache = new box2d.b2SimplexCache;
box2d.b2TestOverlapShape.s_output = new box2d.b2DistanceOutput;
box2d.b2Timer = function() {
    this.m_start = (new Date).getTime()
};
goog.exportSymbol("box2d.b2Timer", box2d.b2Timer);
box2d.b2Timer.prototype.m_start = 0;
goog.exportProperty(box2d.b2Timer.prototype, "m_start", box2d.b2Timer.prototype.m_start);
box2d.b2Timer.prototype.Reset = function() {
    this.m_start = (new Date).getTime();
    return this
};
goog.exportProperty(box2d.b2Timer.prototype, "Reset", box2d.b2Timer.prototype.Reset);
box2d.b2Timer.prototype.GetMilliseconds = function() {
    return(new Date).getTime() - this.m_start
};
goog.exportProperty(box2d.b2Timer.prototype, "GetMilliseconds", box2d.b2Timer.prototype.GetMilliseconds);
box2d.b2Counter = function() {
};
goog.exportSymbol("box2d.b2Counter", box2d.b2Counter);
box2d.b2Counter.prototype.m_count = 0;
goog.exportProperty(box2d.b2Counter.prototype, "m_count", box2d.b2Counter.prototype.m_count);
box2d.b2Counter.prototype.m_min_count = 0;
goog.exportProperty(box2d.b2Counter.prototype, "m_min_count", box2d.b2Counter.prototype.m_min_count);
box2d.b2Counter.prototype.m_max_count = 0;
goog.exportProperty(box2d.b2Counter.prototype, "m_max_count", box2d.b2Counter.prototype.m_max_count);
box2d.b2Counter.prototype.GetCount = function() {
    return this.m_count
};
goog.exportProperty(box2d.b2Counter.prototype, "GetCount", box2d.b2Counter.prototype.GetCount);
box2d.b2Counter.prototype.GetMinCount = function() {
    return this.m_min_count
};
goog.exportProperty(box2d.b2Counter.prototype, "GetMinCount", box2d.b2Counter.prototype.GetMinCount);
box2d.b2Counter.prototype.GetMaxCount = function() {
    return this.m_max_count
};
goog.exportProperty(box2d.b2Counter.prototype, "GetMaxCount", box2d.b2Counter.prototype.GetMaxCount);
box2d.b2Counter.prototype.ResetCount = function() {
    var a = this.m_count;
    this.m_count = 0;
    return a
};
goog.exportProperty(box2d.b2Counter.prototype, "ResetCount", box2d.b2Counter.prototype.ResetCount);
box2d.b2Counter.prototype.ResetMinCount = function() {
    this.m_min_count = 0
};
goog.exportProperty(box2d.b2Counter.prototype, "ResetMinCount", box2d.b2Counter.prototype.ResetMinCount);
box2d.b2Counter.prototype.ResetMaxCount = function() {
    this.m_max_count = 0
};
goog.exportProperty(box2d.b2Counter.prototype, "ResetMaxCount", box2d.b2Counter.prototype.ResetMaxCount);
box2d.b2Counter.prototype.Increment = function() {
    this.m_count++;
    this.m_max_count < this.m_count && (this.m_max_count = this.m_count)
};
goog.exportProperty(box2d.b2Counter.prototype, "Increment", box2d.b2Counter.prototype.Increment);
box2d.b2Counter.prototype.Decrement = function() {
    this.m_count--;
    this.m_min_count > this.m_count && (this.m_min_count = this.m_count)
};
goog.exportProperty(box2d.b2Counter.prototype, "Decrement", box2d.b2Counter.prototype.Decrement);
box2d.b2_toiTime = 0;
goog.exportSymbol("box2d.b2_toiTime", box2d.b2_toiTime);
box2d.b2_toiMaxTime = 0;
goog.exportSymbol("box2d.b2_toiMaxTime", box2d.b2_toiMaxTime);
box2d.b2_toiCalls = 0;
goog.exportSymbol("box2d.b2_toiCalls", box2d.b2_toiCalls);
box2d.b2_toiIters = 0;
goog.exportSymbol("box2d.b2_toiIters", box2d.b2_toiIters);
box2d.b2_toiMaxIters = 0;
goog.exportSymbol("box2d.b2_toiMaxIters", box2d.b2_toiMaxIters);
box2d.b2_toiRootIters = 0;
goog.exportSymbol("box2d.b2_toiRootIters", box2d.b2_toiRootIters);
box2d.b2_toiMaxRootIters = 0;
goog.exportSymbol("box2d.b2_toiMaxRootIters", box2d.b2_toiMaxRootIters);
box2d.b2TOIInput = function() {
    this.proxyA = new box2d.b2DistanceProxy;
    this.proxyB = new box2d.b2DistanceProxy;
    this.sweepA = new box2d.b2Sweep;
    this.sweepB = new box2d.b2Sweep
};
goog.exportSymbol("box2d.b2TOIInput", box2d.b2TOIInput);
box2d.b2TOIInput.prototype.proxyA = null;
goog.exportProperty(box2d.b2TOIInput.prototype, "proxyA", box2d.b2TOIInput.prototype.proxyA);
box2d.b2TOIInput.prototype.proxyB = null;
goog.exportProperty(box2d.b2TOIInput.prototype, "proxyB", box2d.b2TOIInput.prototype.proxyB);
box2d.b2TOIInput.prototype.sweepA = null;
goog.exportProperty(box2d.b2TOIInput.prototype, "sweepA", box2d.b2TOIInput.prototype.sweepA);
box2d.b2TOIInput.prototype.sweepB = null;
goog.exportProperty(box2d.b2TOIInput.prototype, "sweepB", box2d.b2TOIInput.prototype.sweepB);
box2d.b2TOIInput.prototype.tMax = 0;
goog.exportProperty(box2d.b2TOIInput.prototype, "tMax", box2d.b2TOIInput.prototype.tMax);
box2d.b2TOIOutputState = {e_unknown: 0, e_failed: 1, e_overlapped: 2, e_touching: 3, e_separated: 4};
goog.exportSymbol("box2d.b2TOIOutputState", box2d.b2TOIOutputState);
goog.exportProperty(box2d.b2TOIOutputState, "e_unknown", box2d.b2TOIOutputState.e_unknown);
goog.exportProperty(box2d.b2TOIOutputState, "e_failed", box2d.b2TOIOutputState.e_failed);
goog.exportProperty(box2d.b2TOIOutputState, "e_overlapped", box2d.b2TOIOutputState.e_overlapped);
goog.exportProperty(box2d.b2TOIOutputState, "e_touching", box2d.b2TOIOutputState.e_touching);
goog.exportProperty(box2d.b2TOIOutputState, "e_separated", box2d.b2TOIOutputState.e_separated);
box2d.b2TOIOutput = function() {
};
goog.exportSymbol("box2d.b2TOIOutput", box2d.b2TOIOutput);
box2d.b2TOIOutput.prototype.state = box2d.b2TOIOutputState.e_unknown;
goog.exportProperty(box2d.b2TOIOutput.prototype, "state", box2d.b2TOIOutput.prototype.state);
box2d.b2TOIOutput.prototype.t = 0;
goog.exportProperty(box2d.b2TOIOutput.prototype, "t", box2d.b2TOIOutput.prototype.t);
box2d.b2SeparationFunctionType = {e_unknown: -1, e_points: 0, e_faceA: 1, e_faceB: 2};
goog.exportSymbol("box2d.b2SeparationFunctionType", box2d.b2SeparationFunctionType);
goog.exportProperty(box2d.b2SeparationFunctionType, "e_unknown", box2d.b2SeparationFunctionType.e_unknown);
goog.exportProperty(box2d.b2SeparationFunctionType, "e_points", box2d.b2SeparationFunctionType.e_points);
goog.exportProperty(box2d.b2SeparationFunctionType, "e_faceA", box2d.b2SeparationFunctionType.e_faceA);
goog.exportProperty(box2d.b2SeparationFunctionType, "e_faceB", box2d.b2SeparationFunctionType.e_faceB);
box2d.b2SeparationFunction = function() {
    this.m_sweepA = new box2d.b2Sweep;
    this.m_sweepB = new box2d.b2Sweep;
    this.m_localPoint = new box2d.b2Vec2;
    this.m_axis = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2SeparationFunction", box2d.b2SeparationFunction);
box2d.b2SeparationFunction.prototype.m_proxyA = null;
goog.exportProperty(box2d.b2SeparationFunction.prototype, "m_proxyA", box2d.b2SeparationFunction.prototype.m_proxyA);
box2d.b2SeparationFunction.prototype.m_proxyB = null;
goog.exportProperty(box2d.b2SeparationFunction.prototype, "m_proxyB", box2d.b2SeparationFunction.prototype.m_proxyB);
box2d.b2SeparationFunction.prototype.m_sweepA = null;
goog.exportProperty(box2d.b2SeparationFunction.prototype, "m_sweepA", box2d.b2SeparationFunction.prototype.m_sweepA);
box2d.b2SeparationFunction.prototype.m_sweepB = null;
goog.exportProperty(box2d.b2SeparationFunction.prototype, "m_sweepB", box2d.b2SeparationFunction.prototype.m_sweepB);
box2d.b2SeparationFunction.prototype.m_type = box2d.b2SeparationFunctionType.e_unknown;
goog.exportProperty(box2d.b2SeparationFunction.prototype, "m_type", box2d.b2SeparationFunction.prototype.m_type);
box2d.b2SeparationFunction.prototype.m_localPoint = null;
goog.exportProperty(box2d.b2SeparationFunction.prototype, "m_localPoint", box2d.b2SeparationFunction.prototype.m_localPoint);
box2d.b2SeparationFunction.prototype.m_axis = null;
goog.exportProperty(box2d.b2SeparationFunction.prototype, "m_axis", box2d.b2SeparationFunction.prototype.m_axis);
box2d.b2SeparationFunction.prototype.Initialize = function(a, b, c, e, d, f) {
    this.m_proxyA = b;
    this.m_proxyB = e;
    b = a.count;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < b && 3 > b);
    this.m_sweepA.Copy(c);
    this.m_sweepB.Copy(d);
    c = box2d.b2TimeOfImpact.s_xfA;
    d = box2d.b2TimeOfImpact.s_xfB;
    this.m_sweepA.GetTransform(c, f);
    this.m_sweepB.GetTransform(d, f);
    1 == b ? (this.m_type = box2d.b2SeparationFunctionType.e_points, b = this.m_proxyA.GetVertex(a.indexA[0]), a = this.m_proxyB.GetVertex(a.indexB[0]), c = box2d.b2MulXV(c, b, box2d.b2TimeOfImpact.s_pointA),
            d = box2d.b2MulXV(d, a, box2d.b2TimeOfImpact.s_pointB), box2d.b2SubVV(d, c, this.m_axis), a = this.m_axis.Normalize()) : (a.indexA[0] == a.indexA[1] ? (this.m_type = box2d.b2SeparationFunctionType.e_faceB, b = this.m_proxyB.GetVertex(a.indexB[0]), e = this.m_proxyB.GetVertex(a.indexB[1]), box2d.b2CrossVOne(box2d.b2SubVV(e, b, box2d.b2Vec2.s_t0), this.m_axis).SelfNormalize(), f = box2d.b2MulRV(d.q, this.m_axis, box2d.b2TimeOfImpact.s_normal), box2d.b2MidVV(b, e, this.m_localPoint), d = box2d.b2MulXV(d, this.m_localPoint, box2d.b2TimeOfImpact.s_pointB),
            b = this.m_proxyA.GetVertex(a.indexA[0]), c = box2d.b2MulXV(c, b, box2d.b2TimeOfImpact.s_pointA), a = box2d.b2DotVV(box2d.b2SubVV(c, d, box2d.b2Vec2.s_t0), f)) : (this.m_type = box2d.b2SeparationFunctionType.e_faceA, b = this.m_proxyA.GetVertex(a.indexA[0]), e = this.m_proxyA.GetVertex(a.indexA[1]), box2d.b2CrossVOne(box2d.b2SubVV(e, b, box2d.b2Vec2.s_t0), this.m_axis).SelfNormalize(), f = box2d.b2MulRV(c.q, this.m_axis, box2d.b2TimeOfImpact.s_normal), box2d.b2MidVV(b, e, this.m_localPoint), c = box2d.b2MulXV(c, this.m_localPoint, box2d.b2TimeOfImpact.s_pointA),
            a = this.m_proxyB.GetVertex(a.indexB[0]), d = box2d.b2MulXV(d, a, box2d.b2TimeOfImpact.s_pointB), a = box2d.b2DotVV(box2d.b2SubVV(d, c, box2d.b2Vec2.s_t0), f)), 0 > a && (this.m_axis.SelfNeg(), a = -a));
    return a
};
goog.exportProperty(box2d.b2SeparationFunction.prototype, "Initialize", box2d.b2SeparationFunction.prototype.Initialize);
box2d.b2SeparationFunction.prototype.FindMinSeparation = function(a, b, c) {
    var e = box2d.b2TimeOfImpact.s_xfA, d = box2d.b2TimeOfImpact.s_xfB;
    this.m_sweepA.GetTransform(e, c);
    this.m_sweepB.GetTransform(d, c);
    switch (this.m_type) {
        case box2d.b2SeparationFunctionType.e_points:
            var f = box2d.b2MulTRV(e.q, this.m_axis, box2d.b2TimeOfImpact.s_axisA), g = box2d.b2MulTRV(d.q, box2d.b2NegV(this.m_axis, box2d.b2Vec2.s_t0), box2d.b2TimeOfImpact.s_axisB);
            a[0] = this.m_proxyA.GetSupport(f);
            b[0] = this.m_proxyB.GetSupport(g);
            a = this.m_proxyA.GetVertex(a[0]);
            b = this.m_proxyB.GetVertex(b[0]);
            e = box2d.b2MulXV(e, a, box2d.b2TimeOfImpact.s_pointA);
            d = box2d.b2MulXV(d, b, box2d.b2TimeOfImpact.s_pointB);
            return b = box2d.b2DotVV(box2d.b2SubVV(d, e, box2d.b2Vec2.s_t0), this.m_axis);
        case box2d.b2SeparationFunctionType.e_faceA:
            return c = box2d.b2MulRV(e.q, this.m_axis, box2d.b2TimeOfImpact.s_normal), e = box2d.b2MulXV(e, this.m_localPoint, box2d.b2TimeOfImpact.s_pointA), g = box2d.b2MulTRV(d.q, box2d.b2NegV(c, box2d.b2Vec2.s_t0), box2d.b2TimeOfImpact.s_axisB), a[0] = -1, b[0] = this.m_proxyB.GetSupport(g),
                    b = this.m_proxyB.GetVertex(b[0]), d = box2d.b2MulXV(d, b, box2d.b2TimeOfImpact.s_pointB), b = box2d.b2DotVV(box2d.b2SubVV(d, e, box2d.b2Vec2.s_t0), c);
        case box2d.b2SeparationFunctionType.e_faceB:
            return c = box2d.b2MulRV(d.q, this.m_axis, box2d.b2TimeOfImpact.s_normal), d = box2d.b2MulXV(d, this.m_localPoint, box2d.b2TimeOfImpact.s_pointB), f = box2d.b2MulTRV(e.q, box2d.b2NegV(c, box2d.b2Vec2.s_t0), box2d.b2TimeOfImpact.s_axisA), b[0] = -1, a[0] = this.m_proxyA.GetSupport(f), a = this.m_proxyA.GetVertex(a[0]), e = box2d.b2MulXV(e, a, box2d.b2TimeOfImpact.s_pointA),
                    b = box2d.b2DotVV(box2d.b2SubVV(e, d, box2d.b2Vec2.s_t0), c);
        default:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), a[0] = -1, b[0] = -1, 0
        }
};
goog.exportProperty(box2d.b2SeparationFunction.prototype, "FindMinSeparation", box2d.b2SeparationFunction.prototype.FindMinSeparation);
box2d.b2SeparationFunction.prototype.Evaluate = function(a, b, c) {
    var e = box2d.b2TimeOfImpact.s_xfA, d = box2d.b2TimeOfImpact.s_xfB;
    this.m_sweepA.GetTransform(e, c);
    this.m_sweepB.GetTransform(d, c);
    switch (this.m_type) {
        case box2d.b2SeparationFunctionType.e_points:
            return a = this.m_proxyA.GetVertex(a), b = this.m_proxyB.GetVertex(b), e = box2d.b2MulXV(e, a, box2d.b2TimeOfImpact.s_pointA), d = box2d.b2MulXV(d, b, box2d.b2TimeOfImpact.s_pointB), e = box2d.b2DotVV(box2d.b2SubVV(d, e, box2d.b2Vec2.s_t0), this.m_axis);
        case box2d.b2SeparationFunctionType.e_faceA:
            return c =
                    box2d.b2MulRV(e.q, this.m_axis, box2d.b2TimeOfImpact.s_normal), e = box2d.b2MulXV(e, this.m_localPoint, box2d.b2TimeOfImpact.s_pointA), b = this.m_proxyB.GetVertex(b), d = box2d.b2MulXV(d, b, box2d.b2TimeOfImpact.s_pointB), e = box2d.b2DotVV(box2d.b2SubVV(d, e, box2d.b2Vec2.s_t0), c);
        case box2d.b2SeparationFunctionType.e_faceB:
            return c = box2d.b2MulRV(d.q, this.m_axis, box2d.b2TimeOfImpact.s_normal), d = box2d.b2MulXV(d, this.m_localPoint, box2d.b2TimeOfImpact.s_pointB), a = this.m_proxyA.GetVertex(a), e = box2d.b2MulXV(e, a, box2d.b2TimeOfImpact.s_pointA),
                    e = box2d.b2DotVV(box2d.b2SubVV(e, d, box2d.b2Vec2.s_t0), c);
        default:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), 0
        }
};
goog.exportProperty(box2d.b2SeparationFunction.prototype, "Evaluate", box2d.b2SeparationFunction.prototype.Evaluate);
box2d.b2TimeOfImpact = function(a, b) {
    var c = box2d.b2TimeOfImpact.s_timer.Reset();
    ++box2d.b2_toiCalls;
    a.state = box2d.b2TOIOutputState.e_unknown;
    a.t = b.tMax;
    var e = b.proxyA, d = b.proxyB, f = box2d.b2TimeOfImpact.s_sweepA.Copy(b.sweepA), g = box2d.b2TimeOfImpact.s_sweepB.Copy(b.sweepB);
    f.Normalize();
    g.Normalize();
    var h = b.tMax, l = box2d.b2Max(box2d.b2_linearSlop, e.m_radius + d.m_radius - 3 * box2d.b2_linearSlop), k = 0.25 * box2d.b2_linearSlop;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(l > k);
    var m = 0, n = 0, p = box2d.b2TimeOfImpact.s_cache;
    p.count = 0;
    var q = box2d.b2TimeOfImpact.s_distanceInput;
    q.proxyA = b.proxyA;
    q.proxyB = b.proxyB;
    for (q.useRadii = !1; ; ) {
        var r = box2d.b2TimeOfImpact.s_xfA, t = box2d.b2TimeOfImpact.s_xfB;
        f.GetTransform(r, m);
        g.GetTransform(t, m);
        q.transformA.Copy(r);
        q.transformB.Copy(t);
        r = box2d.b2TimeOfImpact.s_distanceOutput;
        box2d.b2Distance(r, p, q);
        if (0 >= r.distance) {
            a.state = box2d.b2TOIOutputState.e_overlapped;
            a.t = 0;
            break
        }
        if (r.distance < l + k) {
            a.state = box2d.b2TOIOutputState.e_touching;
            a.t = m;
            break
        }
        r = box2d.b2TimeOfImpact.s_fcn;
        r.Initialize(p,
                e, f, d, g, m);
        for (var t = !1, s = h, u = 0; ; ) {
            var v = box2d.b2TimeOfImpact.s_indexA, y = box2d.b2TimeOfImpact.s_indexB, D = r.FindMinSeparation(v, y, s);
            if (D > l + k) {
                a.state = box2d.b2TOIOutputState.e_separated;
                a.t = h;
                t = !0;
                break
            }
            if (D > l - k) {
                m = s;
                break
            }
            var x = r.Evaluate(v[0], y[0], m);
            if (x < l - k) {
                a.state = box2d.b2TOIOutputState.e_failed;
                a.t = m;
                t = !0;
                break
            }
            if (x <= l + k) {
                a.state = box2d.b2TOIOutputState.e_touching;
                a.t = m;
                t = !0;
                break
            }
            for (var w = 0, C = m, A = s; ; ) {
                var E = 0, E = w & 1 ? C + (l - x) * (A - C) / (D - x) : 0.5 * (C + A);
                ++w;
                ++box2d.b2_toiRootIters;
                var B = r.Evaluate(v[0],
                        y[0], E);
                if (box2d.b2Abs(B - l) < k) {
                    s = E;
                    break
                }
                B > l ? (C = E, x = B) : (A = E, D = B);
                if (50 == w)
                    break
            }
            box2d.b2_toiMaxRootIters = box2d.b2Max(box2d.b2_toiMaxRootIters, w);
            ++u;
            if (u == box2d.b2_maxPolygonVertices)
                break
        }
        ++n;
        ++box2d.b2_toiIters;
        if (t)
            break;
        if (20 == n) {
            a.state = box2d.b2TOIOutputState.e_failed;
            a.t = m;
            break
        }
    }
    box2d.b2_toiMaxIters = box2d.b2Max(box2d.b2_toiMaxIters, n);
    c = c.GetMilliseconds();
    box2d.b2_toiMaxTime = box2d.b2Max(box2d.b2_toiMaxTime, c);
    box2d.b2_toiTime += c
};
goog.exportSymbol("box2d.b2TimeOfImpact", box2d.b2TimeOfImpact);
box2d.b2TimeOfImpact.s_timer = new box2d.b2Timer;
box2d.b2TimeOfImpact.s_cache = new box2d.b2SimplexCache;
box2d.b2TimeOfImpact.s_distanceInput = new box2d.b2DistanceInput;
box2d.b2TimeOfImpact.s_distanceOutput = new box2d.b2DistanceOutput;
box2d.b2TimeOfImpact.s_xfA = new box2d.b2Transform;
box2d.b2TimeOfImpact.s_xfB = new box2d.b2Transform;
box2d.b2TimeOfImpact.s_indexA = box2d.b2MakeNumberArray(1);
box2d.b2TimeOfImpact.s_indexB = box2d.b2MakeNumberArray(1);
box2d.b2TimeOfImpact.s_fcn = new box2d.b2SeparationFunction;
box2d.b2TimeOfImpact.s_sweepA = new box2d.b2Sweep;
box2d.b2TimeOfImpact.s_sweepB = new box2d.b2Sweep;
box2d.b2TimeOfImpact.s_pointA = new box2d.b2Vec2;
box2d.b2TimeOfImpact.s_pointB = new box2d.b2Vec2;
box2d.b2TimeOfImpact.s_normal = new box2d.b2Vec2;
box2d.b2TimeOfImpact.s_axisA = new box2d.b2Vec2;
box2d.b2TimeOfImpact.s_axisB = new box2d.b2Vec2;
box2d.b2MixFriction = function(a, b) {
    return box2d.b2Sqrt(a * b)
};
goog.exportSymbol("box2d.b2MixFriction", box2d.b2MixFriction);
box2d.b2MixRestitution = function(a, b) {
    return a > b ? a : b
};
goog.exportSymbol("box2d.b2MixRestitution", box2d.b2MixRestitution);
box2d.b2ContactEdge = function() {
};
goog.exportSymbol("box2d.b2ContactEdge", box2d.b2ContactEdge);
box2d.b2ContactEdge.prototype.other = null;
goog.exportProperty(box2d.b2ContactEdge.prototype, "other", box2d.b2ContactEdge.prototype.other);
box2d.b2ContactEdge.prototype.contact = null;
goog.exportProperty(box2d.b2ContactEdge.prototype, "contact", box2d.b2ContactEdge.prototype.contact);
box2d.b2ContactEdge.prototype.prev = null;
goog.exportProperty(box2d.b2ContactEdge.prototype, "prev", box2d.b2ContactEdge.prototype.prev);
box2d.b2ContactEdge.prototype.next = null;
goog.exportProperty(box2d.b2ContactEdge.prototype, "next", box2d.b2ContactEdge.prototype.next);
box2d.b2ContactFlag = {e_none: 0, e_islandFlag: 1, e_touchingFlag: 2, e_enabledFlag: 4, e_filterFlag: 8, e_bulletHitFlag: 16, e_toiFlag: 32};
goog.exportProperty(box2d.b2ContactFlag, "e_none", box2d.b2ContactFlag.e_none);
goog.exportProperty(box2d.b2ContactFlag, "e_islandFlag", box2d.b2ContactFlag.e_islandFlag);
goog.exportProperty(box2d.b2ContactFlag, "e_touchingFlag", box2d.b2ContactFlag.e_touchingFlag);
goog.exportProperty(box2d.b2ContactFlag, "e_enabledFlag", box2d.b2ContactFlag.e_enabledFlag);
goog.exportProperty(box2d.b2ContactFlag, "e_filterFlag", box2d.b2ContactFlag.e_filterFlag);
goog.exportProperty(box2d.b2ContactFlag, "e_bulletHitFlag", box2d.b2ContactFlag.e_bulletHitFlag);
goog.exportProperty(box2d.b2ContactFlag, "e_toiFlag", box2d.b2ContactFlag.e_toiFlag);
box2d.b2Contact = function() {
    this.m_nodeA = new box2d.b2ContactEdge;
    this.m_nodeB = new box2d.b2ContactEdge;
    this.m_manifold = new box2d.b2Manifold;
    this.m_oldManifold = new box2d.b2Manifold
};
goog.exportSymbol("box2d.b2Contact", box2d.b2Contact);
box2d.b2Contact.prototype.m_flags = box2d.b2ContactFlag.e_none;
goog.exportProperty(box2d.b2Contact.prototype, "m_flags", box2d.b2Contact.prototype.m_flags);
box2d.b2Contact.prototype.m_prev = null;
goog.exportProperty(box2d.b2Contact.prototype, "m_prev", box2d.b2Contact.prototype.m_prev);
box2d.b2Contact.prototype.m_next = null;
goog.exportProperty(box2d.b2Contact.prototype, "m_next", box2d.b2Contact.prototype.m_next);
box2d.b2Contact.prototype.m_nodeA = null;
goog.exportProperty(box2d.b2Contact.prototype, "m_nodeA", box2d.b2Contact.prototype.m_nodeA);
box2d.b2Contact.prototype.m_nodeB = null;
goog.exportProperty(box2d.b2Contact.prototype, "m_nodeB", box2d.b2Contact.prototype.m_nodeB);
box2d.b2Contact.prototype.m_fixtureA = null;
goog.exportProperty(box2d.b2Contact.prototype, "m_fixtureA", box2d.b2Contact.prototype.m_fixtureA);
box2d.b2Contact.prototype.m_fixtureB = null;
goog.exportProperty(box2d.b2Contact.prototype, "m_fixtureB", box2d.b2Contact.prototype.m_fixtureB);
box2d.b2Contact.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2Contact.prototype, "m_indexA", box2d.b2Contact.prototype.m_indexA);
box2d.b2Contact.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2Contact.prototype, "m_indexB", box2d.b2Contact.prototype.m_indexB);
box2d.b2Contact.prototype.m_manifold = null;
goog.exportProperty(box2d.b2Contact.prototype, "m_manifold", box2d.b2Contact.prototype.m_manifold);
box2d.b2Contact.prototype.m_toiCount = 0;
goog.exportProperty(box2d.b2Contact.prototype, "m_toiCount", box2d.b2Contact.prototype.m_toiCount);
box2d.b2Contact.prototype.m_toi = 0;
goog.exportProperty(box2d.b2Contact.prototype, "m_toi", box2d.b2Contact.prototype.m_toi);
box2d.b2Contact.prototype.m_friction = 0;
goog.exportProperty(box2d.b2Contact.prototype, "m_friction", box2d.b2Contact.prototype.m_friction);
box2d.b2Contact.prototype.m_restitution = 0;
goog.exportProperty(box2d.b2Contact.prototype, "m_restitution", box2d.b2Contact.prototype.m_restitution);
box2d.b2Contact.prototype.m_tangentSpeed = 0;
goog.exportProperty(box2d.b2Contact.prototype, "m_tangentSpeed", box2d.b2Contact.prototype.m_tangentSpeed);
box2d.b2Contact.prototype.m_oldManifold = null;
goog.exportProperty(box2d.b2Contact.prototype, "m_oldManifold", box2d.b2Contact.prototype.m_oldManifold);
box2d.b2Contact.prototype.GetManifold = function() {
    return this.m_manifold
};
goog.exportProperty(box2d.b2Contact.prototype, "GetManifold", box2d.b2Contact.prototype.GetManifold);
box2d.b2Contact.prototype.GetWorldManifold = function(a) {
    var b = this.m_fixtureA.GetBody(), c = this.m_fixtureB.GetBody(), e = this.m_fixtureA.GetShape(), d = this.m_fixtureB.GetShape();
    a.Initialize(this.m_manifold, b.GetTransform(), e.m_radius, c.GetTransform(), d.m_radius)
};
goog.exportProperty(box2d.b2Contact.prototype, "GetWorldManifold", box2d.b2Contact.prototype.GetWorldManifold);
box2d.b2Contact.prototype.IsTouching = function() {
    return(this.m_flags & box2d.b2ContactFlag.e_touchingFlag) == box2d.b2ContactFlag.e_touchingFlag
};
goog.exportProperty(box2d.b2Contact.prototype, "IsTouching", box2d.b2Contact.prototype.IsTouching);
box2d.b2Contact.prototype.SetEnabled = function(a) {
    this.m_flags = a ? this.m_flags | box2d.b2ContactFlag.e_enabledFlag : this.m_flags & ~box2d.b2ContactFlag.e_enabledFlag
};
goog.exportProperty(box2d.b2Contact.prototype, "SetEnabled", box2d.b2Contact.prototype.SetEnabled);
box2d.b2Contact.prototype.IsEnabled = function() {
    return(this.m_flags & box2d.b2ContactFlag.e_enabledFlag) == box2d.b2ContactFlag.e_enabledFlag
};
goog.exportProperty(box2d.b2Contact.prototype, "IsEnabled", box2d.b2Contact.prototype.IsEnabled);
box2d.b2Contact.prototype.GetNext = function() {
    return this.m_next
};
goog.exportProperty(box2d.b2Contact.prototype, "GetNext", box2d.b2Contact.prototype.GetNext);
box2d.b2Contact.prototype.GetFixtureA = function() {
    return this.m_fixtureA
};
goog.exportProperty(box2d.b2Contact.prototype, "GetFixtureA", box2d.b2Contact.prototype.GetFixtureA);
box2d.b2Contact.prototype.GetChildIndexA = function() {
    return this.m_indexA
};
goog.exportProperty(box2d.b2Contact.prototype, "GetChildIndexA", box2d.b2Contact.prototype.GetChildIndexA);
box2d.b2Contact.prototype.GetFixtureB = function() {
    return this.m_fixtureB
};
goog.exportProperty(box2d.b2Contact.prototype, "GetFixtureB", box2d.b2Contact.prototype.GetFixtureB);
box2d.b2Contact.prototype.GetChildIndexB = function() {
    return this.m_indexB
};
goog.exportProperty(box2d.b2Contact.prototype, "GetChildIndexB", box2d.b2Contact.prototype.GetChildIndexB);
box2d.b2Contact.prototype.Evaluate = function(a, b, c) {
};
goog.exportProperty(box2d.b2Contact.prototype, "Evaluate", box2d.b2Contact.prototype.Evaluate);
box2d.b2Contact.prototype.FlagForFiltering = function() {
    this.m_flags |= box2d.b2ContactFlag.e_filterFlag
};
goog.exportProperty(box2d.b2Contact.prototype, "FlagForFiltering", box2d.b2Contact.prototype.FlagForFiltering);
box2d.b2Contact.prototype.SetFriction = function(a) {
    this.m_friction = a
};
goog.exportProperty(box2d.b2Contact.prototype, "SetFriction", box2d.b2Contact.prototype.SetFriction);
box2d.b2Contact.prototype.GetFriction = function() {
    return this.m_friction
};
goog.exportProperty(box2d.b2Contact.prototype, "GetFriction", box2d.b2Contact.prototype.GetFriction);
box2d.b2Contact.prototype.ResetFriction = function() {
    this.m_friction = box2d.b2MixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction)
};
goog.exportProperty(box2d.b2Contact.prototype, "ResetFriction", box2d.b2Contact.prototype.ResetFriction);
box2d.b2Contact.prototype.SetRestitution = function(a) {
    this.m_restitution = a
};
goog.exportProperty(box2d.b2Contact.prototype, "SetRestitution", box2d.b2Contact.prototype.SetRestitution);
box2d.b2Contact.prototype.GetRestitution = function() {
    return this.m_restitution
};
goog.exportProperty(box2d.b2Contact.prototype, "GetRestitution", box2d.b2Contact.prototype.GetRestitution);
box2d.b2Contact.prototype.ResetRestitution = function() {
    this.m_restitution = box2d.b2MixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution)
};
goog.exportProperty(box2d.b2Contact.prototype, "ResetRestitution", box2d.b2Contact.prototype.ResetRestitution);
box2d.b2Contact.prototype.SetTangentSpeed = function(a) {
    this.m_tangentSpeed = a
};
goog.exportProperty(box2d.b2Contact.prototype, "SetTangentSpeed", box2d.b2Contact.prototype.SetTangentSpeed);
box2d.b2Contact.prototype.GetTangentSpeed = function() {
    return this.m_tangentSpeed
};
goog.exportProperty(box2d.b2Contact.prototype, "GetTangentSpeed", box2d.b2Contact.prototype.GetTangentSpeed);
box2d.b2Contact.prototype.Reset = function(a, b, c, e) {
    this.m_flags = box2d.b2ContactFlag.e_enabledFlag;
    this.m_fixtureA = a;
    this.m_fixtureB = c;
    this.m_indexA = b;
    this.m_indexB = e;
    this.m_manifold.pointCount = 0;
    this.m_next = this.m_prev = null;
    this.m_nodeA.contact = null;
    this.m_nodeA.prev = null;
    this.m_nodeA.next = null;
    this.m_nodeA.other = null;
    this.m_nodeB.contact = null;
    this.m_nodeB.prev = null;
    this.m_nodeB.next = null;
    this.m_nodeB.other = null;
    this.m_toiCount = 0;
    this.m_friction = box2d.b2MixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);
    this.m_restitution = box2d.b2MixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution)
};
goog.exportProperty(box2d.b2Contact.prototype, "Reset", box2d.b2Contact.prototype.Reset);
box2d.b2Contact.prototype.Update = function(a) {
    var b = this.m_oldManifold;
    this.m_oldManifold = this.m_manifold;
    this.m_manifold = b;
    this.m_flags |= box2d.b2ContactFlag.e_enabledFlag;
    var c = !1, b = (this.m_flags & box2d.b2ContactFlag.e_touchingFlag) == box2d.b2ContactFlag.e_touchingFlag, e = this.m_fixtureA.IsSensor(), d = this.m_fixtureB.IsSensor(), e = e || d, d = this.m_fixtureA.GetBody(), f = this.m_fixtureB.GetBody(), c = d.GetTransform(), g = f.GetTransform();
    if (e)
        d = this.m_fixtureA.GetShape(), f = this.m_fixtureB.GetShape(), c = box2d.b2TestOverlapShape(d,
                this.m_indexA, f, this.m_indexB, c, g), this.m_manifold.pointCount = 0;
    else {
        this.Evaluate(this.m_manifold, c, g);
        c = 0 < this.m_manifold.pointCount;
        for (g = 0; g < this.m_manifold.pointCount; ++g) {
            var h = this.m_manifold.points[g];
            h.normalImpulse = 0;
            h.tangentImpulse = 0;
            for (var l = h.id, k = 0; k < this.m_oldManifold.pointCount; ++k) {
                var m = this.m_oldManifold.points[k];
                if (m.id.key == l.key) {
                    h.normalImpulse = m.normalImpulse;
                    h.tangentImpulse = m.tangentImpulse;
                    break
                }
            }
        }
        c != b && (d.SetAwake(!0), f.SetAwake(!0))
    }
    this.m_flags = c ? this.m_flags | box2d.b2ContactFlag.e_touchingFlag :
            this.m_flags & ~box2d.b2ContactFlag.e_touchingFlag;
    !1 == b && (!0 == c && a) && a.BeginContact(this);
    !0 == b && (!1 == c && a) && a.EndContact(this);
    !1 == e && (c && a) && a.PreSolve(this, this.m_oldManifold)
};
goog.exportProperty(box2d.b2Contact.prototype, "Update", box2d.b2Contact.prototype.Update);
box2d.b2Contact.prototype.ComputeTOI = function(a, b) {
    var c = box2d.b2Contact.prototype.ComputeTOI.s_input;
    c.proxyA.SetShape(this.m_fixtureA.GetShape(), this.m_indexA);
    c.proxyB.SetShape(this.m_fixtureB.GetShape(), this.m_indexB);
    c.sweepA.Copy(a);
    c.sweepB.Copy(b);
    c.tMax = box2d.b2_linearSlop;
    var e = box2d.b2Contact.prototype.ComputeTOI.s_output;
    box2d.b2TimeOfImpact(e, c);
    return e.t
};
goog.exportProperty(box2d.b2Contact.prototype, "ComputeTOI", box2d.b2Contact.prototype.ComputeTOI);
box2d.b2Contact.prototype.ComputeTOI.s_input = new box2d.b2TOIInput;
box2d.b2Contact.prototype.ComputeTOI.s_output = new box2d.b2TOIOutput;
box2d.b2PolygonAndCircleContact = function() {
    box2d.b2Contact.call(this)
};
goog.inherits(box2d.b2PolygonAndCircleContact, box2d.b2Contact);
goog.exportSymbol("box2d.b2PolygonAndCircleContact", box2d.b2PolygonAndCircleContact);
box2d.b2PolygonAndCircleContact.Create = function(a) {
    return new box2d.b2PolygonAndCircleContact
};
goog.exportProperty(box2d.b2PolygonAndCircleContact, "Create", box2d.b2PolygonAndCircleContact.Create);
box2d.b2PolygonAndCircleContact.Destroy = function(a, b) {
};
goog.exportProperty(box2d.b2PolygonAndCircleContact, "Destroy", box2d.b2PolygonAndCircleContact.Destroy);
box2d.b2PolygonAndCircleContact.prototype.Reset = function(a, b, c, e) {
    box2d.b2PolygonAndCircleContact.superClass_.Reset.call(this, a, b, c, e);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.GetType() == box2d.b2ShapeType.e_polygonShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(c.GetType() == box2d.b2ShapeType.e_circleShape)
};
goog.exportProperty(box2d.b2PolygonAndCircleContact.prototype, "Reset", box2d.b2PolygonAndCircleContact.prototype.Reset);
box2d.b2PolygonAndCircleContact.prototype.Evaluate = function(a, b, c) {
    var e = this.m_fixtureA.GetShape(), d = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e instanceof box2d.b2PolygonShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(d instanceof box2d.b2CircleShape);
    box2d.b2CollidePolygonAndCircle(a, e instanceof box2d.b2PolygonShape ? e : null, b, d instanceof box2d.b2CircleShape ? d : null, c)
};
goog.exportProperty(box2d.b2PolygonAndCircleContact.prototype, "Evaluate", box2d.b2PolygonAndCircleContact.prototype.Evaluate);
box2d.b2EdgeAndPolygonContact = function() {
    box2d.b2Contact.call(this)
};
goog.inherits(box2d.b2EdgeAndPolygonContact, box2d.b2Contact);
goog.exportSymbol("box2d.b2EdgeAndPolygonContact", box2d.b2EdgeAndPolygonContact);
box2d.b2EdgeAndPolygonContact.Create = function(a) {
    return new box2d.b2EdgeAndPolygonContact
};
goog.exportProperty(box2d.b2EdgeAndPolygonContact, "Create", box2d.b2EdgeAndPolygonContact.Create);
box2d.b2EdgeAndPolygonContact.Destroy = function(a, b) {
};
goog.exportProperty(box2d.b2EdgeAndPolygonContact, "Destroy", box2d.b2EdgeAndPolygonContact.Destroy);
box2d.b2EdgeAndPolygonContact.prototype.Reset = function(a, b, c, e) {
    box2d.b2EdgeAndPolygonContact.superClass_.Reset.call(this, a, b, c, e);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.GetType() == box2d.b2ShapeType.e_edgeShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(c.GetType() == box2d.b2ShapeType.e_polygonShape)
};
goog.exportProperty(box2d.b2EdgeAndPolygonContact.prototype, "Reset", box2d.b2EdgeAndPolygonContact.prototype.Reset);
box2d.b2EdgeAndPolygonContact.prototype.Evaluate = function(a, b, c) {
    var e = this.m_fixtureA.GetShape(), d = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e instanceof box2d.b2EdgeShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(d instanceof box2d.b2PolygonShape);
    box2d.b2CollideEdgeAndPolygon(a, e instanceof box2d.b2EdgeShape ? e : null, b, d instanceof box2d.b2PolygonShape ? d : null, c)
};
goog.exportProperty(box2d.b2EdgeAndPolygonContact.prototype, "Evaluate", box2d.b2EdgeAndPolygonContact.prototype.Evaluate);
box2d.b2MassData = function() {
    this.center = new box2d.b2Vec2(0, 0)
};
goog.exportSymbol("box2d.b2MassData", box2d.b2MassData);
box2d.b2MassData.prototype.mass = 0;
goog.exportProperty(box2d.b2MassData.prototype, "mass", box2d.b2MassData.prototype.mass);
box2d.b2MassData.prototype.center = null;
goog.exportProperty(box2d.b2MassData.prototype, "center", box2d.b2MassData.prototype.center);
box2d.b2MassData.prototype.I = 0;
goog.exportProperty(box2d.b2MassData.prototype, "I", box2d.b2MassData.prototype.I);
box2d.b2ShapeType = {e_unknown: -1, e_circleShape: 0, e_edgeShape: 1, e_polygonShape: 2, e_chainShape: 3, e_shapeTypeCount: 4};
goog.exportSymbol("box2d.b2ShapeType", box2d.b2ShapeType);
goog.exportProperty(box2d.b2ShapeType, "e_unknown", box2d.b2ShapeType.e_unknown);
goog.exportProperty(box2d.b2ShapeType, "e_circleShape", box2d.b2ShapeType.e_circleShape);
goog.exportProperty(box2d.b2ShapeType, "e_edgeShape", box2d.b2ShapeType.e_edgeShape);
goog.exportProperty(box2d.b2ShapeType, "e_polygonShape", box2d.b2ShapeType.e_polygonShape);
goog.exportProperty(box2d.b2ShapeType, "e_chainShape", box2d.b2ShapeType.e_chainShape);
goog.exportProperty(box2d.b2ShapeType, "e_shapeTypeCount", box2d.b2ShapeType.e_shapeTypeCount);
box2d.b2Shape = function(a, b) {
    this.m_type = a;
    this.m_radius = b
};
goog.exportSymbol("box2d.b2Shape", box2d.b2Shape);
box2d.b2Shape.prototype.m_type = box2d.b2ShapeType.e_unknown;
goog.exportProperty(box2d.b2Shape.prototype, "m_type", box2d.b2Shape.prototype.m_type);
box2d.b2Shape.prototype.m_radius = 0;
goog.exportProperty(box2d.b2Shape.prototype, "m_radius", box2d.b2Shape.prototype.m_radius);
box2d.b2Shape.prototype.Clone = function() {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1);
    return null
};
goog.exportProperty(box2d.b2Shape.prototype, "Clone", box2d.b2Shape.prototype.Clone);
box2d.b2Shape.prototype.Copy = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_type == a.m_type);
    this.m_radius = a.m_radius;
    return this
};
goog.exportProperty(box2d.b2Shape.prototype, "Copy", box2d.b2Shape.prototype.Copy);
box2d.b2Shape.prototype.GetType = function() {
    return this.m_type
};
goog.exportProperty(box2d.b2Shape.prototype, "GetType", box2d.b2Shape.prototype.GetType);
box2d.b2Shape.prototype.GetChildCount = function() {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual");
    return 0
};
goog.exportProperty(box2d.b2Shape.prototype, "GetChildCount", box2d.b2Shape.prototype.GetChildCount);
box2d.b2Shape.prototype.TestPoint = function(a, b) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual");
    return!1
};
goog.exportProperty(box2d.b2Shape.prototype, "TestPoint", box2d.b2Shape.prototype.TestPoint);
box2d.b2Shape.prototype.RayCast = function(a, b, c, e) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual");
    return!1
};
goog.exportProperty(box2d.b2Shape.prototype, "RayCast", box2d.b2Shape.prototype.RayCast);
box2d.b2Shape.prototype.ComputeAABB = function(a, b, c) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual")
};
goog.exportProperty(box2d.b2Shape.prototype, "ComputeAABB", box2d.b2Shape.prototype.ComputeAABB);
box2d.b2Shape.prototype.ComputeMass = function(a, b) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual")
};
goog.exportProperty(box2d.b2Shape.prototype, "ComputeMass", box2d.b2Shape.prototype.ComputeMass);
box2d.b2Shape.prototype.SetupDistanceProxy = function(a, b) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual")
};
box2d.b2Shape.prototype.ComputeSubmergedArea = function(a, b, c, e) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual");
    return 0
};
goog.exportProperty(box2d.b2Shape.prototype, "ComputeSubmergedArea", box2d.b2Shape.prototype.ComputeSubmergedArea);
box2d.b2Shape.prototype.Dump = function() {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual")
};
goog.exportProperty(box2d.b2Shape.prototype, "Dump", box2d.b2Shape.prototype.Dump);
box2d.b2PolygonShape = function() {
    box2d.b2Shape.call(this, box2d.b2ShapeType.e_polygonShape, box2d.b2_polygonRadius);
    this.m_centroid = new box2d.b2Vec2(0, 0);
    this.m_vertices = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices);
    this.m_normals = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices)
};
goog.inherits(box2d.b2PolygonShape, box2d.b2Shape);
goog.exportSymbol("box2d.b2PolygonShape", box2d.b2PolygonShape);
box2d.b2PolygonShape.prototype.m_centroid = null;
goog.exportProperty(box2d.b2PolygonShape.prototype, "m_centroid", box2d.b2PolygonShape.prototype.m_centroid);
box2d.b2PolygonShape.prototype.m_vertices = null;
goog.exportProperty(box2d.b2PolygonShape.prototype, "m_vertices", box2d.b2PolygonShape.prototype.m_vertices);
box2d.b2PolygonShape.prototype.m_normals = null;
goog.exportProperty(box2d.b2PolygonShape.prototype, "m_normals", box2d.b2PolygonShape.prototype.m_normals);
box2d.b2PolygonShape.prototype.m_count = 0;
goog.exportProperty(box2d.b2PolygonShape.prototype, "m_count", box2d.b2PolygonShape.prototype.m_count);
box2d.b2PolygonShape.prototype.Clone = function() {
    return(new box2d.b2PolygonShape).Copy(this)
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "Clone", box2d.b2PolygonShape.prototype.Clone);
box2d.b2PolygonShape.prototype.Copy = function(a) {
    box2d.b2PolygonShape.superClass_.Copy.call(this, a);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a instanceof box2d.b2PolygonShape);
    this.m_centroid.Copy(a.m_centroid);
    this.m_count = a.m_count;
    for (var b = 0, c = this.m_count; b < c; ++b)
        this.m_vertices[b].Copy(a.m_vertices[b]), this.m_normals[b].Copy(a.m_normals[b]);
    return this
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "Copy", box2d.b2PolygonShape.prototype.Copy);
box2d.b2PolygonShape.prototype.SetAsBox = function(a, b) {
    this.m_count = 4;
    this.m_vertices[0].SetXY(-a, -b);
    this.m_vertices[1].SetXY(a, -b);
    this.m_vertices[2].SetXY(a, b);
    this.m_vertices[3].SetXY(-a, b);
    this.m_normals[0].SetXY(0, -1);
    this.m_normals[1].SetXY(1, 0);
    this.m_normals[2].SetXY(0, 1);
    this.m_normals[3].SetXY(-1, 0);
    this.m_centroid.SetZero();
    return this
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "SetAsBox", box2d.b2PolygonShape.prototype.SetAsBox);
box2d.b2PolygonShape.prototype.SetAsOrientedBox = function(a, b, c, e) {
    this.m_count = 4;
    this.m_vertices[0].SetXY(-a, -b);
    this.m_vertices[1].SetXY(a, -b);
    this.m_vertices[2].SetXY(a, b);
    this.m_vertices[3].SetXY(-a, b);
    this.m_normals[0].SetXY(0, -1);
    this.m_normals[1].SetXY(1, 0);
    this.m_normals[2].SetXY(0, 1);
    this.m_normals[3].SetXY(-1, 0);
    this.m_centroid.Copy(c);
    a = new box2d.b2Transform;
    a.SetPosition(c);
    a.SetRotationAngleRadians(e);
    c = 0;
    for (e = this.m_count; c < e; ++c)
        box2d.b2MulXV(a, this.m_vertices[c], this.m_vertices[c]),
                box2d.b2MulRV(a.q, this.m_normals[c], this.m_normals[c]);
    return this
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "SetAsOrientedBox", box2d.b2PolygonShape.prototype.SetAsOrientedBox);
box2d.b2PolygonShape.prototype.Set = function(a, b) {
    void 0 === b && (b = a.length);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(3 <= b && b <= box2d.b2_maxPolygonVertices);
    if (3 > b)
        return this.SetAsBox(1, 1);
    for (var c = box2d.b2Min(b, box2d.b2_maxPolygonVertices), e = box2d.b2PolygonShape.prototype.Set.s_ps, d = 0; d < c; ++d)
        e[d].Copy(a[d]);
    for (var f = 0, g = e[0].x, d = 1; d < b; ++d) {
        var h = e[d].x;
        if (h > g || h == g && e[d].y < e[f].y)
            f = d, g = h
    }
    h = box2d.b2PolygonShape.prototype.Set.s_hull;
    g = 0;
    for (d = f; ; ) {
        h[g] = d;
        for (var l = 0, k = 1; k < c; ++k)
            if (l == d)
                l = k;
            else {
                var m =
                        box2d.b2SubVV(e[l], e[h[g]], box2d.b2PolygonShape.prototype.Set.s_r), n = box2d.b2SubVV(e[k], e[h[g]], box2d.b2PolygonShape.prototype.Set.s_v), p = box2d.b2CrossVV(m, n);
                0 > p && (l = k);
                0 == p && n.GetLengthSquared() > m.GetLengthSquared() && (l = k)
            }
        ++g;
        d = l;
        if (l == f)
            break
    }
    this.m_count = g;
    for (d = 0; d < g; ++d)
        this.m_vertices[d].Copy(e[h[d]]);
    d = 0;
    for (c = g; d < c; ++d)
        e = box2d.b2SubVV(this.m_vertices[(d + 1) % c], this.m_vertices[d], box2d.b2Vec2.s_t0), box2d.ENABLE_ASSERTS && box2d.b2Assert(e.GetLengthSquared() > box2d.b2_epsilon_sq), box2d.b2CrossVOne(e,
                this.m_normals[d]).SelfNormalize();
    box2d.b2PolygonShape.ComputeCentroid(this.m_vertices, g, this.m_centroid);
    return this
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "Set", box2d.b2PolygonShape.prototype.Set);
box2d.b2PolygonShape.prototype.Set.s_ps = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices);
box2d.b2PolygonShape.prototype.Set.s_hull = box2d.b2MakeNumberArray(box2d.b2_maxPolygonVertices);
box2d.b2PolygonShape.prototype.Set.s_r = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.Set.s_v = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.SetAsVector = function(a, b) {
    this.Set(a, b);
    return this
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "SetAsVector", box2d.b2PolygonShape.prototype.SetAsVector);
box2d.b2PolygonShape.prototype.SetAsArray = function(a, b) {
    this.Set(a, b);
    return this
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "SetAsArray", box2d.b2PolygonShape.prototype.SetAsArray);
box2d.b2PolygonShape.prototype.GetChildCount = function() {
    return 1
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "GetChildCount", box2d.b2PolygonShape.prototype.GetChildCount);
box2d.b2PolygonShape.prototype.TestPoint = function(a, b) {
    for (var c = box2d.b2MulTXV(a, b, box2d.b2PolygonShape.prototype.TestPoint.s_pLocal), e = 0, d = this.m_count; e < d; ++e)
        if (0 < box2d.b2DotVV(this.m_normals[e], box2d.b2SubVV(c, this.m_vertices[e], box2d.b2Vec2.s_t0)))
            return!1;
    return!0
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "TestPoint", box2d.b2PolygonShape.prototype.TestPoint);
box2d.b2PolygonShape.prototype.TestPoint.s_pLocal = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.RayCast = function(a, b, c, e) {
    e = box2d.b2MulTXV(c, b.p1, box2d.b2PolygonShape.prototype.RayCast.s_p1);
    for (var d = box2d.b2MulTXV(c, b.p2, box2d.b2PolygonShape.prototype.RayCast.s_p2), d = box2d.b2SubVV(d, e, box2d.b2PolygonShape.prototype.RayCast.s_d), f = 0, g = b.maxFraction, h = -1, l = 0, k = this.m_count; l < k; ++l) {
        var m = box2d.b2DotVV(this.m_normals[l], box2d.b2SubVV(this.m_vertices[l], e, box2d.b2Vec2.s_t0)), n = box2d.b2DotVV(this.m_normals[l], d);
        if (0 == n) {
            if (0 > m)
                return!1
        } else
            0 > n && m < f * n ? (f = m / n, h = l) :
                    0 < n && m < g * n && (g = m / n);
        if (g < f)
            return!1
    }
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= f && f <= b.maxFraction);
    return 0 <= h ? (a.fraction = f, box2d.b2MulRV(c.q, this.m_normals[h], a.normal), !0) : !1
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "RayCast", box2d.b2PolygonShape.prototype.RayCast);
box2d.b2PolygonShape.prototype.RayCast.s_p1 = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.RayCast.s_p2 = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.RayCast.s_d = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.ComputeAABB = function(a, b, c) {
    c = box2d.b2MulXV(b, this.m_vertices[0], a.lowerBound);
    a = a.upperBound.Copy(c);
    for (var e = 0, d = this.m_count; e < d; ++e) {
        var f = box2d.b2MulXV(b, this.m_vertices[e], box2d.b2PolygonShape.prototype.ComputeAABB.s_v);
        box2d.b2MinV(f, c, c);
        box2d.b2MaxV(f, a, a)
    }
    b = this.m_radius;
    c.SelfSubXY(b, b);
    a.SelfAddXY(b, b)
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "ComputeAABB", box2d.b2PolygonShape.prototype.ComputeAABB);
box2d.b2PolygonShape.prototype.ComputeAABB.s_v = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.ComputeMass = function(a, b) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(3 <= this.m_count);
    for (var c = box2d.b2PolygonShape.prototype.ComputeMass.s_center.SetZero(), e = 0, d = 0, f = box2d.b2PolygonShape.prototype.ComputeMass.s_s.SetZero(), g = 0, h = this.m_count; g < h; ++g)
        f.SelfAdd(this.m_vertices[g]);
    f.SelfMul(1 / this.m_count);
    for (var l = 1 / 3, g = 0, h = this.m_count; g < h; ++g) {
        var k = box2d.b2SubVV(this.m_vertices[g], f, box2d.b2PolygonShape.prototype.ComputeMass.s_e1), m = box2d.b2SubVV(this.m_vertices[(g + 1) %
        h], f, box2d.b2PolygonShape.prototype.ComputeMass.s_e2), n = box2d.b2CrossVV(k, m), p = 0.5 * n, e = e + p;
        c.SelfAdd(box2d.b2MulSV(p * l, box2d.b2AddVV(k, m, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t1));
        var p = k.x, k = k.y, q = m.x, m = m.y, d = d + 0.25 * l * n * (p * p + q * p + q * q + (k * k + m * k + m * m))
    }
    a.mass = b * e;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e > box2d.b2_epsilon);
    c.SelfMul(1 / e);
    box2d.b2AddVV(c, f, a.center);
    a.I = b * d;
    a.I += a.mass * (box2d.b2DotVV(a.center, a.center) - box2d.b2DotVV(c, c))
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "ComputeMass", box2d.b2PolygonShape.prototype.ComputeMass);
box2d.b2PolygonShape.prototype.ComputeMass.s_center = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.ComputeMass.s_s = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.ComputeMass.s_e1 = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.ComputeMass.s_e2 = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.Validate = function() {
    for (var a = 0; a < this.m_count; ++a)
        for (var b = a, c = (a + 1) % this.m_count, e = this.m_vertices[b], d = box2d.b2SubVV(this.m_vertices[c], e, box2d.b2PolygonShape.prototype.Validate.s_e), f = 0; f < this.m_count; ++f)
            if (f != b && f != c) {
                var g = box2d.b2SubVV(this.m_vertices[f], e, box2d.b2PolygonShape.prototype.Validate.s_v);
                if (0 > box2d.b2CrossVV(d, g))
                    return!1
            }
    return!0
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "Validate", box2d.b2PolygonShape.prototype.Validate);
box2d.b2PolygonShape.prototype.Validate.s_e = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.Validate.s_v = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.SetupDistanceProxy = function(a, b) {
    a.m_vertices = this.m_vertices;
    a.m_count = this.m_count;
    a.m_radius = this.m_radius
};
box2d.b2PolygonShape.prototype.ComputeSubmergedArea = function(a, b, c, e) {
    var d = box2d.b2MulTRV(c.q, a, box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_normalL), f = b - box2d.b2DotVV(a, c.p), g = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_depths, h = 0, l = -1;
    b = -1;
    var k = !1;
    a = 0;
    for (var m = this.m_count; a < m; ++a) {
        g[a] = box2d.b2DotVV(d, this.m_vertices[a]) - f;
        var n = g[a] < -box2d.b2_epsilon;
        0 < a && (n ? k || (l = a - 1, h++) : k && (b = a - 1, h++));
        k = n
    }
    switch (h) {
        case 0:
            return k ? (a = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_md,
                    this.ComputeMass(a, 1), box2d.b2MulXV(c, a.center, e), a.mass) : 0;
        case 1:
            -1 == l ? l = this.m_count - 1 : b = this.m_count - 1
    }
    a = (l + 1) % this.m_count;
    d = (b + 1) % this.m_count;
    f = (0 - g[l]) / (g[a] - g[l]);
    g = (0 - g[b]) / (g[d] - g[b]);
    l = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_intoVec.SetXY(this.m_vertices[l].x * (1 - f) + this.m_vertices[a].x * f, this.m_vertices[l].y * (1 - f) + this.m_vertices[a].y * f);
    b = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_outoVec.SetXY(this.m_vertices[b].x * (1 - g) + this.m_vertices[d].x * g, this.m_vertices[b].y *
            (1 - g) + this.m_vertices[d].y * g);
    g = 0;
    f = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_center.SetZero();
    h = this.m_vertices[a];
    for (k = null; a != d; )
        a = (a + 1) % this.m_count, k = a == d ? b : this.m_vertices[a], m = 0.5 * ((h.x - l.x) * (k.y - l.y) - (h.y - l.y) * (k.x - l.x)), g += m, f.x += m * (l.x + h.x + k.x) / 3, f.y += m * (l.y + h.y + k.y) / 3, h = k;
    f.SelfMul(1 / g);
    box2d.b2MulXV(c, f, e);
    return g
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "ComputeSubmergedArea", box2d.b2PolygonShape.prototype.ComputeSubmergedArea);
box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_normalL = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_depths = box2d.b2MakeNumberArray(box2d.b2_maxPolygonVertices);
box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_md = new box2d.b2MassData;
box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_intoVec = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_outoVec = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_center = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.Dump = function() {
    box2d.b2Log("    /*box2d.b2PolygonShape*/ var shape = new box2d.b2PolygonShape();\n");
    box2d.b2Log("    /*box2d.b2Vec2[]*/ var vs = box2d.b2Vec2.MakeArray(%d);\n", box2d.b2_maxPolygonVertices);
    for (var a = 0; a < this.m_count; ++a)
        box2d.b2Log("    vs[%d].SetXY(%.15f, %.15f);\n", a, this.m_vertices[a].x, this.m_vertices[a].y);
    box2d.b2Log("    shape.Set(vs, %d);\n", this.m_count)
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "Dump", box2d.b2PolygonShape.prototype.Dump);
box2d.b2PolygonShape.ComputeCentroid = function(a, b, c) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(3 <= b);
    c.SetZero();
    for (var e = 0, d = box2d.b2PolygonShape.ComputeCentroid.s_pRef.SetZero(), f = 1 / 3, g = 0; g < b; ++g) {
        var h = d, l = a[g], k = a[(g + 1) % b], m = box2d.b2SubVV(l, h, box2d.b2PolygonShape.ComputeCentroid.s_e1), n = box2d.b2SubVV(k, h, box2d.b2PolygonShape.ComputeCentroid.s_e2), m = 0.5 * box2d.b2CrossVV(m, n), e = e + m;
        c.x += m * f * (h.x + l.x + k.x);
        c.y += m * f * (h.y + l.y + k.y)
    }
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e > box2d.b2_epsilon);
    c.SelfMul(1 / e);
    return c
};
goog.exportProperty(box2d.b2PolygonShape, "ComputeCentroid", box2d.b2PolygonShape.ComputeCentroid);
box2d.b2PolygonShape.ComputeCentroid.s_pRef = new box2d.b2Vec2;
box2d.b2PolygonShape.ComputeCentroid.s_e1 = new box2d.b2Vec2;
box2d.b2PolygonShape.ComputeCentroid.s_e2 = new box2d.b2Vec2;
box2d.b2CollideEdge = {};
box2d.b2CollideEdgeAndCircle = function(a, b, c, e, d) {
    a.pointCount = 0;
    c = box2d.b2MulTXV(c, box2d.b2MulXV(d, e.m_p, box2d.b2Vec2.s_t0), box2d.b2CollideEdgeAndCircle.s_Q);
    var f = b.m_vertex1, g = b.m_vertex2, h = box2d.b2SubVV(g, f, box2d.b2CollideEdgeAndCircle.s_e), l = box2d.b2DotVV(h, box2d.b2SubVV(g, c, box2d.b2Vec2.s_t0)), k = box2d.b2DotVV(h, box2d.b2SubVV(c, f, box2d.b2Vec2.s_t0)), m = b.m_radius + e.m_radius;
    d = box2d.b2CollideEdgeAndCircle.s_id;
    d.cf.indexB = 0;
    d.cf.typeB = box2d.b2ContactFeatureType.e_vertex;
    if (0 >= k) {
        var n = f, l = box2d.b2SubVV(c,
                n, box2d.b2CollideEdgeAndCircle.s_d), l = box2d.b2DotVV(l, l);
        if (!(l > m * m)) {
            if (b.m_hasVertex0 && (b = box2d.b2SubVV(f, b.m_vertex0, box2d.b2CollideEdgeAndCircle.s_e1), 0 < box2d.b2DotVV(b, box2d.b2SubVV(f, c, box2d.b2Vec2.s_t0))))
                return;
            d.cf.indexA = 0;
            d.cf.typeA = box2d.b2ContactFeatureType.e_vertex;
            a.pointCount = 1;
            a.type = box2d.b2ManifoldType.e_circles;
            a.localNormal.SetZero();
            a.localPoint.Copy(n);
            a.points[0].id.Copy(d);
            a.points[0].localPoint.Copy(e.m_p)
        }
    } else if (0 >= l) {
        if (n = g, l = box2d.b2SubVV(c, n, box2d.b2CollideEdgeAndCircle.s_d),
                l = box2d.b2DotVV(l, l), !(l > m * m)) {
            if (b.m_hasVertex3 && (f = box2d.b2SubVV(b.m_vertex3, g, box2d.b2CollideEdgeAndCircle.s_e2), 0 < box2d.b2DotVV(f, box2d.b2SubVV(c, g, box2d.b2Vec2.s_t0))))
                return;
            d.cf.indexA = 1;
            d.cf.typeA = box2d.b2ContactFeatureType.e_vertex;
            a.pointCount = 1;
            a.type = box2d.b2ManifoldType.e_circles;
            a.localNormal.SetZero();
            a.localPoint.Copy(n);
            a.points[0].id.Copy(d);
            a.points[0].localPoint.Copy(e.m_p)
        }
    } else
        b = box2d.b2DotVV(h, h), box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < b), n = box2d.b2CollideEdgeAndCircle.s_P,
                n.x = 1 / b * (l * f.x + k * g.x), n.y = 1 / b * (l * f.y + k * g.y), l = box2d.b2SubVV(c, n, box2d.b2CollideEdgeAndCircle.s_d), l = box2d.b2DotVV(l, l), l > m * m || (n = box2d.b2CollideEdgeAndCircle.s_n.SetXY(-h.y, h.x), 0 > box2d.b2DotVV(n, box2d.b2SubVV(c, f, box2d.b2Vec2.s_t0)) && n.SetXY(-n.x, -n.y), n.Normalize(), d.cf.indexA = 0, d.cf.typeA = box2d.b2ContactFeatureType.e_face, a.pointCount = 1, a.type = box2d.b2ManifoldType.e_faceA, a.localNormal.Copy(n), a.localPoint.Copy(f), a.points[0].id.Copy(d), a.points[0].localPoint.Copy(e.m_p))
};
goog.exportSymbol("box2d.b2CollideEdgeAndCircle", box2d.b2CollideEdgeAndCircle);
box2d.b2CollideEdgeAndCircle.s_Q = new box2d.b2Vec2;
box2d.b2CollideEdgeAndCircle.s_e = new box2d.b2Vec2;
box2d.b2CollideEdgeAndCircle.s_d = new box2d.b2Vec2;
box2d.b2CollideEdgeAndCircle.s_e1 = new box2d.b2Vec2;
box2d.b2CollideEdgeAndCircle.s_e2 = new box2d.b2Vec2;
box2d.b2CollideEdgeAndCircle.s_P = new box2d.b2Vec2;
box2d.b2CollideEdgeAndCircle.s_n = new box2d.b2Vec2;
box2d.b2CollideEdgeAndCircle.s_id = new box2d.b2ContactID;
box2d.b2EPAxisType = {e_unknown: 0, e_edgeA: 1, e_edgeB: 2};
goog.exportSymbol("box2d.b2EPAxisType", box2d.b2EPAxisType);
goog.exportProperty(box2d.b2EPAxisType, "e_unknown", box2d.b2EPAxisType.e_unknown);
goog.exportProperty(box2d.b2EPAxisType, "e_edgeA", box2d.b2EPAxisType.e_edgeA);
goog.exportProperty(box2d.b2EPAxisType, "e_edgeB", box2d.b2EPAxisType.e_edgeB);
box2d.b2EPAxis = function() {
};
goog.exportSymbol("box2d.b2EPAxis", box2d.b2EPAxis);
box2d.b2EPAxis.prototype.type = box2d.b2EPAxisType.e_unknown;
goog.exportProperty(box2d.b2EPAxis.prototype, "type", box2d.b2EPAxis.prototype.type);
box2d.b2EPAxis.prototype.index = 0;
goog.exportProperty(box2d.b2EPAxis.prototype, "index", box2d.b2EPAxis.prototype.index);
box2d.b2EPAxis.prototype.separation = 0;
goog.exportProperty(box2d.b2EPAxis.prototype, "separation", box2d.b2EPAxis.prototype.separation);
box2d.b2TempPolygon = function() {
    this.vertices = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices);
    this.normals = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices);
    this.count = 0
};
goog.exportSymbol("box2d.b2TempPolygon", box2d.b2TempPolygon);
box2d.b2TempPolygon.prototype.vertices = null;
goog.exportProperty(box2d.b2TempPolygon.prototype, "vertices", box2d.b2TempPolygon.prototype.vertices);
box2d.b2TempPolygon.prototype.normals = null;
goog.exportProperty(box2d.b2TempPolygon.prototype, "normals", box2d.b2TempPolygon.prototype.normals);
box2d.b2TempPolygon.prototype.count = 0;
goog.exportProperty(box2d.b2TempPolygon.prototype, "count", box2d.b2TempPolygon.prototype.count);
box2d.b2ReferenceFace = function() {
    this.i2 = this.i1 = 0;
    this.v1 = new box2d.b2Vec2;
    this.v2 = new box2d.b2Vec2;
    this.normal = new box2d.b2Vec2;
    this.sideNormal1 = new box2d.b2Vec2;
    this.sideOffset1 = 0;
    this.sideNormal2 = new box2d.b2Vec2;
    this.sideOffset2 = 0
};
goog.exportSymbol("box2d.b2ReferenceFace", box2d.b2ReferenceFace);
box2d.b2ReferenceFace.prototype.i1 = 0;
goog.exportProperty(box2d.b2ReferenceFace.prototype, "i1", box2d.b2ReferenceFace.prototype.i1);
box2d.b2ReferenceFace.prototype.i2 = 0;
goog.exportProperty(box2d.b2ReferenceFace.prototype, "i2", box2d.b2ReferenceFace.prototype.i2);
box2d.b2ReferenceFace.prototype.v1 = null;
goog.exportProperty(box2d.b2ReferenceFace.prototype, "v1", box2d.b2ReferenceFace.prototype.v1);
box2d.b2ReferenceFace.prototype.v2 = null;
goog.exportProperty(box2d.b2ReferenceFace.prototype, "v2", box2d.b2ReferenceFace.prototype.v2);
box2d.b2ReferenceFace.prototype.normal = null;
goog.exportProperty(box2d.b2ReferenceFace.prototype, "normal", box2d.b2ReferenceFace.prototype.normal);
box2d.b2ReferenceFace.prototype.sideNormal1 = null;
goog.exportProperty(box2d.b2ReferenceFace.prototype, "sideNormal1", box2d.b2ReferenceFace.prototype.sideNormal1);
box2d.b2ReferenceFace.prototype.sideOffset1 = 0;
goog.exportProperty(box2d.b2ReferenceFace.prototype, "sideOffset1", box2d.b2ReferenceFace.prototype.sideOffset1);
box2d.b2ReferenceFace.prototype.sideNormal2 = null;
goog.exportProperty(box2d.b2ReferenceFace.prototype, "sideNormal2", box2d.b2ReferenceFace.prototype.sideNormal2);
box2d.b2ReferenceFace.prototype.sideOffset2 = 0;
goog.exportProperty(box2d.b2ReferenceFace.prototype, "sideOffset2", box2d.b2ReferenceFace.prototype.sideOffset2);
box2d.b2EPColliderVertexType = {e_isolated: 0, e_concave: 1, e_convex: 2};
goog.exportSymbol("box2d.b2EPColliderVertexType", box2d.b2EPColliderVertexType);
goog.exportProperty(box2d.b2EPColliderVertexType, "e_isolated", box2d.b2EPColliderVertexType.e_isolated);
goog.exportProperty(box2d.b2EPColliderVertexType, "e_concave", box2d.b2EPColliderVertexType.e_concave);
goog.exportProperty(box2d.b2EPColliderVertexType, "e_convex", box2d.b2EPColliderVertexType.e_convex);
box2d.b2EPCollider = function() {
    this.m_polygonB = new box2d.b2TempPolygon;
    this.m_xf = new box2d.b2Transform;
    this.m_centroidB = new box2d.b2Vec2;
    this.m_v0 = new box2d.b2Vec2;
    this.m_v1 = new box2d.b2Vec2;
    this.m_v2 = new box2d.b2Vec2;
    this.m_v3 = new box2d.b2Vec2;
    this.m_normal0 = new box2d.b2Vec2;
    this.m_normal1 = new box2d.b2Vec2;
    this.m_normal2 = new box2d.b2Vec2;
    this.m_normal = new box2d.b2Vec2;
    this.m_type2 = this.m_type1 = box2d.b2EPColliderVertexType.e_isolated;
    this.m_lowerLimit = new box2d.b2Vec2;
    this.m_upperLimit = new box2d.b2Vec2;
    this.m_radius = 0;
    this.m_front = !1
};
goog.exportSymbol("box2d.b2EPCollider", box2d.b2EPCollider);
box2d.b2EPCollider.prototype.m_polygonB = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_polygonB", box2d.b2EPCollider.prototype.m_polygonB);
box2d.b2EPCollider.prototype.m_xf = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_xf", box2d.b2EPCollider.prototype.m_xf);
box2d.b2EPCollider.prototype.m_centroidB = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_centroidB", box2d.b2EPCollider.prototype.m_centroidB);
box2d.b2EPCollider.prototype.m_v0 = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_v0", box2d.b2EPCollider.prototype.m_v0);
box2d.b2EPCollider.prototype.m_v1 = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_v1", box2d.b2EPCollider.prototype.m_v1);
box2d.b2EPCollider.prototype.m_v2 = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_v2", box2d.b2EPCollider.prototype.m_v2);
box2d.b2EPCollider.prototype.m_v3 = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_v3", box2d.b2EPCollider.prototype.m_v3);
box2d.b2EPCollider.prototype.m_normal0 = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_normal0", box2d.b2EPCollider.prototype.m_normal0);
box2d.b2EPCollider.prototype.m_normal1 = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_normal1", box2d.b2EPCollider.prototype.m_normal1);
box2d.b2EPCollider.prototype.m_normal2 = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_normal2", box2d.b2EPCollider.prototype.m_normal2);
box2d.b2EPCollider.prototype.m_normal = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_normal", box2d.b2EPCollider.prototype.m_normal);
box2d.b2EPCollider.prototype.m_type1 = box2d.b2EPColliderVertexType.e_isolated;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_type1", box2d.b2EPCollider.prototype.m_type1);
box2d.b2EPCollider.prototype.m_type2 = box2d.b2EPColliderVertexType.e_isolated;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_type2", box2d.b2EPCollider.prototype.m_type2);
box2d.b2EPCollider.prototype.m_lowerLimit = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_lowerLimit", box2d.b2EPCollider.prototype.m_lowerLimit);
box2d.b2EPCollider.prototype.m_upperLimit = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_upperLimit", box2d.b2EPCollider.prototype.m_upperLimit);
box2d.b2EPCollider.prototype.m_radius = 0;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_radius", box2d.b2EPCollider.prototype.m_radius);
box2d.b2EPCollider.prototype.m_front = !1;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_front", box2d.b2EPCollider.prototype.m_front);
box2d.b2EPCollider.prototype.Collide = function(a, b, c, e, d) {
    box2d.b2MulTXX(c, d, this.m_xf);
    box2d.b2MulXV(this.m_xf, e.m_centroid, this.m_centroidB);
    this.m_v0.Copy(b.m_vertex0);
    this.m_v1.Copy(b.m_vertex1);
    this.m_v2.Copy(b.m_vertex2);
    this.m_v3.Copy(b.m_vertex3);
    c = b.m_hasVertex0;
    b = b.m_hasVertex3;
    d = box2d.b2SubVV(this.m_v2, this.m_v1, box2d.b2EPCollider.s_edge1);
    d.Normalize();
    this.m_normal1.SetXY(d.y, -d.x);
    var f = box2d.b2DotVV(this.m_normal1, box2d.b2SubVV(this.m_centroidB, this.m_v1, box2d.b2Vec2.s_t0)), g = 0, h = 0,
            l = !1, k = !1;
    c && (g = box2d.b2SubVV(this.m_v1, this.m_v0, box2d.b2EPCollider.s_edge0), g.Normalize(), this.m_normal0.SetXY(g.y, -g.x), l = 0 <= box2d.b2CrossVV(g, d), g = box2d.b2DotVV(this.m_normal0, box2d.b2SubVV(this.m_centroidB, this.m_v0, box2d.b2Vec2.s_t0)));
    b && (h = box2d.b2SubVV(this.m_v3, this.m_v2, box2d.b2EPCollider.s_edge2), h.Normalize(), this.m_normal2.SetXY(h.y, -h.x), k = 0 < box2d.b2CrossVV(d, h), h = box2d.b2DotVV(this.m_normal2, box2d.b2SubVV(this.m_centroidB, this.m_v2, box2d.b2Vec2.s_t0)));
    c && b ? l && k ? (this.m_front = 0 <= g ||
            0 <= f || 0 <= h) ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal0), this.m_upperLimit.Copy(this.m_normal2)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal1).SelfNeg()) : l ? (this.m_front = 0 <= g || 0 <= f && 0 <= h) ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal0), this.m_upperLimit.Copy(this.m_normal1)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal2).SelfNeg(),
            this.m_upperLimit.Copy(this.m_normal1).SelfNeg()) : k ? (this.m_front = 0 <= h || 0 <= g && 0 <= f) ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal2)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal0).SelfNeg()) : (this.m_front = 0 <= g && 0 <= f && 0 <= h) ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal1)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(),
            this.m_lowerLimit.Copy(this.m_normal2).SelfNeg(), this.m_upperLimit.Copy(this.m_normal0).SelfNeg()) : c ? l ? ((this.m_front = 0 <= g || 0 <= f) ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal0)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1)), this.m_upperLimit.Copy(this.m_normal1).SelfNeg()) : (this.m_front = 0 <= g && 0 <= f) ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal1).SelfNeg()) : (this.m_normal.Copy(this.m_normal1).SelfNeg(),
            this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal0).SelfNeg()) : b ? k ? (this.m_front = 0 <= f || 0 <= h) ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal2)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal1)) : ((this.m_front = 0 <= f && 0 <= h) ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg()) : (this.m_normal.Copy(this.m_normal1).SelfNeg(),
            this.m_lowerLimit.Copy(this.m_normal2).SelfNeg()), this.m_upperLimit.Copy(this.m_normal1)) : (this.m_front = 0 <= f) ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal1).SelfNeg()) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal1));
    this.m_polygonB.count = e.m_count;
    f = 0;
    for (g = e.m_count; f < g; ++f)
        box2d.b2MulXV(this.m_xf, e.m_vertices[f], this.m_polygonB.vertices[f]), box2d.b2MulRV(this.m_xf.q,
                e.m_normals[f], this.m_polygonB.normals[f]);
    this.m_radius = 2 * box2d.b2_polygonRadius;
    a.pointCount = 0;
    c = this.ComputeEdgeSeparation(box2d.b2EPCollider.s_edgeAxis);
    if (!(c.type == box2d.b2EPAxisType.e_unknown || c.separation > this.m_radius || (b = this.ComputePolygonSeparation(box2d.b2EPCollider.s_polygonAxis), b.type != box2d.b2EPAxisType.e_unknown && b.separation > this.m_radius))) {
        c = b.type == box2d.b2EPAxisType.e_unknown ? c : b.separation > 0.98 * c.separation + 0.001 ? b : c;
        d = box2d.b2EPCollider.s_ie;
        b = box2d.b2EPCollider.s_rf;
        if (c.type ==
                box2d.b2EPAxisType.e_edgeA) {
            a.type = box2d.b2ManifoldType.e_faceA;
            h = 0;
            l = box2d.b2DotVV(this.m_normal, this.m_polygonB.normals[0]);
            f = 1;
            for (g = this.m_polygonB.count; f < g; ++f)
                k = box2d.b2DotVV(this.m_normal, this.m_polygonB.normals[f]), k < l && (l = k, h = f);
            g = h;
            f = (g + 1) % this.m_polygonB.count;
            h = d[0];
            h.v.Copy(this.m_polygonB.vertices[g]);
            h.id.cf.indexA = 0;
            h.id.cf.indexB = g;
            h.id.cf.typeA = box2d.b2ContactFeatureType.e_face;
            h.id.cf.typeB = box2d.b2ContactFeatureType.e_vertex;
            g = d[1];
            g.v.Copy(this.m_polygonB.vertices[f]);
            g.id.cf.indexA =
                    0;
            g.id.cf.indexB = f;
            g.id.cf.typeA = box2d.b2ContactFeatureType.e_face;
            g.id.cf.typeB = box2d.b2ContactFeatureType.e_vertex;
            this.m_front ? (b.i1 = 0, b.i2 = 1, b.v1.Copy(this.m_v1), b.v2.Copy(this.m_v2), b.normal.Copy(this.m_normal1)) : (b.i1 = 1, b.i2 = 0, b.v1.Copy(this.m_v2), b.v2.Copy(this.m_v1), b.normal.Copy(this.m_normal1).SelfNeg())
        } else
            a.type = box2d.b2ManifoldType.e_faceB, h = d[0], h.v.Copy(this.m_v1), h.id.cf.indexA = 0, h.id.cf.indexB = c.index, h.id.cf.typeA = box2d.b2ContactFeatureType.e_vertex, h.id.cf.typeB = box2d.b2ContactFeatureType.e_face,
                    g = d[1], g.v.Copy(this.m_v2), g.id.cf.indexA = 0, g.id.cf.indexB = c.index, g.id.cf.typeA = box2d.b2ContactFeatureType.e_vertex, g.id.cf.typeB = box2d.b2ContactFeatureType.e_face, b.i1 = c.index, b.i2 = (b.i1 + 1) % this.m_polygonB.count, b.v1.Copy(this.m_polygonB.vertices[b.i1]), b.v2.Copy(this.m_polygonB.vertices[b.i2]), b.normal.Copy(this.m_polygonB.normals[b.i1]);
        b.sideNormal1.SetXY(b.normal.y, -b.normal.x);
        b.sideNormal2.Copy(b.sideNormal1).SelfNeg();
        b.sideOffset1 = box2d.b2DotVV(b.sideNormal1, b.v1);
        b.sideOffset2 = box2d.b2DotVV(b.sideNormal2,
                b.v2);
        f = box2d.b2EPCollider.s_clipPoints1;
        h = box2d.b2EPCollider.s_clipPoints2;
        g = 0;
        g = box2d.b2ClipSegmentToLine(f, d, b.sideNormal1, b.sideOffset1, b.i1);
        if (!(g < box2d.b2_maxManifoldPoints || (g = box2d.b2ClipSegmentToLine(h, f, b.sideNormal2, b.sideOffset2, b.i2), g < box2d.b2_maxManifoldPoints))) {
            c.type == box2d.b2EPAxisType.e_edgeA ? (a.localNormal.Copy(b.normal), a.localPoint.Copy(b.v1)) : (a.localNormal.Copy(e.m_normals[b.i1]), a.localPoint.Copy(e.m_vertices[b.i1]));
            f = e = 0;
            for (g = box2d.b2_maxManifoldPoints; f < g; ++f)
                box2d.b2DotVV(b.normal,
                        box2d.b2SubVV(h[f].v, b.v1, box2d.b2Vec2.s_t0)) <= this.m_radius && (d = a.points[e], c.type == box2d.b2EPAxisType.e_edgeA ? (box2d.b2MulTXV(this.m_xf, h[f].v, d.localPoint), d.id = h[f].id) : (d.localPoint.Copy(h[f].v), d.id.cf.typeA = h[f].id.cf.typeB, d.id.cf.typeB = h[f].id.cf.typeA, d.id.cf.indexA = h[f].id.cf.indexB, d.id.cf.indexB = h[f].id.cf.indexA), ++e);
            a.pointCount = e
        }
    }
};
goog.exportProperty(box2d.b2EPCollider.prototype, "Collide", box2d.b2EPCollider.prototype.Collide);
box2d.b2EPCollider.s_edge1 = new box2d.b2Vec2;
box2d.b2EPCollider.s_edge0 = new box2d.b2Vec2;
box2d.b2EPCollider.s_edge2 = new box2d.b2Vec2;
box2d.b2EPCollider.s_ie = box2d.b2ClipVertex.MakeArray(2);
box2d.b2EPCollider.s_rf = new box2d.b2ReferenceFace;
box2d.b2EPCollider.s_clipPoints1 = box2d.b2ClipVertex.MakeArray(2);
box2d.b2EPCollider.s_clipPoints2 = box2d.b2ClipVertex.MakeArray(2);
box2d.b2EPCollider.s_edgeAxis = new box2d.b2EPAxis;
box2d.b2EPCollider.s_polygonAxis = new box2d.b2EPAxis;
box2d.b2EPCollider.prototype.ComputeEdgeSeparation = function(a) {
    a.type = box2d.b2EPAxisType.e_edgeA;
    a.index = this.m_front ? 0 : 1;
    a.separation = box2d.b2_maxFloat;
    for (var b = 0, c = this.m_polygonB.count; b < c; ++b) {
        var e = box2d.b2DotVV(this.m_normal, box2d.b2SubVV(this.m_polygonB.vertices[b], this.m_v1, box2d.b2Vec2.s_t0));
        e < a.separation && (a.separation = e)
    }
    return a
};
goog.exportProperty(box2d.b2EPCollider.prototype, "ComputeEdgeSeparation", box2d.b2EPCollider.prototype.ComputeEdgeSeparation);
box2d.b2EPCollider.prototype.ComputePolygonSeparation = function(a) {
    a.type = box2d.b2EPAxisType.e_unknown;
    a.index = -1;
    a.separation = -box2d.b2_maxFloat;
    for (var b = box2d.b2EPCollider.s_perp.SetXY(-this.m_normal.y, this.m_normal.x), c = 0, e = this.m_polygonB.count; c < e; ++c) {
        var d = box2d.b2NegV(this.m_polygonB.normals[c], box2d.b2EPCollider.s_n), f = box2d.b2DotVV(d, box2d.b2SubVV(this.m_polygonB.vertices[c], this.m_v1, box2d.b2Vec2.s_t0)), g = box2d.b2DotVV(d, box2d.b2SubVV(this.m_polygonB.vertices[c], this.m_v2, box2d.b2Vec2.s_t0)),
                f = box2d.b2Min(f, g);
        if (f > this.m_radius) {
            a.type = box2d.b2EPAxisType.e_edgeB;
            a.index = c;
            a.separation = f;
            break
        }
        if (0 <= box2d.b2DotVV(d, b)) {
            if (box2d.b2DotVV(box2d.b2SubVV(d, this.m_upperLimit, box2d.b2Vec2.s_t0), this.m_normal) < -box2d.b2_angularSlop)
                continue
        } else if (box2d.b2DotVV(box2d.b2SubVV(d, this.m_lowerLimit, box2d.b2Vec2.s_t0), this.m_normal) < -box2d.b2_angularSlop)
            continue;
        f > a.separation && (a.type = box2d.b2EPAxisType.e_edgeB, a.index = c, a.separation = f)
    }
    return a
};
goog.exportProperty(box2d.b2EPCollider.prototype, "ComputePolygonSeparation", box2d.b2EPCollider.prototype.ComputePolygonSeparation);
box2d.b2EPCollider.s_n = new box2d.b2Vec2;
box2d.b2EPCollider.s_perp = new box2d.b2Vec2;
box2d.b2CollideEdgeAndPolygon = function(a, b, c, e, d) {
    box2d.b2CollideEdgeAndPolygon.s_collider.Collide(a, b, c, e, d)
};
goog.exportSymbol("box2d.b2CollideEdgeAndPolygon", box2d.b2CollideEdgeAndPolygon);
box2d.b2CollideEdgeAndPolygon.s_collider = new box2d.b2EPCollider;
box2d.b2EdgeShape = function() {
    box2d.b2Shape.call(this, box2d.b2ShapeType.e_edgeShape, box2d.b2_polygonRadius);
    this.m_vertex1 = new box2d.b2Vec2;
    this.m_vertex2 = new box2d.b2Vec2;
    this.m_vertex0 = new box2d.b2Vec2;
    this.m_vertex3 = new box2d.b2Vec2
};
goog.inherits(box2d.b2EdgeShape, box2d.b2Shape);
goog.exportSymbol("box2d.b2EdgeShape", box2d.b2EdgeShape);
box2d.b2EdgeShape.prototype.m_vertex1 = null;
goog.exportProperty(box2d.b2EdgeShape.prototype, "m_vertex1", box2d.b2EdgeShape.prototype.m_vertex1);
box2d.b2EdgeShape.prototype.m_vertex2 = null;
goog.exportProperty(box2d.b2EdgeShape.prototype, "m_vertex2", box2d.b2EdgeShape.prototype.m_vertex2);
box2d.b2EdgeShape.prototype.m_vertex0 = null;
goog.exportProperty(box2d.b2EdgeShape.prototype, "m_vertex0", box2d.b2EdgeShape.prototype.m_vertex0);
box2d.b2EdgeShape.prototype.m_vertex3 = null;
goog.exportProperty(box2d.b2EdgeShape.prototype, "m_vertex3", box2d.b2EdgeShape.prototype.m_vertex3);
box2d.b2EdgeShape.prototype.m_hasVertex0 = !1;
goog.exportProperty(box2d.b2EdgeShape.prototype, "m_hasVertex0", box2d.b2EdgeShape.prototype.m_hasVertex0);
box2d.b2EdgeShape.prototype.m_hasVertex3 = !1;
goog.exportProperty(box2d.b2EdgeShape.prototype, "m_hasVertex3", box2d.b2EdgeShape.prototype.m_hasVertex3);
box2d.b2EdgeShape.prototype.Set = function(a, b) {
    this.m_vertex1.Copy(a);
    this.m_vertex2.Copy(b);
    this.m_hasVertex3 = this.m_hasVertex0 = !1;
    return this
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "Set", box2d.b2EdgeShape.prototype.Set);
box2d.b2EdgeShape.prototype.SetAsEdge = box2d.b2EdgeShape.prototype.Set;
box2d.b2EdgeShape.prototype.Clone = function() {
    return(new box2d.b2EdgeShape).Copy(this)
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "Clone", box2d.b2EdgeShape.prototype.Clone);
box2d.b2EdgeShape.prototype.Copy = function(a) {
    box2d.b2EdgeShape.superClass_.Copy.call(this, a);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a instanceof box2d.b2EdgeShape);
    this.m_vertex1.Copy(a.m_vertex1);
    this.m_vertex2.Copy(a.m_vertex2);
    this.m_vertex0.Copy(a.m_vertex0);
    this.m_vertex3.Copy(a.m_vertex3);
    this.m_hasVertex0 = a.m_hasVertex0;
    this.m_hasVertex3 = a.m_hasVertex3;
    return this
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "Copy", box2d.b2EdgeShape.prototype.Copy);
box2d.b2EdgeShape.prototype.GetChildCount = function() {
    return 1
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "GetChildCount", box2d.b2EdgeShape.prototype.GetChildCount);
box2d.b2EdgeShape.prototype.TestPoint = function(a, b) {
    return!1
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "TestPoint", box2d.b2EdgeShape.prototype.TestPoint);
box2d.b2EdgeShape.prototype.RayCast = function(a, b, c, e) {
    var d = box2d.b2MulTXV(c, b.p1, box2d.b2EdgeShape.prototype.RayCast.s_p1);
    e = box2d.b2MulTXV(c, b.p2, box2d.b2EdgeShape.prototype.RayCast.s_p2);
    var f = box2d.b2SubVV(e, d, box2d.b2EdgeShape.prototype.RayCast.s_d);
    e = this.m_vertex1;
    var g = this.m_vertex2, h = box2d.b2SubVV(g, e, box2d.b2EdgeShape.prototype.RayCast.s_e), l = a.normal.SetXY(h.y, -h.x).SelfNormalize(), h = box2d.b2DotVV(l, box2d.b2SubVV(e, d, box2d.b2Vec2.s_t0)), l = box2d.b2DotVV(l, f);
    if (0 == l)
        return!1;
    l = h / l;
    if (0 >
            l || b.maxFraction < l)
        return!1;
    b = box2d.b2AddVMulSV(d, l, f, box2d.b2EdgeShape.prototype.RayCast.s_q);
    d = box2d.b2SubVV(g, e, box2d.b2EdgeShape.prototype.RayCast.s_r);
    g = box2d.b2DotVV(d, d);
    if (0 == g)
        return!1;
    e = box2d.b2DotVV(box2d.b2SubVV(b, e, box2d.b2Vec2.s_t0), d) / g;
    if (0 > e || 1 < e)
        return!1;
    a.fraction = l;
    box2d.b2MulRV(c.q, a.normal, a.normal);
    0 < h && a.normal.SelfNeg();
    return!0
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "RayCast", box2d.b2EdgeShape.prototype.RayCast);
box2d.b2EdgeShape.prototype.RayCast.s_p1 = new box2d.b2Vec2;
box2d.b2EdgeShape.prototype.RayCast.s_p2 = new box2d.b2Vec2;
box2d.b2EdgeShape.prototype.RayCast.s_d = new box2d.b2Vec2;
box2d.b2EdgeShape.prototype.RayCast.s_e = new box2d.b2Vec2;
box2d.b2EdgeShape.prototype.RayCast.s_q = new box2d.b2Vec2;
box2d.b2EdgeShape.prototype.RayCast.s_r = new box2d.b2Vec2;
box2d.b2EdgeShape.prototype.ComputeAABB = function(a, b, c) {
    c = box2d.b2MulXV(b, this.m_vertex1, box2d.b2EdgeShape.prototype.ComputeAABB.s_v1);
    b = box2d.b2MulXV(b, this.m_vertex2, box2d.b2EdgeShape.prototype.ComputeAABB.s_v2);
    box2d.b2MinV(c, b, a.lowerBound);
    box2d.b2MaxV(c, b, a.upperBound);
    b = this.m_radius;
    a.lowerBound.SelfSubXY(b, b);
    a.upperBound.SelfAddXY(b, b)
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "ComputeAABB", box2d.b2EdgeShape.prototype.ComputeAABB);
box2d.b2EdgeShape.prototype.ComputeAABB.s_v1 = new box2d.b2Vec2;
box2d.b2EdgeShape.prototype.ComputeAABB.s_v2 = new box2d.b2Vec2;
box2d.b2EdgeShape.prototype.ComputeMass = function(a, b) {
    a.mass = 0;
    box2d.b2MidVV(this.m_vertex1, this.m_vertex2, a.center);
    a.I = 0
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "ComputeMass", box2d.b2EdgeShape.prototype.ComputeMass);
box2d.b2EdgeShape.prototype.SetupDistanceProxy = function(a, b) {
    a.m_vertices = Array(2);
    a.m_vertices[0] = this.m_vertex1;
    a.m_vertices[1] = this.m_vertex2;
    a.m_count = 2;
    a.m_radius = this.m_radius
};
box2d.b2EdgeShape.prototype.ComputeSubmergedArea = function(a, b, c, e) {
    e.SetZero();
    return 0
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "ComputeSubmergedArea", box2d.b2EdgeShape.prototype.ComputeSubmergedArea);
box2d.b2EdgeShape.prototype.Dump = function() {
    box2d.b2Log("    /*box2d.b2EdgeShape*/ var shape = new box2d.b2EdgeShape();\n");
    box2d.b2Log("    shape.m_radius = %.15f;\n", this.m_radius);
    box2d.b2Log("    shape.m_vertex0.SetXY(%.15f, %.15f);\n", this.m_vertex0.x, this.m_vertex0.y);
    box2d.b2Log("    shape.m_vertex1.SetXY(%.15f, %.15f);\n", this.m_vertex1.x, this.m_vertex1.y);
    box2d.b2Log("    shape.m_vertex2.SetXY(%.15f, %.15f);\n", this.m_vertex2.x, this.m_vertex2.y);
    box2d.b2Log("    shape.m_vertex3.SetXY(%.15f, %.15f);\n",
            this.m_vertex3.x, this.m_vertex3.y);
    box2d.b2Log("    shape.m_hasVertex0 = %s;\n", this.m_hasVertex0);
    box2d.b2Log("    shape.m_hasVertex3 = %s;\n", this.m_hasVertex3)
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "Dump", box2d.b2EdgeShape.prototype.Dump);
box2d.b2ChainShape = function() {
    box2d.b2Shape.call(this, box2d.b2ShapeType.e_chainShape, box2d.b2_polygonRadius);
    this.m_prevVertex = new box2d.b2Vec2;
    this.m_nextVertex = new box2d.b2Vec2
};
goog.inherits(box2d.b2ChainShape, box2d.b2Shape);
goog.exportSymbol("box2d.b2ChainShape", box2d.b2ChainShape);
box2d.b2ChainShape.prototype.m_vertices = null;
goog.exportProperty(box2d.b2ChainShape.prototype, "m_vertices", box2d.b2ChainShape.prototype.m_vertices);
box2d.b2ChainShape.prototype.m_count = 0;
goog.exportProperty(box2d.b2ChainShape.prototype, "m_count", box2d.b2ChainShape.prototype.m_count);
box2d.b2ChainShape.prototype.m_prevVertex = null;
goog.exportProperty(box2d.b2ChainShape.prototype, "m_prevVertex", box2d.b2ChainShape.prototype.m_prevVertex);
box2d.b2ChainShape.prototype.m_nextVertex = null;
goog.exportProperty(box2d.b2ChainShape.prototype, "m_nextVertex", box2d.b2ChainShape.prototype.m_nextVertex);
box2d.b2ChainShape.prototype.m_hasPrevVertex = !1;
goog.exportProperty(box2d.b2ChainShape.prototype, "m_hasPrevVertex", box2d.b2ChainShape.prototype.m_hasPrevVertex);
box2d.b2ChainShape.prototype.m_hasNextVertex = !1;
goog.exportProperty(box2d.b2ChainShape.prototype, "m_hasNextVertex", box2d.b2ChainShape.prototype.m_hasNextVertex);
box2d.b2ChainShape.prototype.CreateLoop = function(a, b) {
    b = b || a.length;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(null == this.m_vertices && 0 == this.m_count);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(3 <= b);
    if (box2d.ENABLE_ASSERTS)
        for (var c = 1; c < b; ++c)
            box2d.b2Assert(box2d.b2DistanceSquaredVV(a[c - 1], a[c]) > box2d.b2_linearSlop * box2d.b2_linearSlop);
    this.m_count = b + 1;
    this.m_vertices = box2d.b2Vec2.MakeArray(this.m_count);
    for (c = 0; c < b; ++c)
        this.m_vertices[c].Copy(a[c]);
    this.m_vertices[b].Copy(this.m_vertices[0]);
    this.m_prevVertex.Copy(this.m_vertices[this.m_count -
    2]);
    this.m_nextVertex.Copy(this.m_vertices[1]);
    this.m_hasNextVertex = this.m_hasPrevVertex = !0;
    return this
};
goog.exportProperty(box2d.b2ChainShape.prototype, "CreateLoop", box2d.b2ChainShape.prototype.CreateLoop);
box2d.b2ChainShape.prototype.CreateChain = function(a, b) {
    b = b || a.length;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(null == this.m_vertices && 0 == this.m_count);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(2 <= b);
    if (box2d.ENABLE_ASSERTS)
        for (var c = 1; c < b; ++c)
            box2d.b2Assert(box2d.b2DistanceSquaredVV(a[c - 1], a[c]) > box2d.b2_linearSlop * box2d.b2_linearSlop);
    this.m_count = b;
    this.m_vertices = box2d.b2Vec2.MakeArray(b);
    for (c = 0; c < b; ++c)
        this.m_vertices[c].Copy(a[c]);
    this.m_hasNextVertex = this.m_hasPrevVertex = !1;
    return this
};
goog.exportProperty(box2d.b2ChainShape.prototype, "CreateChain", box2d.b2ChainShape.prototype.CreateChain);
box2d.b2ChainShape.prototype.SetPrevVertex = function(a) {
    this.m_prevVertex.Copy(a);
    this.m_hasPrevVertex = !0;
    return this
};
goog.exportProperty(box2d.b2ChainShape.prototype, "SetPrevVertex", box2d.b2ChainShape.prototype.SetPrevVertex);
box2d.b2ChainShape.prototype.SetNextVertex = function(a) {
    this.m_nextVertex.Copy(a);
    this.m_hasNextVertex = !0;
    return this
};
goog.exportProperty(box2d.b2ChainShape.prototype, "SetNextVertex", box2d.b2ChainShape.prototype.SetNextVertex);
box2d.b2ChainShape.prototype.Clone = function() {
    return(new box2d.b2ChainShape).Copy(this)
};
goog.exportProperty(box2d.b2ChainShape.prototype, "Clone", box2d.b2ChainShape.prototype.Clone);
box2d.b2ChainShape.prototype.Copy = function(a) {
    box2d.b2ChainShape.superClass_.Copy.call(this, a);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a instanceof box2d.b2ChainShape);
    this.CreateChain(a.m_vertices, a.m_count);
    this.m_prevVertex.Copy(a.m_prevVertex);
    this.m_nextVertex.Copy(a.m_nextVertex);
    this.m_hasPrevVertex = a.m_hasPrevVertex;
    this.m_hasNextVertex = a.m_hasNextVertex;
    return this
};
goog.exportProperty(box2d.b2ChainShape.prototype, "Copy", box2d.b2ChainShape.prototype.Copy);
box2d.b2ChainShape.prototype.GetChildCount = function() {
    return this.m_count - 1
};
goog.exportProperty(box2d.b2ChainShape.prototype, "GetChildCount", box2d.b2ChainShape.prototype.GetChildCount);
box2d.b2ChainShape.prototype.GetChildEdge = function(a, b) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= b && b < this.m_count - 1);
    a.m_type = box2d.b2ShapeType.e_edgeShape;
    a.m_radius = this.m_radius;
    a.m_vertex1.Copy(this.m_vertices[b]);
    a.m_vertex2.Copy(this.m_vertices[b + 1]);
    0 < b ? (a.m_vertex0.Copy(this.m_vertices[b - 1]), a.m_hasVertex0 = !0) : (a.m_vertex0.Copy(this.m_prevVertex), a.m_hasVertex0 = this.m_hasPrevVertex);
    b < this.m_count - 2 ? (a.m_vertex3.Copy(this.m_vertices[b + 2]), a.m_hasVertex3 = !0) : (a.m_vertex3.Copy(this.m_nextVertex),
            a.m_hasVertex3 = this.m_hasNextVertex)
};
goog.exportProperty(box2d.b2ChainShape.prototype, "GetChildEdge", box2d.b2ChainShape.prototype.GetChildEdge);
box2d.b2ChainShape.prototype.TestPoint = function(a, b) {
    return!1
};
goog.exportProperty(box2d.b2ChainShape.prototype, "TestPoint", box2d.b2ChainShape.prototype.TestPoint);
box2d.b2ChainShape.prototype.RayCast = function(a, b, c, e) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e < this.m_count);
    var d = box2d.b2ChainShape.s_edgeShape;
    d.m_vertex1.Copy(this.m_vertices[e]);
    d.m_vertex2.Copy(this.m_vertices[(e + 1) % this.m_count]);
    return d.RayCast(a, b, c, 0)
};
goog.exportProperty(box2d.b2ChainShape.prototype, "RayCast", box2d.b2ChainShape.prototype.RayCast);
box2d.b2ChainShape.s_edgeShape = new box2d.b2EdgeShape;
goog.exportProperty(box2d.b2ChainShape, "s_edgeShape", box2d.b2ChainShape.s_edgeShape);
box2d.b2ChainShape.prototype.ComputeAABB = function(a, b, c) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(c < this.m_count);
    var e = this.m_vertices[(c + 1) % this.m_count];
    c = box2d.b2MulXV(b, this.m_vertices[c], box2d.b2ChainShape.prototype.ComputeAABB.s_v1);
    b = box2d.b2MulXV(b, e, box2d.b2ChainShape.prototype.ComputeAABB.s_v2);
    box2d.b2MinV(c, b, a.lowerBound);
    box2d.b2MaxV(c, b, a.upperBound)
};
goog.exportProperty(box2d.b2ChainShape.prototype, "ComputeAABB", box2d.b2ChainShape.prototype.ComputeAABB);
box2d.b2ChainShape.prototype.ComputeAABB.s_v1 = new box2d.b2Vec2;
goog.exportProperty(box2d.b2ChainShape.prototype.ComputeAABB, "s_v1", box2d.b2ChainShape.prototype.ComputeAABB.s_v1);
box2d.b2ChainShape.prototype.ComputeAABB.s_v2 = new box2d.b2Vec2;
goog.exportProperty(box2d.b2ChainShape.prototype.ComputeAABB, "s_v2", box2d.b2ChainShape.prototype.ComputeAABB.s_v2);
box2d.b2ChainShape.prototype.ComputeMass = function(a, b) {
    a.mass = 0;
    a.center.SetZero();
    a.I = 0
};
goog.exportProperty(box2d.b2ChainShape.prototype, "ComputeMass", box2d.b2ChainShape.prototype.ComputeMass);
box2d.b2ChainShape.prototype.SetupDistanceProxy = function(a, b) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= b && b < this.m_count);
    a.m_buffer[0].Copy(this.m_vertices[b]);
    b + 1 < this.m_count ? a.m_buffer[1].Copy(this.m_vertices[b + 1]) : a.m_buffer[1].Copy(this.m_vertices[0]);
    a.m_vertices = a.m_buffer;
    a.m_count = 2;
    a.m_radius = this.m_radius
};
box2d.b2ChainShape.prototype.ComputeSubmergedArea = function(a, b, c, e) {
    e.SetZero();
    return 0
};
goog.exportProperty(box2d.b2ChainShape.prototype, "ComputeSubmergedArea", box2d.b2ChainShape.prototype.ComputeSubmergedArea);
box2d.b2ChainShape.prototype.Dump = function() {
    box2d.b2Log("    /*box2d.b2ChainShape*/ var shape = new box2d.b2ChainShape();\n");
    box2d.b2Log("    /*box2d.b2Vec2[]*/ var vs = box2d.b2Vec2.MakeArray(%d);\n", box2d.b2_maxPolygonVertices);
    for (var a = 0; a < this.m_count; ++a)
        box2d.b2Log("    vs[%d].SetXY(%.15f, %.15f);\n", a, this.m_vertices[a].x, this.m_vertices[a].y);
    box2d.b2Log("    shape.CreateChain(vs, %d);\n", this.m_count);
    box2d.b2Log("    shape.m_prevVertex.SetXY(%.15f, %.15f);\n", this.m_prevVertex.x, this.m_prevVertex.y);
    box2d.b2Log("    shape.m_nextVertex.SetXY(%.15f, %.15f);\n", this.m_nextVertex.x, this.m_nextVertex.y);
    box2d.b2Log("    shape.m_hasPrevVertex = %s;\n", this.m_hasPrevVertex ? "true" : "false");
    box2d.b2Log("    shape.m_hasNextVertex = %s;\n", this.m_hasNextVertex ? "true" : "false")
};
goog.exportProperty(box2d.b2ChainShape.prototype, "Dump", box2d.b2ChainShape.prototype.Dump);
box2d.b2ChainAndPolygonContact = function() {
    box2d.b2Contact.call(this)
};
goog.inherits(box2d.b2ChainAndPolygonContact, box2d.b2Contact);
goog.exportSymbol("box2d.b2ChainAndPolygonContact", box2d.b2ChainAndPolygonContact);
box2d.b2ChainAndPolygonContact.Create = function(a) {
    return new box2d.b2ChainAndPolygonContact
};
goog.exportProperty(box2d.b2ChainAndPolygonContact, "Create", box2d.b2ChainAndPolygonContact.Create);
box2d.b2ChainAndPolygonContact.Destroy = function(a, b) {
};
goog.exportProperty(box2d.b2ChainAndPolygonContact, "Destroy", box2d.b2ChainAndPolygonContact.Destroy);
box2d.b2ChainAndPolygonContact.prototype.Reset = function(a, b, c, e) {
    box2d.b2ChainAndPolygonContact.superClass_.Reset.call(this, a, b, c, e);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.GetType() == box2d.b2ShapeType.e_chainShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(c.GetType() == box2d.b2ShapeType.e_polygonShape)
};
goog.exportProperty(box2d.b2ChainAndPolygonContact.prototype, "Reset", box2d.b2ChainAndPolygonContact.prototype.Reset);
box2d.b2ChainAndPolygonContact.prototype.Evaluate = function(a, b, c) {
    var e = this.m_fixtureA.GetShape(), d = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e instanceof box2d.b2ChainShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(d instanceof box2d.b2PolygonShape);
    var f = box2d.b2ChainAndPolygonContact.prototype.Evaluate.s_edge;
    (e instanceof box2d.b2ChainShape ? e : null).GetChildEdge(f, this.m_indexA);
    box2d.b2CollideEdgeAndPolygon(a, f, b, d instanceof box2d.b2PolygonShape ? d : null, c)
};
goog.exportProperty(box2d.b2ChainAndPolygonContact.prototype, "Evaluate", box2d.b2ChainAndPolygonContact.prototype.Evaluate);
box2d.b2ChainAndPolygonContact.prototype.Evaluate.s_edge = new box2d.b2EdgeShape;
box2d.b2CollidePolygon = {};
box2d.b2EdgeSeparation = function(a, b, c, e, d) {
    var f = a.m_count, g = a.m_vertices, h = a.m_normals;
    a = e.m_count;
    e = e.m_vertices;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= c && c < f);
    for (var f = box2d.b2MulRV(b.q, h[c], box2d.b2EdgeSeparation.s_normal1World), l = box2d.b2MulTRV(d.q, f, box2d.b2EdgeSeparation.s_normal1), h = 0, k = box2d.b2_maxFloat, m = 0; m < a; ++m) {
        var n = box2d.b2DotVV(e[m], l);
        n < k && (k = n, h = m)
    }
    b = box2d.b2MulXV(b, g[c], box2d.b2EdgeSeparation.s_v1);
    d = box2d.b2MulXV(d, e[h], box2d.b2EdgeSeparation.s_v2);
    return box2d.b2DotVV(box2d.b2SubVV(d,
            b, box2d.b2Vec2.s_t0), f)
};
goog.exportSymbol("box2d.b2EdgeSeparation", box2d.b2EdgeSeparation);
box2d.b2EdgeSeparation.s_normal1World = new box2d.b2Vec2;
box2d.b2EdgeSeparation.s_normal1 = new box2d.b2Vec2;
box2d.b2EdgeSeparation.s_v1 = new box2d.b2Vec2;
box2d.b2EdgeSeparation.s_v2 = new box2d.b2Vec2;
box2d.b2FindMaxSeparation = function(a, b, c, e, d) {
    for (var f = b.m_count, g = b.m_normals, h = box2d.b2SubVV(box2d.b2MulXV(d, e.m_centroid, box2d.b2Vec2.s_t0), box2d.b2MulXV(c, b.m_centroid, box2d.b2Vec2.s_t1), box2d.b2FindMaxSeparation.s_d), l = box2d.b2MulTRV(c.q, h, box2d.b2FindMaxSeparation.s_dLocal1), h = 0, k = -box2d.b2_maxFloat, m = 0; m < f; ++m) {
        var n = box2d.b2DotVV(g[m], l);
        n > k && (k = n, h = m)
    }
    var g = box2d.b2EdgeSeparation(b, c, h, e, d), l = (h + f - 1) % f, k = box2d.b2EdgeSeparation(b, c, l, e, d), m = (h + 1) % f, n = box2d.b2EdgeSeparation(b, c, m, e, d), p = 0,
            q = 0, r = 0;
    if (k > g && k > n)
        r = -1, p = l, q = k;
    else if (n > g)
        r = 1, p = m, q = n;
    else
        return a[0] = h, g;
    for (; ; )
        if (h = -1 == r ? (p + f - 1) % f : (p + 1) % f, g = box2d.b2EdgeSeparation(b, c, h, e, d), g > q)
            p = h, q = g;
        else
            break;
    a[0] = p;
    return q
};
goog.exportSymbol("box2d.b2FindMaxSeparation", box2d.b2FindMaxSeparation);
box2d.b2FindMaxSeparation.s_d = new box2d.b2Vec2;
box2d.b2FindMaxSeparation.s_dLocal1 = new box2d.b2Vec2;
box2d.b2FindIncidentEdge = function(a, b, c, e, d, f) {
    var g = b.m_count, h = b.m_normals, l = d.m_count;
    b = d.m_vertices;
    d = d.m_normals;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= e && e < g);
    c = box2d.b2MulTRV(f.q, box2d.b2MulRV(c.q, h[e], box2d.b2Vec2.s_t0), box2d.b2FindIncidentEdge.s_normal1);
    for (var g = 0, h = box2d.b2_maxFloat, k = 0; k < l; ++k) {
        var m = box2d.b2DotVV(c, d[k]);
        m < h && (h = m, g = k)
    }
    d = g;
    l = (d + 1) % l;
    c = a[0];
    box2d.b2MulXV(f, b[d], c.v);
    c = c.id.cf;
    c.indexA = e;
    c.indexB = d;
    c.typeA = box2d.b2ContactFeatureType.e_face;
    c.typeB = box2d.b2ContactFeatureType.e_vertex;
    a = a[1];
    box2d.b2MulXV(f, b[l], a.v);
    f = a.id.cf;
    f.indexA = e;
    f.indexB = l;
    f.typeA = box2d.b2ContactFeatureType.e_face;
    f.typeB = box2d.b2ContactFeatureType.e_vertex
};
goog.exportSymbol("box2d.b2FindIncidentEdge", box2d.b2FindIncidentEdge);
box2d.b2FindIncidentEdge.s_normal1 = new box2d.b2Vec2;
box2d.b2CollidePolygons = function(a, b, c, e, d) {
    a.pointCount = 0;
    var f = b.m_radius + e.m_radius, g = box2d.b2CollidePolygons.s_edgeA;
    g[0] = 0;
    var h = box2d.b2FindMaxSeparation(g, b, c, e, d);
    if (!(h > f)) {
        var l = box2d.b2CollidePolygons.s_edgeB;
        l[0] = 0;
        var k = box2d.b2FindMaxSeparation(l, e, d, b, c);
        if (!(k > f)) {
            var m = 0, n = 0;
            k > 0.98 * h + 0.001 ? (h = e, e = b, b = d, m = l[0], a.type = box2d.b2ManifoldType.e_faceB, n = 1) : (h = b, b = c, c = d, m = g[0], a.type = box2d.b2ManifoldType.e_faceA, n = 0);
            g = box2d.b2CollidePolygons.s_incidentEdge;
            box2d.b2FindIncidentEdge(g, h, b,
                    m, e, c);
            d = h.m_vertices;
            var l = m, h = (m + 1) % h.m_count, p = d[l], q = d[h], m = box2d.b2SubVV(q, p, box2d.b2CollidePolygons.s_localTangent);
            m.Normalize();
            d = box2d.b2CrossVOne(m, box2d.b2CollidePolygons.s_localNormal);
            e = box2d.b2MidVV(p, q, box2d.b2CollidePolygons.s_planePoint);
            var k = box2d.b2MulRV(b.q, m, box2d.b2CollidePolygons.s_tangent), m = box2d.b2CrossVOne(k, box2d.b2CollidePolygons.s_normal), p = box2d.b2MulXV(b, p, box2d.b2CollidePolygons.s_v11), r = box2d.b2MulXV(b, q, box2d.b2CollidePolygons.s_v12);
            b = box2d.b2DotVV(m, p);
            var q =
                    -box2d.b2DotVV(k, p) + f, r = box2d.b2DotVV(k, r) + f, t = box2d.b2CollidePolygons.s_clipPoints1, p = box2d.b2CollidePolygons.s_clipPoints2, s = box2d.b2NegV(k, box2d.b2CollidePolygons.s_ntangent), g = box2d.b2ClipSegmentToLine(t, g, s, q, l);
            if (!(2 > g || (g = box2d.b2ClipSegmentToLine(p, t, k, r, h), 2 > g))) {
                a.localNormal.Copy(d);
                a.localPoint.Copy(e);
                for (l = g = 0; l < box2d.b2_maxManifoldPoints; ++l)
                    d = p[l], box2d.b2DotVV(m, d.v) - b <= f && (h = a.points[g], box2d.b2MulTXV(c, d.v, h.localPoint), h.id.Copy(d.id), n && (d = h.id.cf, h.id.cf.indexA = d.indexB, h.id.cf.indexB =
                            d.indexA, h.id.cf.typeA = d.typeB, h.id.cf.typeB = d.typeA), ++g);
                a.pointCount = g
            }
        }
    }
};
goog.exportSymbol("box2d.b2CollidePolygons", box2d.b2CollidePolygons);
box2d.b2CollidePolygons.s_incidentEdge = box2d.b2ClipVertex.MakeArray(2);
box2d.b2CollidePolygons.s_clipPoints1 = box2d.b2ClipVertex.MakeArray(2);
box2d.b2CollidePolygons.s_clipPoints2 = box2d.b2ClipVertex.MakeArray(2);
box2d.b2CollidePolygons.s_edgeA = box2d.b2MakeNumberArray(1);
box2d.b2CollidePolygons.s_edgeB = box2d.b2MakeNumberArray(1);
box2d.b2CollidePolygons.s_localTangent = new box2d.b2Vec2;
box2d.b2CollidePolygons.s_localNormal = new box2d.b2Vec2;
box2d.b2CollidePolygons.s_planePoint = new box2d.b2Vec2;
box2d.b2CollidePolygons.s_normal = new box2d.b2Vec2;
box2d.b2CollidePolygons.s_tangent = new box2d.b2Vec2;
box2d.b2CollidePolygons.s_ntangent = new box2d.b2Vec2;
box2d.b2CollidePolygons.s_v11 = new box2d.b2Vec2;
box2d.b2CollidePolygons.s_v12 = new box2d.b2Vec2;
box2d.b2PolygonContact = function() {
    box2d.b2Contact.call(this)
};
goog.inherits(box2d.b2PolygonContact, box2d.b2Contact);
goog.exportSymbol("box2d.b2PolygonContact", box2d.b2PolygonContact);
box2d.b2PolygonContact.Create = function(a) {
    return new box2d.b2PolygonContact
};
goog.exportProperty(box2d.b2PolygonContact, "Create", box2d.b2PolygonContact.Create);
box2d.b2PolygonContact.Destroy = function(a, b) {
};
goog.exportProperty(box2d.b2PolygonContact, "Destroy", box2d.b2PolygonContact.Destroy);
box2d.b2PolygonContact.prototype.Reset = function(a, b, c, e) {
    box2d.b2PolygonContact.superClass_.Reset.call(this, a, b, c, e)
};
goog.exportProperty(box2d.b2PolygonContact.prototype, "Reset", box2d.b2PolygonContact.prototype.Reset);
box2d.b2PolygonContact.prototype.Evaluate = function(a, b, c) {
    var e = this.m_fixtureA.GetShape(), d = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e instanceof box2d.b2PolygonShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(d instanceof box2d.b2PolygonShape);
    box2d.b2CollidePolygons(a, e instanceof box2d.b2PolygonShape ? e : null, b, d instanceof box2d.b2PolygonShape ? d : null, c)
};
goog.exportProperty(box2d.b2PolygonContact.prototype, "Evaluate", box2d.b2PolygonContact.prototype.Evaluate);
box2d.b2CollideCircle = {};
box2d.b2CollideCircles = function(a, b, c, e, d) {
    a.pointCount = 0;
    c = box2d.b2MulXV(c, b.m_p, box2d.b2CollideCircles.s_pA);
    d = box2d.b2MulXV(d, e.m_p, box2d.b2CollideCircles.s_pB);
    d = box2d.b2DistanceSquaredVV(c, d);
    c = b.m_radius + e.m_radius;
    d > c * c || (a.type = box2d.b2ManifoldType.e_circles, a.localPoint.Copy(b.m_p), a.localNormal.SetZero(), a.pointCount = 1, a.points[0].localPoint.Copy(e.m_p), a.points[0].id.key = 0)
};
goog.exportSymbol("box2d.b2CollideCircles", box2d.b2CollideCircles);
box2d.b2CollideCircles.s_pA = new box2d.b2Vec2;
box2d.b2CollideCircles.s_pB = new box2d.b2Vec2;
box2d.b2CollidePolygonAndCircle = function(a, b, c, e, d) {
    a.pointCount = 0;
    d = box2d.b2MulXV(d, e.m_p, box2d.b2CollidePolygonAndCircle.s_c);
    c = box2d.b2MulTXV(c, d, box2d.b2CollidePolygonAndCircle.s_cLocal);
    var f = 0, g = -box2d.b2_maxFloat;
    d = b.m_radius + e.m_radius;
    var h = b.m_count, l = b.m_vertices;
    b = b.m_normals;
    for (var k = 0; k < h; ++k) {
        var m = box2d.b2DotVV(b[k], box2d.b2SubVV(c, l[k], box2d.b2Vec2.s_t0));
        if (m > d)
            return;
        m > g && (g = m, f = k)
    }
    k = f;
    m = l[k];
    h = l[(k + 1) % h];
    g < box2d.b2_epsilon ? (a.pointCount = 1, a.type = box2d.b2ManifoldType.e_faceA, a.localNormal.Copy(b[f]),
            box2d.b2MidVV(m, h, a.localPoint), a.points[0].localPoint.Copy(e.m_p), a.points[0].id.key = 0) : (g = box2d.b2DotVV(box2d.b2SubVV(c, m, box2d.b2Vec2.s_t0), box2d.b2SubVV(h, m, box2d.b2Vec2.s_t1)), f = box2d.b2DotVV(box2d.b2SubVV(c, h, box2d.b2Vec2.s_t0), box2d.b2SubVV(m, h, box2d.b2Vec2.s_t1)), 0 >= g ? box2d.b2DistanceSquaredVV(c, m) > d * d || (a.pointCount = 1, a.type = box2d.b2ManifoldType.e_faceA, box2d.b2SubVV(c, m, a.localNormal).SelfNormalize(), a.localPoint.Copy(m), a.points[0].localPoint.Copy(e.m_p), a.points[0].id.key = 0) : 0 >= f ? box2d.b2DistanceSquaredVV(c,
            h) > d * d || (a.pointCount = 1, a.type = box2d.b2ManifoldType.e_faceA, box2d.b2SubVV(c, h, a.localNormal).SelfNormalize(), a.localPoint.Copy(h), a.points[0].localPoint.Copy(e.m_p), a.points[0].id.key = 0) : (f = box2d.b2MidVV(m, h, box2d.b2CollidePolygonAndCircle.s_faceCenter), g = box2d.b2DotVV(box2d.b2SubVV(c, f, box2d.b2Vec2.s_t1), b[k]), g > d || (a.pointCount = 1, a.type = box2d.b2ManifoldType.e_faceA, a.localNormal.Copy(b[k]).SelfNormalize(), a.localPoint.Copy(f), a.points[0].localPoint.Copy(e.m_p), a.points[0].id.key = 0)))
};
goog.exportSymbol("box2d.b2CollidePolygonAndCircle", box2d.b2CollidePolygonAndCircle);
box2d.b2CollidePolygonAndCircle.s_c = new box2d.b2Vec2;
box2d.b2CollidePolygonAndCircle.s_cLocal = new box2d.b2Vec2;
box2d.b2CollidePolygonAndCircle.s_faceCenter = new box2d.b2Vec2;
box2d.b2CircleContact = function() {
    box2d.b2Contact.call(this)
};
goog.inherits(box2d.b2CircleContact, box2d.b2Contact);
goog.exportSymbol("box2d.b2CircleContact", box2d.b2CircleContact);
box2d.b2CircleContact.Create = function(a) {
    return new box2d.b2CircleContact
};
goog.exportProperty(box2d.b2CircleContact, "Create", box2d.b2CircleContact.Create);
box2d.b2CircleContact.Destroy = function(a, b) {
};
goog.exportProperty(box2d.b2CircleContact, "Destroy", box2d.b2CircleContact.Destroy);
box2d.b2CircleContact.prototype.Reset = function(a, b, c, e) {
    box2d.b2CircleContact.superClass_.Reset.call(this, a, b, c, e)
};
goog.exportProperty(box2d.b2CircleContact.prototype, "Reset", box2d.b2CircleContact.prototype.Reset);
box2d.b2CircleContact.prototype.Evaluate = function(a, b, c) {
    var e = this.m_fixtureA.GetShape(), d = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e instanceof box2d.b2CircleShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(d instanceof box2d.b2CircleShape);
    box2d.b2CollideCircles(a, e instanceof box2d.b2CircleShape ? e : null, b, d instanceof box2d.b2CircleShape ? d : null, c)
};
goog.exportProperty(box2d.b2CircleContact.prototype, "Evaluate", box2d.b2CircleContact.prototype.Evaluate);
box2d.b2ChainAndCircleContact = function() {
    box2d.b2Contact.call(this)
};
goog.inherits(box2d.b2ChainAndCircleContact, box2d.b2Contact);
goog.exportSymbol("box2d.b2ChainAndCircleContact", box2d.b2ChainAndCircleContact);
box2d.b2ChainAndCircleContact.Create = function(a) {
    return new box2d.b2ChainAndCircleContact
};
goog.exportProperty(box2d.b2ChainAndCircleContact, "Create", box2d.b2ChainAndCircleContact.Create);
box2d.b2ChainAndCircleContact.Destroy = function(a, b) {
};
goog.exportProperty(box2d.b2ChainAndCircleContact, "Destroy", box2d.b2ChainAndCircleContact.Destroy);
box2d.b2ChainAndCircleContact.prototype.Reset = function(a, b, c, e) {
    box2d.b2ChainAndCircleContact.superClass_.Reset.call(this, a, b, c, e);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.GetType() == box2d.b2ShapeType.e_chainShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(c.GetType() == box2d.b2ShapeType.e_circleShape)
};
goog.exportProperty(box2d.b2ChainAndCircleContact.prototype, "Reset", box2d.b2ChainAndCircleContact.prototype.Reset);
box2d.b2ChainAndCircleContact.prototype.Evaluate = function(a, b, c) {
    var e = this.m_fixtureA.GetShape(), d = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e instanceof box2d.b2ChainShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(d instanceof box2d.b2CircleShape);
    var f = box2d.b2ChainAndCircleContact.prototype.Evaluate.s_edge;
    (e instanceof box2d.b2ChainShape ? e : null).GetChildEdge(f, this.m_indexA);
    box2d.b2CollideEdgeAndCircle(a, f, b, d instanceof box2d.b2CircleShape ? d : null, c)
};
goog.exportProperty(box2d.b2ChainAndCircleContact.prototype, "Evaluate", box2d.b2ChainAndCircleContact.prototype.Evaluate);
box2d.b2ChainAndCircleContact.prototype.Evaluate.s_edge = new box2d.b2EdgeShape;
box2d.b2EdgeAndCircleContact = function() {
    box2d.b2Contact.call(this)
};
goog.inherits(box2d.b2EdgeAndCircleContact, box2d.b2Contact);
goog.exportSymbol("box2d.b2EdgeAndCircleContact", box2d.b2EdgeAndCircleContact);
box2d.b2EdgeAndCircleContact.Create = function(a) {
    return new box2d.b2EdgeAndCircleContact
};
goog.exportProperty(box2d.b2EdgeAndCircleContact, "Create", box2d.b2EdgeAndCircleContact.Create);
box2d.b2EdgeAndCircleContact.Destroy = function(a, b) {
};
goog.exportProperty(box2d.b2EdgeAndCircleContact, "Destroy", box2d.b2EdgeAndCircleContact.Destroy);
box2d.b2EdgeAndCircleContact.prototype.Reset = function(a, b, c, e) {
    box2d.b2EdgeAndCircleContact.superClass_.Reset.call(this, a, b, c, e);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.GetType() == box2d.b2ShapeType.e_edgeShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(c.GetType() == box2d.b2ShapeType.e_circleShape)
};
goog.exportProperty(box2d.b2EdgeAndCircleContact.prototype, "Reset", box2d.b2EdgeAndCircleContact.prototype.Reset);
box2d.b2EdgeAndCircleContact.prototype.Evaluate = function(a, b, c) {
    var e = this.m_fixtureA.GetShape(), d = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e instanceof box2d.b2EdgeShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(d instanceof box2d.b2CircleShape);
    box2d.b2CollideEdgeAndCircle(a, e instanceof box2d.b2EdgeShape ? e : null, b, d instanceof box2d.b2CircleShape ? d : null, c)
};
goog.exportProperty(box2d.b2EdgeAndCircleContact.prototype, "Evaluate", box2d.b2EdgeAndCircleContact.prototype.Evaluate);
box2d.b2VelocityConstraintPoint = function() {
    this.rA = new box2d.b2Vec2;
    this.rB = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2VelocityConstraintPoint", box2d.b2VelocityConstraintPoint);
box2d.b2VelocityConstraintPoint.prototype.rA = null;
goog.exportProperty(box2d.b2VelocityConstraintPoint.prototype, "rA", box2d.b2VelocityConstraintPoint.prototype.rA);
box2d.b2VelocityConstraintPoint.prototype.rB = null;
goog.exportProperty(box2d.b2VelocityConstraintPoint.prototype, "rB", box2d.b2VelocityConstraintPoint.prototype.rB);
box2d.b2VelocityConstraintPoint.prototype.normalImpulse = 0;
goog.exportProperty(box2d.b2VelocityConstraintPoint.prototype, "normalImpulse", box2d.b2VelocityConstraintPoint.prototype.normalImpulse);
box2d.b2VelocityConstraintPoint.prototype.tangentImpulse = 0;
goog.exportProperty(box2d.b2VelocityConstraintPoint.prototype, "tangentImpulse", box2d.b2VelocityConstraintPoint.prototype.tangentImpulse);
box2d.b2VelocityConstraintPoint.prototype.normalMass = 0;
goog.exportProperty(box2d.b2VelocityConstraintPoint.prototype, "normalMass", box2d.b2VelocityConstraintPoint.prototype.normalMass);
box2d.b2VelocityConstraintPoint.prototype.tangentMass = 0;
goog.exportProperty(box2d.b2VelocityConstraintPoint.prototype, "tangentMass", box2d.b2VelocityConstraintPoint.prototype.tangentMass);
box2d.b2VelocityConstraintPoint.prototype.velocityBias = 0;
goog.exportProperty(box2d.b2VelocityConstraintPoint.prototype, "velocityBias", box2d.b2VelocityConstraintPoint.prototype.velocityBias);
box2d.b2VelocityConstraintPoint.MakeArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return new box2d.b2VelocityConstraintPoint
    })
};
goog.exportProperty(box2d.b2VelocityConstraintPoint, "MakeArray", box2d.b2VelocityConstraintPoint.MakeArray);
box2d.b2ContactVelocityConstraint = function() {
    this.points = box2d.b2VelocityConstraintPoint.MakeArray(box2d.b2_maxManifoldPoints);
    this.normal = new box2d.b2Vec2;
    this.tangent = new box2d.b2Vec2;
    this.normalMass = new box2d.b2Mat22;
    this.K = new box2d.b2Mat22
};
goog.exportSymbol("box2d.b2ContactVelocityConstraint", box2d.b2ContactVelocityConstraint);
box2d.b2ContactVelocityConstraint.prototype.points = null;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "points", box2d.b2ContactVelocityConstraint.prototype.points);
box2d.b2ContactVelocityConstraint.prototype.normal = null;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "normal", box2d.b2ContactVelocityConstraint.prototype.normal);
box2d.b2ContactVelocityConstraint.prototype.tangent = null;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "tangent", box2d.b2ContactVelocityConstraint.prototype.tangent);
box2d.b2ContactVelocityConstraint.prototype.normalMass = null;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "normalMass", box2d.b2ContactVelocityConstraint.prototype.normalMass);
box2d.b2ContactVelocityConstraint.prototype.K = null;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "K", box2d.b2ContactVelocityConstraint.prototype.K);
box2d.b2ContactVelocityConstraint.prototype.indexA = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "indexA", box2d.b2ContactVelocityConstraint.prototype.indexA);
box2d.b2ContactVelocityConstraint.prototype.indexB = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "indexB", box2d.b2ContactVelocityConstraint.prototype.indexB);
box2d.b2ContactVelocityConstraint.prototype.invMassA = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "invMassA", box2d.b2ContactVelocityConstraint.prototype.invMassA);
box2d.b2ContactVelocityConstraint.prototype.invMassB = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "invMassB", box2d.b2ContactVelocityConstraint.prototype.invMassB);
box2d.b2ContactVelocityConstraint.prototype.invIA = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "invIA", box2d.b2ContactVelocityConstraint.prototype.invIA);
box2d.b2ContactVelocityConstraint.prototype.invIB = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "invIB", box2d.b2ContactVelocityConstraint.prototype.invIB);
box2d.b2ContactVelocityConstraint.prototype.friction = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "friction", box2d.b2ContactVelocityConstraint.prototype.friction);
box2d.b2ContactVelocityConstraint.prototype.restitution = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "restitution", box2d.b2ContactVelocityConstraint.prototype.restitution);
box2d.b2ContactVelocityConstraint.prototype.tangentSpeed = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "tangentSpeed", box2d.b2ContactVelocityConstraint.prototype.tangentSpeed);
box2d.b2ContactVelocityConstraint.prototype.pointCount = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "pointCount", box2d.b2ContactVelocityConstraint.prototype.pointCount);
box2d.b2ContactVelocityConstraint.prototype.contactIndex = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "contactIndex", box2d.b2ContactVelocityConstraint.prototype.contactIndex);
box2d.b2ContactVelocityConstraint.MakeArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return new box2d.b2ContactVelocityConstraint
    })
};
goog.exportProperty(box2d.b2ContactVelocityConstraint, "MakeArray", box2d.b2ContactVelocityConstraint.MakeArray);
box2d.b2ContactPositionConstraint = function() {
    this.localPoints = box2d.b2Vec2.MakeArray(box2d.b2_maxManifoldPoints);
    this.localNormal = new box2d.b2Vec2;
    this.localPoint = new box2d.b2Vec2;
    this.localCenterA = new box2d.b2Vec2;
    this.localCenterB = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2ContactPositionConstraint", box2d.b2ContactPositionConstraint);
box2d.b2ContactPositionConstraint.prototype.localPoints = null;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "localPoints", box2d.b2ContactPositionConstraint.prototype.localPoints);
box2d.b2ContactPositionConstraint.prototype.localNormal = null;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "localNormal", box2d.b2ContactPositionConstraint.prototype.localNormal);
box2d.b2ContactPositionConstraint.prototype.localPoint = null;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "localPoint", box2d.b2ContactPositionConstraint.prototype.localPoint);
box2d.b2ContactPositionConstraint.prototype.indexA = 0;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "indexA", box2d.b2ContactPositionConstraint.prototype.indexA);
box2d.b2ContactPositionConstraint.prototype.indexB = 0;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "indexB", box2d.b2ContactPositionConstraint.prototype.indexB);
box2d.b2ContactPositionConstraint.prototype.invMassA = 0;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "invMassA", box2d.b2ContactPositionConstraint.prototype.invMassA);
box2d.b2ContactPositionConstraint.prototype.invMassB = 0;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "invMassB", box2d.b2ContactPositionConstraint.prototype.invMassB);
box2d.b2ContactPositionConstraint.prototype.localCenterA = null;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "localCenterA", box2d.b2ContactPositionConstraint.prototype.localCenterA);
box2d.b2ContactPositionConstraint.prototype.localCenterB = null;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "localCenterB", box2d.b2ContactPositionConstraint.prototype.localCenterB);
box2d.b2ContactPositionConstraint.prototype.invIA = 0;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "invIA", box2d.b2ContactPositionConstraint.prototype.invIA);
box2d.b2ContactPositionConstraint.prototype.invIB = 0;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "invIB", box2d.b2ContactPositionConstraint.prototype.invIB);
box2d.b2ContactPositionConstraint.prototype.type = box2d.b2ManifoldType.e_unknown;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "type", box2d.b2ContactPositionConstraint.prototype.type);
box2d.b2ContactPositionConstraint.prototype.radiusA = 0;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "radiusA", box2d.b2ContactPositionConstraint.prototype.radiusA);
box2d.b2ContactPositionConstraint.prototype.radiusB = 0;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "radiusB", box2d.b2ContactPositionConstraint.prototype.radiusB);
box2d.b2ContactPositionConstraint.prototype.pointCount = 0;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "pointCount", box2d.b2ContactPositionConstraint.prototype.pointCount);
box2d.b2ContactPositionConstraint.MakeArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return new box2d.b2ContactPositionConstraint
    })
};
goog.exportProperty(box2d.b2ContactPositionConstraint, "MakeArray", box2d.b2ContactPositionConstraint.MakeArray);
box2d.b2ContactSolverDef = function() {
    this.step = new box2d.b2TimeStep
};
goog.exportSymbol("box2d.b2ContactSolverDef", box2d.b2ContactSolverDef);
box2d.b2ContactSolverDef.prototype.step = null;
goog.exportProperty(box2d.b2ContactSolverDef.prototype, "step", box2d.b2ContactSolverDef.prototype.step);
box2d.b2ContactSolverDef.prototype.contacts = null;
goog.exportProperty(box2d.b2ContactSolverDef.prototype, "contacts", box2d.b2ContactSolverDef.prototype.contacts);
box2d.b2ContactSolverDef.prototype.count = 0;
goog.exportProperty(box2d.b2ContactSolverDef.prototype, "count", box2d.b2ContactSolverDef.prototype.count);
box2d.b2ContactSolverDef.prototype.positions = null;
goog.exportProperty(box2d.b2ContactSolverDef.prototype, "positions", box2d.b2ContactSolverDef.prototype.positions);
box2d.b2ContactSolverDef.prototype.velocities = null;
goog.exportProperty(box2d.b2ContactSolverDef.prototype, "velocities", box2d.b2ContactSolverDef.prototype.velocities);
box2d.b2ContactSolverDef.prototype.allocator = null;
goog.exportProperty(box2d.b2ContactSolverDef.prototype, "allocator", box2d.b2ContactSolverDef.prototype.allocator);
box2d.b2ContactSolver = function() {
    this.m_step = new box2d.b2TimeStep;
    this.m_positionConstraints = box2d.b2ContactPositionConstraint.MakeArray(1024);
    this.m_velocityConstraints = box2d.b2ContactVelocityConstraint.MakeArray(1024)
};
goog.exportSymbol("box2d.b2ContactSolver", box2d.b2ContactSolver);
box2d.b2ContactSolver.prototype.m_step = null;
goog.exportProperty(box2d.b2ContactSolver.prototype, "m_step", box2d.b2ContactSolver.prototype.m_step);
box2d.b2ContactSolver.prototype.m_positions = null;
goog.exportProperty(box2d.b2ContactSolver.prototype, "m_positions", box2d.b2ContactSolver.prototype.m_positions);
box2d.b2ContactSolver.prototype.m_velocities = null;
goog.exportProperty(box2d.b2ContactSolver.prototype, "m_velocities", box2d.b2ContactSolver.prototype.m_velocities);
box2d.b2ContactSolver.prototype.m_allocator = null;
goog.exportProperty(box2d.b2ContactSolver.prototype, "m_allocator", box2d.b2ContactSolver.prototype.m_allocator);
box2d.b2ContactSolver.prototype.m_positionConstraints = null;
goog.exportProperty(box2d.b2ContactSolver.prototype, "m_positionConstraints", box2d.b2ContactSolver.prototype.m_positionConstraints);
box2d.b2ContactSolver.prototype.m_velocityConstraints = null;
goog.exportProperty(box2d.b2ContactSolver.prototype, "m_velocityConstraints", box2d.b2ContactSolver.prototype.m_velocityConstraints);
box2d.b2ContactSolver.prototype.m_contacts = null;
goog.exportProperty(box2d.b2ContactSolver.prototype, "m_contacts", box2d.b2ContactSolver.prototype.m_contacts);
box2d.b2ContactSolver.prototype.m_count = 0;
goog.exportProperty(box2d.b2ContactSolver.prototype, "m_count", box2d.b2ContactSolver.prototype.m_count);
box2d.b2ContactSolver.prototype.Initialize = function(a) {
    this.m_step.Copy(a.step);
    this.m_allocator = a.allocator;
    this.m_count = a.count;
    if (this.m_positionConstraints.length < this.m_count) {
        var b = box2d.b2Max(2 * this.m_positionConstraints.length, this.m_count);
        for (box2d.DEBUG && window.console.log("box2d.b2ContactSolver.m_positionConstraints: " + b); this.m_positionConstraints.length < b; )
            this.m_positionConstraints[this.m_positionConstraints.length] = new box2d.b2ContactPositionConstraint
    }
    if (this.m_velocityConstraints.length <
            this.m_count)
        for (b = box2d.b2Max(2 * this.m_velocityConstraints.length, this.m_count), box2d.DEBUG && window.console.log("box2d.b2ContactSolver.m_velocityConstraints: " + b); this.m_velocityConstraints.length < b; )
            this.m_velocityConstraints[this.m_velocityConstraints.length] = new box2d.b2ContactVelocityConstraint;
    this.m_positions = a.positions;
    this.m_velocities = a.velocities;
    this.m_contacts = a.contacts;
    var c, e, d, f, g, h, l, k;
    a = 0;
    for (b = this.m_count; a < b; ++a)
        for (d = this.m_contacts[a], f = d.m_fixtureA, g = d.m_fixtureB, c = f.GetShape(),
                e = g.GetShape(), c = c.m_radius, e = e.m_radius, h = f.GetBody(), l = g.GetBody(), g = d.GetManifold(), k = g.pointCount, box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < k), f = this.m_velocityConstraints[a], f.friction = d.m_friction, f.restitution = d.m_restitution, f.tangentSpeed = d.m_tangentSpeed, f.indexA = h.m_islandIndex, f.indexB = l.m_islandIndex, f.invMassA = h.m_invMass, f.invMassB = l.m_invMass, f.invIA = h.m_invI, f.invIB = l.m_invI, f.contactIndex = a, f.pointCount = k, f.K.SetZero(), f.normalMass.SetZero(), d = this.m_positionConstraints[a], d.indexA =
                h.m_islandIndex, d.indexB = l.m_islandIndex, d.invMassA = h.m_invMass, d.invMassB = l.m_invMass, d.localCenterA.Copy(h.m_sweep.localCenter), d.localCenterB.Copy(l.m_sweep.localCenter), d.invIA = h.m_invI, d.invIB = l.m_invI, d.localNormal.Copy(g.localNormal), d.localPoint.Copy(g.localPoint), d.pointCount = k, d.radiusA = c, d.radiusB = e, d.type = g.type, c = 0, e = k; c < e; ++c)
            h = g.points[c], k = f.points[c], this.m_step.warmStarting ? (k.normalImpulse = this.m_step.dtRatio * h.normalImpulse, k.tangentImpulse = this.m_step.dtRatio * h.tangentImpulse) :
                    (k.normalImpulse = 0, k.tangentImpulse = 0), k.rA.SetZero(), k.rB.SetZero(), k.normalMass = 0, k.tangentMass = 0, k.velocityBias = 0, d.localPoints[c].Copy(h.localPoint);
    return this
};
goog.exportProperty(box2d.b2ContactSolver.prototype, "Initialize", box2d.b2ContactSolver.prototype.Initialize);
box2d.b2ContactSolver.prototype.InitializeVelocityConstraints = function() {
    var a, b, c, e, d, f, g, h, l, k, m, n, p, q, r, t, s, u, v, y, D = box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfA, x = box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfB, w = box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_worldManifold;
    a = 0;
    for (b = this.m_count; a < b; ++a) {
        d = this.m_velocityConstraints[a];
        f = this.m_positionConstraints[a];
        c = f.radiusA;
        e = f.radiusB;
        g = this.m_contacts[d.contactIndex].GetManifold();
        h = d.indexA;
        l = d.indexB;
        k = d.invMassA;
        m = d.invMassB;
        n = d.invIA;
        p = d.invIB;
        q = f.localCenterA;
        r = f.localCenterB;
        f = this.m_positions[h].c;
        t = this.m_positions[h].a;
        s = this.m_velocities[h].v;
        h = this.m_velocities[h].w;
        u = this.m_positions[l].c;
        v = this.m_positions[l].a;
        y = this.m_velocities[l].v;
        l = this.m_velocities[l].w;
        box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < g.pointCount);
        D.q.SetAngleRadians(t);
        x.q.SetAngleRadians(v);
        box2d.b2SubVV(f, box2d.b2MulRV(D.q, q, box2d.b2Vec2.s_t0), D.p);
        box2d.b2SubVV(u, box2d.b2MulRV(x.q, r, box2d.b2Vec2.s_t0),
                x.p);
        w.Initialize(g, D, c, x, e);
        d.normal.Copy(w.normal);
        box2d.b2CrossVOne(d.normal, d.tangent);
        e = d.pointCount;
        for (c = 0; c < e; ++c)
            g = d.points[c], box2d.b2SubVV(w.points[c], f, g.rA), box2d.b2SubVV(w.points[c], u, g.rB), q = box2d.b2CrossVV(g.rA, d.normal), r = box2d.b2CrossVV(g.rB, d.normal), q = k + m + n * q * q + p * r * r, g.normalMass = 0 < q ? 1 / q : 0, r = d.tangent, q = box2d.b2CrossVV(g.rA, r), r = box2d.b2CrossVV(g.rB, r), q = k + m + n * q * q + p * r * r, g.tangentMass = 0 < q ? 1 / q : 0, g.velocityBias = 0, q = box2d.b2DotVV(d.normal, box2d.b2SubVV(box2d.b2AddVCrossSV(y, l, g.rB,
                    box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(s, h, g.rA, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t0)), q < -box2d.b2_velocityThreshold && (g.velocityBias += -d.restitution * q);
        2 == d.pointCount && (s = d.points[0], u = d.points[1], f = box2d.b2CrossVV(s.rA, d.normal), s = box2d.b2CrossVV(s.rB, d.normal), h = box2d.b2CrossVV(u.rA, d.normal), l = box2d.b2CrossVV(u.rB, d.normal), u = k + m + n * f * f + p * s * s, y = k + m + n * h * h + p * l * l, k = k + m + n * f * h + p * s * l, u * u < 1E3 * (u * y - k * k) ? (d.K.ex.SetXY(u, k), d.K.ey.SetXY(k, y), d.K.GetInverse(d.normalMass)) : d.pointCount = 1)
    }
};
goog.exportProperty(box2d.b2ContactSolver.prototype, "InitializeVelocityConstraints", box2d.b2ContactSolver.prototype.InitializeVelocityConstraints);
box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfA = new box2d.b2Transform;
box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfB = new box2d.b2Transform;
box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_worldManifold = new box2d.b2WorldManifold;
box2d.b2ContactSolver.prototype.WarmStart = function() {
    var a, b, c, e, d, f, g, h, l, k, m, n, p, q, r, t, s, u, v = box2d.b2ContactSolver.prototype.WarmStart.s_P;
    a = 0;
    for (b = this.m_count; a < b; ++a) {
        d = this.m_velocityConstraints[a];
        f = d.indexA;
        g = d.indexB;
        h = d.invMassA;
        l = d.invIA;
        k = d.invMassB;
        m = d.invIB;
        e = d.pointCount;
        n = this.m_velocities[f].v;
        p = this.m_velocities[f].w;
        q = this.m_velocities[g].v;
        r = this.m_velocities[g].w;
        t = d.normal;
        s = d.tangent;
        for (c = 0; c < e; ++c)
            u = d.points[c], box2d.b2AddVV(box2d.b2MulSV(u.normalImpulse, t, box2d.b2Vec2.s_t0),
                    box2d.b2MulSV(u.tangentImpulse, s, box2d.b2Vec2.s_t1), v), p -= l * box2d.b2CrossVV(u.rA, v), n.SelfMulSub(h, v), r += m * box2d.b2CrossVV(u.rB, v), q.SelfMulAdd(k, v);
        this.m_velocities[f].w = p;
        this.m_velocities[g].w = r
    }
};
goog.exportProperty(box2d.b2ContactSolver.prototype, "WarmStart", box2d.b2ContactSolver.prototype.WarmStart);
box2d.b2ContactSolver.prototype.WarmStart.s_P = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints = function() {
    var a, b, c, e, d, f, g, h, l, k, m, n, p, q, r, t, s, u, v, y = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv, D = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv1, x = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv2, w, C, A = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P, E = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_a, B = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_b, z = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_x,
            G = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_d, F = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1, H = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P2, I = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1P2;
    a = 0;
    for (b = this.m_count; a < b; ++a) {
        d = this.m_velocityConstraints[a];
        f = d.indexA;
        g = d.indexB;
        h = d.invMassA;
        l = d.invIA;
        k = d.invMassB;
        m = d.invIB;
        n = d.pointCount;
        p = this.m_velocities[f].v;
        q = this.m_velocities[f].w;
        r = this.m_velocities[g].v;
        t = this.m_velocities[g].w;
        s = d.normal;
        u = d.tangent;
        v = d.friction;
        box2d.ENABLE_ASSERTS && box2d.b2Assert(1 == n || 2 == n);
        c = 0;
        for (e = n; c < e; ++c)
            n = d.points[c], box2d.b2SubVV(box2d.b2AddVCrossSV(r, t, n.rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(p, q, n.rA, box2d.b2Vec2.s_t1), y), w = box2d.b2DotVV(y, u) - d.tangentSpeed, w = n.tangentMass * -w, C = v * n.normalImpulse, C = box2d.b2Clamp(n.tangentImpulse + w, -C, C), w = C - n.tangentImpulse, n.tangentImpulse = C, box2d.b2MulSV(w, u, A), p.SelfMulSub(h, A), q -= l * box2d.b2CrossVV(n.rA, A), r.SelfMulAdd(k, A), t += m * box2d.b2CrossVV(n.rB, A);
        if (1 == d.pointCount)
            n = d.points[0], box2d.b2SubVV(box2d.b2AddVCrossSV(r, t, n.rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(p, q, n.rA, box2d.b2Vec2.s_t1), y), d = box2d.b2DotVV(y, s), w = -n.normalMass * (d - n.velocityBias), C = box2d.b2Max(n.normalImpulse + w, 0), w = C - n.normalImpulse, n.normalImpulse = C, box2d.b2MulSV(w, s, A), p.SelfMulSub(h, A), q -= l * box2d.b2CrossVV(n.rA, A), r.SelfMulAdd(k, A), t += m * box2d.b2CrossVV(n.rB, A);
        else
            for (c = d.points[0], u = d.points[1], E.SetXY(c.normalImpulse, u.normalImpulse), box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <=
                    E.x && 0 <= E.y), box2d.b2SubVV(box2d.b2AddVCrossSV(r, t, c.rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(p, q, c.rA, box2d.b2Vec2.s_t1), D), box2d.b2SubVV(box2d.b2AddVCrossSV(r, t, u.rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(p, q, u.rA, box2d.b2Vec2.s_t1), x), v = box2d.b2DotVV(D, s), n = box2d.b2DotVV(x, s), B.x = v - c.velocityBias, B.y = n - u.velocityBias, B.SelfSub(box2d.b2MulMV(d.K, E, box2d.b2Vec2.s_t0)); ; ) {
                box2d.b2MulMV(d.normalMass, B, z).SelfNeg();
                if (0 <= z.x && 0 <= z.y) {
                    box2d.b2SubVV(z, E, G);
                    box2d.b2MulSV(G.x, s, F);
                    box2d.b2MulSV(G.y, s,
                            H);
                    box2d.b2AddVV(F, H, I);
                    p.SelfMulSub(h, I);
                    q -= l * (box2d.b2CrossVV(c.rA, F) + box2d.b2CrossVV(u.rA, H));
                    r.SelfMulAdd(k, I);
                    t += m * (box2d.b2CrossVV(c.rB, F) + box2d.b2CrossVV(u.rB, H));
                    c.normalImpulse = z.x;
                    u.normalImpulse = z.y;
                    break
                }
                z.x = -c.normalMass * B.x;
                z.y = 0;
                n = d.K.ex.y * z.x + B.y;
                if (0 <= z.x && 0 <= n) {
                    box2d.b2SubVV(z, E, G);
                    box2d.b2MulSV(G.x, s, F);
                    box2d.b2MulSV(G.y, s, H);
                    box2d.b2AddVV(F, H, I);
                    p.SelfMulSub(h, I);
                    q -= l * (box2d.b2CrossVV(c.rA, F) + box2d.b2CrossVV(u.rA, H));
                    r.SelfMulAdd(k, I);
                    t += m * (box2d.b2CrossVV(c.rB, F) + box2d.b2CrossVV(u.rB,
                            H));
                    c.normalImpulse = z.x;
                    u.normalImpulse = z.y;
                    break
                }
                z.x = 0;
                z.y = -u.normalMass * B.y;
                v = d.K.ey.x * z.y + B.x;
                if (0 <= z.y && 0 <= v) {
                    box2d.b2SubVV(z, E, G);
                    box2d.b2MulSV(G.x, s, F);
                    box2d.b2MulSV(G.y, s, H);
                    box2d.b2AddVV(F, H, I);
                    p.SelfMulSub(h, I);
                    q -= l * (box2d.b2CrossVV(c.rA, F) + box2d.b2CrossVV(u.rA, H));
                    r.SelfMulAdd(k, I);
                    t += m * (box2d.b2CrossVV(c.rB, F) + box2d.b2CrossVV(u.rB, H));
                    c.normalImpulse = z.x;
                    u.normalImpulse = z.y;
                    break
                }
                z.x = 0;
                z.y = 0;
                v = B.x;
                n = B.y;
                if (0 <= v && 0 <= n) {
                    box2d.b2SubVV(z, E, G);
                    box2d.b2MulSV(G.x, s, F);
                    box2d.b2MulSV(G.y, s, H);
                    box2d.b2AddVV(F,
                            H, I);
                    p.SelfMulSub(h, I);
                    q -= l * (box2d.b2CrossVV(c.rA, F) + box2d.b2CrossVV(u.rA, H));
                    r.SelfMulAdd(k, I);
                    t += m * (box2d.b2CrossVV(c.rB, F) + box2d.b2CrossVV(u.rB, H));
                    c.normalImpulse = z.x;
                    u.normalImpulse = z.y;
                    break
                }
                break
            }
        this.m_velocities[f].w = q;
        this.m_velocities[g].w = t
    }
};
goog.exportProperty(box2d.b2ContactSolver.prototype, "SolveVelocityConstraints", box2d.b2ContactSolver.prototype.SolveVelocityConstraints);
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv1 = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv2 = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_a = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_b = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_x = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_d = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1 = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P2 = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1P2 = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.StoreImpulses = function() {
    var a, b, c, e, d, f;
    a = 0;
    for (b = this.m_count; a < b; ++a)
        for (d = this.m_velocityConstraints[a], f = this.m_contacts[d.contactIndex].GetManifold(), c = 0, e = d.pointCount; c < e; ++c)
            f.points[c].normalImpulse = d.points[c].normalImpulse, f.points[c].tangentImpulse = d.points[c].tangentImpulse
};
goog.exportProperty(box2d.b2ContactSolver.prototype, "StoreImpulses", box2d.b2ContactSolver.prototype.StoreImpulses);
box2d.b2PositionSolverManifold = function() {
    this.normal = new box2d.b2Vec2;
    this.point = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2PositionSolverManifold", box2d.b2PositionSolverManifold);
box2d.b2PositionSolverManifold.prototype.normal = null;
goog.exportProperty(box2d.b2PositionSolverManifold.prototype, "normal", box2d.b2PositionSolverManifold.prototype.normal);
box2d.b2PositionSolverManifold.prototype.point = null;
goog.exportProperty(box2d.b2PositionSolverManifold.prototype, "point", box2d.b2PositionSolverManifold.prototype.point);
box2d.b2PositionSolverManifold.prototype.separation = 0;
goog.exportProperty(box2d.b2PositionSolverManifold.prototype, "separation", box2d.b2PositionSolverManifold.prototype.separation);
box2d.b2PositionSolverManifold.prototype.Initialize = function(a, b, c, e) {
    var d = box2d.b2PositionSolverManifold.prototype.Initialize.s_pointA, f = box2d.b2PositionSolverManifold.prototype.Initialize.s_pointB, g = box2d.b2PositionSolverManifold.prototype.Initialize.s_planePoint, h = box2d.b2PositionSolverManifold.prototype.Initialize.s_clipPoint;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < a.pointCount);
    switch (a.type) {
        case box2d.b2ManifoldType.e_circles:
            box2d.b2MulXV(b, a.localPoint, d);
            box2d.b2MulXV(c, a.localPoints[0],
                    f);
            box2d.b2SubVV(f, d, this.normal).SelfNormalize();
            box2d.b2MidVV(d, f, this.point);
            this.separation = box2d.b2DotVV(box2d.b2SubVV(f, d, box2d.b2Vec2.s_t0), this.normal) - a.radiusA - a.radiusB;
            break;
        case box2d.b2ManifoldType.e_faceA:
            box2d.b2MulRV(b.q, a.localNormal, this.normal);
            box2d.b2MulXV(b, a.localPoint, g);
            box2d.b2MulXV(c, a.localPoints[e], h);
            this.separation = box2d.b2DotVV(box2d.b2SubVV(h, g, box2d.b2Vec2.s_t0), this.normal) - a.radiusA - a.radiusB;
            this.point.Copy(h);
            break;
        case box2d.b2ManifoldType.e_faceB:
            box2d.b2MulRV(c.q,
                    a.localNormal, this.normal), box2d.b2MulXV(c, a.localPoint, g), box2d.b2MulXV(b, a.localPoints[e], h), this.separation = box2d.b2DotVV(box2d.b2SubVV(h, g, box2d.b2Vec2.s_t0), this.normal) - a.radiusA - a.radiusB, this.point.Copy(h), this.normal.SelfNeg()
        }
};
goog.exportProperty(box2d.b2PositionSolverManifold.prototype, "Initialize", box2d.b2PositionSolverManifold.prototype.Initialize);
box2d.b2PositionSolverManifold.prototype.Initialize.s_pointA = new box2d.b2Vec2;
box2d.b2PositionSolverManifold.prototype.Initialize.s_pointB = new box2d.b2Vec2;
box2d.b2PositionSolverManifold.prototype.Initialize.s_planePoint = new box2d.b2Vec2;
box2d.b2PositionSolverManifold.prototype.Initialize.s_clipPoint = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolvePositionConstraints = function() {
    var a, b, c, e, d, f, g, h, l, k, m, n, p, q, r, t, s, u = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfA, v = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfB, y = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_psm, D, x, w, C = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rA, A = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rB, E, B = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_P, z =
            0;
    a = 0;
    for (b = this.m_count; a < b; ++a) {
        d = this.m_positionConstraints[a];
        f = d.indexA;
        g = d.indexB;
        h = d.localCenterA;
        l = d.invMassA;
        k = d.invIA;
        m = d.localCenterB;
        n = d.invMassB;
        p = d.invIB;
        e = d.pointCount;
        q = this.m_positions[f].c;
        r = this.m_positions[f].a;
        t = this.m_positions[g].c;
        s = this.m_positions[g].a;
        for (c = 0; c < e; ++c)
            u.q.SetAngleRadians(r), v.q.SetAngleRadians(s), box2d.b2SubVV(q, box2d.b2MulRV(u.q, h, box2d.b2Vec2.s_t0), u.p), box2d.b2SubVV(t, box2d.b2MulRV(v.q, m, box2d.b2Vec2.s_t0), v.p), y.Initialize(d, u, v, c), D = y.normal, x = y.point,
                    w = y.separation, box2d.b2SubVV(x, q, C), box2d.b2SubVV(x, t, A), z = box2d.b2Min(z, w), x = box2d.b2Clamp(box2d.b2_baumgarte * (w + box2d.b2_linearSlop), -box2d.b2_maxLinearCorrection, 0), w = box2d.b2CrossVV(C, D), E = box2d.b2CrossVV(A, D), w = l + n + k * w * w + p * E * E, x = 0 < w ? -x / w : 0, box2d.b2MulSV(x, D, B), q.SelfMulSub(l, B), r -= k * box2d.b2CrossVV(C, B), t.SelfMulAdd(n, B), s += p * box2d.b2CrossVV(A, B);
        this.m_positions[f].a = r;
        this.m_positions[g].a = s
    }
    return z > -3 * box2d.b2_linearSlop
};
goog.exportProperty(box2d.b2ContactSolver.prototype, "SolvePositionConstraints", box2d.b2ContactSolver.prototype.SolvePositionConstraints);
box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfA = new box2d.b2Transform;
box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfB = new box2d.b2Transform;
box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_psm = new box2d.b2PositionSolverManifold;
box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rA = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rB = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints = function(a, b) {
    var c, e, d, f, g, h, l, k, m, n, p, q, r, t, s, u, v, y = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfA, D = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfB, x = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_psm, w, C, A, E = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rA, B = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rB, z, G = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_P,
            F = 0;
    c = 0;
    for (e = this.m_count; c < e; ++c) {
        g = this.m_positionConstraints[c];
        h = g.indexA;
        l = g.indexB;
        k = g.localCenterA;
        m = g.localCenterB;
        f = g.pointCount;
        p = n = 0;
        if (h == a || h == b)
            n = g.invMassA, p = g.invIA;
        r = q = 0;
        if (l == a || l == b)
            q = g.invMassB, r = g.invIB;
        t = this.m_positions[h].c;
        s = this.m_positions[h].a;
        u = this.m_positions[l].c;
        v = this.m_positions[l].a;
        for (d = 0; d < f; ++d)
            y.q.SetAngleRadians(s), D.q.SetAngleRadians(v), box2d.b2SubVV(t, box2d.b2MulRV(y.q, k, box2d.b2Vec2.s_t0), y.p), box2d.b2SubVV(u, box2d.b2MulRV(D.q, m, box2d.b2Vec2.s_t0), D.p),
                    x.Initialize(g, y, D, d), w = x.normal, C = x.point, A = x.separation, box2d.b2SubVV(C, t, E), box2d.b2SubVV(C, u, B), F = box2d.b2Min(F, A), C = box2d.b2Clamp(box2d.b2_toiBaumgarte * (A + box2d.b2_linearSlop), -box2d.b2_maxLinearCorrection, 0), A = box2d.b2CrossVV(E, w), z = box2d.b2CrossVV(B, w), A = n + q + p * A * A + r * z * z, C = 0 < A ? -C / A : 0, box2d.b2MulSV(C, w, G), t.SelfMulSub(n, G), s -= p * box2d.b2CrossVV(E, G), u.SelfMulAdd(q, G), v += r * box2d.b2CrossVV(B, G);
        this.m_positions[h].a = s;
        this.m_positions[l].a = v
    }
    return F >= -1.5 * box2d.b2_linearSlop
};
goog.exportProperty(box2d.b2ContactSolver.prototype, "SolveTOIPositionConstraints", box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints);
box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfA = new box2d.b2Transform;
box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfB = new box2d.b2Transform;
box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_psm = new box2d.b2PositionSolverManifold;
box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rA = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rB = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_P = new box2d.b2Vec2;
box2d.b2WorldCallbacks = {};
box2d.b2DestructionListener = function() {
};
goog.exportSymbol("box2d.b2DestructionListener", box2d.b2DestructionListener);
box2d.b2DestructionListener.prototype.SayGoodbyeJoint = function(a) {
};
goog.exportProperty(box2d.b2DestructionListener.prototype, "SayGoodbyeJoint", box2d.b2DestructionListener.prototype.SayGoodbyeJoint);
box2d.b2DestructionListener.prototype.SayGoodbyeFixture = function(a) {
};
goog.exportProperty(box2d.b2DestructionListener.prototype, "SayGoodbyeFixture", box2d.b2DestructionListener.prototype.SayGoodbyeFixture);
box2d.b2ContactFilter = function() {
};
goog.exportSymbol("box2d.b2ContactFilter", box2d.b2ContactFilter);
box2d.b2ContactFilter.prototype.ShouldCollide = function(a, b) {
    var c = a.GetFilterData(), e = b.GetFilterData();
    return c.groupIndex == e.groupIndex && 0 != c.groupIndex ? 0 < c.groupIndex : 0 != (c.maskBits & e.categoryBits) && 0 != (c.categoryBits & e.maskBits)
};
goog.exportProperty(box2d.b2ContactFilter.prototype, "ShouldCollide", box2d.b2ContactFilter.prototype.ShouldCollide);
box2d.b2ContactFilter.b2_defaultFilter = new box2d.b2ContactFilter;
box2d.b2ContactImpulse = function() {
    this.normalImpulses = box2d.b2MakeNumberArray(box2d.b2_maxManifoldPoints);
    this.tangentImpulses = box2d.b2MakeNumberArray(box2d.b2_maxManifoldPoints)
};
goog.exportSymbol("box2d.b2ContactImpulse", box2d.b2ContactImpulse);
box2d.b2ContactImpulse.prototype.normalImpulses = null;
box2d.b2ContactImpulse.prototype.tangentImpulses = null;
box2d.b2ContactImpulse.prototype.count = 0;
box2d.b2ContactListener = function() {
};
goog.exportSymbol("box2d.b2ContactListener", box2d.b2ContactListener);
box2d.b2ContactListener.prototype.BeginContact = function(a) {
};
goog.exportProperty(box2d.b2ContactListener.prototype, "BeginContact", box2d.b2ContactListener.prototype.BeginContact);
box2d.b2ContactListener.prototype.EndContact = function(a) {
};
goog.exportProperty(box2d.b2ContactListener.prototype, "EndContact", box2d.b2ContactListener.prototype.EndContact);
box2d.b2ContactListener.prototype.PreSolve = function(a, b) {
};
goog.exportProperty(box2d.b2ContactListener.prototype, "PreSolve", box2d.b2ContactListener.prototype.PreSolve);
box2d.b2ContactListener.prototype.PostSolve = function(a, b) {
};
goog.exportProperty(box2d.b2ContactListener.prototype, "PostSolve", box2d.b2ContactListener.prototype.PostSolve);
box2d.b2ContactListener.b2_defaultListener = new box2d.b2ContactListener;
goog.exportProperty(box2d.b2ContactListener, "b2_defaultListener", box2d.b2ContactListener.b2_defaultListener);
box2d.b2QueryCallback = function() {
};
goog.exportSymbol("box2d.b2QueryCallback", box2d.b2QueryCallback);
box2d.b2QueryCallback.prototype.ReportFixture = function(a) {
    return!0
};
goog.exportProperty(box2d.b2QueryCallback.prototype, "ReportFixture", box2d.b2QueryCallback.prototype.ReportFixture);
box2d.b2RayCastCallback = function() {
};
goog.exportSymbol("box2d.b2RayCastCallback", box2d.b2RayCastCallback);
box2d.b2RayCastCallback.prototype.ReportFixture = function(a, b, c, e) {
    return e
};
goog.exportProperty(box2d.b2RayCastCallback.prototype, "ReportFixture", box2d.b2RayCastCallback.prototype.ReportFixture);
box2d.b2Island = function() {
    this.m_bodies = Array(1024);
    this.m_contacts = Array(1024);
    this.m_joints = Array(1024);
    this.m_positions = box2d.b2Position.MakeArray(1024);
    this.m_velocities = box2d.b2Velocity.MakeArray(1024)
};
goog.exportSymbol("box2d.b2Island", box2d.b2Island);
box2d.b2Island.prototype.m_allocator = null;
goog.exportProperty(box2d.b2Island.prototype, "m_allocator", box2d.b2Island.prototype.m_allocator);
box2d.b2Island.prototype.m_listener = null;
goog.exportProperty(box2d.b2Island.prototype, "m_listener", box2d.b2Island.prototype.m_listener);
box2d.b2Island.prototype.m_bodies = null;
goog.exportProperty(box2d.b2Island.prototype, "m_bodies", box2d.b2Island.prototype.m_bodies);
box2d.b2Island.prototype.m_contacts = null;
goog.exportProperty(box2d.b2Island.prototype, "m_contacts", box2d.b2Island.prototype.m_contacts);
box2d.b2Island.prototype.m_joints = null;
goog.exportProperty(box2d.b2Island.prototype, "m_joints", box2d.b2Island.prototype.m_joints);
box2d.b2Island.prototype.m_positions = null;
goog.exportProperty(box2d.b2Island.prototype, "m_positions", box2d.b2Island.prototype.m_positions);
box2d.b2Island.prototype.m_velocities = null;
goog.exportProperty(box2d.b2Island.prototype, "m_velocities", box2d.b2Island.prototype.m_velocities);
box2d.b2Island.prototype.m_bodyCount = 0;
goog.exportProperty(box2d.b2Island.prototype, "m_bodyCount", box2d.b2Island.prototype.m_bodyCount);
box2d.b2Island.prototype.m_jointCount = 0;
goog.exportProperty(box2d.b2Island.prototype, "m_jointCount", box2d.b2Island.prototype.m_jointCount);
box2d.b2Island.prototype.m_contactCount = 0;
goog.exportProperty(box2d.b2Island.prototype, "m_contactCount", box2d.b2Island.prototype.m_contactCount);
box2d.b2Island.prototype.m_bodyCapacity = 0;
goog.exportProperty(box2d.b2Island.prototype, "m_bodyCapacity", box2d.b2Island.prototype.m_bodyCapacity);
box2d.b2Island.prototype.m_contactCapacity = 0;
goog.exportProperty(box2d.b2Island.prototype, "m_contactCapacity", box2d.b2Island.prototype.m_contactCapacity);
box2d.b2Island.prototype.m_jointCapacity = 0;
goog.exportProperty(box2d.b2Island.prototype, "m_jointCapacity", box2d.b2Island.prototype.m_jointCapacity);
box2d.b2Island.prototype.Initialize = function(a, b, c, e, d) {
    this.m_bodyCapacity = a;
    this.m_contactCapacity = b;
    this.m_jointCapacity = c;
    this.m_jointCount = this.m_contactCount = this.m_bodyCount = 0;
    this.m_allocator = e;
    for (this.m_listener = d; this.m_bodies.length < a; )
        this.m_bodies[this.m_bodies.length] = null;
    for (; this.m_contacts.length < b; )
        this.m_contacts[this.m_contacts.length] = null;
    for (; this.m_joints.length < c; )
        this.m_joints[this.m_joints.length] = null;
    if (this.m_positions.length < a)
        for (b = box2d.b2Max(2 * this.m_positions.length,
                a), box2d.DEBUG && window.console.log("box2d.b2Island.m_positions: " + b); this.m_positions.length < b; )
            this.m_positions[this.m_positions.length] = new box2d.b2Position;
    if (this.m_velocities.length < a)
        for (b = box2d.b2Max(2 * this.m_velocities.length, a), box2d.DEBUG && window.console.log("box2d.b2Island.m_velocities: " + b); this.m_velocities.length < b; )
            this.m_velocities[this.m_velocities.length] = new box2d.b2Velocity
};
goog.exportProperty(box2d.b2Island.prototype, "Initialize", box2d.b2Island.prototype.Initialize);
box2d.b2Island.prototype.Clear = function() {
    this.m_jointCount = this.m_contactCount = this.m_bodyCount = 0
};
goog.exportProperty(box2d.b2Island.prototype, "Clear", box2d.b2Island.prototype.Clear);
box2d.b2Island.prototype.AddBody = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_bodyCount < this.m_bodyCapacity);
    a.m_islandIndex = this.m_bodyCount;
    this.m_bodies[this.m_bodyCount++] = a
};
goog.exportProperty(box2d.b2Island.prototype, "AddBody", box2d.b2Island.prototype.AddBody);
box2d.b2Island.prototype.AddContact = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_contactCount < this.m_contactCapacity);
    this.m_contacts[this.m_contactCount++] = a
};
goog.exportProperty(box2d.b2Island.prototype, "AddContact", box2d.b2Island.prototype.AddContact);
box2d.b2Island.prototype.AddJoint = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_jointCount < this.m_jointCapacity);
    this.m_joints[this.m_jointCount++] = a
};
goog.exportProperty(box2d.b2Island.prototype, "AddJoint", box2d.b2Island.prototype.AddJoint);
box2d.b2Island.prototype.Solve = function(a, b, c, e) {
    for (var d = box2d.b2Island.s_timer.Reset(), f = b.dt, g = 0; g < this.m_bodyCount; ++g) {
        var h = this.m_bodies[g], l = this.m_positions[g].c.Copy(h.m_sweep.c), k = h.m_sweep.a, m = this.m_velocities[g].v.Copy(h.m_linearVelocity), n = h.m_angularVelocity;
        h.m_sweep.c0.Copy(h.m_sweep.c);
        h.m_sweep.a0 = h.m_sweep.a;
        h.m_type == box2d.b2BodyType.b2_dynamicBody && (m.x += f * (h.m_gravityScale * c.x + h.m_invMass * h.m_force.x), m.y += f * (h.m_gravityScale * c.y + h.m_invMass * h.m_force.y), n += f * h.m_invI * h.m_torque,
                m.SelfMul(box2d.b2Clamp(1 - f * h.m_linearDamping, 0, 1)), n *= box2d.b2Clamp(1 - f * h.m_angularDamping, 0, 1));
        this.m_positions[g].a = k;
        this.m_velocities[g].w = n
    }
    d.Reset();
    h = box2d.b2Island.s_solverData;
    h.step.Copy(b);
    h.positions = this.m_positions;
    h.velocities = this.m_velocities;
    g = box2d.b2Island.s_contactSolverDef;
    g.step.Copy(b);
    g.contacts = this.m_contacts;
    g.count = this.m_contactCount;
    g.positions = this.m_positions;
    g.velocities = this.m_velocities;
    g.allocator = this.m_allocator;
    c = box2d.b2Island.s_contactSolver.Initialize(g);
    c.InitializeVelocityConstraints();
    b.warmStarting && c.WarmStart();
    for (g = 0; g < this.m_jointCount; ++g)
        this.m_joints[g].InitVelocityConstraints(h);
    a.solveInit = d.GetMilliseconds();
    d.Reset();
    for (g = 0; g < b.velocityIterations; ++g) {
        for (k = 0; k < this.m_jointCount; ++k)
            this.m_joints[k].SolveVelocityConstraints(h);
        c.SolveVelocityConstraints()
    }
    c.StoreImpulses();
    a.solveVelocity = d.GetMilliseconds();
    for (g = 0; g < this.m_bodyCount; ++g) {
        var l = this.m_positions[g].c, k = this.m_positions[g].a, m = this.m_velocities[g].v, n = this.m_velocities[g].w,
                p = box2d.b2MulSV(f, m, box2d.b2Island.s_translation);
        box2d.b2DotVV(p, p) > box2d.b2_maxTranslationSquared && (p = box2d.b2_maxTranslation / p.GetLength(), m.SelfMul(p));
        p = f * n;
        p * p > box2d.b2_maxRotationSquared && (p = box2d.b2_maxRotation / box2d.b2Abs(p), n *= p);
        l.x += f * m.x;
        l.y += f * m.y;
        k += f * n;
        this.m_positions[g].a = k;
        this.m_velocities[g].w = n
    }
    d.Reset();
    l = !1;
    for (g = 0; g < b.positionIterations; ++g) {
        m = c.SolvePositionConstraints();
        n = !0;
        for (k = 0; k < this.m_jointCount; ++k)
            p = this.m_joints[k].SolvePositionConstraints(h), n = n && p;
        if (m && n) {
            l =
                    !0;
            break
        }
    }
    for (g = 0; g < this.m_bodyCount; ++g)
        b = this.m_bodies[g], b.m_sweep.c.Copy(this.m_positions[g].c), b.m_sweep.a = this.m_positions[g].a, b.m_linearVelocity.Copy(this.m_velocities[g].v), b.m_angularVelocity = this.m_velocities[g].w, b.SynchronizeTransform();
    a.solvePosition = d.GetMilliseconds();
    this.Report(c.m_velocityConstraints);
    if (e) {
        a = box2d.b2_maxFloat;
        e = box2d.b2_linearSleepTolerance * box2d.b2_linearSleepTolerance;
        d = box2d.b2_angularSleepTolerance * box2d.b2_angularSleepTolerance;
        for (g = 0; g < this.m_bodyCount; ++g)
            h =
                    this.m_bodies[g], h.GetType() != box2d.b2BodyType.b2_staticBody && (0 == (h.m_flags & box2d.b2BodyFlag.e_autoSleepFlag) || h.m_angularVelocity * h.m_angularVelocity > d || box2d.b2DotVV(h.m_linearVelocity, h.m_linearVelocity) > e ? a = h.m_sleepTime = 0 : (h.m_sleepTime += f, a = box2d.b2Min(a, h.m_sleepTime)));
        if (a >= box2d.b2_timeToSleep && l)
            for (g = 0; g < this.m_bodyCount; ++g)
                h = this.m_bodies[g], h.SetAwake(!1)
    }
};
goog.exportProperty(box2d.b2Island.prototype, "Solve", box2d.b2Island.prototype.Solve);
box2d.b2Island.prototype.SolveTOI = function(a, b, c) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(b < this.m_bodyCount);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(c < this.m_bodyCount);
    for (var e = 0; e < this.m_bodyCount; ++e) {
        var d = this.m_bodies[e];
        this.m_positions[e].c.Copy(d.m_sweep.c);
        this.m_positions[e].a = d.m_sweep.a;
        this.m_velocities[e].v.Copy(d.m_linearVelocity);
        this.m_velocities[e].w = d.m_angularVelocity
    }
    e = box2d.b2Island.s_contactSolverDef;
    e.contacts = this.m_contacts;
    e.count = this.m_contactCount;
    e.allocator = this.m_allocator;
    e.step.Copy(a);
    e.positions = this.m_positions;
    e.velocities = this.m_velocities;
    d = box2d.b2Island.s_contactSolver.Initialize(e);
    for (e = 0; e < a.positionIterations && !d.SolveTOIPositionConstraints(b, c); ++e){};
    this.m_bodies[b].m_sweep.c0.Copy(this.m_positions[b].c);
    this.m_bodies[b].m_sweep.a0 = this.m_positions[b].a;
    this.m_bodies[c].m_sweep.c0.Copy(this.m_positions[c].c);
    this.m_bodies[c].m_sweep.a0 = this.m_positions[c].a;
    d.InitializeVelocityConstraints();
    for (e = 0; e < a.velocityIterations; ++e)
        d.SolveVelocityConstraints();
    a = a.dt;
    for (e = 0; e < this.m_bodyCount; ++e) {
        b = this.m_positions[e].c;
        c = this.m_positions[e].a;
        var f = this.m_velocities[e].v, g = this.m_velocities[e].w, h = box2d.b2MulSV(a, f, box2d.b2Island.s_translation);
        box2d.b2DotVV(h, h) > box2d.b2_maxTranslationSquared && (h = box2d.b2_maxTranslation / h.GetLength(), f.SelfMul(h));
        h = a * g;
        h * h > box2d.b2_maxRotationSquared && (h = box2d.b2_maxRotation / box2d.b2Abs(h), g *= h);
        b.SelfMulAdd(a, f);
        c += a * g;
        this.m_positions[e].a = c;
        this.m_velocities[e].w = g;
        h = this.m_bodies[e];
        h.m_sweep.c.Copy(b);
        h.m_sweep.a =
                c;
        h.m_linearVelocity.Copy(f);
        h.m_angularVelocity = g;
        h.SynchronizeTransform()
    }
    this.Report(d.m_velocityConstraints)
};
goog.exportProperty(box2d.b2Island.prototype, "SolveTOI", box2d.b2Island.prototype.SolveTOI);
box2d.b2Island.prototype.Report = function(a) {
    if (null != this.m_listener)
        for (var b = 0; b < this.m_contactCount; ++b) {
            var c = this.m_contacts[b];
            if (c) {
                var e = a[b], d = box2d.b2Island.s_impulse;
                d.count = e.pointCount;
                for (var f = 0; f < e.pointCount; ++f)
                    d.normalImpulses[f] = e.points[f].normalImpulse, d.tangentImpulses[f] = e.points[f].tangentImpulse;
                this.m_listener.PostSolve(c, d)
            }
        }
};
goog.exportProperty(box2d.b2Island.prototype, "Report", box2d.b2Island.prototype.Report);
box2d.b2Island.s_timer = new box2d.b2Timer;
box2d.b2Island.s_solverData = new box2d.b2SolverData;
box2d.b2Island.s_contactSolverDef = new box2d.b2ContactSolverDef;
box2d.b2Island.s_contactSolver = new box2d.b2ContactSolver;
box2d.b2Island.s_translation = new box2d.b2Vec2;
box2d.b2Island.s_impulse = new box2d.b2ContactImpulse;
box2d.b2ContactRegister = function() {
};
goog.exportSymbol("box2d.b2ContactRegister", box2d.b2ContactRegister);
box2d.b2ContactRegister.prototype.createFcn = null;
box2d.b2ContactRegister.prototype.destroyFcn = null;
box2d.b2ContactRegister.prototype.primary = !1;
box2d.b2ContactFactory = function(a) {
    this.m_allocator = a;
    this.InitializeRegisters()
};
goog.exportSymbol("box2d.b2ContactFactory", box2d.b2ContactFactory);
box2d.b2ContactFactory.prototype.m_allocator = null;
box2d.b2ContactFactory.prototype.AddType = function(a, b, c, e) {
    var d = box2d.b2MakeArray(256, function(b) {
        return a()
    });
    b = function(b) {
        return 0 < d.length ? d.pop() : a(b)
    };
    var f = function(a, b) {
        d.push(a)
    };
    this.m_registers[c][e].pool = d;
    this.m_registers[c][e].createFcn = b;
    this.m_registers[c][e].destroyFcn = f;
    this.m_registers[c][e].primary = !0;
    c != e && (this.m_registers[e][c].pool = d, this.m_registers[e][c].createFcn = b, this.m_registers[e][c].destroyFcn = f, this.m_registers[e][c].primary = !1)
};
goog.exportProperty(box2d.b2ContactFactory.prototype, "AddType", box2d.b2ContactFactory.prototype.AddType);
box2d.b2ContactFactory.prototype.InitializeRegisters = function() {
    this.m_registers = Array(box2d.b2ShapeType.e_shapeTypeCount);
    for (var a = 0; a < box2d.b2ShapeType.e_shapeTypeCount; a++) {
        this.m_registers[a] = Array(box2d.b2ShapeType.e_shapeTypeCount);
        for (var b = 0; b < box2d.b2ShapeType.e_shapeTypeCount; b++)
            this.m_registers[a][b] = new box2d.b2ContactRegister
    }
    this.AddType(box2d.b2CircleContact.Create, box2d.b2CircleContact.Destroy, box2d.b2ShapeType.e_circleShape, box2d.b2ShapeType.e_circleShape);
    this.AddType(box2d.b2PolygonAndCircleContact.Create,
            box2d.b2PolygonAndCircleContact.Destroy, box2d.b2ShapeType.e_polygonShape, box2d.b2ShapeType.e_circleShape);
    this.AddType(box2d.b2PolygonContact.Create, box2d.b2PolygonContact.Destroy, box2d.b2ShapeType.e_polygonShape, box2d.b2ShapeType.e_polygonShape);
    this.AddType(box2d.b2EdgeAndCircleContact.Create, box2d.b2EdgeAndCircleContact.Destroy, box2d.b2ShapeType.e_edgeShape, box2d.b2ShapeType.e_circleShape);
    this.AddType(box2d.b2EdgeAndPolygonContact.Create, box2d.b2EdgeAndPolygonContact.Destroy, box2d.b2ShapeType.e_edgeShape,
            box2d.b2ShapeType.e_polygonShape);
    this.AddType(box2d.b2ChainAndCircleContact.Create, box2d.b2ChainAndCircleContact.Destroy, box2d.b2ShapeType.e_chainShape, box2d.b2ShapeType.e_circleShape);
    this.AddType(box2d.b2ChainAndPolygonContact.Create, box2d.b2ChainAndPolygonContact.Destroy, box2d.b2ShapeType.e_chainShape, box2d.b2ShapeType.e_polygonShape)
};
goog.exportProperty(box2d.b2ContactFactory.prototype, "InitializeRegisters", box2d.b2ContactFactory.prototype.InitializeRegisters);
box2d.b2ContactFactory.prototype.Create = function(a, b, c, e) {
    var d = a.GetType(), f = c.GetType();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= d && d < box2d.b2ShapeType.e_shapeTypeCount);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= f && f < box2d.b2ShapeType.e_shapeTypeCount);
    d = this.m_registers[d][f];
    f = d.createFcn;
    return null != f ? (d.primary ? (d = f(this.m_allocator), d.Reset(a, b, c, e)) : (d = f(this.m_allocator), d.Reset(c, e, a, b)), d) : null
};
goog.exportProperty(box2d.b2ContactFactory.prototype, "Create", box2d.b2ContactFactory.prototype.Create);
box2d.b2ContactFactory.prototype.Destroy = function(a) {
    var b = a.m_fixtureA, c = a.m_fixtureB;
    0 < a.m_manifold.pointCount && (!1 == b.IsSensor() && !1 == c.IsSensor()) && (b.GetBody().SetAwake(!0), c.GetBody().SetAwake(!0));
    b = b.GetType();
    c = c.GetType();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= b && c < box2d.b2ShapeType.e_shapeTypeCount);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= b && c < box2d.b2ShapeType.e_shapeTypeCount);
    c = this.m_registers[b][c].destroyFcn;
    c(a, this.m_allocator)
};
goog.exportProperty(box2d.b2ContactFactory.prototype, "Destroy", box2d.b2ContactFactory.prototype.Destroy);
box2d.b2GrowableStack = function(a) {
    this.m_stack = Array(a)
};
goog.exportSymbol("box2d.b2GrowableStack", box2d.b2GrowableStack);
box2d.b2GrowableStack.prototype.m_stack = null;
goog.exportProperty(box2d.b2GrowableStack.prototype, "m_stack", box2d.b2GrowableStack.prototype.m_stack);
box2d.b2GrowableStack.prototype.m_count = 0;
goog.exportProperty(box2d.b2GrowableStack.prototype, "m_count", box2d.b2GrowableStack.prototype.m_count);
box2d.b2GrowableStack.prototype.Reset = function() {
    this.m_count = 0;
    return this
};
goog.exportProperty(box2d.b2GrowableStack.prototype, "Reset", box2d.b2GrowableStack.prototype.Reset);
box2d.b2GrowableStack.prototype.Push = function(a) {
    this.m_stack[this.m_count] = a;
    ++this.m_count
};
goog.exportProperty(box2d.b2GrowableStack.prototype, "Push", box2d.b2GrowableStack.prototype.Push);
box2d.b2GrowableStack.prototype.Pop = function() {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < this.m_count);
    --this.m_count;
    var a = this.m_stack[this.m_count];
    this.m_stack[this.m_count] = null;
    return a
};
goog.exportProperty(box2d.b2GrowableStack.prototype, "Pop", box2d.b2GrowableStack.prototype.Pop);
box2d.b2GrowableStack.prototype.GetCount = function() {
    return this.m_count
};
goog.exportProperty(box2d.b2GrowableStack.prototype, "GetCount", box2d.b2GrowableStack.prototype.GetCount);
box2d.b2TreeNode = function(a) {
    this.m_id = a || 0;
    this.aabb = new box2d.b2AABB
};
goog.exportSymbol("box2d.b2TreeNode", box2d.b2TreeNode);
box2d.b2TreeNode.prototype.m_id = 0;
goog.exportProperty(box2d.b2TreeNode.prototype, "m_id", box2d.b2TreeNode.prototype.m_id);
box2d.b2TreeNode.prototype.aabb = null;
goog.exportProperty(box2d.b2TreeNode.prototype, "aabb", box2d.b2TreeNode.prototype.aabb);
box2d.b2TreeNode.prototype.userData = null;
goog.exportProperty(box2d.b2TreeNode.prototype, "userData", box2d.b2TreeNode.prototype.userData);
box2d.b2TreeNode.prototype.parent = null;
goog.exportProperty(box2d.b2TreeNode.prototype, "parent", box2d.b2TreeNode.prototype.parent);
box2d.b2TreeNode.prototype.child1 = null;
goog.exportProperty(box2d.b2TreeNode.prototype, "child1", box2d.b2TreeNode.prototype.child1);
box2d.b2TreeNode.prototype.child2 = null;
goog.exportProperty(box2d.b2TreeNode.prototype, "child2", box2d.b2TreeNode.prototype.child2);
box2d.b2TreeNode.prototype.height = 0;
goog.exportProperty(box2d.b2TreeNode.prototype, "height", box2d.b2TreeNode.prototype.height);
box2d.b2TreeNode.prototype.IsLeaf = function() {
    return null == this.child1
};
goog.exportProperty(box2d.b2TreeNode.prototype, "IsLeaf", box2d.b2TreeNode.prototype.IsLeaf);
box2d.b2DynamicTree = function() {
};
goog.exportSymbol("box2d.b2DynamicTree", box2d.b2DynamicTree);
box2d.b2DynamicTree.prototype.m_root = null;
goog.exportProperty(box2d.b2DynamicTree.prototype, "m_root", box2d.b2DynamicTree.prototype.m_root);
box2d.b2DynamicTree.prototype.m_freeList = null;
goog.exportProperty(box2d.b2DynamicTree.prototype, "m_freeList", box2d.b2DynamicTree.prototype.m_freeList);
box2d.b2DynamicTree.prototype.m_path = 0;
goog.exportProperty(box2d.b2DynamicTree.prototype, "m_path", box2d.b2DynamicTree.prototype.m_path);
box2d.b2DynamicTree.prototype.m_insertionCount = 0;
goog.exportProperty(box2d.b2DynamicTree.prototype, "m_insertionCount", box2d.b2DynamicTree.prototype.m_insertionCount);
box2d.b2DynamicTree.s_stack = new box2d.b2GrowableStack(256);
box2d.b2DynamicTree.s_r = new box2d.b2Vec2;
box2d.b2DynamicTree.s_v = new box2d.b2Vec2;
box2d.b2DynamicTree.s_abs_v = new box2d.b2Vec2;
box2d.b2DynamicTree.s_segmentAABB = new box2d.b2AABB;
box2d.b2DynamicTree.s_subInput = new box2d.b2RayCastInput;
box2d.b2DynamicTree.s_combinedAABB = new box2d.b2AABB;
box2d.b2DynamicTree.s_aabb = new box2d.b2AABB;
box2d.b2DynamicTree.prototype.GetUserData = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(null != a);
    return a.userData
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "GetUserData", box2d.b2DynamicTree.prototype.GetUserData);
box2d.b2DynamicTree.prototype.GetFatAABB = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(null != a);
    return a.aabb
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "GetFatAABB", box2d.b2DynamicTree.prototype.GetFatAABB);
box2d.b2DynamicTree.prototype.Query = function(a, b) {
    if (null != this.m_root) {
        var c = box2d.b2DynamicTree.s_stack.Reset();
        for (c.Push(this.m_root); 0 < c.GetCount(); ) {
            var e = c.Pop();
            if (null != e && e.aabb.TestOverlap(b))
                if (e.IsLeaf()) {
                    if (!1 == a(e))
                        break
                } else
                    c.Push(e.child1), c.Push(e.child2)
        }
    }
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "Query", box2d.b2DynamicTree.prototype.Query);
box2d.b2DynamicTree.prototype.RayCast = function(a, b) {
    if (null != this.m_root) {
        var c = b.p1, e = b.p2, d = box2d.b2SubVV(e, c, box2d.b2DynamicTree.s_r);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < d.GetLengthSquared());
        d.Normalize();
        var d = box2d.b2CrossOneV(d, box2d.b2DynamicTree.s_v), f = box2d.b2AbsV(d, box2d.b2DynamicTree.s_abs_v), g = b.maxFraction, h = box2d.b2DynamicTree.s_segmentAABB, l = c.x + g * (e.x - c.x), k = c.y + g * (e.y - c.y);
        h.lowerBound.x = box2d.b2Min(c.x, l);
        h.lowerBound.y = box2d.b2Min(c.y, k);
        h.upperBound.x = box2d.b2Max(c.x, l);
        h.upperBound.y =
                box2d.b2Max(c.y, k);
        var m = box2d.b2DynamicTree.s_stack.Reset();
        for (m.Push(this.m_root); 0 < m.GetCount(); )
            if (l = m.Pop(), null != l && !1 != box2d.b2TestOverlapAABB(l.aabb, h)) {
                var k = l.aabb.GetCenter(), n = l.aabb.GetExtents();
                if (!(0 < box2d.b2Abs(box2d.b2DotVV(d, box2d.b2SubVV(c, k, box2d.b2Vec2.s_t0))) - box2d.b2DotVV(f, n)))
                    if (l.IsLeaf()) {
                        k = box2d.b2DynamicTree.s_subInput;
                        k.p1.Copy(b.p1);
                        k.p2.Copy(b.p2);
                        k.maxFraction = g;
                        l = a(k, l);
                        if (0 == l)
                            break;
                        0 < l && (g = l, l = c.x + g * (e.x - c.x), k = c.y + g * (e.y - c.y), h.lowerBound.x = box2d.b2Min(c.x, l),
                                h.lowerBound.y = box2d.b2Min(c.y, k), h.upperBound.x = box2d.b2Max(c.x, l), h.upperBound.y = box2d.b2Max(c.y, k))
                    } else
                        m.Push(l.child1), m.Push(l.child2)
            }
    }
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "RayCast", box2d.b2DynamicTree.prototype.RayCast);
box2d.b2DynamicTree.prototype.AllocateNode = function() {
    if (this.m_freeList) {
        var a = this.m_freeList;
        this.m_freeList = a.parent;
        a.parent = null;
        a.child1 = null;
        a.child2 = null;
        a.height = 0;
        a.userData = null;
        return a
    }
    return new box2d.b2TreeNode(box2d.b2DynamicTree.prototype.s_node_id++)
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "AllocateNode", box2d.b2DynamicTree.prototype.AllocateNode);
box2d.b2DynamicTree.prototype.s_node_id = 0;
box2d.b2DynamicTree.prototype.FreeNode = function(a) {
    a.parent = this.m_freeList;
    a.height = -1;
    this.m_freeList = a
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "FreeNode", box2d.b2DynamicTree.prototype.FreeNode);
box2d.b2DynamicTree.prototype.CreateProxy = function(a, b) {
    var c = this.AllocateNode(), e = box2d.b2_aabbExtension, d = box2d.b2_aabbExtension;
    c.aabb.lowerBound.x = a.lowerBound.x - e;
    c.aabb.lowerBound.y = a.lowerBound.y - d;
    c.aabb.upperBound.x = a.upperBound.x + e;
    c.aabb.upperBound.y = a.upperBound.y + d;
    c.userData = b;
    c.height = 0;
    this.InsertLeaf(c);
    return c
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "CreateProxy", box2d.b2DynamicTree.prototype.CreateProxy);
box2d.b2DynamicTree.prototype.DestroyProxy = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.IsLeaf());
    this.RemoveLeaf(a);
    this.FreeNode(a)
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "DestroyProxy", box2d.b2DynamicTree.prototype.DestroyProxy);
box2d.b2DynamicTree.prototype.MoveProxy = function(a, b, c) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.IsLeaf());
    if (a.aabb.Contains(b))
        return!1;
    this.RemoveLeaf(a);
    var e = box2d.b2_aabbExtension + box2d.b2_aabbMultiplier * (0 < c.x ? c.x : -c.x);
    c = box2d.b2_aabbExtension + box2d.b2_aabbMultiplier * (0 < c.y ? c.y : -c.y);
    a.aabb.lowerBound.x = b.lowerBound.x - e;
    a.aabb.lowerBound.y = b.lowerBound.y - c;
    a.aabb.upperBound.x = b.upperBound.x + e;
    a.aabb.upperBound.y = b.upperBound.y + c;
    this.InsertLeaf(a);
    return!0
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "MoveProxy", box2d.b2DynamicTree.prototype.MoveProxy);
box2d.b2DynamicTree.prototype.InsertLeaf = function(a) {
    ++this.m_insertionCount;
    if (null == this.m_root)
        this.m_root = a, this.m_root.parent = null;
    else {
        var b = a.aabb;
        b.GetCenter();
        for (var c = this.m_root, e, d; !1 == c.IsLeaf(); ) {
            e = c.child1;
            d = c.child2;
            var f = c.aabb.GetPerimeter(), g = box2d.b2DynamicTree.s_combinedAABB;
            g.Combine2(c.aabb, b);
            var h = g.GetPerimeter(), g = 2 * h, h = 2 * (h - f), l = box2d.b2DynamicTree.s_aabb, k, m;
            e.IsLeaf() ? (l.Combine2(b, e.aabb), f = l.GetPerimeter() + h) : (l.Combine2(b, e.aabb), k = e.aabb.GetPerimeter(), m = l.GetPerimeter(),
                    f = m - k + h);
            d.IsLeaf() ? (l.Combine2(b, d.aabb), h = l.GetPerimeter() + h) : (l.Combine2(b, d.aabb), k = d.aabb.GetPerimeter(), m = l.GetPerimeter(), h = m - k + h);
            if (g < f && g < h)
                break;
            c = f < h ? e : d
        }
        e = c.parent;
        d = this.AllocateNode();
        d.parent = e;
        d.userData = null;
        d.aabb.Combine2(b, c.aabb);
        d.height = c.height + 1;
        e ? (e.child1 == c ? e.child1 = d : e.child2 = d, d.child1 = c, d.child2 = a, c.parent = d, a.parent = d) : (d.child1 = c, d.child2 = a, c.parent = d, this.m_root = a.parent = d);
        for (c = a.parent; null != c; )
            c = this.Balance(c), e = c.child1, d = c.child2, box2d.ENABLE_ASSERTS && box2d.b2Assert(null !=
                    e), box2d.ENABLE_ASSERTS && box2d.b2Assert(null != d), c.height = 1 + box2d.b2Max(e.height, d.height), c.aabb.Combine2(e.aabb, d.aabb), c = c.parent
    }
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "InsertLeaf", box2d.b2DynamicTree.prototype.InsertLeaf);
box2d.b2DynamicTree.prototype.RemoveLeaf = function(a) {
    if (a == this.m_root)
        this.m_root = null;
    else {
        var b = a.parent, c = b.parent;
        a = b.child1 == a ? b.child2 : b.child1;
        if (c)
            for (c.child1 == b?c.child1 = a:c.child2 = a, a.parent = c, this.FreeNode(b), b = c; b; )
                b = this.Balance(b), c = b.child1, a = b.child2, b.aabb.Combine2(c.aabb, a.aabb), b.height = 1 + box2d.b2Max(c.height, a.height), b = b.parent;
        else
            this.m_root = a, a.parent = null, this.FreeNode(b)
    }
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "RemoveLeaf", box2d.b2DynamicTree.prototype.RemoveLeaf);
box2d.b2DynamicTree.prototype.Balance = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(null != a);
    if (a.IsLeaf() || 2 > a.height)
        return a;
    var b = a.child1, c = a.child2, e = c.height - b.height;
    if (1 < e) {
        var e = c.child1, d = c.child2;
        c.child1 = a;
        c.parent = a.parent;
        a.parent = c;
        null != c.parent ? c.parent.child1 == a ? c.parent.child1 = c : (box2d.ENABLE_ASSERTS && box2d.b2Assert(c.parent.child2 == a), c.parent.child2 = c) : this.m_root = c;
        e.height > d.height ? (c.child2 = e, a.child2 = d, d.parent = a, a.aabb.Combine2(b.aabb, d.aabb), c.aabb.Combine2(a.aabb, e.aabb),
                a.height = 1 + box2d.b2Max(b.height, d.height), c.height = 1 + box2d.b2Max(a.height, e.height)) : (c.child2 = d, a.child2 = e, e.parent = a, a.aabb.Combine2(b.aabb, e.aabb), c.aabb.Combine2(a.aabb, d.aabb), a.height = 1 + box2d.b2Max(b.height, e.height), c.height = 1 + box2d.b2Max(a.height, d.height));
        return c
    }
    return-1 > e ? (e = b.child1, d = b.child2, b.child1 = a, b.parent = a.parent, a.parent = b, null != b.parent ? b.parent.child1 == a ? b.parent.child1 = b : (box2d.ENABLE_ASSERTS && box2d.b2Assert(b.parent.child2 == a), b.parent.child2 = b) : this.m_root = b, e.height >
            d.height ? (b.child2 = e, a.child1 = d, d.parent = a, a.aabb.Combine2(c.aabb, d.aabb), b.aabb.Combine2(a.aabb, e.aabb), a.height = 1 + box2d.b2Max(c.height, d.height), b.height = 1 + box2d.b2Max(a.height, e.height)) : (b.child2 = d, a.child1 = e, e.parent = a, a.aabb.Combine2(c.aabb, e.aabb), b.aabb.Combine2(a.aabb, d.aabb), a.height = 1 + box2d.b2Max(c.height, e.height), b.height = 1 + box2d.b2Max(a.height, d.height)), b) : a
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "Balance", box2d.b2DynamicTree.prototype.Balance);
box2d.b2DynamicTree.prototype.GetHeight = function() {
    return null == this.m_root ? 0 : this.m_root.height
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "GetHeight", box2d.b2DynamicTree.prototype.GetHeight);
box2d.b2DynamicTree.prototype.GetAreaRatio = function() {
    if (null == this.m_root)
        return 0;
    var a = this.m_root.aabb.GetPerimeter(), b = function(a) {
        if (null == a || a.IsLeaf())
            return 0;
        var e = a.aabb.GetPerimeter(), e = e + b(a.child1);
        return e += b(a.child2)
    };
    return b(this.m_root) / a
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "GetAreaRatio", box2d.b2DynamicTree.prototype.GetAreaRatio);
box2d.b2DynamicTree.prototype.ComputeHeightNode = function(a) {
    if (a.IsLeaf())
        return 0;
    var b = this.ComputeHeightNode(a.child1);
    a = this.ComputeHeightNode(a.child2);
    return 1 + box2d.b2Max(b, a)
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "ComputeHeightNode", box2d.b2DynamicTree.prototype.ComputeHeightNode);
box2d.b2DynamicTree.prototype.ComputeHeight = function() {
    return this.ComputeHeightNode(this.m_root)
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "ComputeHeight", box2d.b2DynamicTree.prototype.ComputeHeight);
box2d.b2DynamicTree.prototype.ValidateStructure = function(a) {
    if (null != a) {
        a == this.m_root && box2d.ENABLE_ASSERTS && box2d.b2Assert(null == a.parent);
        var b = a.child1, c = a.child2;
        a.IsLeaf() ? (box2d.ENABLE_ASSERTS && box2d.b2Assert(null == b), box2d.ENABLE_ASSERTS && box2d.b2Assert(null == c), box2d.ENABLE_ASSERTS && box2d.b2Assert(0 == a.height)) : (box2d.ENABLE_ASSERTS && box2d.b2Assert(b.parent == a), box2d.ENABLE_ASSERTS && box2d.b2Assert(c.parent == a), this.ValidateStructure(b), this.ValidateStructure(c))
    }
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "ValidateStructure", box2d.b2DynamicTree.prototype.ValidateStructure);
box2d.b2DynamicTree.prototype.ValidateMetrics = function(a) {
    if (null != a) {
        var b = a.child1, c = a.child2;
        if (a.IsLeaf())
            box2d.ENABLE_ASSERTS && box2d.b2Assert(null == b), box2d.ENABLE_ASSERTS && box2d.b2Assert(null == c), box2d.ENABLE_ASSERTS && box2d.b2Assert(0 == a.height);
        else {
            var e;
            e = 1 + box2d.b2Max(b.height, c.height);
            box2d.ENABLE_ASSERTS && box2d.b2Assert(a.height == e);
            e = box2d.b2DynamicTree.s_aabb;
            e.Combine2(b.aabb, c.aabb);
            box2d.ENABLE_ASSERTS && box2d.b2Assert(e.lowerBound == a.aabb.lowerBound);
            box2d.ENABLE_ASSERTS && box2d.b2Assert(e.upperBound ==
                    a.aabb.upperBound);
            this.ValidateMetrics(b);
            this.ValidateMetrics(c)
        }
    }
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "ValidateMetrics", box2d.b2DynamicTree.prototype.ValidateMetrics);
box2d.b2DynamicTree.prototype.Validate = function() {
    this.ValidateStructure(this.m_root);
    this.ValidateMetrics(this.m_root);
    for (var a = 0, b = this.m_freeList; null != b; )
        b = b.parent, ++a;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.GetHeight() == this.ComputeHeight())
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "Validate", box2d.b2DynamicTree.prototype.Validate);
box2d.b2DynamicTree.prototype.GetMaxBalance = function() {
    var a;
    a = this.m_root;
    null == a ? a = 0 : 1 >= a.height ? a = 0 : (box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == a.IsLeaf()), a = box2d.b2Abs(a.child2.height - a.child1.height), a = box2d.b2Max(0, a));
    return a
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "GetMaxBalance", box2d.b2DynamicTree.prototype.GetMaxBalance);
box2d.b2DynamicTree.prototype.RebuildBottomUp = function() {
    this.Validate()
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "RebuildBottomUp", box2d.b2DynamicTree.prototype.RebuildBottomUp);
box2d.b2DynamicTree.prototype.ShiftOrigin = function(a) {
    var b = function(a, e) {
        if (null != a && !(1 >= a.height)) {
            box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == a.IsLeaf());
            var d = a.child2;
            b(a.child1, e);
            b(d, e);
            a.aabb.lowerBound.SelfSub(e);
            a.aabb.upperBound.SelfSub(e)
        }
    };
    b(this.m_root, a)
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "ShiftOrigin", box2d.b2DynamicTree.prototype.ShiftOrigin);
box2d.b2Pair = function() {
};
goog.exportSymbol("box2d.b2Pair", box2d.b2Pair);
box2d.b2Pair.prototype.proxyA = null;
goog.exportProperty(box2d.b2Pair.prototype, "proxyA", box2d.b2Pair.prototype.proxyA);
box2d.b2Pair.prototype.proxyB = null;
goog.exportProperty(box2d.b2Pair.prototype, "proxyB", box2d.b2Pair.prototype.proxyB);
box2d.b2BroadPhase = function() {
    this.m_tree = new box2d.b2DynamicTree;
    this.m_moveBuffer = [];
    this.m_pairBuffer = []
};
goog.exportSymbol("box2d.b2BroadPhase", box2d.b2BroadPhase);
box2d.b2BroadPhase.prototype.m_tree = null;
goog.exportProperty(box2d.b2BroadPhase.prototype, "m_tree", box2d.b2BroadPhase.prototype.m_tree);
box2d.b2BroadPhase.prototype.m_proxyCount = 0;
goog.exportProperty(box2d.b2BroadPhase.prototype, "m_proxyCount", box2d.b2BroadPhase.prototype.m_proxyCount);
box2d.b2BroadPhase.prototype.m_moveCount = 0;
goog.exportProperty(box2d.b2BroadPhase.prototype, "m_moveCount", box2d.b2BroadPhase.prototype.m_moveCount);
box2d.b2BroadPhase.prototype.m_moveBuffer = null;
goog.exportProperty(box2d.b2BroadPhase.prototype, "m_moveBuffer", box2d.b2BroadPhase.prototype.m_moveBuffer);
box2d.b2BroadPhase.prototype.m_pairCount = 0;
goog.exportProperty(box2d.b2BroadPhase.prototype, "m_pairCount", box2d.b2BroadPhase.prototype.m_pairCount);
box2d.b2BroadPhase.prototype.m_pairBuffer = null;
goog.exportProperty(box2d.b2BroadPhase.prototype, "m_pairBuffer", box2d.b2BroadPhase.prototype.m_pairBuffer);
box2d.b2BroadPhase.prototype.CreateProxy = function(a, b) {
    var c = this.m_tree.CreateProxy(a, b);
    ++this.m_proxyCount;
    this.BufferMove(c);
    return c
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "CreateProxy", box2d.b2BroadPhase.prototype.CreateProxy);
box2d.b2BroadPhase.prototype.DestroyProxy = function(a) {
    this.UnBufferMove(a);
    --this.m_proxyCount;
    this.m_tree.DestroyProxy(a)
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "DestroyProxy", box2d.b2BroadPhase.prototype.DestroyProxy);
box2d.b2BroadPhase.prototype.MoveProxy = function(a, b, c) {
    this.m_tree.MoveProxy(a, b, c) && this.BufferMove(a)
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "MoveProxy", box2d.b2BroadPhase.prototype.MoveProxy);
box2d.b2BroadPhase.prototype.TouchProxy = function(a) {
    this.BufferMove(a)
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "TouchProxy", box2d.b2BroadPhase.prototype.TouchProxy);
box2d.b2BroadPhase.prototype.GetFatAABB = function(a) {
    return this.m_tree.GetFatAABB(a)
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "GetFatAABB", box2d.b2BroadPhase.prototype.GetFatAABB);
box2d.b2BroadPhase.prototype.GetUserData = function(a) {
    return this.m_tree.GetUserData(a)
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "GetUserData", box2d.b2BroadPhase.prototype.GetUserData);
box2d.b2BroadPhase.prototype.TestOverlap = function(a, b) {
    var c = this.m_tree.GetFatAABB(a), e = this.m_tree.GetFatAABB(b);
    return box2d.b2TestOverlapAABB(c, e)
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "TestOverlap", box2d.b2BroadPhase.prototype.TestOverlap);
box2d.b2BroadPhase.prototype.GetProxyCount = function() {
    return this.m_proxyCount
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "GetProxyCount", box2d.b2BroadPhase.prototype.GetProxyCount);
box2d.b2BroadPhase.prototype.GetTreeHeight = function() {
    return this.m_tree.GetHeight()
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "GetTreeHeight", box2d.b2BroadPhase.prototype.GetTreeHeight);
box2d.b2BroadPhase.prototype.GetTreeBalance = function() {
    return this.m_tree.GetMaxBalance()
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "GetTreeBalance", box2d.b2BroadPhase.prototype.GetTreeBalance);
box2d.b2BroadPhase.prototype.GetTreeQuality = function() {
    return this.m_tree.GetAreaRatio()
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "GetTreeQuality", box2d.b2BroadPhase.prototype.GetTreeQuality);
box2d.b2BroadPhase.prototype.ShiftOrigin = function(a) {
    this.m_tree.ShiftOrigin(a)
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "ShiftOrigin", box2d.b2BroadPhase.prototype.ShiftOrigin);
box2d.b2BroadPhase.prototype.UpdatePairs = function(a) {
    for (var b = this.m_pairCount = 0; b < this.m_moveCount; ++b) {
        var c = this.m_moveBuffer[b];
        if (null != c) {
            var e = this, d = this.m_tree.GetFatAABB(c);
            this.m_tree.Query(function(a) {
                if (a.m_id == c.m_id)
                    return!0;
                e.m_pairCount == e.m_pairBuffer.length && (e.m_pairBuffer[e.m_pairCount] = new box2d.b2Pair);
                var b = e.m_pairBuffer[e.m_pairCount];
                a.m_id < c.m_id ? (b.proxyA = a, b.proxyB = c) : (b.proxyA = c, b.proxyB = a);
                ++e.m_pairCount;
                return!0
            }, d)
        }
    }
    this.m_moveCount = 0;
    this.m_pairBuffer.length = this.m_pairCount;
    this.m_pairBuffer.sort(box2d.b2PairLessThan);
    for (b = 0; b < this.m_pairCount; ) {
        var d = this.m_pairBuffer[b], f = this.m_tree.GetUserData(d.proxyA), g = this.m_tree.GetUserData(d.proxyB);
        a.AddPair(f, g);
        for (++b; b < this.m_pairCount; ) {
            f = this.m_pairBuffer[b];
            if (f.proxyA.m_id != d.proxyA.m_id || f.proxyB.m_id != d.proxyB.m_id)
                break;
            ++b
        }
    }
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "UpdatePairs", box2d.b2BroadPhase.prototype.UpdatePairs);
box2d.b2BroadPhase.prototype.Query = function(a, b) {
    this.m_tree.Query(a, b)
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "Query", box2d.b2BroadPhase.prototype.Query);
box2d.b2BroadPhase.prototype.RayCast = function(a, b) {
    this.m_tree.RayCast(a, b)
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "RayCast", box2d.b2BroadPhase.prototype.RayCast);
box2d.b2BroadPhase.prototype.BufferMove = function(a) {
    this.m_moveBuffer[this.m_moveCount] = a;
    ++this.m_moveCount
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "BufferMove", box2d.b2BroadPhase.prototype.BufferMove);
box2d.b2BroadPhase.prototype.UnBufferMove = function(a) {
    a = this.m_moveBuffer.indexOf(a);
    this.m_moveBuffer[a] = null
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "UnBufferMove", box2d.b2BroadPhase.prototype.UnBufferMove);
box2d.b2PairLessThan = function(a, b) {
    return a.proxyA.m_id == b.proxyA.m_id ? a.proxyB.m_id - b.proxyB.m_id : a.proxyA.m_id - b.proxyA.m_id
};
box2d.b2ContactManager = function() {
    this.m_broadPhase = new box2d.b2BroadPhase;
    this.m_contactFactory = new box2d.b2ContactFactory(this.m_allocator)
};
box2d.b2ContactManager.prototype.m_broadPhase = null;
goog.exportSymbol("box2d.b2ContactManager.prototype.m_broadPhase", box2d.b2ContactManager.prototype.m_broadPhase);
box2d.b2ContactManager.prototype.m_contactList = null;
goog.exportSymbol("box2d.b2ContactManager.prototype.m_contactList", box2d.b2ContactManager.prototype.m_contactList);
box2d.b2ContactManager.prototype.m_contactCount = 0;
goog.exportSymbol("box2d.b2ContactManager.prototype.m_contactCount", box2d.b2ContactManager.prototype.m_contactCount);
box2d.b2ContactManager.prototype.m_contactFilter = box2d.b2ContactFilter.b2_defaultFilter;
goog.exportSymbol("box2d.b2ContactManager.prototype.m_contactFilter", box2d.b2ContactManager.prototype.m_contactFilter);
box2d.b2ContactManager.prototype.m_contactListener = box2d.b2ContactListener.b2_defaultListener;
goog.exportSymbol("box2d.b2ContactManager.prototype.m_contactListener", box2d.b2ContactManager.prototype.m_contactListener);
box2d.b2ContactManager.prototype.m_allocator = null;
goog.exportSymbol("box2d.b2ContactManager.prototype.m_allocator", box2d.b2ContactManager.prototype.m_allocator);
box2d.b2ContactManager.prototype.m_contactFactory = null;
goog.exportSymbol("box2d.b2ContactManager.prototype.m_contactFactory", box2d.b2ContactManager.prototype.m_contactFactory);
box2d.b2ContactManager.prototype.Destroy = function(a) {
    var b = a.GetFixtureA(), c = a.GetFixtureB(), b = b.GetBody(), c = c.GetBody();
    this.m_contactListener && a.IsTouching() && this.m_contactListener.EndContact(a);
    a.m_prev && (a.m_prev.m_next = a.m_next);
    a.m_next && (a.m_next.m_prev = a.m_prev);
    a == this.m_contactList && (this.m_contactList = a.m_next);
    a.m_nodeA.prev && (a.m_nodeA.prev.next = a.m_nodeA.next);
    a.m_nodeA.next && (a.m_nodeA.next.prev = a.m_nodeA.prev);
    a.m_nodeA == b.m_contactList && (b.m_contactList = a.m_nodeA.next);
    a.m_nodeB.prev &&
            (a.m_nodeB.prev.next = a.m_nodeB.next);
    a.m_nodeB.next && (a.m_nodeB.next.prev = a.m_nodeB.prev);
    a.m_nodeB == c.m_contactList && (c.m_contactList = a.m_nodeB.next);
    this.m_contactFactory.Destroy(a);
    --this.m_contactCount
};
goog.exportSymbol("box2d.b2ContactManager.prototype.Destroy", box2d.b2ContactManager.prototype.Destroy);
box2d.b2ContactManager.prototype.Collide = function() {
    for (var a = this.m_contactList; a; ) {
        var b = a.GetFixtureA(), c = a.GetFixtureB(), e = a.GetChildIndexA(), d = a.GetChildIndexB(), f = b.GetBody(), g = c.GetBody();
        if (a.m_flags & box2d.b2ContactFlag.e_filterFlag) {
            if (!1 == g.ShouldCollide(f)) {
                b = a;
                a = b.m_next;
                this.Destroy(b);
                continue
            }
            if (this.m_contactFilter && !1 == this.m_contactFilter.ShouldCollide(b, c)) {
                b = a;
                a = b.m_next;
                this.Destroy(b);
                continue
            }
            a.m_flags &= ~box2d.b2ContactFlag.e_filterFlag
        }
        f = f.IsAwake() && f.m_type != box2d.b2BodyType.b2_staticBody;
        g = g.IsAwake() && g.m_type != box2d.b2BodyType.b2_staticBody;
        !1 == f && !1 == g ? a = a.m_next : !1 == this.m_broadPhase.TestOverlap(b.m_proxies[e].proxy, c.m_proxies[d].proxy) ? (b = a, a = b.m_next, this.Destroy(b)) : (a.Update(this.m_contactListener), a = a.m_next)
    }
};
goog.exportSymbol("box2d.b2ContactManager.prototype.Collide", box2d.b2ContactManager.prototype.Collide);
box2d.b2ContactManager.prototype.FindNewContacts = function() {
    this.m_broadPhase.UpdatePairs(this)
};
goog.exportSymbol("box2d.b2ContactManager.prototype.FindNewContacts", box2d.b2ContactManager.prototype.FindNewContacts);
box2d.b2ContactManager.prototype.AddPair = function(a, b) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a instanceof box2d.b2FixtureProxy);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(b instanceof box2d.b2FixtureProxy);
    var c = a.fixture, e = b.fixture, d = a.childIndex, f = b.childIndex, g = c.GetBody(), h = e.GetBody();
    if (g != h) {
        for (var l = h.GetContactList(); l; ) {
            if (l.other == g) {
                var k = l.contact.GetFixtureA(), m = l.contact.GetFixtureB(), n = l.contact.GetChildIndexA(), p = l.contact.GetChildIndexB();
                if (k == c && m == e && n == d && p == f || k == e && m == c && n == f &&
                        p == d)
                    return
            }
            l = l.next
        }
        !1 == h.ShouldCollide(g) || this.m_contactFilter && !1 == this.m_contactFilter.ShouldCollide(c, e) || (d = this.m_contactFactory.Create(c, d, e, f), null != d && (c = d.GetFixtureA(), e = d.GetFixtureB(), d.GetChildIndexA(), d.GetChildIndexB(), g = c.m_body, h = e.m_body, d.m_prev = null, d.m_next = this.m_contactList, null !== this.m_contactList && (this.m_contactList.m_prev = d), this.m_contactList = d, d.m_nodeA.contact = d, d.m_nodeA.other = h, d.m_nodeA.prev = null, d.m_nodeA.next = g.m_contactList, null != g.m_contactList && (g.m_contactList.prev =
                d.m_nodeA), g.m_contactList = d.m_nodeA, d.m_nodeB.contact = d, d.m_nodeB.other = g, d.m_nodeB.prev = null, d.m_nodeB.next = h.m_contactList, null != h.m_contactList && (h.m_contactList.prev = d.m_nodeB), h.m_contactList = d.m_nodeB, !1 == c.IsSensor() && !1 == e.IsSensor() && (g.SetAwake(!0), h.SetAwake(!0)), ++this.m_contactCount))
    }
};
goog.exportSymbol("box2d.b2ContactManager.prototype.AddPair", box2d.b2ContactManager.prototype.AddPair);
box2d.b2JointFactory = {};
box2d.b2JointFactory.Create = function(a, b) {
    var c = null;
    switch (a.type) {
        case box2d.b2JointType.e_distanceJoint:
            c = new box2d.b2DistanceJoint(a instanceof box2d.b2DistanceJointDef ? a : null);
            break;
        case box2d.b2JointType.e_mouseJoint:
            c = new box2d.b2MouseJoint(a instanceof box2d.b2MouseJointDef ? a : null);
            break;
        case box2d.b2JointType.e_prismaticJoint:
            c = new box2d.b2PrismaticJoint(a instanceof box2d.b2PrismaticJointDef ? a : null);
            break;
        case box2d.b2JointType.e_revoluteJoint:
            c = new box2d.b2RevoluteJoint(a instanceof box2d.b2RevoluteJointDef ?
                    a : null);
            break;
        case box2d.b2JointType.e_pulleyJoint:
            c = new box2d.b2PulleyJoint(a instanceof box2d.b2PulleyJointDef ? a : null);
            break;
        case box2d.b2JointType.e_gearJoint:
            c = new box2d.b2GearJoint(a instanceof box2d.b2GearJointDef ? a : null);
            break;
        case box2d.b2JointType.e_wheelJoint:
            c = new box2d.b2WheelJoint(a instanceof box2d.b2WheelJointDef ? a : null);
            break;
        case box2d.b2JointType.e_weldJoint:
            c = new box2d.b2WeldJoint(a instanceof box2d.b2WeldJointDef ? a : null);
            break;
        case box2d.b2JointType.e_frictionJoint:
            c = new box2d.b2FrictionJoint(a instanceof
                    box2d.b2FrictionJointDef ? a : null);
            break;
        case box2d.b2JointType.e_ropeJoint:
            c = new box2d.b2RopeJoint(a instanceof box2d.b2RopeJointDef ? a : null);
            break;
        case box2d.b2JointType.e_motorJoint:
            c = new box2d.b2MotorJoint(a instanceof box2d.b2MotorJointDef ? a : null);
            break;
        case box2d.b2JointType.e_areaJoint:
            c = new box2d.b2AreaJoint(a instanceof box2d.b2AreaJointDef ? a : null);
            break;
        default:
            box2d.ENABLE_ASSERTS && box2d.b2Assert(!1)
    }
    return c
};
goog.exportSymbol("box2d.b2JointFactory.Create", box2d.b2JointFactory.Create);
box2d.b2JointFactory.Destroy = function(a, b) {
};
goog.exportSymbol("box2d.b2JointFactory.Destroy", box2d.b2JointFactory.Destroy);
box2d.b2Color = function(a, b, c) {
    this.r = a;
    this.g = b;
    this.b = c
};
goog.exportSymbol("box2d.b2Color", box2d.b2Color);
box2d.b2Color.prototype.r = 0.5;
goog.exportProperty(box2d.b2Color.prototype, "r", box2d.b2Color.prototype.r);
box2d.b2Color.prototype.g = 0.5;
goog.exportProperty(box2d.b2Color.prototype, "g", box2d.b2Color.prototype.g);
box2d.b2Color.prototype.b = 0.5;
goog.exportProperty(box2d.b2Color.prototype, "b", box2d.b2Color.prototype.b);
box2d.b2Color.prototype.SetRGB = function(a, b, c) {
    this.r = a;
    this.g = b;
    this.b = c;
    return this
};
goog.exportProperty(box2d.b2Color.prototype, "SetRGB", box2d.b2Color.prototype.SetRGB);
box2d.b2Color.prototype.MakeStyleString = function(a) {
    var b = Math.round(Math.max(0, Math.min(255, 255 * this.r))), c = Math.round(Math.max(0, Math.min(255, 255 * this.g))), e = Math.round(Math.max(0, Math.min(255, 255 * this.b)));
    a = "undefined" == typeof a ? Math.max(0, Math.min(1, a)) : 1;
    return box2d.b2Color.MakeStyleString(b, c, e, a)
};
goog.exportProperty(box2d.b2Color.prototype, "MakeStyleString", box2d.b2Color.prototype.MakeStyleString);
box2d.b2Color.MakeStyleString = function(a, b, c, e) {
    return 1 > e ? "rgba(" + a + "," + b + "," + c + "," + e + ")" : "rgb(" + a + "," + b + "," + c + ")"
};
goog.exportProperty(box2d.b2Color, "MakeStyleString", box2d.b2Color.MakeStyleString);
box2d.b2Color.RED = new box2d.b2Color(1, 0, 0);
goog.exportProperty(box2d.b2Color, "RED", box2d.b2Color.RED);
box2d.b2Color.GREEN = new box2d.b2Color(0, 1, 0);
goog.exportProperty(box2d.b2Color, "GREEN", box2d.b2Color.GREEN);
box2d.b2Color.BLUE = new box2d.b2Color(0, 0, 1);
goog.exportProperty(box2d.b2Color, "BLUE", box2d.b2Color.BLUE);
box2d.b2DrawFlags = {e_none: 0, e_shapeBit: 1, e_jointBit: 2, e_aabbBit: 4, e_pairBit: 8, e_centerOfMassBit: 16, e_controllerBit: 32, e_all: 63};
goog.exportSymbol("box2d.b2DrawFlags", box2d.b2DrawFlags);
goog.exportProperty(box2d.b2DrawFlags, "e_none", box2d.b2DrawFlags.e_none);
goog.exportProperty(box2d.b2DrawFlags, "e_shapeBit", box2d.b2DrawFlags.e_shapeBit);
goog.exportProperty(box2d.b2DrawFlags, "e_jointBit", box2d.b2DrawFlags.e_jointBit);
goog.exportProperty(box2d.b2DrawFlags, "e_aabbBit", box2d.b2DrawFlags.e_aabbBit);
goog.exportProperty(box2d.b2DrawFlags, "e_pairBit", box2d.b2DrawFlags.e_pairBit);
goog.exportProperty(box2d.b2DrawFlags, "e_centerOfMassBit", box2d.b2DrawFlags.e_centerOfMassBit);
goog.exportProperty(box2d.b2DrawFlags, "e_controllerBit", box2d.b2DrawFlags.e_controllerBit);
goog.exportProperty(box2d.b2DrawFlags, "e_all", box2d.b2DrawFlags.e_all);
box2d.b2Draw = function() {
};
goog.exportSymbol("box2d.b2Draw", box2d.b2Draw);
box2d.b2Draw.prototype.m_drawFlags = box2d.b2DrawFlags.e_none;
goog.exportProperty(box2d.b2Draw.prototype, "m_drawFlags", box2d.b2Draw.prototype.m_drawFlags);
box2d.b2Draw.prototype.SetFlags = function(a) {
    this.m_drawFlags = a
};
goog.exportProperty(box2d.b2Draw.prototype, "SetFlags", box2d.b2Draw.prototype.SetFlags);
box2d.b2Draw.prototype.GetFlags = function() {
    return this.m_drawFlags
};
goog.exportProperty(box2d.b2Draw.prototype, "GetFlags", box2d.b2Draw.prototype.GetFlags);
box2d.b2Draw.prototype.AppendFlags = function(a) {
    this.m_drawFlags |= a
};
goog.exportProperty(box2d.b2Draw.prototype, "AppendFlags", box2d.b2Draw.prototype.AppendFlags);
box2d.b2Draw.prototype.ClearFlags = function(a) {
    this.m_drawFlags &= ~a
};
goog.exportProperty(box2d.b2Draw.prototype, "ClearFlags", box2d.b2Draw.prototype.ClearFlags);
box2d.b2Draw.prototype.PushTransform = function(a) {
};
goog.exportProperty(box2d.b2Draw.prototype, "PushTransform", box2d.b2Draw.prototype.PushTransform);
box2d.b2Draw.prototype.PopTransform = function(a) {
};
goog.exportProperty(box2d.b2Draw.prototype, "PopTransform", box2d.b2Draw.prototype.PopTransform);
box2d.b2Draw.prototype.DrawPolygon = function(a, b, c) {
};
goog.exportProperty(box2d.b2Draw.prototype, "DrawPolygon", box2d.b2Draw.prototype.DrawPolygon);
box2d.b2Draw.prototype.DrawSolidPolygon = function(a, b, c) {
};
goog.exportProperty(box2d.b2Draw.prototype, "DrawSolidPolygon", box2d.b2Draw.prototype.DrawSolidPolygon);
box2d.b2Draw.prototype.DrawCircle = function(a, b, c) {
};
goog.exportProperty(box2d.b2Draw.prototype, "DrawCircle", box2d.b2Draw.prototype.DrawCircle);
box2d.b2Draw.prototype.DrawSolidCircle = function(a, b, c, e) {
};
goog.exportProperty(box2d.b2Draw.prototype, "DrawSolidCircle", box2d.b2Draw.prototype.DrawSolidCircle);
box2d.b2Draw.prototype.DrawSegment = function(a, b, c) {
};
goog.exportProperty(box2d.b2Draw.prototype, "DrawSegment", box2d.b2Draw.prototype.DrawSegment);
box2d.b2Draw.prototype.DrawTransform = function(a) {
};
goog.exportProperty(box2d.b2Draw.prototype, "DrawTransform", box2d.b2Draw.prototype.DrawTransform);
box2d.b2Filter = function() {
};
goog.exportSymbol("box2d.b2Filter", box2d.b2Filter);
box2d.b2Filter.prototype.categoryBits = 1;
goog.exportProperty(box2d.b2Filter.prototype, "categoryBits", box2d.b2Filter.prototype.categoryBits);
box2d.b2Filter.prototype.maskBits = 65535;
goog.exportProperty(box2d.b2Filter.prototype, "maskBits", box2d.b2Filter.prototype.maskBits);
box2d.b2Filter.prototype.groupIndex = 0;
goog.exportProperty(box2d.b2Filter.prototype, "groupIndex", box2d.b2Filter.prototype.groupIndex);
box2d.b2Filter.prototype.Clone = function() {
    return(new box2d.b2Filter).Copy(this)
};
goog.exportProperty(box2d.b2Filter.prototype, "Clone", box2d.b2Filter.prototype.Clone);
box2d.b2Filter.prototype.Copy = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this !== a);
    this.categoryBits = a.categoryBits;
    this.maskBits = a.maskBits;
    this.groupIndex = a.groupIndex;
    return this
};
goog.exportProperty(box2d.b2Filter.prototype, "Copy", box2d.b2Filter.prototype.Copy);
box2d.b2FixtureDef = function() {
    this.filter = new box2d.b2Filter
};
goog.exportSymbol("box2d.b2FixtureDef", box2d.b2FixtureDef);
box2d.b2FixtureDef.prototype.shape = null;
goog.exportProperty(box2d.b2FixtureDef.prototype, "shape", box2d.b2FixtureDef.prototype.shape);
box2d.b2FixtureDef.prototype.userData = null;
goog.exportProperty(box2d.b2FixtureDef.prototype, "userData", box2d.b2FixtureDef.prototype.userData);
box2d.b2FixtureDef.prototype.friction = 0.2;
goog.exportProperty(box2d.b2FixtureDef.prototype, "friction", box2d.b2FixtureDef.prototype.friction);
box2d.b2FixtureDef.prototype.restitution = 0;
goog.exportProperty(box2d.b2FixtureDef.prototype, "restitution", box2d.b2FixtureDef.prototype.restitution);
box2d.b2FixtureDef.prototype.density = 0;
goog.exportProperty(box2d.b2FixtureDef.prototype, "density", box2d.b2FixtureDef.prototype.density);
box2d.b2FixtureDef.prototype.isSensor = !1;
goog.exportProperty(box2d.b2FixtureDef.prototype, "isSensor", box2d.b2FixtureDef.prototype.isSensor);
box2d.b2FixtureDef.prototype.filter = null;
goog.exportProperty(box2d.b2FixtureDef.prototype, "filter", box2d.b2FixtureDef.prototype.filter);
box2d.b2FixtureProxy = function() {
    this.aabb = new box2d.b2AABB
};
goog.exportSymbol("box2d.b2FixtureProxy", box2d.b2FixtureProxy);
box2d.b2FixtureProxy.prototype.aabb = null;
goog.exportProperty(box2d.b2FixtureProxy.prototype, "aabb", box2d.b2FixtureProxy.prototype.aabb);
box2d.b2FixtureProxy.prototype.fixture = null;
goog.exportProperty(box2d.b2FixtureProxy.prototype, "fixture", box2d.b2FixtureProxy.prototype.fixture);
box2d.b2FixtureProxy.prototype.childIndex = 0;
goog.exportProperty(box2d.b2FixtureProxy.prototype, "childIndex", box2d.b2FixtureProxy.prototype.childIndex);
box2d.b2FixtureProxy.prototype.proxy = null;
goog.exportProperty(box2d.b2FixtureProxy.prototype, "proxy", box2d.b2FixtureProxy.prototype.proxy);
box2d.b2FixtureProxy.MakeArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return new box2d.b2FixtureProxy
    })
};
goog.exportProperty(box2d.b2FixtureProxy, "MakeArray", box2d.b2FixtureProxy.MakeArray);
box2d.b2Fixture = function() {
    this.m_proxyCount = 0;
    this.m_filter = new box2d.b2Filter
};
goog.exportSymbol("box2d.b2Fixture", box2d.b2Fixture);
box2d.b2Fixture.prototype.m_density = 0;
goog.exportProperty(box2d.b2Fixture.prototype, "m_density", box2d.b2Fixture.prototype.m_density);
box2d.b2Fixture.prototype.m_next = null;
goog.exportProperty(box2d.b2Fixture.prototype, "m_next", box2d.b2Fixture.prototype.m_next);
box2d.b2Fixture.prototype.m_body = null;
goog.exportProperty(box2d.b2Fixture.prototype, "m_body", box2d.b2Fixture.prototype.m_body);
box2d.b2Fixture.prototype.m_shape = null;
goog.exportProperty(box2d.b2Fixture.prototype, "m_shape", box2d.b2Fixture.prototype.m_shape);
box2d.b2Fixture.prototype.m_friction = 0;
goog.exportProperty(box2d.b2Fixture.prototype, "m_friction", box2d.b2Fixture.prototype.m_friction);
box2d.b2Fixture.prototype.m_restitution = 0;
goog.exportProperty(box2d.b2Fixture.prototype, "m_restitution", box2d.b2Fixture.prototype.m_restitution);
box2d.b2Fixture.prototype.m_proxies = null;
goog.exportProperty(box2d.b2Fixture.prototype, "m_proxies", box2d.b2Fixture.prototype.m_proxies);
box2d.b2Fixture.prototype.m_proxyCount = 0;
goog.exportProperty(box2d.b2Fixture.prototype, "m_proxyCount", box2d.b2Fixture.prototype.m_proxyCount);
box2d.b2Fixture.prototype.m_filter = null;
goog.exportProperty(box2d.b2Fixture.prototype, "m_filter", box2d.b2Fixture.prototype.m_filter);
box2d.b2Fixture.prototype.m_isSensor = !1;
goog.exportProperty(box2d.b2Fixture.prototype, "m_isSensor", box2d.b2Fixture.prototype.m_isSensor);
box2d.b2Fixture.prototype.m_userData = null;
goog.exportProperty(box2d.b2Fixture.prototype, "m_userData", box2d.b2Fixture.prototype.m_userData);
box2d.b2Fixture.prototype.GetType = function() {
    return this.m_shape.GetType()
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetType", box2d.b2Fixture.prototype.GetType);
box2d.b2Fixture.prototype.GetShape = function() {
    return this.m_shape
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetShape", box2d.b2Fixture.prototype.GetShape);
box2d.b2Fixture.prototype.IsSensor = function() {
    return this.m_isSensor
};
goog.exportProperty(box2d.b2Fixture.prototype, "IsSensor", box2d.b2Fixture.prototype.IsSensor);
box2d.b2Fixture.prototype.GetFilterData = function() {
    return this.m_filter
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetFilterData", box2d.b2Fixture.prototype.GetFilterData);
box2d.b2Fixture.prototype.GetUserData = function() {
    return this.m_userData
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetUserData", box2d.b2Fixture.prototype.GetUserData);
box2d.b2Fixture.prototype.SetUserData = function(a) {
    this.m_userData = a
};
goog.exportProperty(box2d.b2Fixture.prototype, "SetUserData", box2d.b2Fixture.prototype.SetUserData);
box2d.b2Fixture.prototype.GetBody = function() {
    return this.m_body
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetBody", box2d.b2Fixture.prototype.GetBody);
box2d.b2Fixture.prototype.GetNext = function() {
    return this.m_next
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetNext", box2d.b2Fixture.prototype.GetNext);
box2d.b2Fixture.prototype.SetDensity = function(a) {
    this.m_density = a
};
goog.exportProperty(box2d.b2Fixture.prototype, "SetDensity", box2d.b2Fixture.prototype.SetDensity);
box2d.b2Fixture.prototype.GetDensity = function() {
    return this.m_density
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetDensity", box2d.b2Fixture.prototype.GetDensity);
box2d.b2Fixture.prototype.GetFriction = function() {
    return this.m_friction
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetFriction", box2d.b2Fixture.prototype.GetFriction);
box2d.b2Fixture.prototype.SetFriction = function(a) {
    this.m_friction = a
};
goog.exportProperty(box2d.b2Fixture.prototype, "SetFriction", box2d.b2Fixture.prototype.SetFriction);
box2d.b2Fixture.prototype.GetRestitution = function() {
    return this.m_restitution
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetRestitution", box2d.b2Fixture.prototype.GetRestitution);
box2d.b2Fixture.prototype.SetRestitution = function(a) {
    this.m_restitution = a
};
goog.exportProperty(box2d.b2Fixture.prototype, "SetRestitution", box2d.b2Fixture.prototype.SetRestitution);
box2d.b2Fixture.prototype.TestPoint = function(a) {
    return this.m_shape.TestPoint(this.m_body.GetTransform(), a)
};
goog.exportProperty(box2d.b2Fixture.prototype, "TestPoint", box2d.b2Fixture.prototype.TestPoint);
box2d.b2Fixture.prototype.RayCast = function(a, b, c) {
    return this.m_shape.RayCast(a, b, this.m_body.GetTransform(), c)
};
goog.exportProperty(box2d.b2Fixture.prototype, "RayCast", box2d.b2Fixture.prototype.RayCast);
box2d.b2Fixture.prototype.GetMassData = function(a) {
    a = a || new box2d.b2MassData;
    this.m_shape.ComputeMass(a, this.m_density);
    return a
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetMassData", box2d.b2Fixture.prototype.GetMassData);
box2d.b2Fixture.prototype.GetAABB = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= a && a < this.m_proxyCount);
    return this.m_proxies[a].aabb
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetAABB", box2d.b2Fixture.prototype.GetAABB);
box2d.b2Fixture.prototype.Create = function(a, b) {
    this.m_userData = b.userData;
    this.m_friction = b.friction;
    this.m_restitution = b.restitution;
    this.m_body = a;
    this.m_next = null;
    this.m_filter.Copy(b.filter);
    this.m_isSensor = b.isSensor;
    this.m_shape = b.shape.Clone();
    this.m_proxies = box2d.b2FixtureProxy.MakeArray(this.m_shape.GetChildCount());
    this.m_proxyCount = 0;
    this.m_density = b.density
};
goog.exportProperty(box2d.b2Fixture.prototype, "Create", box2d.b2Fixture.prototype.Create);
box2d.b2Fixture.prototype.Destroy = function() {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 == this.m_proxyCount);
    this.m_shape = null
};
goog.exportProperty(box2d.b2Fixture.prototype, "Destroy", box2d.b2Fixture.prototype.Destroy);
box2d.b2Fixture.prototype.CreateProxies = function(a, b) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 == this.m_proxyCount);
    this.m_proxyCount = this.m_shape.GetChildCount();
    for (var c = 0; c < this.m_proxyCount; ++c) {
        var e = this.m_proxies[c];
        this.m_shape.ComputeAABB(e.aabb, b, c);
        e.proxy = a.CreateProxy(e.aabb, e);
        e.fixture = this;
        e.childIndex = c
    }
};
goog.exportProperty(box2d.b2Fixture.prototype, "CreateProxies", box2d.b2Fixture.prototype.CreateProxies);
box2d.b2Fixture.prototype.DestroyProxies = function(a) {
    for (var b = 0; b < this.m_proxyCount; ++b) {
        var c = this.m_proxies[b];
        a.DestroyProxy(c.proxy);
        c.proxy = null
    }
    this.m_proxyCount = 0
};
goog.exportProperty(box2d.b2Fixture.prototype, "DestroyProxies", box2d.b2Fixture.prototype.DestroyProxies);
box2d.b2Fixture.prototype.Synchronize = function(a, b, c) {
    if (0 != this.m_proxyCount)
        for (var e = 0; e < this.m_proxyCount; ++e) {
            var d = this.m_proxies[e], f = box2d.b2Fixture.prototype.Synchronize.s_aabb1, g = box2d.b2Fixture.prototype.Synchronize.s_aabb2;
            this.m_shape.ComputeAABB(f, b, e);
            this.m_shape.ComputeAABB(g, c, e);
            d.aabb.Combine2(f, g);
            f = box2d.b2SubVV(c.p, b.p, box2d.b2Fixture.prototype.Synchronize.s_displacement);
            a.MoveProxy(d.proxy, d.aabb, f)
        }
};
goog.exportProperty(box2d.b2Fixture.prototype, "Synchronize", box2d.b2Fixture.prototype.Synchronize);
box2d.b2Fixture.prototype.Synchronize.s_aabb1 = new box2d.b2AABB;
box2d.b2Fixture.prototype.Synchronize.s_aabb2 = new box2d.b2AABB;
box2d.b2Fixture.prototype.Synchronize.s_displacement = new box2d.b2Vec2;
box2d.b2Fixture.prototype.SetFilterData = function(a) {
    this.m_filter.Copy(a);
    this.Refilter()
};
goog.exportProperty(box2d.b2Fixture.prototype, "SetFilterData", box2d.b2Fixture.prototype.SetFilterData);
box2d.b2Fixture.prototype.Refilter = function() {
    if (!this.m_body) {
        for (var a = this.m_body.GetContactList(); a; ) {
            var b = a.contact, c = b.GetFixtureA(), e = b.GetFixtureB();
            c != this && e != this || b.FlagForFiltering();
            a = a.next
        }
        a = this.m_body.GetWorld();
        if (null !== a)
            for (a = a.m_contactManager.m_broadPhase, b = 0; b < this.m_proxyCount; ++b)
                a.TouchProxy(this.m_proxies[b].proxy)
    }
};
goog.exportProperty(box2d.b2Fixture.prototype, "Refilter", box2d.b2Fixture.prototype.Refilter);
box2d.b2Fixture.prototype.SetSensor = function(a) {
    a != this.m_isSensor && (this.m_body.SetAwake(!0), this.m_isSensor = a)
};
goog.exportProperty(box2d.b2Fixture.prototype, "SetSensor", box2d.b2Fixture.prototype.SetSensor);
box2d.b2Fixture.prototype.Dump = function(a) {
    box2d.DEBUG && (box2d.b2Log("    /*box2d.b2FixtureDef*/ var fd = new box2d.b2FixtureDef();\n"), box2d.b2Log("    fd.friction = %.15f;\n", this.m_friction), box2d.b2Log("    fd.restitution = %.15f;\n", this.m_restitution), box2d.b2Log("    fd.density = %.15f;\n", this.m_density), box2d.b2Log("    fd.isSensor = %s;\n", this.m_isSensor ? "true" : "false"), box2d.b2Log("    fd.filter.categoryBits = %d;\n", this.m_filter.categoryBits), box2d.b2Log("    fd.filter.maskBits = %d;\n",
            this.m_filter.maskBits), box2d.b2Log("    fd.filter.groupIndex = %d;\n", this.m_filter.groupIndex), this.m_shape.Dump(), box2d.b2Log("\n"), box2d.b2Log("    fd.shape = shape;\n"), box2d.b2Log("\n"), box2d.b2Log("    bodies[%d].CreateFixture(fd);\n", a))
};
goog.exportProperty(box2d.b2Fixture.prototype, "Dump", box2d.b2Fixture.prototype.Dump);
box2d.b2BodyType = {b2_unknown: -1, b2_staticBody: 0, b2_kinematicBody: 1, b2_dynamicBody: 2, b2_bulletBody: 3};
goog.exportSymbol("box2d.b2BodyType", box2d.b2BodyType);
goog.exportProperty(box2d.b2BodyType, "b2_unknown", box2d.b2BodyType.b2_unknown);
goog.exportProperty(box2d.b2BodyType, "b2_staticBody", box2d.b2BodyType.b2_staticBody);
goog.exportProperty(box2d.b2BodyType, "b2_kinematicBody", box2d.b2BodyType.b2_kinematicBody);
goog.exportProperty(box2d.b2BodyType, "b2_dynamicBody", box2d.b2BodyType.b2_dynamicBody);
goog.exportProperty(box2d.b2BodyType, "b2_bulletBody", box2d.b2BodyType.b2_bulletBody);
box2d.b2BodyDef = function() {
    this.position = new box2d.b2Vec2(0, 0);
    this.linearVelocity = new box2d.b2Vec2(0, 0)
};
goog.exportSymbol("box2d.b2BodyDef", box2d.b2BodyDef);
box2d.b2BodyDef.prototype.type = box2d.b2BodyType.b2_staticBody;
goog.exportProperty(box2d.b2BodyDef.prototype, "type", box2d.b2BodyDef.prototype.type);
box2d.b2BodyDef.prototype.position = null;
goog.exportProperty(box2d.b2BodyDef.prototype, "position", box2d.b2BodyDef.prototype.position);
box2d.b2BodyDef.prototype.angle = 0;
goog.exportProperty(box2d.b2BodyDef.prototype, "angle", box2d.b2BodyDef.prototype.angle);
box2d.b2BodyDef.prototype.linearVelocity = null;
goog.exportProperty(box2d.b2BodyDef.prototype, "linearVelocity", box2d.b2BodyDef.prototype.linearVelocity);
box2d.b2BodyDef.prototype.angularVelocity = 0;
goog.exportProperty(box2d.b2BodyDef.prototype, "angularVelocity", box2d.b2BodyDef.prototype.angularVelocity);
box2d.b2BodyDef.prototype.linearDamping = 0;
goog.exportProperty(box2d.b2BodyDef.prototype, "linearDamping", box2d.b2BodyDef.prototype.linearDamping);
box2d.b2BodyDef.prototype.angularDamping = 0;
goog.exportProperty(box2d.b2BodyDef.prototype, "angularDamping", box2d.b2BodyDef.prototype.angularDamping);
box2d.b2BodyDef.prototype.allowSleep = !0;
goog.exportProperty(box2d.b2BodyDef.prototype, "allowSleep", box2d.b2BodyDef.prototype.allowSleep);
box2d.b2BodyDef.prototype.awake = !0;
goog.exportProperty(box2d.b2BodyDef.prototype, "awake", box2d.b2BodyDef.prototype.awake);
box2d.b2BodyDef.prototype.fixedRotation = !1;
goog.exportProperty(box2d.b2BodyDef.prototype, "fixedRotation", box2d.b2BodyDef.prototype.fixedRotation);
box2d.b2BodyDef.prototype.bullet = !1;
goog.exportProperty(box2d.b2BodyDef.prototype, "bullet", box2d.b2BodyDef.prototype.bullet);
box2d.b2BodyDef.prototype.active = !0;
goog.exportProperty(box2d.b2BodyDef.prototype, "active", box2d.b2BodyDef.prototype.active);
box2d.b2BodyDef.prototype.userData = null;
goog.exportProperty(box2d.b2BodyDef.prototype, "userData", box2d.b2BodyDef.prototype.userData);
box2d.b2BodyDef.prototype.gravityScale = 1;
goog.exportProperty(box2d.b2BodyDef.prototype, "gravityScale", box2d.b2BodyDef.prototype.gravityScale);
box2d.b2BodyFlag = {e_none: 0, e_islandFlag: 1, e_awakeFlag: 2, e_autoSleepFlag: 4, e_bulletFlag: 8, e_fixedRotationFlag: 16, e_activeFlag: 32, e_toiFlag: 64};
goog.exportProperty(box2d.b2BodyFlag, "e_none", box2d.b2BodyFlag.e_none);
goog.exportProperty(box2d.b2BodyFlag, "e_islandFlag", box2d.b2BodyFlag.e_islandFlag);
goog.exportProperty(box2d.b2BodyFlag, "e_awakeFlag", box2d.b2BodyFlag.e_awakeFlag);
goog.exportProperty(box2d.b2BodyFlag, "e_autoSleepFlag", box2d.b2BodyFlag.e_autoSleepFlag);
goog.exportProperty(box2d.b2BodyFlag, "e_bulletFlag", box2d.b2BodyFlag.e_bulletFlag);
goog.exportProperty(box2d.b2BodyFlag, "e_fixedRotationFlag", box2d.b2BodyFlag.e_fixedRotationFlag);
goog.exportProperty(box2d.b2BodyFlag, "e_activeFlag", box2d.b2BodyFlag.e_activeFlag);
goog.exportProperty(box2d.b2BodyFlag, "e_toiFlag", box2d.b2BodyFlag.e_toiFlag);
box2d.b2Body = function(a, b) {
    this.m_xf = new box2d.b2Transform;
    this.m_out_xf = new box2d.b2Transform;
    this.m_sweep = new box2d.b2Sweep;
    this.m_out_sweep = new box2d.b2Sweep;
    this.m_linearVelocity = new box2d.b2Vec2;
    this.m_out_linearVelocity = new box2d.b2Vec2;
    this.m_force = new box2d.b2Vec2;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.position.IsValid());
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.linearVelocity.IsValid());
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a.angle));
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a.angularVelocity));
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a.gravityScale) && 0 <= a.gravityScale);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a.angularDamping) && 0 <= a.angularDamping);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a.linearDamping) && 0 <= a.linearDamping);
    this.m_flags = box2d.b2BodyFlag.e_none;
    a.bullet && (this.m_flags |= box2d.b2BodyFlag.e_bulletFlag);
    a.fixedRotation && (this.m_flags |= box2d.b2BodyFlag.e_fixedRotationFlag);
    a.allowSleep && (this.m_flags |= box2d.b2BodyFlag.e_autoSleepFlag);
    a.awake &&
            (this.m_flags |= box2d.b2BodyFlag.e_awakeFlag);
    a.active && (this.m_flags |= box2d.b2BodyFlag.e_activeFlag);
    this.m_world = b;
    this.m_xf.p.Copy(a.position);
    this.m_xf.q.SetAngleRadians(a.angle);
    this.m_sweep.localCenter.SetZero();
    this.m_sweep.c0.Copy(this.m_xf.p);
    this.m_sweep.c.Copy(this.m_xf.p);
    this.m_sweep.a0 = a.angle;
    this.m_sweep.a = a.angle;
    this.m_sweep.alpha0 = 0;
    this.m_linearVelocity.Copy(a.linearVelocity);
    this.m_angularVelocity = a.angularVelocity;
    this.m_linearDamping = a.linearDamping;
    this.m_angularDamping = a.angularDamping;
    this.m_gravityScale = a.gravityScale;
    this.m_force.SetZero();
    this.m_sleepTime = this.m_torque = 0;
    this.m_type = a.type;
    this.m_invMass = a.type == box2d.b2BodyType.b2_dynamicBody ? this.m_mass = 1 : this.m_mass = 0;
    this.m_invI = this.m_I = 0;
    this.m_userData = a.userData;
    this.m_fixtureList = null;
    this.m_fixtureCount = 0;
    this.m_controllerList = null;
    this.m_controllerCount = 0
};
goog.exportSymbol("box2d.b2Body", box2d.b2Body);
box2d.b2Body.prototype.m_flags = box2d.b2BodyFlag.e_none;
goog.exportProperty(box2d.b2Body.prototype, "m_flags", box2d.b2Body.prototype.m_flags);
box2d.b2Body.prototype.m_islandIndex = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_islandIndex", box2d.b2Body.prototype.m_islandIndex);
box2d.b2Body.prototype.m_world = null;
goog.exportProperty(box2d.b2Body.prototype, "m_world", box2d.b2Body.prototype.m_world);
box2d.b2Body.prototype.m_xf = null;
goog.exportProperty(box2d.b2Body.prototype, "m_xf", box2d.b2Body.prototype.m_xf);
box2d.b2Body.prototype.m_out_xf = null;
goog.exportProperty(box2d.b2Body.prototype, "m_out_xf", box2d.b2Body.prototype.m_out_xf);
box2d.b2Body.prototype.m_sweep = null;
goog.exportProperty(box2d.b2Body.prototype, "m_sweep", box2d.b2Body.prototype.m_sweep);
box2d.b2Body.prototype.m_out_sweep = null;
goog.exportProperty(box2d.b2Body.prototype, "m_out_sweep", box2d.b2Body.prototype.m_out_sweep);
box2d.b2Body.prototype.m_jointList = null;
goog.exportProperty(box2d.b2Body.prototype, "m_jointList", box2d.b2Body.prototype.m_jointList);
box2d.b2Body.prototype.m_contactList = null;
goog.exportProperty(box2d.b2Body.prototype, "m_contactList", box2d.b2Body.prototype.m_contactList);
box2d.b2Body.prototype.m_prev = null;
goog.exportProperty(box2d.b2Body.prototype, "m_prev", box2d.b2Body.prototype.m_prev);
box2d.b2Body.prototype.m_next = null;
goog.exportProperty(box2d.b2Body.prototype, "m_next", box2d.b2Body.prototype.m_next);
box2d.b2Body.prototype.m_linearVelocity = null;
goog.exportProperty(box2d.b2Body.prototype, "m_linearVelocity", box2d.b2Body.prototype.m_linearVelocity);
box2d.b2Body.prototype.m_out_linearVelocity = null;
goog.exportProperty(box2d.b2Body.prototype, "m_out_linearVelocity", box2d.b2Body.prototype.m_out_linearVelocity);
box2d.b2Body.prototype.m_angularVelocity = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_angularVelocity", box2d.b2Body.prototype.m_angularVelocity);
box2d.b2Body.prototype.m_linearDamping = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_linearDamping", box2d.b2Body.prototype.m_linearDamping);
box2d.b2Body.prototype.m_angularDamping = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_angularDamping", box2d.b2Body.prototype.m_angularDamping);
box2d.b2Body.prototype.m_gravityScale = 1;
goog.exportProperty(box2d.b2Body.prototype, "m_gravityScale", box2d.b2Body.prototype.m_gravityScale);
box2d.b2Body.prototype.m_force = null;
goog.exportProperty(box2d.b2Body.prototype, "m_force", box2d.b2Body.prototype.m_force);
box2d.b2Body.prototype.m_torque = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_torque", box2d.b2Body.prototype.m_torque);
box2d.b2Body.prototype.m_sleepTime = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_sleepTime", box2d.b2Body.prototype.m_sleepTime);
box2d.b2Body.prototype.m_type = box2d.b2BodyType.b2_staticBody;
goog.exportProperty(box2d.b2Body.prototype, "m_type", box2d.b2Body.prototype.m_type);
box2d.b2Body.prototype.m_mass = 1;
goog.exportProperty(box2d.b2Body.prototype, "m_mass", box2d.b2Body.prototype.m_mass);
box2d.b2Body.prototype.m_invMass = 1;
goog.exportProperty(box2d.b2Body.prototype, "m_invMass", box2d.b2Body.prototype.m_invMass);
box2d.b2Body.prototype.m_I = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_I", box2d.b2Body.prototype.m_I);
box2d.b2Body.prototype.m_invI = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_invI", box2d.b2Body.prototype.m_invI);
box2d.b2Body.prototype.m_userData = null;
goog.exportProperty(box2d.b2Body.prototype, "m_userData", box2d.b2Body.prototype.m_userData);
box2d.b2Body.prototype.m_fixtureList = null;
goog.exportProperty(box2d.b2Body.prototype, "m_fixtureList", box2d.b2Body.prototype.m_fixtureList);
box2d.b2Body.prototype.m_fixtureCount = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_fixtureCount", box2d.b2Body.prototype.m_fixtureCount);
box2d.b2Body.prototype.m_controllerList = null;
goog.exportProperty(box2d.b2Body.prototype, "m_controllerList", box2d.b2Body.prototype.m_controllerList);
box2d.b2Body.prototype.m_controllerCount = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_controllerCount", box2d.b2Body.prototype.m_controllerCount);
box2d.b2Body.prototype.CreateFixture = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.m_world.IsLocked());
    if (!0 == this.m_world.IsLocked())
        return null;
    var b = new box2d.b2Fixture;
    b.Create(this, a);
    this.m_flags & box2d.b2BodyFlag.e_activeFlag && b.CreateProxies(this.m_world.m_contactManager.m_broadPhase, this.m_xf);
    b.m_next = this.m_fixtureList;
    this.m_fixtureList = b;
    ++this.m_fixtureCount;
    b.m_body = this;
    0 < b.m_density && this.ResetMassData();
    this.m_world.m_flags |= box2d.b2WorldFlag.e_newFixture;
    return b
};
goog.exportProperty(box2d.b2Body.prototype, "CreateFixture", box2d.b2Body.prototype.CreateFixture);
box2d.b2Body.prototype.CreateFixture2 = function(a, b) {
    void 0 === b && (b = 0);
    var c = box2d.b2Body.prototype.CreateFixture2.s_def;
    c.shape = a;
    c.density = b;
    return this.CreateFixture(c)
};
goog.exportProperty(box2d.b2Body.prototype, "CreateFixture2", box2d.b2Body.prototype.CreateFixture2);
box2d.b2Body.prototype.CreateFixture2.s_def = new box2d.b2FixtureDef;
box2d.b2Body.prototype.DestroyFixture = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.m_world.IsLocked());
    if (!0 != this.m_world.IsLocked()) {
        box2d.ENABLE_ASSERTS && box2d.b2Assert(a.m_body == this);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < this.m_fixtureCount);
        for (var b = this.m_fixtureList, c = null, e = !1; null != b; ) {
            if (b == a) {
                c ? c.m_next = a.m_next : this.m_fixtureList = a.m_next;
                e = !0;
                break
            }
            c = b;
            b = b.m_next
        }
        box2d.ENABLE_ASSERTS && box2d.b2Assert(e);
        for (b = this.m_contactList; b; ) {
            var c = b.contact, b = b.next, e = c.GetFixtureA(),
                    d = c.GetFixtureB();
            a != e && a != d || this.m_world.m_contactManager.Destroy(c)
        }
        this.m_flags & box2d.b2BodyFlag.e_activeFlag && a.DestroyProxies(this.m_world.m_contactManager.m_broadPhase);
        a.Destroy();
        a.m_body = null;
        a.m_next = null;
        --this.m_fixtureCount;
        this.ResetMassData()
    }
};
goog.exportProperty(box2d.b2Body.prototype, "DestroyFixture", box2d.b2Body.prototype.DestroyFixture);
box2d.b2Body.prototype.SetTransformVecRadians = function(a, b) {
    this.SetTransformXYRadians(a.x, a.y, b)
};
goog.exportProperty(box2d.b2Body.prototype, "SetTransformVecRadians", box2d.b2Body.prototype.SetTransformVecRadians);
box2d.b2Body.prototype.SetTransformXYRadians = function(a, b, c) {
    if (this.m_xf.p.x != a || this.m_xf.p.y != b || this.m_xf.q.GetAngleRadians() != c)
        if (box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.m_world.IsLocked()), !0 != this.m_world.IsLocked()) {
            this.m_xf.q.SetAngleRadians(c);
            this.m_xf.p.SetXY(a, b);
            box2d.b2MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);
            this.m_sweep.a = c;
            this.m_sweep.c0.Copy(this.m_sweep.c);
            this.m_sweep.a0 = c;
            a = this.m_world.m_contactManager.m_broadPhase;
            for (b = this.m_fixtureList; b; b = b.m_next)
                b.Synchronize(a,
                        this.m_xf, this.m_xf);
            this.m_world.m_contactManager.FindNewContacts()
        }
};
goog.exportProperty(box2d.b2Body.prototype, "SetTransformXYRadians", box2d.b2Body.prototype.SetTransformXYRadians);
box2d.b2Body.prototype.SetTransform = function(a) {
    this.SetTransformVecRadians(a.p, a.GetAngleRadians())
};
goog.exportProperty(box2d.b2Body.prototype, "SetTransform", box2d.b2Body.prototype.SetTransform);
box2d.b2Body.prototype.GetTransform = function(a) {
    a = a || this.m_out_xf;
    return a.Copy(this.m_xf)
};
goog.exportProperty(box2d.b2Body.prototype, "GetTransform", box2d.b2Body.prototype.GetTransform);
box2d.b2Body.prototype.GetPosition = function(a) {
    a = a || this.m_out_xf.p;
    return a.Copy(this.m_xf.p)
};
goog.exportProperty(box2d.b2Body.prototype, "GetPosition", box2d.b2Body.prototype.GetPosition);
box2d.b2Body.prototype.SetPosition = function(a) {
    this.SetTransformVecRadians(a, this.GetAngleRadians())
};
goog.exportProperty(box2d.b2Body.prototype, "SetPosition", box2d.b2Body.prototype.SetPosition);
box2d.b2Body.prototype.SetPositionXY = function(a, b) {
    this.SetTransformXYRadians(a, b, this.GetAngleRadians())
};
goog.exportProperty(box2d.b2Body.prototype, "SetPositionXY", box2d.b2Body.prototype.SetPositionXY);
box2d.b2Body.prototype.GetAngleRadians = function() {
    return this.m_sweep.a
};
goog.exportProperty(box2d.b2Body.prototype, "GetAngleRadians", box2d.b2Body.prototype.GetAngleRadians);
box2d.b2Body.prototype.SetAngleRadians = function(a) {
    this.SetTransformVecRadians(this.GetPosition(), a)
};
goog.exportProperty(box2d.b2Body.prototype, "SetAngleRadians", box2d.b2Body.prototype.SetAngleRadians);
box2d.b2Body.prototype.GetWorldCenter = function(a) {
    a = a || this.m_out_sweep.c;
    return a.Copy(this.m_sweep.c)
};
goog.exportProperty(box2d.b2Body.prototype, "GetWorldCenter", box2d.b2Body.prototype.GetWorldCenter);
box2d.b2Body.prototype.GetLocalCenter = function(a) {
    a = a || this.m_out_sweep.localCenter;
    return a.Copy(this.m_sweep.localCenter)
};
goog.exportProperty(box2d.b2Body.prototype, "GetLocalCenter", box2d.b2Body.prototype.GetLocalCenter);
box2d.b2Body.prototype.SetLinearVelocity = function(a) {
    this.m_type != box2d.b2BodyType.b2_staticBody && (0 < box2d.b2DotVV(a, a) && this.SetAwake(!0), this.m_linearVelocity.Copy(a))
};
goog.exportProperty(box2d.b2Body.prototype, "SetLinearVelocity", box2d.b2Body.prototype.SetLinearVelocity);
box2d.b2Body.prototype.GetLinearVelocity = function(a) {
    a = a || this.m_out_linearVelocity;
    return a.Copy(this.m_linearVelocity)
};
goog.exportProperty(box2d.b2Body.prototype, "GetLinearVelocity", box2d.b2Body.prototype.GetLinearVelocity);
box2d.b2Body.prototype.SetAngularVelocity = function(a) {
    this.m_type != box2d.b2BodyType.b2_staticBody && (0 < a * a && this.SetAwake(!0), this.m_angularVelocity = a)
};
goog.exportProperty(box2d.b2Body.prototype, "SetAngularVelocity", box2d.b2Body.prototype.SetAngularVelocity);
box2d.b2Body.prototype.GetAngularVelocity = function() {
    return this.m_angularVelocity
};
goog.exportProperty(box2d.b2Body.prototype, "GetAngularVelocity", box2d.b2Body.prototype.GetAngularVelocity);
box2d.b2Body.prototype.GetDefinition = function(a) {
    a.type = this.GetType();
    a.allowSleep = (this.m_flags & box2d.b2BodyFlag.e_autoSleepFlag) == box2d.b2BodyFlag.e_autoSleepFlag;
    a.angle = this.GetAngleRadians();
    a.angularDamping = this.m_angularDamping;
    a.gravityScale = this.m_gravityScale;
    a.angularVelocity = this.m_angularVelocity;
    a.fixedRotation = (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) == box2d.b2BodyFlag.e_fixedRotationFlag;
    a.bullet = (this.m_flags & box2d.b2BodyFlag.e_bulletFlag) == box2d.b2BodyFlag.e_bulletFlag;
    a.awake = (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) == box2d.b2BodyFlag.e_awakeFlag;
    a.linearDamping = this.m_linearDamping;
    a.linearVelocity.Copy(this.GetLinearVelocity());
    a.position.Copy(this.GetPosition());
    a.userData = this.GetUserData();
    return a
};
goog.exportProperty(box2d.b2Body.prototype, "GetDefinition", box2d.b2Body.prototype.GetDefinition);
box2d.b2Body.prototype.ApplyForce = function(a, b, c) {
    this.m_type == box2d.b2BodyType.b2_dynamicBody && (0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_force.x += a.x, this.m_force.y += a.y, this.m_torque += (b.x - this.m_sweep.c.x) * a.y - (b.y - this.m_sweep.c.y) * a.x))
};
goog.exportProperty(box2d.b2Body.prototype, "ApplyForce", box2d.b2Body.prototype.ApplyForce);
box2d.b2Body.prototype.ApplyForceToCenter = function(a, b) {
    this.m_type == box2d.b2BodyType.b2_dynamicBody && (0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_force.x += a.x, this.m_force.y += a.y))
};
goog.exportProperty(box2d.b2Body.prototype, "ApplyForceToCenter", box2d.b2Body.prototype.ApplyForceToCenter);
box2d.b2Body.prototype.ApplyTorque = function(a, b) {
    this.m_type == box2d.b2BodyType.b2_dynamicBody && (0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_torque += a))
};
goog.exportProperty(box2d.b2Body.prototype, "ApplyTorque", box2d.b2Body.prototype.ApplyTorque);
box2d.b2Body.prototype.ApplyLinearImpulse = function(a, b, c) {
    this.m_type == box2d.b2BodyType.b2_dynamicBody && (0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_linearVelocity.x += this.m_invMass * a.x, this.m_linearVelocity.y += this.m_invMass * a.y, this.m_angularVelocity += this.m_invI * ((b.x - this.m_sweep.c.x) * a.y - (b.y - this.m_sweep.c.y) * a.x)))
};
goog.exportProperty(box2d.b2Body.prototype, "ApplyLinearImpulse", box2d.b2Body.prototype.ApplyLinearImpulse);
box2d.b2Body.prototype.ApplyAngularImpulse = function(a, b) {
    this.m_type == box2d.b2BodyType.b2_dynamicBody && (0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_angularVelocity += this.m_invI * a))
};
goog.exportProperty(box2d.b2Body.prototype, "ApplyAngularImpulse", box2d.b2Body.prototype.ApplyAngularImpulse);
box2d.b2Body.prototype.GetMass = function() {
    return this.m_mass
};
goog.exportProperty(box2d.b2Body.prototype, "GetMass", box2d.b2Body.prototype.GetMass);
box2d.b2Body.prototype.GetInertia = function() {
    return this.m_I + this.m_mass * box2d.b2DotVV(this.m_sweep.localCenter, this.m_sweep.localCenter)
};
goog.exportProperty(box2d.b2Body.prototype, "GetInertia", box2d.b2Body.prototype.GetInertia);
box2d.b2Body.prototype.GetMassData = function(a) {
    a.mass = this.m_mass;
    a.I = this.m_I + this.m_mass * box2d.b2DotVV(this.m_sweep.localCenter, this.m_sweep.localCenter);
    a.center.Copy(this.m_sweep.localCenter);
    return a
};
goog.exportProperty(box2d.b2Body.prototype, "GetMassData", box2d.b2Body.prototype.GetMassData);
box2d.b2Body.prototype.SetMassData = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.m_world.IsLocked());
    if (!0 != this.m_world.IsLocked() && this.m_type == box2d.b2BodyType.b2_dynamicBody) {
        this.m_invI = this.m_I = this.m_invMass = 0;
        this.m_mass = a.mass;
        0 >= this.m_mass && (this.m_mass = 1);
        this.m_invMass = 1 / this.m_mass;
        0 < a.I && 0 == (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) && (this.m_I = a.I - this.m_mass * box2d.b2DotVV(a.center, a.center), box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < this.m_I), this.m_invI = 1 / this.m_I);
        var b = box2d.b2Body.prototype.SetMassData.s_oldCenter.Copy(this.m_sweep.c);
        this.m_sweep.localCenter.Copy(a.center);
        box2d.b2MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);
        this.m_sweep.c0.Copy(this.m_sweep.c);
        box2d.b2AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, box2d.b2SubVV(this.m_sweep.c, b, box2d.b2Vec2.s_t0), this.m_linearVelocity)
    }
};
goog.exportProperty(box2d.b2Body.prototype, "SetMassData", box2d.b2Body.prototype.SetMassData);
box2d.b2Body.prototype.SetMassData.s_oldCenter = new box2d.b2Vec2;
box2d.b2Body.prototype.ResetMassData = function() {
    this.m_invI = this.m_I = this.m_invMass = this.m_mass = 0;
    this.m_sweep.localCenter.SetZero();
    if (this.m_type == box2d.b2BodyType.b2_staticBody || this.m_type == box2d.b2BodyType.b2_kinematicBody)
        this.m_sweep.c0.Copy(this.m_xf.p), this.m_sweep.c.Copy(this.m_xf.p), this.m_sweep.a0 = this.m_sweep.a;
    else {
        box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_type == box2d.b2BodyType.b2_dynamicBody);
        for (var a = box2d.b2Body.prototype.ResetMassData.s_localCenter.SetZero(), b = this.m_fixtureList; b; b =
                b.m_next)
            if (0 != b.m_density) {
                var c = b.GetMassData(box2d.b2Body.prototype.ResetMassData.s_massData);
                this.m_mass += c.mass;
                a.x += c.center.x * c.mass;
                a.y += c.center.y * c.mass;
                this.m_I += c.I
            }
        0 < this.m_mass ? (this.m_invMass = 1 / this.m_mass, a.x *= this.m_invMass, a.y *= this.m_invMass) : this.m_invMass = this.m_mass = 1;
        0 < this.m_I && 0 == (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) ? (this.m_I -= this.m_mass * box2d.b2DotVV(a, a), box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < this.m_I), this.m_invI = 1 / this.m_I) : this.m_invI = this.m_I = 0;
        b = box2d.b2Body.prototype.ResetMassData.s_oldCenter.Copy(this.m_sweep.c);
        this.m_sweep.localCenter.Copy(a);
        box2d.b2MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);
        this.m_sweep.c0.Copy(this.m_sweep.c);
        box2d.b2AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, box2d.b2SubVV(this.m_sweep.c, b, box2d.b2Vec2.s_t0), this.m_linearVelocity)
    }
};
goog.exportProperty(box2d.b2Body.prototype, "ResetMassData", box2d.b2Body.prototype.ResetMassData);
box2d.b2Body.prototype.ResetMassData.s_localCenter = new box2d.b2Vec2;
box2d.b2Body.prototype.ResetMassData.s_oldCenter = new box2d.b2Vec2;
box2d.b2Body.prototype.ResetMassData.s_massData = new box2d.b2MassData;
box2d.b2Body.prototype.GetWorldPoint = function(a, b) {
    return box2d.b2MulXV(this.m_xf, a, b)
};
goog.exportProperty(box2d.b2Body.prototype, "GetWorldPoint", box2d.b2Body.prototype.GetWorldPoint);
box2d.b2Body.prototype.GetWorldVector = function(a, b) {
    return box2d.b2MulRV(this.m_xf.q, a, b)
};
goog.exportProperty(box2d.b2Body.prototype, "GetWorldVector", box2d.b2Body.prototype.GetWorldVector);
box2d.b2Body.prototype.GetLocalPoint = function(a, b) {
    return box2d.b2MulTXV(this.m_xf, a, b)
};
goog.exportProperty(box2d.b2Body.prototype, "GetLocalPoint", box2d.b2Body.prototype.GetLocalPoint);
box2d.b2Body.prototype.GetLocalVector = function(a, b) {
    return box2d.b2MulTRV(this.m_xf.q, a, b)
};
goog.exportProperty(box2d.b2Body.prototype, "GetLocalVector", box2d.b2Body.prototype.GetLocalVector);
box2d.b2Body.prototype.GetLinearVelocityFromWorldPoint = function(a, b) {
    return box2d.b2AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, box2d.b2SubVV(a, this.m_sweep.c, box2d.b2Vec2.s_t0), b)
};
goog.exportProperty(box2d.b2Body.prototype, "GetLinearVelocityFromWorldPoint", box2d.b2Body.prototype.GetLinearVelocityFromWorldPoint);
box2d.b2Body.prototype.GetLinearVelocityFromLocalPoint = function(a, b) {
    return this.GetLinearVelocityFromWorldPoint(this.GetWorldPoint(a, b), b)
};
goog.exportProperty(box2d.b2Body.prototype, "GetLinearVelocityFromLocalPoint", box2d.b2Body.prototype.GetLinearVelocityFromLocalPoint);
box2d.b2Body.prototype.GetLinearDamping = function() {
    return this.m_linearDamping
};
goog.exportProperty(box2d.b2Body.prototype, "GetLinearDamping", box2d.b2Body.prototype.GetLinearDamping);
box2d.b2Body.prototype.SetLinearDamping = function(a) {
    this.m_linearDamping = a
};
goog.exportProperty(box2d.b2Body.prototype, "SetLinearDamping", box2d.b2Body.prototype.SetLinearDamping);
box2d.b2Body.prototype.GetAngularDamping = function() {
    return this.m_angularDamping
};
goog.exportProperty(box2d.b2Body.prototype, "GetAngularDamping", box2d.b2Body.prototype.GetAngularDamping);
box2d.b2Body.prototype.SetAngularDamping = function(a) {
    this.m_angularDamping = a
};
goog.exportProperty(box2d.b2Body.prototype, "SetAngularDamping", box2d.b2Body.prototype.SetAngularDamping);
box2d.b2Body.prototype.GetGravityScale = function() {
    return this.m_gravityScale
};
goog.exportProperty(box2d.b2Body.prototype, "GetGravityScale", box2d.b2Body.prototype.GetGravityScale);
box2d.b2Body.prototype.SetGravityScale = function(a) {
    this.m_gravityScale = a
};
goog.exportProperty(box2d.b2Body.prototype, "SetGravityScale", box2d.b2Body.prototype.SetGravityScale);
box2d.b2Body.prototype.SetType = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.m_world.IsLocked());
    if (!0 != this.m_world.IsLocked() && this.m_type != a) {
        this.m_type = a;
        this.ResetMassData();
        this.m_type == box2d.b2BodyType.b2_staticBody && (this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0, this.m_sweep.a0 = this.m_sweep.a, this.m_sweep.c0.Copy(this.m_sweep.c), this.SynchronizeFixtures());
        this.SetAwake(!0);
        this.m_force.SetZero();
        this.m_torque = 0;
        for (a = this.m_contactList; a; ) {
            var b = a;
            a = a.next;
            this.m_world.m_contactManager.Destroy(b.contact)
        }
        this.m_contactList =
                null;
        a = this.m_world.m_contactManager.m_broadPhase;
        for (b = this.m_fixtureList; b; b = b.m_next)
            for (var c = b.m_proxyCount, e = 0; e < c; ++e)
                a.TouchProxy(b.m_proxies[e].proxy)
    }
};
goog.exportProperty(box2d.b2Body.prototype, "SetType", box2d.b2Body.prototype.SetType);
box2d.b2Body.prototype.GetType = function() {
    return this.m_type
};
goog.exportProperty(box2d.b2Body.prototype, "GetType", box2d.b2Body.prototype.GetType);
box2d.b2Body.prototype.SetBullet = function(a) {
    this.m_flags = a ? this.m_flags | box2d.b2BodyFlag.e_bulletFlag : this.m_flags & ~box2d.b2BodyFlag.e_bulletFlag
};
goog.exportProperty(box2d.b2Body.prototype, "SetBullet", box2d.b2Body.prototype.SetBullet);
box2d.b2Body.prototype.IsBullet = function() {
    return(this.m_flags & box2d.b2BodyFlag.e_bulletFlag) == box2d.b2BodyFlag.e_bulletFlag
};
goog.exportProperty(box2d.b2Body.prototype, "IsBullet", box2d.b2Body.prototype.IsBullet);
box2d.b2Body.prototype.SetSleepingAllowed = function(a) {
    a ? this.m_flags |= box2d.b2BodyFlag.e_autoSleepFlag : (this.m_flags &= ~box2d.b2BodyFlag.e_autoSleepFlag, this.SetAwake(!0))
};
goog.exportProperty(box2d.b2Body.prototype, "SetSleepingAllowed", box2d.b2Body.prototype.SetSleepingAllowed);
box2d.b2Body.prototype.IsSleepingAllowed = function() {
    return(this.m_flags & box2d.b2BodyFlag.e_autoSleepFlag) == box2d.b2BodyFlag.e_autoSleepFlag
};
goog.exportProperty(box2d.b2Body.prototype, "IsSleepingAllowed", box2d.b2Body.prototype.IsSleepingAllowed);
box2d.b2Body.prototype.SetAwake = function(a) {
    a ? 0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && (this.m_flags |= box2d.b2BodyFlag.e_awakeFlag, this.m_sleepTime = 0) : (this.m_flags &= ~box2d.b2BodyFlag.e_awakeFlag, this.m_sleepTime = 0, this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0, this.m_force.SetZero(), this.m_torque = 0)
};
goog.exportProperty(box2d.b2Body.prototype, "SetAwake", box2d.b2Body.prototype.SetAwake);
box2d.b2Body.prototype.IsAwake = function() {
    return(this.m_flags & box2d.b2BodyFlag.e_awakeFlag) == box2d.b2BodyFlag.e_awakeFlag
};
goog.exportProperty(box2d.b2Body.prototype, "IsAwake", box2d.b2Body.prototype.IsAwake);
box2d.b2Body.prototype.SetActive = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.m_world.IsLocked());
    if (a != this.IsActive())
        if (a) {
            this.m_flags |= box2d.b2BodyFlag.e_activeFlag;
            a = this.m_world.m_contactManager.m_broadPhase;
            for (var b = this.m_fixtureList; b; b = b.m_next)
                b.CreateProxies(a, this.m_xf)
        } else {
            this.m_flags &= ~box2d.b2BodyFlag.e_activeFlag;
            a = this.m_world.m_contactManager.m_broadPhase;
            for (b = this.m_fixtureList; b; b = b.m_next)
                b.DestroyProxies(a);
            for (a = this.m_contactList; a; )
                b = a, a = a.next, this.m_world.m_contactManager.Destroy(b.contact);
            this.m_contactList = null
        }
};
goog.exportProperty(box2d.b2Body.prototype, "SetActive", box2d.b2Body.prototype.SetActive);
box2d.b2Body.prototype.IsActive = function() {
    return(this.m_flags & box2d.b2BodyFlag.e_activeFlag) == box2d.b2BodyFlag.e_activeFlag
};
goog.exportProperty(box2d.b2Body.prototype, "IsActive", box2d.b2Body.prototype.IsActive);
box2d.b2Body.prototype.SetFixedRotation = function(a) {
    (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) == box2d.b2BodyFlag.e_fixedRotationFlag != a && (this.m_flags = a ? this.m_flags | box2d.b2BodyFlag.e_fixedRotationFlag : this.m_flags & ~box2d.b2BodyFlag.e_fixedRotationFlag, this.m_angularVelocity = 0, this.ResetMassData())
};
goog.exportProperty(box2d.b2Body.prototype, "SetFixedRotation", box2d.b2Body.prototype.SetFixedRotation);
box2d.b2Body.prototype.IsFixedRotation = function() {
    return(this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) == box2d.b2BodyFlag.e_fixedRotationFlag
};
goog.exportProperty(box2d.b2Body.prototype, "IsFixedRotation", box2d.b2Body.prototype.IsFixedRotation);
box2d.b2Body.prototype.GetFixtureList = function() {
    return this.m_fixtureList
};
goog.exportProperty(box2d.b2Body.prototype, "GetFixtureList", box2d.b2Body.prototype.GetFixtureList);
box2d.b2Body.prototype.GetJointList = function() {
    return this.m_jointList
};
goog.exportProperty(box2d.b2Body.prototype, "GetJointList", box2d.b2Body.prototype.GetJointList);
box2d.b2Body.prototype.GetContactList = function() {
    return this.m_contactList
};
goog.exportProperty(box2d.b2Body.prototype, "GetContactList", box2d.b2Body.prototype.GetContactList);
box2d.b2Body.prototype.GetNext = function() {
    return this.m_next
};
goog.exportProperty(box2d.b2Body.prototype, "GetNext", box2d.b2Body.prototype.GetNext);
box2d.b2Body.prototype.GetUserData = function() {
    return this.m_userData
};
goog.exportProperty(box2d.b2Body.prototype, "GetUserData", box2d.b2Body.prototype.GetUserData);
box2d.b2Body.prototype.SetUserData = function(a) {
    this.m_userData = a
};
goog.exportProperty(box2d.b2Body.prototype, "SetUserData", box2d.b2Body.prototype.SetUserData);
box2d.b2Body.prototype.GetWorld = function() {
    return this.m_world
};
goog.exportProperty(box2d.b2Body.prototype, "GetWorld", box2d.b2Body.prototype.GetWorld);
box2d.b2Body.prototype.SynchronizeFixtures = function() {
    var a = box2d.b2Body.prototype.SynchronizeFixtures.s_xf1;
    a.q.SetAngleRadians(this.m_sweep.a0);
    box2d.b2MulRV(a.q, this.m_sweep.localCenter, a.p);
    box2d.b2SubVV(this.m_sweep.c0, a.p, a.p);
    for (var b = this.m_world.m_contactManager.m_broadPhase, c = this.m_fixtureList; c; c = c.m_next)
        c.Synchronize(b, a, this.m_xf)
};
goog.exportProperty(box2d.b2Body.prototype, "SynchronizeFixtures", box2d.b2Body.prototype.SynchronizeFixtures);
box2d.b2Body.prototype.SynchronizeFixtures.s_xf1 = new box2d.b2Transform;
box2d.b2Body.prototype.SynchronizeTransform = function() {
    this.m_xf.q.SetAngleRadians(this.m_sweep.a);
    box2d.b2MulRV(this.m_xf.q, this.m_sweep.localCenter, this.m_xf.p);
    box2d.b2SubVV(this.m_sweep.c, this.m_xf.p, this.m_xf.p)
};
goog.exportProperty(box2d.b2Body.prototype, "SynchronizeTransform", box2d.b2Body.prototype.SynchronizeTransform);
box2d.b2Body.prototype.ShouldCollide = function(a) {
    if (this.m_type != box2d.b2BodyType.b2_dynamicBody && a.m_type != box2d.b2BodyType.b2_dynamicBody)
        return!1;
    for (var b = this.m_jointList; b; b = b.next)
        if (b.other == a && !1 == b.joint.m_collideConnected)
            return!1;
    return!0
};
goog.exportProperty(box2d.b2Body.prototype, "ShouldCollide", box2d.b2Body.prototype.ShouldCollide);
box2d.b2Body.prototype.Advance = function(a) {
    this.m_sweep.Advance(a);
    this.m_sweep.c.Copy(this.m_sweep.c0);
    this.m_sweep.a = this.m_sweep.a0;
    this.m_xf.q.SetAngleRadians(this.m_sweep.a);
    box2d.b2MulRV(this.m_xf.q, this.m_sweep.localCenter, this.m_xf.p);
    box2d.b2SubVV(this.m_sweep.c, this.m_xf.p, this.m_xf.p)
};
goog.exportProperty(box2d.b2Body.prototype, "Advance", box2d.b2Body.prototype.Advance);
box2d.b2Body.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_islandIndex;
        box2d.b2Log("if (true)\n");
        box2d.b2Log("{\n");
        box2d.b2Log("  /*box2d.b2BodyDef*/ var bd = new box2d.b2BodyDef();\n");
        var b = "";
        switch (this.m_type) {
            case box2d.b2BodyType.b2_staticBody:
                b = "box2d.b2BodyType.b2_staticBody";
                break;
            case box2d.b2BodyType.b2_kinematicBody:
                b = "box2d.b2BodyType.b2_kinematicBody";
                break;
            case box2d.b2BodyType.b2_dynamicBody:
                b = "box2d.b2BodyType.b2_dynamicBody";
                break;
            default:
                box2d.ENABLE_ASSERTS && box2d.b2Assert(!1)
        }
        box2d.b2Log("  bd.type = %s;\n",
                b);
        box2d.b2Log("  bd.position.SetXY(%.15f, %.15f);\n", this.m_xf.p.x, this.m_xf.p.y);
        box2d.b2Log("  bd.angle = %.15f;\n", this.m_sweep.a);
        box2d.b2Log("  bd.linearVelocity.SetXY(%.15f, %.15f);\n", this.m_linearVelocity.x, this.m_linearVelocity.y);
        box2d.b2Log("  bd.angularVelocity = %.15f;\n", this.m_angularVelocity);
        box2d.b2Log("  bd.linearDamping = %.15f;\n", this.m_linearDamping);
        box2d.b2Log("  bd.angularDamping = %.15f;\n", this.m_angularDamping);
        box2d.b2Log("  bd.allowSleep = %s;\n", this.m_flags & box2d.b2BodyFlag.e_autoSleepFlag ?
                "true" : "false");
        box2d.b2Log("  bd.awake = %s;\n", this.m_flags & box2d.b2BodyFlag.e_awakeFlag ? "true" : "false");
        box2d.b2Log("  bd.fixedRotation = %s;\n", this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag ? "true" : "false");
        box2d.b2Log("  bd.bullet = %s;\n", this.m_flags & box2d.b2BodyFlag.e_bulletFlag ? "true" : "false");
        box2d.b2Log("  bd.active = %s;\n", this.m_flags & box2d.b2BodyFlag.e_activeFlag ? "true" : "false");
        box2d.b2Log("  bd.gravityScale = %.15f;\n", this.m_gravityScale);
        box2d.b2Log("\n");
        box2d.b2Log("  bodies[%d] = this.m_world.CreateBody(bd);\n",
                this.m_islandIndex);
        box2d.b2Log("\n");
        for (b = this.m_fixtureList; b; b = b.m_next)
            box2d.b2Log("  if (true)\n"), box2d.b2Log("  {\n"), b.Dump(a), box2d.b2Log("  }\n");
        box2d.b2Log("}\n")
    }
};
goog.exportProperty(box2d.b2Body.prototype, "Dump", box2d.b2Body.prototype.Dump);
box2d.b2Body.prototype.GetControllerList = function() {
    return this.m_controllerList
};
goog.exportProperty(box2d.b2Body.prototype, "GetControllerList", box2d.b2Body.prototype.GetControllerList);
box2d.b2Body.prototype.GetControllerCount = function() {
    return this.m_controllerCount
};
goog.exportProperty(box2d.b2Body.prototype, "GetControllerCount", box2d.b2Body.prototype.GetControllerCount);
box2d.b2WorldFlag = {e_none: 0, e_newFixture: 1, e_locked: 2, e_clearForces: 4};
goog.exportSymbol("box2d.b2WorldFlag", box2d.b2WorldFlag);
goog.exportProperty(box2d.b2WorldFlag, "e_none", box2d.b2WorldFlag.e_none);
goog.exportProperty(box2d.b2WorldFlag, "e_newFixture", box2d.b2WorldFlag.e_newFixture);
goog.exportProperty(box2d.b2WorldFlag, "e_locked", box2d.b2WorldFlag.e_locked);
goog.exportProperty(box2d.b2WorldFlag, "e_clearForces", box2d.b2WorldFlag.e_clearForces);
box2d.b2World = function(a) {
    this.m_flags = box2d.b2WorldFlag.e_clearForces;
    this.m_contactManager = new box2d.b2ContactManager;
    this.m_gravity = a.Clone();
    this.m_out_gravity = new box2d.b2Vec2;
    this.m_allowSleep = !0;
    this.m_debugDraw = this.m_destructionListener = null;
    this.m_continuousPhysics = this.m_warmStarting = !0;
    this.m_subStepping = !1;
    this.m_stepComplete = !0;
    this.m_profile = new box2d.b2Profile;
    this.m_island = new box2d.b2Island;
    this.s_stack = []
};
goog.exportSymbol("box2d.b2World", box2d.b2World);
box2d.b2World.prototype.m_flags = box2d.b2WorldFlag.e_none;
goog.exportProperty(box2d.b2World.prototype, "m_flags", box2d.b2World.prototype.m_flags);
box2d.b2World.prototype.m_contactManager = null;
goog.exportProperty(box2d.b2World.prototype, "m_contactManager", box2d.b2World.prototype.m_contactManager);
box2d.b2World.prototype.m_bodyList = null;
goog.exportProperty(box2d.b2World.prototype, "m_bodyList", box2d.b2World.prototype.m_bodyList);
box2d.b2World.prototype.m_jointList = null;
goog.exportProperty(box2d.b2World.prototype, "m_jointList", box2d.b2World.prototype.m_jointList);
box2d.b2World.prototype.m_bodyCount = 0;
goog.exportProperty(box2d.b2World.prototype, "m_bodyCount", box2d.b2World.prototype.m_bodyCount);
box2d.b2World.prototype.m_jointCount = 0;
goog.exportProperty(box2d.b2World.prototype, "m_jointCount", box2d.b2World.prototype.m_jointCount);
box2d.b2World.prototype.m_gravity = null;
goog.exportProperty(box2d.b2World.prototype, "m_gravity", box2d.b2World.prototype.m_gravity);
box2d.b2World.prototype.m_out_gravity = null;
goog.exportProperty(box2d.b2World.prototype, "m_out_gravity", box2d.b2World.prototype.m_out_gravity);
box2d.b2World.prototype.m_allowSleep = !0;
goog.exportProperty(box2d.b2World.prototype, "m_allowSleep", box2d.b2World.prototype.m_allowSleep);
box2d.b2World.prototype.m_destructionListener = null;
goog.exportProperty(box2d.b2World.prototype, "m_destructionListener", box2d.b2World.prototype.m_destructionListener);
box2d.b2World.prototype.m_debugDraw = null;
goog.exportProperty(box2d.b2World.prototype, "m_debugDraw", box2d.b2World.prototype.m_debugDraw);
box2d.b2World.prototype.m_inv_dt0 = 0;
goog.exportProperty(box2d.b2World.prototype, "m_inv_dt0", box2d.b2World.prototype.m_inv_dt0);
box2d.b2World.prototype.m_warmStarting = !0;
goog.exportProperty(box2d.b2World.prototype, "m_warmStarting", box2d.b2World.prototype.m_warmStarting);
box2d.b2World.prototype.m_continuousPhysics = !0;
goog.exportProperty(box2d.b2World.prototype, "m_continuousPhysics", box2d.b2World.prototype.m_continuousPhysics);
box2d.b2World.prototype.m_subStepping = !1;
goog.exportProperty(box2d.b2World.prototype, "m_subStepping", box2d.b2World.prototype.m_subStepping);
box2d.b2World.prototype.m_stepComplete = !0;
goog.exportProperty(box2d.b2World.prototype, "m_stepComplete", box2d.b2World.prototype.m_stepComplete);
box2d.b2World.prototype.m_profile = null;
goog.exportProperty(box2d.b2World.prototype, "m_profile", box2d.b2World.prototype.m_profile);
box2d.b2World.prototype.m_island = null;
goog.exportProperty(box2d.b2World.prototype, "m_island", box2d.b2World.prototype.m_island);
box2d.b2World.prototype.s_stack = null;
goog.exportProperty(box2d.b2World.prototype, "s_stack", box2d.b2World.prototype.s_stack);
box2d.b2World.prototype.m_controllerList = null;
goog.exportProperty(box2d.b2World.prototype, "m_controllerList", box2d.b2World.prototype.m_controllerList);
box2d.b2World.prototype.m_controllerCount = 0;
goog.exportProperty(box2d.b2World.prototype, "m_controllerCount", box2d.b2World.prototype.m_controllerCount);
box2d.b2World.prototype.SetAllowSleeping = function(a) {
    if (a != this.m_allowSleep && (this.m_allowSleep = a, !1 == this.m_allowSleep))
        for (a = this.m_bodyList; a; a = a.m_next)
            a.SetAwake(!0)
};
goog.exportProperty(box2d.b2World.prototype, "SetAllowSleeping", box2d.b2World.prototype.SetAllowSleeping);
box2d.b2World.prototype.GetAllowSleeping = function() {
    return this.m_allowSleep
};
goog.exportProperty(box2d.b2World.prototype, "GetAllowSleeping", box2d.b2World.prototype.GetAllowSleeping);
box2d.b2World.prototype.SetWarmStarting = function(a) {
    this.m_warmStarting = a
};
goog.exportProperty(box2d.b2World.prototype, "SetWarmStarting", box2d.b2World.prototype.SetWarmStarting);
box2d.b2World.prototype.GetWarmStarting = function() {
    return this.m_warmStarting
};
goog.exportProperty(box2d.b2World.prototype, "GetWarmStarting", box2d.b2World.prototype.GetWarmStarting);
box2d.b2World.prototype.SetContinuousPhysics = function(a) {
    this.m_continuousPhysics = a
};
goog.exportProperty(box2d.b2World.prototype, "SetContinuousPhysics", box2d.b2World.prototype.SetContinuousPhysics);
box2d.b2World.prototype.GetContinuousPhysics = function() {
    return this.m_continuousPhysics
};
goog.exportProperty(box2d.b2World.prototype, "GetContinuousPhysics", box2d.b2World.prototype.GetContinuousPhysics);
box2d.b2World.prototype.SetSubStepping = function(a) {
    this.m_subStepping = a
};
goog.exportProperty(box2d.b2World.prototype, "SetSubStepping", box2d.b2World.prototype.SetSubStepping);
box2d.b2World.prototype.GetSubStepping = function() {
    return this.m_subStepping
};
goog.exportProperty(box2d.b2World.prototype, "GetSubStepping", box2d.b2World.prototype.GetSubStepping);
box2d.b2World.prototype.GetBodyList = function() {
    return this.m_bodyList
};
goog.exportProperty(box2d.b2World.prototype, "GetBodyList", box2d.b2World.prototype.GetBodyList);
box2d.b2World.prototype.GetJointList = function() {
    return this.m_jointList
};
goog.exportProperty(box2d.b2World.prototype, "GetJointList", box2d.b2World.prototype.GetJointList);
box2d.b2World.prototype.GetContactList = function() {
    return this.m_contactManager.m_contactList
};
goog.exportProperty(box2d.b2World.prototype, "GetContactList", box2d.b2World.prototype.GetContactList);
box2d.b2World.prototype.GetBodyCount = function() {
    return this.m_bodyCount
};
goog.exportProperty(box2d.b2World.prototype, "GetBodyCount", box2d.b2World.prototype.GetBodyCount);
box2d.b2World.prototype.GetJointCount = function() {
    return this.m_jointCount
};
goog.exportProperty(box2d.b2World.prototype, "GetJointCount", box2d.b2World.prototype.GetJointCount);
box2d.b2World.prototype.GetContactCount = function() {
    return this.m_contactManager.m_contactCount
};
goog.exportProperty(box2d.b2World.prototype, "GetContactCount", box2d.b2World.prototype.GetContactCount);
box2d.b2World.prototype.SetGravity = function(a, b) {
    b = b || !0;
    if (this.m_gravity.x !== a.x || this.m_gravity.y !== a.y)
        if (this.m_gravity.Copy(a), b)
            for (var c = this.m_bodyList; c; c = c.m_next)
                c.SetAwake(!0)
};
goog.exportProperty(box2d.b2World.prototype, "SetGravity", box2d.b2World.prototype.SetGravity);
box2d.b2World.prototype.GetGravity = function(a) {
    a = a || this.m_out_gravity;
    return a.Copy(this.m_gravity)
};
goog.exportProperty(box2d.b2World.prototype, "GetGravity", box2d.b2World.prototype.GetGravity);
box2d.b2World.prototype.IsLocked = function() {
    return 0 < (this.m_flags & box2d.b2WorldFlag.e_locked)
};
goog.exportProperty(box2d.b2World.prototype, "IsLocked", box2d.b2World.prototype.IsLocked);
box2d.b2World.prototype.SetAutoClearForces = function(a) {
    this.m_flags = a ? this.m_flags | box2d.b2WorldFlag.e_clearForces : this.m_flags & ~box2d.b2WorldFlag.e_clearForces
};
goog.exportProperty(box2d.b2World.prototype, "SetAutoClearForces", box2d.b2World.prototype.SetAutoClearForces);
box2d.b2World.prototype.GetAutoClearForces = function() {
    return(this.m_flags & box2d.b2WorldFlag.e_clearForces) == box2d.b2WorldFlag.e_clearForces
};
goog.exportProperty(box2d.b2World.prototype, "GetAutoClearForces", box2d.b2World.prototype.GetAutoClearForces);
box2d.b2World.prototype.GetContactManager = function() {
    return this.m_contactManager
};
goog.exportProperty(box2d.b2World.prototype, "GetContactManager", box2d.b2World.prototype.GetContactManager);
box2d.b2World.prototype.GetProfile = function() {
    return this.m_profile
};
goog.exportProperty(box2d.b2World.prototype, "GetProfile", box2d.b2World.prototype.GetProfile);
box2d.b2World.prototype.SetDestructionListener = function(a) {
    this.m_destructionListener = a
};
goog.exportProperty(box2d.b2World.prototype, "SetDestructionListener", box2d.b2World.prototype.SetDestructionListener);
box2d.b2World.prototype.SetContactFilter = function(a) {
    this.m_contactManager.m_contactFilter = a
};
goog.exportProperty(box2d.b2World.prototype, "SetContactFilter", box2d.b2World.prototype.SetContactFilter);
box2d.b2World.prototype.SetContactListener = function(a) {
    this.m_contactManager.m_contactListener = a
};
goog.exportProperty(box2d.b2World.prototype, "SetContactListener", box2d.b2World.prototype.SetContactListener);
box2d.b2World.prototype.SetDebugDraw = function(a) {
    this.m_debugDraw = a
};
goog.exportProperty(box2d.b2World.prototype, "SetDebugDraw", box2d.b2World.prototype.SetDebugDraw);
box2d.b2World.prototype.CreateBody = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.IsLocked());
    if (this.IsLocked())
        return null;
    a = new box2d.b2Body(a, this);
    a.m_prev = null;
    if (a.m_next = this.m_bodyList)
        this.m_bodyList.m_prev = a;
    this.m_bodyList = a;
    ++this.m_bodyCount;
    return a
};
goog.exportProperty(box2d.b2World.prototype, "CreateBody", box2d.b2World.prototype.CreateBody);
box2d.b2World.prototype.DestroyBody = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < this.m_bodyCount);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.IsLocked());
    if (!this.IsLocked()) {
        for (var b = a.m_jointList; b; ) {
            var c = b, b = b.next;
            this.m_destructionListener && this.m_destructionListener.SayGoodbyeJoint(c.joint);
            this.DestroyJoint(c.joint);
            a.m_jointList = b
        }
        a.m_jointList = null;
        for (b = a.m_controllerList; b; )
            c = b, b = b.nextController, c.controller.RemoveBody(a);
        for (b = a.m_contactList; b; )
            c = b, b = b.next, this.m_contactManager.Destroy(c.contact);
        a.m_contactList = null;
        for (b = a.m_fixtureList; b; )
            c = b, b = b.m_next, this.m_destructionListener && this.m_destructionListener.SayGoodbyeFixture(c), c.DestroyProxies(this.m_contactManager.m_broadPhase), c.Destroy(), a.m_fixtureList = b, a.m_fixtureCount -= 1;
        a.m_fixtureList = null;
        a.m_fixtureCount = 0;
        a.m_prev && (a.m_prev.m_next = a.m_next);
        a.m_next && (a.m_next.m_prev = a.m_prev);
        a == this.m_bodyList && (this.m_bodyList = a.m_next);
        --this.m_bodyCount
    }
};
goog.exportProperty(box2d.b2World.prototype, "DestroyBody", box2d.b2World.prototype.DestroyBody);
box2d.b2World.prototype.CreateJoint = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.IsLocked());
    if (this.IsLocked())
        return null;
    var b = box2d.b2JointFactory.Create(a, null);
    b.m_prev = null;
    if (b.m_next = this.m_jointList)
        this.m_jointList.m_prev = b;
    this.m_jointList = b;
    ++this.m_jointCount;
    b.m_edgeA.joint = b;
    b.m_edgeA.other = b.m_bodyB;
    b.m_edgeA.prev = null;
    if (b.m_edgeA.next = b.m_bodyA.m_jointList)
        b.m_bodyA.m_jointList.prev = b.m_edgeA;
    b.m_bodyA.m_jointList = b.m_edgeA;
    b.m_edgeB.joint = b;
    b.m_edgeB.other = b.m_bodyA;
    b.m_edgeB.prev = null;
    if (b.m_edgeB.next = b.m_bodyB.m_jointList)
        b.m_bodyB.m_jointList.prev = b.m_edgeB;
    b.m_bodyB.m_jointList = b.m_edgeB;
    var c = a.bodyA, e = a.bodyB;
    if (!1 == a.collideConnected)
        for (a = e.GetContactList(); a; )
            a.other == c && a.contact.FlagForFiltering(), a = a.next;
    return b
};
goog.exportProperty(box2d.b2World.prototype, "CreateJoint", box2d.b2World.prototype.CreateJoint);
box2d.b2World.prototype.DestroyJoint = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.IsLocked());
    if (!this.IsLocked()) {
        var b = a.m_collideConnected;
        a.m_prev && (a.m_prev.m_next = a.m_next);
        a.m_next && (a.m_next.m_prev = a.m_prev);
        a == this.m_jointList && (this.m_jointList = a.m_next);
        var c = a.m_bodyA, e = a.m_bodyB;
        c.SetAwake(!0);
        e.SetAwake(!0);
        a.m_edgeA.prev && (a.m_edgeA.prev.next = a.m_edgeA.next);
        a.m_edgeA.next && (a.m_edgeA.next.prev = a.m_edgeA.prev);
        a.m_edgeA == c.m_jointList && (c.m_jointList = a.m_edgeA.next);
        a.m_edgeA.prev =
                null;
        a.m_edgeA.next = null;
        a.m_edgeB.prev && (a.m_edgeB.prev.next = a.m_edgeB.next);
        a.m_edgeB.next && (a.m_edgeB.next.prev = a.m_edgeB.prev);
        a.m_edgeB == e.m_jointList && (e.m_jointList = a.m_edgeB.next);
        a.m_edgeB.prev = null;
        a.m_edgeB.next = null;
        box2d.b2JointFactory.Destroy(a, null);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < this.m_jointCount);
        --this.m_jointCount;
        if (!1 == b)
            for (a = e.GetContactList(); a; )
                a.other == c && a.contact.FlagForFiltering(), a = a.next
    }
};
goog.exportProperty(box2d.b2World.prototype, "DestroyJoint", box2d.b2World.prototype.DestroyJoint);
box2d.b2World.prototype.Solve = function(a) {
    for (var b = this.m_controllerList; b; b = b.m_next)
        b.Step(a);
    this.m_profile.solveInit = 0;
    this.m_profile.solveVelocity = 0;
    this.m_profile.solvePosition = 0;
    b = this.m_island;
    b.Initialize(this.m_bodyCount, this.m_contactManager.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener);
    for (var c = this.m_bodyList; c; c = c.m_next)
        c.m_flags &= ~box2d.b2BodyFlag.e_islandFlag;
    for (var e = this.m_contactManager.m_contactList; e; e = e.m_next)
        e.m_flags &= ~box2d.b2ContactFlag.e_islandFlag;
    for (e = this.m_jointList; e; e = e.m_next)
        e.m_islandFlag = !1;
    for (var e = this.m_bodyCount, d = this.s_stack, f = this.m_bodyList; f; f = f.m_next)
        if (!(f.m_flags & box2d.b2BodyFlag.e_islandFlag) && !1 != f.IsAwake() && !1 != f.IsActive() && f.GetType() != box2d.b2BodyType.b2_staticBody) {
            b.Clear();
            var g = 0;
            d[g++] = f;
            for (f.m_flags |= box2d.b2BodyFlag.e_islandFlag; 0 < g; )
                if (c = d[--g], box2d.ENABLE_ASSERTS && box2d.b2Assert(!0 == c.IsActive()), b.AddBody(c), c.SetAwake(!0), c.GetType() != box2d.b2BodyType.b2_staticBody) {
                    for (var h = c.m_contactList; h; h =
                            h.next) {
                        var l = h.contact;
                        if (!(l.m_flags & box2d.b2ContactFlag.e_islandFlag) && !1 != l.IsEnabled() && !1 != l.IsTouching()) {
                            var k = l.m_fixtureB.m_isSensor;
                            l.m_fixtureA.m_isSensor || k || (b.AddContact(l), l.m_flags |= box2d.b2ContactFlag.e_islandFlag, l = h.other, l.m_flags & box2d.b2BodyFlag.e_islandFlag || (box2d.ENABLE_ASSERTS && box2d.b2Assert(g < e), d[g++] = l, l.m_flags |= box2d.b2BodyFlag.e_islandFlag))
                        }
                    }
                    for (c = c.m_jointList; c; c = c.next)
                        !0 != c.joint.m_islandFlag && (l = c.other, !1 != l.IsActive() && (b.AddJoint(c.joint), c.joint.m_islandFlag =
                                !0, l.m_flags & box2d.b2BodyFlag.e_islandFlag || (box2d.ENABLE_ASSERTS && box2d.b2Assert(g < e), d[g++] = l, l.m_flags |= box2d.b2BodyFlag.e_islandFlag)))
                }
            c = new box2d.b2Profile;
            b.Solve(c, a, this.m_gravity, this.m_allowSleep);
            this.m_profile.solveInit += c.solveInit;
            this.m_profile.solveVelocity += c.solveVelocity;
            this.m_profile.solvePosition += c.solvePosition;
            for (g = 0; g < b.m_bodyCount; ++g)
                c = b.m_bodies[g], c.GetType() == box2d.b2BodyType.b2_staticBody && (c.m_flags &= ~box2d.b2BodyFlag.e_islandFlag)
        }
    for (g = 0; g < d.length && d[g]; ++g)
        d[g] =
                null;
    a = new box2d.b2Timer;
    for (c = this.m_bodyList; c; c = c.m_next)
        0 != (c.m_flags & box2d.b2BodyFlag.e_islandFlag) && c.GetType() != box2d.b2BodyType.b2_staticBody && c.SynchronizeFixtures();
    this.m_contactManager.FindNewContacts();
    this.m_profile.broadphase = a.GetMilliseconds()
};
goog.exportProperty(box2d.b2World.prototype, "Solve", box2d.b2World.prototype.Solve);
box2d.b2World.prototype.SolveTOI = function(a) {
    var b = this.m_island;
    b.Initialize(2 * box2d.b2_maxTOIContacts, box2d.b2_maxTOIContacts, 0, null, this.m_contactManager.m_contactListener);
    if (this.m_stepComplete) {
        for (var c = this.m_bodyList; c; c = c.m_next)
            c.m_flags &= ~box2d.b2BodyFlag.e_islandFlag, c.m_sweep.alpha0 = 0;
        for (var e = this.m_contactManager.m_contactList; e; e = e.m_next)
            e.m_flags &= ~(box2d.b2ContactFlag.e_toiFlag | box2d.b2ContactFlag.e_islandFlag), e.m_toiCount = 0, e.m_toi = 1
    }
    for (; ; ) {
        for (var d = null, c = 1, e = this.m_contactManager.m_contactList; e; e =
                e.m_next)
            if (!1 != e.IsEnabled() && !(e.m_toiCount > box2d.b2_maxSubSteps)) {
                var f = 1;
                if (e.m_flags & box2d.b2ContactFlag.e_toiFlag)
                    f = e.m_toi;
                else {
                    var g = e.GetFixtureA(), h = e.GetFixtureB();
                    if (g.IsSensor() || h.IsSensor())
                        continue;
                    var f = g.GetBody(), l = h.GetBody(), k = f.m_type, m = l.m_type;
                    box2d.ENABLE_ASSERTS && box2d.b2Assert(k == box2d.b2BodyType.b2_dynamicBody || m == box2d.b2BodyType.b2_dynamicBody);
                    var n = f.IsAwake() && k != box2d.b2BodyType.b2_staticBody, p = l.IsAwake() && m != box2d.b2BodyType.b2_staticBody;
                    if (!1 == n && !1 == p)
                        continue;
                    k = f.IsBullet() || k != box2d.b2BodyType.b2_dynamicBody;
                    m = l.IsBullet() || m != box2d.b2BodyType.b2_dynamicBody;
                    if (!1 == k && !1 == m)
                        continue;
                    m = f.m_sweep.alpha0;
                    f.m_sweep.alpha0 < l.m_sweep.alpha0 ? (m = l.m_sweep.alpha0, f.m_sweep.Advance(m)) : l.m_sweep.alpha0 < f.m_sweep.alpha0 && (m = f.m_sweep.alpha0, l.m_sweep.Advance(m));
                    box2d.ENABLE_ASSERTS && box2d.b2Assert(1 > m);
                    n = e.GetChildIndexA();
                    p = e.GetChildIndexB();
                    k = box2d.b2World.prototype.SolveTOI.s_toi_input;
                    k.proxyA.SetShape(g.GetShape(), n);
                    k.proxyB.SetShape(h.GetShape(), p);
                    k.sweepA.Copy(f.m_sweep);
                    k.sweepB.Copy(l.m_sweep);
                    k.tMax = 1;
                    f = box2d.b2World.prototype.SolveTOI.s_toi_output;
                    box2d.b2TimeOfImpact(f, k);
                    l = f.t;
                    f = f.state == box2d.b2TOIOutputState.e_touching ? box2d.b2Min(m + (1 - m) * l, 1) : 1;
                    e.m_toi = f;
                    e.m_flags |= box2d.b2ContactFlag.e_toiFlag
                }
                f < c && (d = e, c = f)
            }
        if (null == d || 1 - 10 * box2d.b2_epsilon < c) {
            this.m_stepComplete = !0;
            break
        }
        g = d.GetFixtureA();
        h = d.GetFixtureB();
        f = g.GetBody();
        l = h.GetBody();
        e = box2d.b2World.prototype.SolveTOI.s_backup1.Copy(f.m_sweep);
        g = box2d.b2World.prototype.SolveTOI.s_backup2.Copy(l.m_sweep);
        f.Advance(c);
        l.Advance(c);
        d.Update(this.m_contactManager.m_contactListener);
        d.m_flags &= ~box2d.b2ContactFlag.e_toiFlag;
        ++d.m_toiCount;
        if (!1 == d.IsEnabled() || !1 == d.IsTouching())
            d.SetEnabled(!1), f.m_sweep.Copy(e), l.m_sweep.Copy(g), f.SynchronizeTransform(), l.SynchronizeTransform();
        else {
            f.SetAwake(!0);
            l.SetAwake(!0);
            b.Clear();
            b.AddBody(f);
            b.AddBody(l);
            b.AddContact(d);
            f.m_flags |= box2d.b2BodyFlag.e_islandFlag;
            l.m_flags |= box2d.b2BodyFlag.e_islandFlag;
            d.m_flags |= box2d.b2ContactFlag.e_islandFlag;
            for (d = 0; 2 > d; ++d)
                if (e =
                        0 == d ? f : l, e.m_type == box2d.b2BodyType.b2_dynamicBody)
                    for (g = e.m_contactList; g && b.m_bodyCount != b.m_bodyCapacity && b.m_contactCount != b.m_contactCapacity; g = g.next)
                        h = g.contact, h.m_flags & box2d.b2ContactFlag.e_islandFlag || (m = g.other, m.m_type == box2d.b2BodyType.b2_dynamicBody && !1 == e.IsBullet() && !1 == m.IsBullet()) || (k = h.m_fixtureB.m_isSensor, h.m_fixtureA.m_isSensor || k || (k = box2d.b2World.prototype.SolveTOI.s_backup.Copy(m.m_sweep), 0 == (m.m_flags & box2d.b2BodyFlag.e_islandFlag) && m.Advance(c), h.Update(this.m_contactManager.m_contactListener),
                                !1 == h.IsEnabled() ? (m.m_sweep.Copy(k), m.SynchronizeTransform()) : !1 == h.IsTouching() ? (m.m_sweep.Copy(k), m.SynchronizeTransform()) : (h.m_flags |= box2d.b2ContactFlag.e_islandFlag, b.AddContact(h), m.m_flags & box2d.b2BodyFlag.e_islandFlag || (m.m_flags |= box2d.b2BodyFlag.e_islandFlag, m.m_type != box2d.b2BodyType.b2_staticBody && m.SetAwake(!0), b.AddBody(m)))));
            d = box2d.b2World.prototype.SolveTOI.s_subStep;
            d.dt = (1 - c) * a.dt;
            d.inv_dt = 1 / d.dt;
            d.dtRatio = 1;
            d.positionIterations = 20;
            d.velocityIterations = a.velocityIterations;
            d.warmStarting =
                    !1;
            b.SolveTOI(d, f.m_islandIndex, l.m_islandIndex);
            for (d = 0; d < b.m_bodyCount; ++d)
                if (e = b.m_bodies[d], e.m_flags &= ~box2d.b2BodyFlag.e_islandFlag, e.m_type == box2d.b2BodyType.b2_dynamicBody)
                    for (e.SynchronizeFixtures(), g = e.m_contactList; g; g = g.next)
                        g.contact.m_flags &= ~(box2d.b2ContactFlag.e_toiFlag | box2d.b2ContactFlag.e_islandFlag);
            this.m_contactManager.FindNewContacts();
            if (this.m_subStepping) {
                this.m_stepComplete = !1;
                break
            }
        }
    }
};
goog.exportProperty(box2d.b2World.prototype, "SolveTOI", box2d.b2World.prototype.SolveTOI);
box2d.b2World.prototype.SolveTOI.s_subStep = new box2d.b2TimeStep;
box2d.b2World.prototype.SolveTOI.s_backup = new box2d.b2Sweep;
box2d.b2World.prototype.SolveTOI.s_backup1 = new box2d.b2Sweep;
box2d.b2World.prototype.SolveTOI.s_backup2 = new box2d.b2Sweep;
box2d.b2World.prototype.SolveTOI.s_toi_input = new box2d.b2TOIInput;
box2d.b2World.prototype.SolveTOI.s_toi_output = new box2d.b2TOIOutput;
box2d.b2World.prototype.Step = function(a, b, c) {
    var e = new box2d.b2Timer;
    this.m_flags & box2d.b2WorldFlag.e_newFixture && (this.m_contactManager.FindNewContacts(), this.m_flags &= ~box2d.b2WorldFlag.e_newFixture);
    this.m_flags |= box2d.b2WorldFlag.e_locked;
    var d = box2d.b2World.prototype.Step.s_step;
    d.dt = a;
    d.velocityIterations = b;
    d.positionIterations = c;
    d.inv_dt = 0 < a ? 1 / a : 0;
    d.dtRatio = this.m_inv_dt0 * a;
    d.warmStarting = this.m_warmStarting;
    a = new box2d.b2Timer;
    this.m_contactManager.Collide();
    this.m_profile.collide = a.GetMilliseconds();
    this.m_stepComplete && 0 < d.dt && (a = new box2d.b2Timer, this.Solve(d), this.m_profile.solve = a.GetMilliseconds());
    this.m_continuousPhysics && 0 < d.dt && (a = new box2d.b2Timer, this.SolveTOI(d), this.m_profile.solveTOI = a.GetMilliseconds());
    0 < d.dt && (this.m_inv_dt0 = d.inv_dt);
    this.m_flags & box2d.b2WorldFlag.e_clearForces && this.ClearForces();
    this.m_flags &= ~box2d.b2WorldFlag.e_locked;
    this.m_profile.step = e.GetMilliseconds()
};
goog.exportProperty(box2d.b2World.prototype, "Step", box2d.b2World.prototype.Step);
box2d.b2World.prototype.Step.s_step = new box2d.b2TimeStep;
box2d.b2World.prototype.ClearForces = function() {
    for (var a = this.m_bodyList; a; a = a.m_next)
        a.m_force.SetZero(), a.m_torque = 0
};
goog.exportProperty(box2d.b2World.prototype, "ClearForces", box2d.b2World.prototype.ClearForces);
box2d.b2World.prototype.QueryAABB = function(a, b) {
    var c = this.m_contactManager.m_broadPhase;
    c.Query(function(b) {
        b = c.GetUserData(b);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(b instanceof box2d.b2FixtureProxy);
        b = b.fixture;
        return a instanceof box2d.b2QueryCallback ? a.ReportFixture(b) : a(b)
    }, b)
};
goog.exportProperty(box2d.b2World.prototype, "QueryAABB", box2d.b2World.prototype.QueryAABB);
box2d.b2World.prototype.QueryShape = function(a, b, c) {
    var e = this.m_contactManager.m_broadPhase, d = box2d.b2World.prototype.QueryShape.s_aabb;
    b.ComputeAABB(d, c, 0);
    e.Query(function(d) {
        d = e.GetUserData(d);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(d instanceof box2d.b2FixtureProxy);
        d = d.fixture;
        return box2d.b2TestOverlapShape(b, 0, d.GetShape(), 0, c, d.GetBody().GetTransform()) ? a instanceof box2d.b2QueryCallback ? a.ReportFixture(d) : a(d) : !0
    }, d)
};
goog.exportProperty(box2d.b2World.prototype, "QueryShape", box2d.b2World.prototype.QueryShape);
box2d.b2World.prototype.QueryShape.s_aabb = new box2d.b2AABB;
box2d.b2World.prototype.QueryPoint = function(a, b) {
    var c = this.m_contactManager.m_broadPhase, e = box2d.b2World.prototype.QueryPoint.s_aabb;
    e.lowerBound.SetXY(b.x - box2d.b2_linearSlop, b.y - box2d.b2_linearSlop);
    e.upperBound.SetXY(b.x + box2d.b2_linearSlop, b.y + box2d.b2_linearSlop);
    c.Query(function(d) {
        d = c.GetUserData(d);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(d instanceof box2d.b2FixtureProxy);
        d = d.fixture;
        return d.TestPoint(b) ? a instanceof box2d.b2QueryCallback ? a.ReportFixture(d) : a(d) : !0
    }, e)
};
goog.exportProperty(box2d.b2World.prototype, "QueryPoint", box2d.b2World.prototype.QueryPoint);
box2d.b2World.prototype.QueryPoint.s_aabb = new box2d.b2AABB;
box2d.b2World.prototype.RayCast = function(a, b, c) {
    var e = this.m_contactManager.m_broadPhase, d = box2d.b2World.prototype.RayCast.s_input;
    d.maxFraction = 1;
    d.p1.Copy(b);
    d.p2.Copy(c);
    e.RayCast(function(d, g) {
        var h = e.GetUserData(g);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(h instanceof box2d.b2FixtureProxy);
        var l = h.fixture, k = box2d.b2World.prototype.RayCast.s_output;
        if (l.RayCast(k, d, h.childIndex)) {
            var h = k.fraction, m = box2d.b2World.prototype.RayCast.s_point;
            m.SetXY((1 - h) * b.x + h * c.x, (1 - h) * b.y + h * c.y);
            return a instanceof
                    box2d.b2RayCastCallback ? a.ReportFixture(l, m, k.normal, h) : a(l, m, k.normal, h)
        }
        return d.maxFraction
    }, d)
};
goog.exportProperty(box2d.b2World.prototype, "RayCast", box2d.b2World.prototype.RayCast);
box2d.b2World.prototype.RayCast.s_input = new box2d.b2RayCastInput;
box2d.b2World.prototype.RayCast.s_output = new box2d.b2RayCastOutput;
box2d.b2World.prototype.RayCast.s_point = new box2d.b2Vec2;
box2d.b2World.prototype.RayCastOne = function(a, b) {
    var c = null, e = 1;
    this.RayCast(function(a, b, g, h) {
        h < e && (e = h, c = a);
        return e
    }, a, b);
    return c
};
goog.exportProperty(box2d.b2World.prototype, "RayCastOne", box2d.b2World.prototype.RayCastOne);
box2d.b2World.prototype.RayCastAll = function(a, b, c) {
    c.length = 0;
    this.RayCast(function(a, b, f, g) {
        c.push(a);
        return 1
    }, a, b);
    return c
};
goog.exportProperty(box2d.b2World.prototype, "RayCastAll", box2d.b2World.prototype.RayCastAll);
box2d.b2World.prototype.DrawShape = function(a, b) {
    var c = a.GetShape();
    switch (c.m_type) {
        case box2d.b2ShapeType.e_circleShape:
            c = c instanceof box2d.b2CircleShape ? c : null;
            this.m_debugDraw.DrawSolidCircle(c.m_p, c.m_radius, box2d.b2Vec2.UNITX, b);
            break;
        case box2d.b2ShapeType.e_edgeShape:
            var e = c instanceof box2d.b2EdgeShape ? c : null, c = e.m_vertex1, d = e.m_vertex2;
            this.m_debugDraw.DrawSegment(c, d, b);
            break;
        case box2d.b2ShapeType.e_chainShape:
            var c = c instanceof box2d.b2ChainShape ? c : null, e = c.m_count, f = c.m_vertices, c = f[0];
            this.m_debugDraw.DrawCircle(c, 0.05, b);
            for (var g = 1; g < e; ++g)
                d = f[g], this.m_debugDraw.DrawSegment(c, d, b), this.m_debugDraw.DrawCircle(d, 0.05, b), c = d;
            break;
        case box2d.b2ShapeType.e_polygonShape:
            e = c instanceof box2d.b2PolygonShape ? c : null, c = e.m_count, f = e.m_vertices, this.m_debugDraw.DrawSolidPolygon(f, c, b)
        }
};
goog.exportProperty(box2d.b2World.prototype, "DrawShape", box2d.b2World.prototype.DrawShape);
box2d.b2World.prototype.DrawJoint = function(a) {
    var b = a.GetBodyA(), c = a.GetBodyB(), e = b.m_xf.p, d = c.m_xf.p, c = a.GetAnchorA(box2d.b2World.prototype.DrawJoint.s_p1), b = a.GetAnchorB(box2d.b2World.prototype.DrawJoint.s_p2), f = box2d.b2World.prototype.DrawJoint.s_color.SetRGB(0.5, 0.8, 0.8);
    switch (a.m_type) {
        case box2d.b2JointType.e_distanceJoint:
            this.m_debugDraw.DrawSegment(c, b, f);
            break;
        case box2d.b2JointType.e_pulleyJoint:
            e = a instanceof box2d.b2PulleyJoint ? a : null;
            a = e.GetGroundAnchorA(box2d.b2World.prototype.DrawJoint.s_s1);
            e = e.GetGroundAnchorB(box2d.b2World.prototype.DrawJoint.s_s2);
            this.m_debugDraw.DrawSegment(a, c, f);
            this.m_debugDraw.DrawSegment(e, b, f);
            this.m_debugDraw.DrawSegment(a, e, f);
            break;
        case box2d.b2JointType.e_mouseJoint:
            this.m_debugDraw.DrawSegment(c, b, f);
            break;
        default:
            this.m_debugDraw.DrawSegment(e, c, f), this.m_debugDraw.DrawSegment(c, b, f), this.m_debugDraw.DrawSegment(d, b, f)
        }
};
goog.exportProperty(box2d.b2World.prototype, "DrawJoint", box2d.b2World.prototype.DrawJoint);
box2d.b2World.prototype.DrawJoint.s_p1 = new box2d.b2Vec2;
box2d.b2World.prototype.DrawJoint.s_p2 = new box2d.b2Vec2;
box2d.b2World.prototype.DrawJoint.s_color = new box2d.b2Color(0.5, 0.8, 0.8);
box2d.b2World.prototype.DrawJoint.s_s1 = new box2d.b2Vec2;
box2d.b2World.prototype.DrawJoint.s_s2 = new box2d.b2Vec2;
box2d.b2World.prototype.DrawDebugData = function() {
    if (null != this.m_debugDraw) {
        var a = this.m_debugDraw.GetFlags(), b = box2d.b2World.prototype.DrawDebugData.s_color.SetRGB(0, 0, 0);
        if (a & box2d.b2DrawFlags.e_shapeBit)
            for (var c = this.m_bodyList; c; c = c.m_next) {
                var e = c.m_xf;
                this.m_debugDraw.PushTransform(e);
                for (var d = c.GetFixtureList(); d; d = d.m_next)
                    !1 == c.IsActive() ? b.SetRGB(0.5, 0.5, 0.3) : c.GetType() == box2d.b2BodyType.b2_staticBody ? b.SetRGB(0.5, 0.9, 0.5) : c.GetType() == box2d.b2BodyType.b2_kinematicBody ? b.SetRGB(0.5, 0.5,
                            0.9) : !1 == c.IsAwake() ? b.SetRGB(0.6, 0.6, 0.6) : b.SetRGB(0.9, 0.7, 0.7), this.DrawShape(d, b);
                this.m_debugDraw.PopTransform(e)
            }
        if (a & box2d.b2DrawFlags.e_jointBit)
            for (c = this.m_jointList; c; c = c.m_next)
                this.DrawJoint(c);
        if (a & box2d.b2DrawFlags.e_aabbBit) {
            b.SetRGB(0.9, 0.3, 0.9);
            for (var e = this.m_contactManager.m_broadPhase, f = box2d.b2World.prototype.DrawDebugData.s_vs, c = this.m_bodyList; c; c = c.m_next)
                if (!1 != c.IsActive())
                    for (d = c.GetFixtureList(); d; d = d.m_next)
                        for (var g = 0; g < d.m_proxyCount; ++g) {
                            var h = e.GetFatAABB(d.m_proxies[g].proxy);
                            f[0].SetXY(h.lowerBound.x, h.lowerBound.y);
                            f[1].SetXY(h.upperBound.x, h.lowerBound.y);
                            f[2].SetXY(h.upperBound.x, h.upperBound.y);
                            f[3].SetXY(h.lowerBound.x, h.upperBound.y);
                            this.m_debugDraw.DrawPolygon(f, 4, b)
                        }
        }
        if (a & box2d.b2DrawFlags.e_centerOfMassBit)
            for (c = this.m_bodyList; c; c = c.m_next)
                e = box2d.b2World.prototype.DrawDebugData.s_xf, e.q.Copy(c.m_xf.q), e.p.Copy(c.GetWorldCenter()), this.m_debugDraw.DrawTransform(e);
        if (a & box2d.b2DrawFlags.e_controllerBit)
            for (a = this.m_controllerList; a; a = a.m_next)
                a.Draw(this.m_debugDraw)
    }
};
goog.exportProperty(box2d.b2World.prototype, "DrawDebugData", box2d.b2World.prototype.DrawDebugData);
box2d.b2World.prototype.DrawDebugData.s_color = new box2d.b2Color(0, 0, 0);
box2d.b2World.prototype.DrawDebugData.s_vs = box2d.b2Vec2.MakeArray(4);
box2d.b2World.prototype.DrawDebugData.s_xf = new box2d.b2Transform;
box2d.b2World.prototype.SetBroadPhase = function(a) {
    var b = this.m_contactManager.m_broadPhase;
    this.m_contactManager.m_broadPhase = a;
    for (var c = this.m_bodyList; c; c = c.m_next)
        for (var e = c.m_fixtureList; e; e = e.m_next)
            e.m_proxy = a.CreateProxy(b.GetFatAABB(e.m_proxy), e)
};
goog.exportProperty(box2d.b2World.prototype, "SetBroadPhase", box2d.b2World.prototype.SetBroadPhase);
box2d.b2World.prototype.GetProxyCount = function() {
    return this.m_contactManager.m_broadPhase.GetProxyCount()
};
goog.exportProperty(box2d.b2World.prototype, "GetProxyCount", box2d.b2World.prototype.GetProxyCount);
box2d.b2World.prototype.GetTreeHeight = function() {
    return this.m_contactManager.m_broadPhase.GetTreeHeight()
};
goog.exportProperty(box2d.b2World.prototype, "GetTreeHeight", box2d.b2World.prototype.GetTreeHeight);
box2d.b2World.prototype.GetTreeBalance = function() {
    return this.m_contactManager.m_broadPhase.GetTreeBalance()
};
goog.exportProperty(box2d.b2World.prototype, "GetTreeBalance", box2d.b2World.prototype.GetTreeBalance);
box2d.b2World.prototype.GetTreeQuality = function() {
    return this.m_contactManager.m_broadPhase.GetTreeQuality()
};
goog.exportProperty(box2d.b2World.prototype, "GetTreeQuality", box2d.b2World.prototype.GetTreeQuality);
box2d.b2World.prototype.ShiftOrigin = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.IsLocked());
    if (!this.IsLocked()) {
        for (var b = this.m_bodyList; b; b = b.m_next)
            b.m_xf.p.SelfSub(a), b.m_sweep.c0.SelfSub(a), b.m_sweep.c.SelfSub(a);
        for (b = this.m_jointList; b; b = b.m_next)
            b.ShiftOrigin(a);
        this.m_contactManager.m_broadPhase.ShiftOrigin(a)
    }
};
goog.exportProperty(box2d.b2World.prototype, "ShiftOrigin", box2d.b2World.prototype.ShiftOrigin);
box2d.b2World.prototype.Dump = function() {
    if (box2d.DEBUG && (this.m_flags & box2d.b2WorldFlag.e_locked) != box2d.b2WorldFlag.e_locked) {
        box2d.b2Log("/** @type {box2d.b2Vec2} */ var g = new box2d.b2Vec2(%.15f, %.15f);\n", this.m_gravity.x, this.m_gravity.y);
        box2d.b2Log("this.m_world.SetGravity(g);\n");
        box2d.b2Log("/** @type {Array.<box2d.b2Body>} */ var bodies = new Array(%d);\n", this.m_bodyCount);
        box2d.b2Log("/** @type {Array.<box2d.b2Joint>} */ var joints = new Array(%d);\n", this.m_jointCount);
        for (var a = 0,
                b = this.m_bodyList; b; b = b.m_next)
            b.m_islandIndex = a, b.Dump(), ++a;
        a = 0;
        for (b = this.m_jointList; b; b = b.m_next)
            b.m_index = a, ++a;
        for (b = this.m_jointList; b; b = b.m_next)
            b.m_type != box2d.b2JointType.e_gearJoint && (box2d.b2Log("if (true)\n"), box2d.b2Log("{\n"), b.Dump(), box2d.b2Log("}\n"));
        for (b = this.m_jointList; b; b = b.m_next)
            b.m_type == box2d.b2JointType.e_gearJoint && (box2d.b2Log("if (true)\n"), box2d.b2Log("{\n"), b.Dump(), box2d.b2Log("}\n"))
    }
};
goog.exportProperty(box2d.b2World.prototype, "Dump", box2d.b2World.prototype.Dump);
box2d.b2World.prototype.AddController = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(null === a.m_world, "Controller can only be a member of one world");
    a.m_world = this;
    a.m_next = this.m_controllerList;
    a.m_prev = null;
    this.m_controllerList && (this.m_controllerList.m_prev = a);
    this.m_controllerList = a;
    ++this.m_controllerCount;
    return a
};
goog.exportProperty(box2d.b2World.prototype, "AddController", box2d.b2World.prototype.AddController);
box2d.b2World.prototype.RemoveController = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.m_world === this, "Controller is not a member of this world");
    a.m_prev && (a.m_prev.m_next = a.m_next);
    a.m_next && (a.m_next.m_prev = a.m_prev);
    this.m_controllerList == a && (this.m_controllerList = a.m_next);
    --this.m_controllerCount;
    a.m_prev = null;
    a.m_next = null;
    a.m_world = null
};
goog.exportProperty(box2d.b2World.prototype, "RemoveController", box2d.b2World.prototype.RemoveController);
box2d.b2AreaJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_areaJoint);
    this.bodies = []
};
goog.inherits(box2d.b2AreaJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2AreaJointDef", box2d.b2AreaJointDef);
box2d.b2AreaJointDef.prototype.world = null;
goog.exportProperty(box2d.b2AreaJointDef.prototype, "world", box2d.b2AreaJointDef.prototype.world);
box2d.b2AreaJointDef.prototype.bodies = null;
goog.exportProperty(box2d.b2AreaJointDef.prototype, "bodies", box2d.b2AreaJointDef.prototype.bodies);
box2d.b2AreaJointDef.prototype.frequencyHz = 0;
goog.exportProperty(box2d.b2AreaJointDef.prototype, "frequencyHz", box2d.b2AreaJointDef.prototype.frequencyHz);
box2d.b2AreaJointDef.prototype.dampingRatio = 0;
goog.exportProperty(box2d.b2AreaJointDef.prototype, "dampingRatio", box2d.b2AreaJointDef.prototype.dampingRatio);
box2d.b2AreaJointDef.prototype.AddBody = function(a) {
    this.bodies.push(a);
    1 == this.bodies.length ? this.bodyA = a : 2 == this.bodies.length && (this.bodyB = a)
};
goog.exportProperty(box2d.b2AreaJointDef.prototype, "AddBody", box2d.b2AreaJointDef.prototype.AddBody);
box2d.b2AreaJoint = function(a) {
    box2d.b2Joint.call(this, a);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(3 <= a.bodies.length, "You cannot create an area joint with less than three bodies.");
    this.m_bodies = a.bodies;
    this.m_frequencyHz = a.frequencyHz;
    this.m_dampingRatio = a.dampingRatio;
    this.m_targetLengths = box2d.b2MakeNumberArray(a.bodies.length);
    this.m_normals = box2d.b2Vec2.MakeArray(a.bodies.length);
    this.m_joints = Array(a.bodies.length);
    this.m_deltas = box2d.b2Vec2.MakeArray(a.bodies.length);
    this.m_delta = new box2d.b2Vec2;
    var b = new box2d.b2DistanceJointDef;
    b.frequencyHz = a.frequencyHz;
    b.dampingRatio = a.dampingRatio;
    for (var c = this.m_targetArea = 0, e = this.m_bodies.length; c < e; ++c) {
        var d = this.m_bodies[c], f = this.m_bodies[(c + 1) % e], g = d.GetWorldCenter(), h = f.GetWorldCenter();
        this.m_targetLengths[c] = box2d.b2DistanceVV(g, h);
        this.m_targetArea += box2d.b2CrossVV(g, h);
        b.Initialize(d, f, g, h);
        this.m_joints[c] = a.world.CreateJoint(b)
    }
    this.m_targetArea *= 0.5
};
goog.inherits(box2d.b2AreaJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2AreaJoint", box2d.b2AreaJoint);
box2d.b2AreaJoint.prototype.m_bodies = null;
goog.exportProperty(box2d.b2AreaJoint.prototype, "m_bodies", box2d.b2AreaJoint.prototype.m_bodies);
box2d.b2AreaJoint.prototype.m_frequencyHz = 0;
goog.exportProperty(box2d.b2AreaJoint.prototype, "m_frequencyHz", box2d.b2AreaJoint.prototype.m_frequencyHz);
box2d.b2AreaJoint.prototype.m_dampingRatio = 0;
goog.exportProperty(box2d.b2AreaJoint.prototype, "m_dampingRatio", box2d.b2AreaJoint.prototype.m_dampingRatio);
box2d.b2AreaJoint.prototype.m_impulse = 0;
goog.exportProperty(box2d.b2AreaJoint.prototype, "m_impulse", box2d.b2AreaJoint.prototype.m_impulse);
box2d.b2AreaJoint.prototype.m_targetLengths = null;
box2d.b2AreaJoint.prototype.m_targetArea = 0;
box2d.b2AreaJoint.prototype.m_normals = null;
box2d.b2AreaJoint.prototype.m_joints = null;
box2d.b2AreaJoint.prototype.m_deltas = null;
box2d.b2AreaJoint.prototype.m_delta = null;
box2d.b2AreaJoint.prototype.GetAnchorA = function(a) {
    return a.SetZero()
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "GetAnchorA", box2d.b2AreaJoint.prototype.GetAnchorA);
box2d.b2AreaJoint.prototype.GetAnchorB = function(a) {
    return a.SetZero()
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "GetAnchorB", box2d.b2AreaJoint.prototype.GetAnchorB);
box2d.b2AreaJoint.prototype.GetReactionForce = function(a, b) {
    return b.SetZero()
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "GetReactionForce", box2d.b2AreaJoint.prototype.GetReactionForce);
box2d.b2AreaJoint.prototype.GetReactionTorque = function(a) {
    return 0
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "GetReactionTorque", box2d.b2AreaJoint.prototype.GetReactionTorque);
box2d.b2AreaJoint.prototype.SetFrequency = function(a) {
    this.m_frequencyHz = a;
    for (var b = 0, c = this.m_joints.length; b < c; ++b)
        this.m_joints[b].SetFrequency(a)
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "SetFrequency", box2d.b2AreaJoint.prototype.SetFrequency);
box2d.b2AreaJoint.prototype.GetFrequency = function() {
    return this.m_frequencyHz
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "GetFrequency", box2d.b2AreaJoint.prototype.GetFrequency);
box2d.b2AreaJoint.prototype.SetDampingRatio = function(a) {
    this.m_dampingRatio = a;
    for (var b = 0, c = this.m_joints.length; b < c; ++b)
        this.m_joints[b].SetDampingRatio(a)
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "SetDampingRatio", box2d.b2AreaJoint.prototype.SetDampingRatio);
box2d.b2AreaJoint.prototype.GetDampingRatio = function() {
    return this.m_dampingRatio
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "GetDampingRatio", box2d.b2AreaJoint.prototype.GetDampingRatio);
box2d.b2AreaJoint.prototype.Dump = function() {
    box2d.DEBUG && box2d.b2Log("Area joint dumping is not supported.\n")
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "Dump", box2d.b2AreaJoint.prototype.Dump);
box2d.b2AreaJoint.prototype.InitVelocityConstraints = function(a) {
    for (var b = 0, c = this.m_bodies.length; b < c; ++b) {
        var e = this.m_deltas[b];
        box2d.b2SubVV(a.positions[this.m_bodies[(b + 1) % c].m_islandIndex].c, a.positions[this.m_bodies[(b + c - 1) % c].m_islandIndex].c, e)
    }
    if (a.step.warmStarting)
        for (this.m_impulse *= a.step.dtRatio, b = 0, c = this.m_bodies.length; b < c; ++b) {
            var d = this.m_bodies[b], f = a.velocities[d.m_islandIndex].v, e = this.m_deltas[b];
            f.x += 0.5 * (d.m_invMass * e.y) * this.m_impulse;
            f.y += 0.5 * (d.m_invMass * -e.x) * this.m_impulse
        }
    else
        this.m_impulse =
        0
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "InitVelocityConstraints", box2d.b2AreaJoint.prototype.InitVelocityConstraints);
box2d.b2AreaJoint.prototype.SolveVelocityConstraints = function(a) {
    for (var b = 0, c = 0, e = 0, d = this.m_bodies.length; e < d; ++e)
        var f = this.m_bodies[e], g = a.velocities[f.m_islandIndex].v, h = this.m_deltas[e], b = b + h.GetLengthSquared() / f.GetMass(), c = c + box2d.b2CrossVV(g, h);
    b = -2 * c / b;
    this.m_impulse += b;
    e = 0;
    for (d = this.m_bodies.length; e < d; ++e)
        f = this.m_bodies[e], g = a.velocities[f.m_islandIndex].v, h = this.m_deltas[e], g.x += 0.5 * (f.m_invMass * h.y) * b, g.y += 0.5 * (f.m_invMass * -h.x) * b
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "SolveVelocityConstraints", box2d.b2AreaJoint.prototype.SolveVelocityConstraints);
box2d.b2AreaJoint.prototype.SolvePositionConstraints = function(a) {
    for (var b = 0, c = 0, e = 0, d = this.m_bodies.length; e < d; ++e) {
        var f = this.m_bodies[e], f = a.positions[f.m_islandIndex].c, g = a.positions[this.m_bodies[(e + 1) % d].m_islandIndex].c, h = box2d.b2SubVV(g, f, this.m_delta), l = h.GetLength();
        l < box2d.b2_epsilon && (l = 1);
        this.m_normals[e].x = h.y / l;
        this.m_normals[e].y = -h.x / l;
        b += l;
        c += box2d.b2CrossVV(f, g)
    }
    b = 0.5 * (this.m_targetArea - 0.5 * c) / b;
    c = !0;
    e = 0;
    for (d = this.m_bodies.length; e < d; ++e)
        f = this.m_bodies[e], f = a.positions[f.m_islandIndex].c,
                h = box2d.b2AddVV(this.m_normals[e], this.m_normals[(e + 1) % d], this.m_delta), h.SelfMul(b), g = h.GetLengthSquared(), g > box2d.b2Sq(box2d.b2_maxLinearCorrection) && h.SelfMul(box2d.b2_maxLinearCorrection / box2d.b2Sqrt(g)), g > box2d.b2Sq(box2d.b2_linearSlop) && (c = !1), f.x += h.x, f.y += h.y;
    return c
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "SolvePositionConstraints", box2d.b2AreaJoint.prototype.SolvePositionConstraints);
box2d.b2BuoyancyController = function() {
    box2d.b2Controller.call(this);
    this.normal = new box2d.b2Vec2(0, 1);
    this.velocity = new box2d.b2Vec2(0, 0);
    this.gravity = new box2d.b2Vec2(0, 0)
};
goog.inherits(box2d.b2BuoyancyController, box2d.b2Controller);
goog.exportSymbol("box2d.b2BuoyancyController", box2d.b2BuoyancyController);
box2d.b2BuoyancyController.prototype.normal = null;
goog.exportProperty(box2d.b2BuoyancyController.prototype, "normal", box2d.b2BuoyancyController.prototype.normal);
box2d.b2BuoyancyController.prototype.offset = 0;
goog.exportProperty(box2d.b2BuoyancyController.prototype, "offset", box2d.b2BuoyancyController.prototype.offset);
box2d.b2BuoyancyController.prototype.density = 0;
goog.exportProperty(box2d.b2BuoyancyController.prototype, "density", box2d.b2BuoyancyController.prototype.density);
box2d.b2BuoyancyController.prototype.velocity = null;
goog.exportProperty(box2d.b2BuoyancyController.prototype, "velocity", box2d.b2BuoyancyController.prototype.velocity);
box2d.b2BuoyancyController.prototype.linearDrag = 0;
goog.exportProperty(box2d.b2BuoyancyController.prototype, "linearDrag", box2d.b2BuoyancyController.prototype.linearDrag);
box2d.b2BuoyancyController.prototype.angularDrag = 0;
goog.exportProperty(box2d.b2BuoyancyController.prototype, "angularDrag", box2d.b2BuoyancyController.prototype.angularDrag);
box2d.b2BuoyancyController.prototype.useDensity = !1;
goog.exportProperty(box2d.b2BuoyancyController.prototype, "useDensity", box2d.b2BuoyancyController.prototype.useDensity);
box2d.b2BuoyancyController.prototype.useWorldGravity = !0;
goog.exportProperty(box2d.b2BuoyancyController.prototype, "useWorldGravity", box2d.b2BuoyancyController.prototype.useWorldGravity);
box2d.b2BuoyancyController.prototype.gravity = null;
goog.exportProperty(box2d.b2BuoyancyController.prototype, "gravity", box2d.b2BuoyancyController.prototype.gravity);
box2d.b2BuoyancyController.prototype.Step = function(a) {
    if (this.m_bodyList)
        for (this.useWorldGravity && this.gravity.Copy(this.GetWorld().GetGravity()), a = this.m_bodyList; a; a = a.nextBody) {
            var b = a.body;
            if (!1 != b.IsAwake()) {
                for (var c = new box2d.b2Vec2, e = new box2d.b2Vec2, d = 0, f = 0, g = b.GetFixtureList(); g; g = g.m_next) {
                    var h = new box2d.b2Vec2, l = g.GetShape().ComputeSubmergedArea(this.normal, this.offset, b.GetTransform(), h), d = d + l;
                    c.x += l * h.x;
                    c.y += l * h.y;
                    var k = 0, k = this.useDensity ? g.GetDensity() : 1, f = f + l * k;
                    e.x += l * h.x * k;
                    e.y +=
                            l * h.y * k
                }
                c.x /= d;
                c.y /= d;
                e.x /= f;
                e.y /= f;
                d < box2d.b2_epsilon || (f = box2d.b2NegV(this.gravity, new box2d.b2Vec2), f.SelfMul(this.density * d), b.ApplyForce(f, e), e = b.GetLinearVelocityFromWorldPoint(c, new box2d.b2Vec2), e.SelfSub(this.velocity), e.SelfMul(-this.linearDrag * d), b.ApplyForce(e, c), b.ApplyTorque(-b.GetInertia() / b.GetMass() * d * b.GetAngularVelocity() * this.angularDrag))
            }
        }
};
goog.exportProperty(box2d.b2BuoyancyController.prototype, "Step", box2d.b2BuoyancyController.prototype.Step);
box2d.b2BuoyancyController.prototype.Draw = function(a) {
    var b = new box2d.b2Vec2, c = new box2d.b2Vec2;
    b.x = this.normal.x * this.offset + 100 * this.normal.y;
    b.y = this.normal.y * this.offset - 100 * this.normal.x;
    c.x = this.normal.x * this.offset - 100 * this.normal.y;
    c.y = this.normal.y * this.offset + 100 * this.normal.x;
    var e = new box2d.b2Color(0, 0, 0.8);
    a.DrawSegment(b, c, e)
};
goog.exportProperty(box2d.b2BuoyancyController.prototype, "Draw", box2d.b2BuoyancyController.prototype.Draw);
box2d.b2TensorDampingController = function() {
    box2d.b2Controller.call(this);
    this.T = new box2d.b2Mat22;
    this.maxTimestep = 0
};
goog.inherits(box2d.b2TensorDampingController, box2d.b2Controller);
goog.exportSymbol("box2d.b2TensorDampingController", box2d.b2TensorDampingController);
box2d.b2TensorDampingController.prototype.T = new box2d.b2Mat22;
goog.exportProperty(box2d.b2TensorDampingController.prototype, "T", box2d.b2TensorDampingController.prototype.T);
box2d.b2TensorDampingController.prototype.maxTimestep = 0;
goog.exportProperty(box2d.b2TensorDampingController.prototype, "maxTimestep", box2d.b2TensorDampingController.prototype.maxTimestep);
box2d.b2TensorDampingController.prototype.Step = function(a) {
    a = a.dt;
    if (!(a <= box2d.b2_epsilon)) {
        a > this.maxTimestep && 0 < this.maxTimestep && (a = this.maxTimestep);
        for (var b = this.m_bodyList; b; b = b.nextBody) {
            var c = b.body;
            if (c.IsAwake()) {
                var e = c.GetWorldVector(box2d.b2MulMV(this.T, c.GetLocalVector(c.GetLinearVelocity(), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t1), box2d.b2TensorDampingController.prototype.Step.s_damping);
                c.SetLinearVelocity(box2d.b2AddVV(c.GetLinearVelocity(), box2d.b2MulSV(a, e, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t1))
            }
        }
    }
};
box2d.b2TensorDampingController.prototype.Step.s_damping = new box2d.b2Vec2;
box2d.b2TensorDampingController.prototype.SetAxisAligned = function(a, b) {
    this.T.ex.x = -a;
    this.T.ex.y = 0;
    this.T.ey.x = 0;
    this.T.ey.y = -b;
    this.maxTimestep = 0 < a || 0 < b ? 1 / box2d.b2Max(a, b) : 0
};
box2d.b2DistanceJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_distanceJoint);
    this.localAnchorA = new box2d.b2Vec2;
    this.localAnchorB = new box2d.b2Vec2
};
goog.inherits(box2d.b2DistanceJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2DistanceJointDef", box2d.b2DistanceJointDef);
box2d.b2DistanceJointDef.prototype.localAnchorA = null;
goog.exportProperty(box2d.b2DistanceJointDef.prototype, "localAnchorA", box2d.b2DistanceJointDef.prototype.localAnchorA);
box2d.b2DistanceJointDef.prototype.localAnchorB = null;
goog.exportProperty(box2d.b2DistanceJointDef.prototype, "localAnchorB", box2d.b2DistanceJointDef.prototype.localAnchorB);
box2d.b2DistanceJointDef.prototype.length = 1;
goog.exportProperty(box2d.b2DistanceJointDef.prototype, "length", box2d.b2DistanceJointDef.prototype.length);
box2d.b2DistanceJointDef.prototype.frequencyHz = 0;
goog.exportProperty(box2d.b2DistanceJointDef.prototype, "frequencyHz", box2d.b2DistanceJointDef.prototype.frequencyHz);
box2d.b2DistanceJointDef.prototype.dampingRatio = 0;
goog.exportProperty(box2d.b2DistanceJointDef.prototype, "dampingRatio", box2d.b2DistanceJointDef.prototype.dampingRatio);
box2d.b2DistanceJointDef.prototype.Initialize = function(a, b, c, e) {
    this.bodyA = a;
    this.bodyB = b;
    this.bodyA.GetLocalPoint(c, this.localAnchorA);
    this.bodyB.GetLocalPoint(e, this.localAnchorB);
    this.length = box2d.b2DistanceVV(c, e);
    this.dampingRatio = this.frequencyHz = 0
};
goog.exportProperty(box2d.b2DistanceJointDef.prototype, "Initialize", box2d.b2DistanceJointDef.prototype.Initialize);
box2d.b2DistanceJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_u = new box2d.b2Vec2;
    this.m_rA = new box2d.b2Vec2;
    this.m_rB = new box2d.b2Vec2;
    this.m_localCenterA = new box2d.b2Vec2;
    this.m_localCenterB = new box2d.b2Vec2;
    this.m_qA = new box2d.b2Rot;
    this.m_qB = new box2d.b2Rot;
    this.m_lalcA = new box2d.b2Vec2;
    this.m_lalcB = new box2d.b2Vec2;
    this.m_frequencyHz = a.frequencyHz;
    this.m_dampingRatio = a.dampingRatio;
    this.m_localAnchorA = a.localAnchorA.Clone();
    this.m_localAnchorB = a.localAnchorB.Clone();
    this.m_length = a.length
};
goog.inherits(box2d.b2DistanceJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2DistanceJoint", box2d.b2DistanceJoint);
box2d.b2DistanceJoint.prototype.m_frequencyHz = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_frequencyHz", box2d.b2DistanceJoint.prototype.m_frequencyHz);
box2d.b2DistanceJoint.prototype.m_dampingRatio = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_dampingRatio", box2d.b2DistanceJoint.prototype.m_dampingRatio);
box2d.b2DistanceJoint.prototype.m_bias = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_bias", box2d.b2DistanceJoint.prototype.m_bias);
box2d.b2DistanceJoint.prototype.m_localAnchorA = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_localAnchorA", box2d.b2DistanceJoint.prototype.m_localAnchorA);
box2d.b2DistanceJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_localAnchorB", box2d.b2DistanceJoint.prototype.m_localAnchorB);
box2d.b2DistanceJoint.prototype.m_gamma = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_gamma", box2d.b2DistanceJoint.prototype.m_gamma);
box2d.b2DistanceJoint.prototype.m_impulse = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_impulse", box2d.b2DistanceJoint.prototype.m_impulse);
box2d.b2DistanceJoint.prototype.m_length = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_length", box2d.b2DistanceJoint.prototype.m_length);
box2d.b2DistanceJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_indexA", box2d.b2DistanceJoint.prototype.m_indexA);
box2d.b2DistanceJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_indexB", box2d.b2DistanceJoint.prototype.m_indexB);
box2d.b2DistanceJoint.prototype.m_u = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_u", box2d.b2DistanceJoint.prototype.m_u);
box2d.b2DistanceJoint.prototype.m_rA = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_rA", box2d.b2DistanceJoint.prototype.m_rA);
box2d.b2DistanceJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_rB", box2d.b2DistanceJoint.prototype.m_rB);
box2d.b2DistanceJoint.prototype.m_localCenterA = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_localCenterA", box2d.b2DistanceJoint.prototype.m_localCenterA);
box2d.b2DistanceJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_localCenterB", box2d.b2DistanceJoint.prototype.m_localCenterB);
box2d.b2DistanceJoint.prototype.m_invMassA = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_invMassA", box2d.b2DistanceJoint.prototype.m_invMassA);
box2d.b2DistanceJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_invMassB", box2d.b2DistanceJoint.prototype.m_invMassB);
box2d.b2DistanceJoint.prototype.m_invIA = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_invIA", box2d.b2DistanceJoint.prototype.m_invIA);
box2d.b2DistanceJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_invIB", box2d.b2DistanceJoint.prototype.m_invIB);
box2d.b2DistanceJoint.prototype.m_mass = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_mass", box2d.b2DistanceJoint.prototype.m_mass);
box2d.b2DistanceJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_qA", box2d.b2DistanceJoint.prototype.m_qA);
box2d.b2DistanceJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_qB", box2d.b2DistanceJoint.prototype.m_qB);
box2d.b2DistanceJoint.prototype.m_lalcA = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_lalcA", box2d.b2DistanceJoint.prototype.m_lalcA);
box2d.b2DistanceJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_lalcB", box2d.b2DistanceJoint.prototype.m_lalcB);
box2d.b2DistanceJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, a)
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "GetAnchorA", box2d.b2DistanceJoint.prototype.GetAnchorA);
box2d.b2DistanceJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "GetAnchorB", box2d.b2DistanceJoint.prototype.GetAnchorB);
box2d.b2DistanceJoint.prototype.GetReactionForce = function(a, b) {
    return b.SetXY(a * this.m_impulse * this.m_u.x, a * this.m_impulse * this.m_u.y)
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "GetReactionForce", box2d.b2DistanceJoint.prototype.GetReactionForce);
box2d.b2DistanceJoint.prototype.GetReactionTorque = function(a) {
    return 0
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "GetReactionTorque", box2d.b2DistanceJoint.prototype.GetReactionTorque);
box2d.b2DistanceJoint.prototype.GetLocalAnchorA = function(a) {
    return a.Copy(this.m_localAnchorA)
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "GetLocalAnchorA", box2d.b2DistanceJoint.prototype.GetLocalAnchorA);
box2d.b2DistanceJoint.prototype.GetLocalAnchorB = function(a) {
    return a.Copy(this.m_localAnchorB)
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "GetLocalAnchorB", box2d.b2DistanceJoint.prototype.GetLocalAnchorB);
box2d.b2DistanceJoint.prototype.SetLength = function(a) {
    this.m_length = a
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "SetLength", box2d.b2DistanceJoint.prototype.SetLength);
box2d.b2DistanceJoint.prototype.GetLength = function() {
    return this.m_length
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "GetLength", box2d.b2DistanceJoint.prototype.GetLength);
box2d.b2DistanceJoint.prototype.SetFrequency = function(a) {
    this.m_frequencyHz = a
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "SetFrequency", box2d.b2DistanceJoint.prototype.SetFrequency);
box2d.b2DistanceJoint.prototype.GetFrequency = function() {
    return this.m_frequencyHz
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "GetFrequency", box2d.b2DistanceJoint.prototype.GetFrequency);
box2d.b2DistanceJoint.prototype.SetDampingRatio = function(a) {
    this.m_dampingRatio = a
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "SetDampingRatio", box2d.b2DistanceJoint.prototype.SetDampingRatio);
box2d.b2DistanceJoint.prototype.GetDampingRatio = function() {
    return this.m_dampingRatio
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "GetDampingRatio", box2d.b2DistanceJoint.prototype.GetDampingRatio);
box2d.b2DistanceJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2DistanceJointDef*/ var jd = new box2d.b2DistanceJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
        box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n",
                this.m_localAnchorB.x, this.m_localAnchorB.y);
        box2d.b2Log("  jd.length = %.15f;\n", this.m_length);
        box2d.b2Log("  jd.frequencyHz = %.15f;\n", this.m_frequencyHz);
        box2d.b2Log("  jd.dampingRatio = %.15f;\n", this.m_dampingRatio);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "Dump", box2d.b2DistanceJoint.prototype.Dump);
box2d.b2DistanceJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassA = this.m_bodyA.m_invMass;
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIA = this.m_bodyA.m_invI;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = a.positions[this.m_indexA].c, c = a.velocities[this.m_indexA].v, e = a.velocities[this.m_indexA].w,
            d = a.positions[this.m_indexB].c, f = a.positions[this.m_indexB].a, g = a.velocities[this.m_indexB].v, h = a.velocities[this.m_indexB].w, l = this.m_qA.SetAngleRadians(a.positions[this.m_indexA].a), f = this.m_qB.SetAngleRadians(f);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    box2d.b2MulRV(l, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    box2d.b2MulRV(f, this.m_lalcB, this.m_rB);
    this.m_u.x = d.x + this.m_rB.x - b.x - this.m_rA.x;
    this.m_u.y = d.y + this.m_rB.y -
            b.y - this.m_rA.y;
    d = this.m_u.GetLength();
    d > box2d.b2_linearSlop ? this.m_u.SelfMul(1 / d) : this.m_u.SetZero();
    b = box2d.b2CrossVV(this.m_rA, this.m_u);
    l = box2d.b2CrossVV(this.m_rB, this.m_u);
    b = this.m_invMassA + this.m_invIA * b * b + this.m_invMassB + this.m_invIB * l * l;
    this.m_mass = 0 != b ? 1 / b : 0;
    if (0 < this.m_frequencyHz) {
        var d = d - this.m_length, l = 2 * box2d.b2_pi * this.m_frequencyHz, f = this.m_mass * l * l, k = a.step.dt;
        this.m_gamma = k * (2 * this.m_mass * this.m_dampingRatio * l + k * f);
        this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma : 0;
        this.m_bias = d * k * f *
                this.m_gamma;
        b += this.m_gamma;
        this.m_mass = 0 != b ? 1 / b : 0
    } else
        this.m_bias = this.m_gamma = 0;
    a.step.warmStarting ? (this.m_impulse *= a.step.dtRatio, b = box2d.b2MulSV(this.m_impulse, this.m_u, box2d.b2DistanceJoint.prototype.InitVelocityConstraints.s_P), c.SelfMulSub(this.m_invMassA, b), e -= this.m_invIA * box2d.b2CrossVV(this.m_rA, b), g.SelfMulAdd(this.m_invMassB, b), h += this.m_invIB * box2d.b2CrossVV(this.m_rB, b)) : this.m_impulse = 0;
    a.velocities[this.m_indexA].w = e;
    a.velocities[this.m_indexB].w = h
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "InitVelocityConstraints", box2d.b2DistanceJoint.prototype.InitVelocityConstraints);
box2d.b2DistanceJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2DistanceJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.velocities[this.m_indexB].v, d = a.velocities[this.m_indexB].w, f = box2d.b2AddVCrossSV(b, c, this.m_rA, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpA), g = box2d.b2AddVCrossSV(e, d, this.m_rB, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpB), f = box2d.b2DotVV(this.m_u, box2d.b2SubVV(g, f, box2d.b2Vec2.s_t0)), f = -this.m_mass * (f + this.m_bias + this.m_gamma *
            this.m_impulse);
    this.m_impulse += f;
    f = box2d.b2MulSV(f, this.m_u, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_P);
    b.SelfMulSub(this.m_invMassA, f);
    c -= this.m_invIA * box2d.b2CrossVV(this.m_rA, f);
    e.SelfMulAdd(this.m_invMassB, f);
    d += this.m_invIB * box2d.b2CrossVV(this.m_rB, f);
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = d
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "SolveVelocityConstraints", box2d.b2DistanceJoint.prototype.SolveVelocityConstraints);
box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpA = new box2d.b2Vec2;
box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpB = new box2d.b2Vec2;
box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2DistanceJoint.prototype.SolvePositionConstraints = function(a) {
    if (0 < this.m_frequencyHz)
        return!0;
    var b = a.positions[this.m_indexA].c, c = a.positions[this.m_indexA].a, e = a.positions[this.m_indexB].c, d = a.positions[this.m_indexB].a;
    this.m_qA.SetAngleRadians(c);
    this.m_qB.SetAngleRadians(d);
    var f = box2d.b2MulRV(this.m_qA, this.m_lalcA, this.m_rA), g = box2d.b2MulRV(this.m_qB, this.m_lalcB, this.m_rB), h = this.m_u;
    h.x = e.x + g.x - b.x - f.x;
    h.y = e.y + g.y - b.y - f.y;
    var l = this.m_u.Normalize() - this.m_length, l = box2d.b2Clamp(l,
            -box2d.b2_maxLinearCorrection, box2d.b2_maxLinearCorrection), h = box2d.b2MulSV(-this.m_mass * l, h, box2d.b2DistanceJoint.prototype.SolvePositionConstraints.s_P);
    b.SelfMulSub(this.m_invMassA, h);
    c -= this.m_invIA * box2d.b2CrossVV(f, h);
    e.SelfMulAdd(this.m_invMassB, h);
    d += this.m_invIB * box2d.b2CrossVV(g, h);
    a.positions[this.m_indexA].a = c;
    a.positions[this.m_indexB].a = d;
    return box2d.b2Abs(l) < box2d.b2_linearSlop
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "SolvePositionConstraints", box2d.b2DistanceJoint.prototype.SolvePositionConstraints);
box2d.b2DistanceJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2;
box2d.b2FrictionJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_frictionJoint);
    this.localAnchorA = new box2d.b2Vec2;
    this.localAnchorB = new box2d.b2Vec2
};
goog.inherits(box2d.b2FrictionJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2FrictionJointDef", box2d.b2FrictionJointDef);
box2d.b2FrictionJointDef.prototype.localAnchorA = null;
goog.exportProperty(box2d.b2FrictionJointDef.prototype, "localAnchorA", box2d.b2FrictionJointDef.prototype.localAnchorA);
box2d.b2FrictionJointDef.prototype.localAnchorB = null;
goog.exportProperty(box2d.b2FrictionJointDef.prototype, "localAnchorB", box2d.b2FrictionJointDef.prototype.localAnchorB);
box2d.b2FrictionJointDef.prototype.maxForce = 0;
goog.exportProperty(box2d.b2FrictionJointDef.prototype, "maxForce", box2d.b2FrictionJointDef.prototype.maxForce);
box2d.b2FrictionJointDef.prototype.maxTorque = 0;
goog.exportProperty(box2d.b2FrictionJointDef.prototype, "maxTorque", box2d.b2FrictionJointDef.prototype.maxTorque);
box2d.b2FrictionJointDef.prototype.Initialize = function(a, b, c) {
    this.bodyA = a;
    this.bodyB = b;
    this.bodyA.GetLocalPoint(c, this.localAnchorA);
    this.bodyB.GetLocalPoint(c, this.localAnchorB)
};
goog.exportProperty(box2d.b2FrictionJointDef.prototype, "Initialize", box2d.b2FrictionJointDef.prototype.Initialize);
box2d.b2FrictionJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_localAnchorA = a.localAnchorA.Clone();
    this.m_localAnchorB = a.localAnchorB.Clone();
    this.m_linearImpulse = (new box2d.b2Vec2).SetZero();
    this.m_maxForce = a.maxForce;
    this.m_maxTorque = a.maxTorque;
    this.m_rA = new box2d.b2Vec2;
    this.m_rB = new box2d.b2Vec2;
    this.m_localCenterA = new box2d.b2Vec2;
    this.m_localCenterB = new box2d.b2Vec2;
    this.m_linearMass = (new box2d.b2Mat22).SetZero();
    this.m_qA = new box2d.b2Rot;
    this.m_qB = new box2d.b2Rot;
    this.m_lalcA = new box2d.b2Vec2;
    this.m_lalcB = new box2d.b2Vec2;
    this.m_K = new box2d.b2Mat22
};
goog.inherits(box2d.b2FrictionJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2FrictionJoint", box2d.b2FrictionJoint);
box2d.b2FrictionJoint.prototype.m_localAnchorA = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_localAnchorA", box2d.b2FrictionJoint.prototype.m_localAnchorA);
box2d.b2FrictionJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_localAnchorB", box2d.b2FrictionJoint.prototype.m_localAnchorB);
box2d.b2FrictionJoint.prototype.m_linearImpulse = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_linearImpulse", box2d.b2FrictionJoint.prototype.m_linearImpulse);
box2d.b2FrictionJoint.prototype.m_angularImpulse = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_angularImpulse", box2d.b2FrictionJoint.prototype.m_angularImpulse);
box2d.b2FrictionJoint.prototype.m_maxForce = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_maxForce", box2d.b2FrictionJoint.prototype.m_maxForce);
box2d.b2FrictionJoint.prototype.m_maxTorque = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_maxTorque", box2d.b2FrictionJoint.prototype.m_maxTorque);
box2d.b2FrictionJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_indexA", box2d.b2FrictionJoint.prototype.m_indexA);
box2d.b2FrictionJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_indexB", box2d.b2FrictionJoint.prototype.m_indexB);
box2d.b2FrictionJoint.prototype.m_rA = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_rA", box2d.b2FrictionJoint.prototype.m_rA);
box2d.b2FrictionJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_rB", box2d.b2FrictionJoint.prototype.m_rB);
box2d.b2FrictionJoint.prototype.m_localCenterA = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_localCenterA", box2d.b2FrictionJoint.prototype.m_localCenterA);
box2d.b2FrictionJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_localCenterB", box2d.b2FrictionJoint.prototype.m_localCenterB);
box2d.b2FrictionJoint.prototype.m_invMassA = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_invMassA", box2d.b2FrictionJoint.prototype.m_invMassA);
box2d.b2FrictionJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_invMassB", box2d.b2FrictionJoint.prototype.m_invMassB);
box2d.b2FrictionJoint.prototype.m_invIA = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_invIA", box2d.b2FrictionJoint.prototype.m_invIA);
box2d.b2FrictionJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_invIB", box2d.b2FrictionJoint.prototype.m_invIB);
box2d.b2FrictionJoint.prototype.m_linearMass = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_linearMass", box2d.b2FrictionJoint.prototype.m_linearMass);
box2d.b2FrictionJoint.prototype.m_angularMass = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_angularMass", box2d.b2FrictionJoint.prototype.m_angularMass);
box2d.b2FrictionJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_qA", box2d.b2FrictionJoint.prototype.m_qA);
box2d.b2FrictionJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_qB", box2d.b2FrictionJoint.prototype.m_qB);
box2d.b2FrictionJoint.prototype.m_lalcA = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_lalcA", box2d.b2FrictionJoint.prototype.m_lalcA);
box2d.b2FrictionJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_lalcB", box2d.b2FrictionJoint.prototype.m_lalcB);
box2d.b2FrictionJoint.prototype.m_K = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_K", box2d.b2FrictionJoint.prototype.m_K);
box2d.b2FrictionJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassA = this.m_bodyA.m_invMass;
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIA = this.m_bodyA.m_invI;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.positions[this.m_indexB].a,
            d = a.velocities[this.m_indexB].v, f = a.velocities[this.m_indexB].w, g = this.m_qA.SetAngleRadians(a.positions[this.m_indexA].a), e = this.m_qB.SetAngleRadians(e);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    g = box2d.b2MulRV(g, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var h = box2d.b2MulRV(e, this.m_lalcB, this.m_rB), e = this.m_invMassA, l = this.m_invMassB, k = this.m_invIA, m = this.m_invIB, n = this.m_K;
    n.ex.x = e + l + k * g.y * g.y + m * h.y * h.y;
    n.ex.y = -k * g.x * g.y -
            m * h.x * h.y;
    n.ey.x = n.ex.y;
    n.ey.y = e + l + k * g.x * g.x + m * h.x * h.x;
    n.GetInverse(this.m_linearMass);
    this.m_angularMass = k + m;
    0 < this.m_angularMass && (this.m_angularMass = 1 / this.m_angularMass);
    a.step.warmStarting ? (this.m_linearImpulse.SelfMul(a.step.dtRatio), this.m_angularImpulse *= a.step.dtRatio, g = this.m_linearImpulse, b.SelfMulSub(e, g), c -= k * (box2d.b2CrossVV(this.m_rA, g) + this.m_angularImpulse), d.SelfMulAdd(l, g), f += m * (box2d.b2CrossVV(this.m_rB, g) + this.m_angularImpulse)) : (this.m_linearImpulse.SetZero(), this.m_angularImpulse =
            0);
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = f
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "InitVelocityConstraints", box2d.b2FrictionJoint.prototype.InitVelocityConstraints);
box2d.b2FrictionJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.velocities[this.m_indexB].v, d = a.velocities[this.m_indexB].w, f = this.m_invMassA, g = this.m_invMassB, h = this.m_invIA, l = this.m_invIB, k = a.step.dt, m, n = -this.m_angularMass * (d - c), p = this.m_angularImpulse;
    m = k * this.m_maxTorque;
    this.m_angularImpulse = box2d.b2Clamp(this.m_angularImpulse + n, -m, m);
    n = this.m_angularImpulse - p;
    c -= h * n;
    d += l * n;
    m = box2d.b2SubVV(box2d.b2AddVCrossSV(e, d, this.m_rB,
            box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(b, c, this.m_rA, box2d.b2Vec2.s_t1), box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_Cdot);
    n = box2d.b2MulMV(this.m_linearMass, m, box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_impulseV).SelfNeg();
    p = box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_oldImpulseV.Copy(this.m_linearImpulse);
    this.m_linearImpulse.SelfAdd(n);
    m = k * this.m_maxForce;
    this.m_linearImpulse.GetLengthSquared() > m * m && (this.m_linearImpulse.Normalize(), this.m_linearImpulse.SelfMul(m));
    box2d.b2SubVV(this.m_linearImpulse, p, n);
    b.SelfMulSub(f, n);
    c -= h * box2d.b2CrossVV(this.m_rA, n);
    e.SelfMulAdd(g, n);
    d += l * box2d.b2CrossVV(this.m_rB, n);
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = d
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "SolveVelocityConstraints", box2d.b2FrictionJoint.prototype.SolveVelocityConstraints);
box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2;
box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_impulseV = new box2d.b2Vec2;
box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_oldImpulseV = new box2d.b2Vec2;
box2d.b2FrictionJoint.prototype.SolvePositionConstraints = function(a) {
    return!0
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "SolvePositionConstraints", box2d.b2FrictionJoint.prototype.SolvePositionConstraints);
box2d.b2FrictionJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, a)
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "GetAnchorA", box2d.b2FrictionJoint.prototype.GetAnchorA);
box2d.b2FrictionJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "GetAnchorB", box2d.b2FrictionJoint.prototype.GetAnchorB);
box2d.b2FrictionJoint.prototype.GetReactionForce = function(a, b) {
    return b.SetXY(a * this.m_linearImpulse.x, a * this.m_linearImpulse.y)
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "GetReactionForce", box2d.b2FrictionJoint.prototype.GetReactionForce);
box2d.b2FrictionJoint.prototype.GetReactionTorque = function(a) {
    return a * this.m_angularImpulse
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "GetReactionTorque", box2d.b2FrictionJoint.prototype.GetReactionTorque);
box2d.b2FrictionJoint.prototype.GetLocalAnchorA = function(a) {
    return a.Copy(this.m_localAnchorA)
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "GetLocalAnchorA", box2d.b2FrictionJoint.prototype.GetLocalAnchorA);
box2d.b2FrictionJoint.prototype.GetLocalAnchorB = function(a) {
    return a.Copy(this.m_localAnchorB)
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "GetLocalAnchorB", box2d.b2FrictionJoint.prototype.GetLocalAnchorB);
box2d.b2FrictionJoint.prototype.SetMaxForce = function(a) {
    this.m_maxForce = a
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "SetMaxForce", box2d.b2FrictionJoint.prototype.SetMaxForce);
box2d.b2FrictionJoint.prototype.GetMaxForce = function() {
    return this.m_maxForce
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "GetMaxForce", box2d.b2FrictionJoint.prototype.GetMaxForce);
box2d.b2FrictionJoint.prototype.SetMaxTorque = function(a) {
    this.m_maxTorque = a
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "SetMaxTorque", box2d.b2FrictionJoint.prototype.SetMaxTorque);
box2d.b2FrictionJoint.prototype.GetMaxTorque = function() {
    return this.m_maxTorque
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "GetMaxTorque", box2d.b2FrictionJoint.prototype.GetMaxTorque);
box2d.b2FrictionJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2FrictionJointDef*/ var jd = new box2d.b2FrictionJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
        box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n",
                this.m_localAnchorB.x, this.m_localAnchorB.y);
        box2d.b2Log("  jd.maxForce = %.15f;\n", this.m_maxForce);
        box2d.b2Log("  jd.maxTorque = %.15f;\n", this.m_maxTorque);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "Dump", box2d.b2FrictionJoint.prototype.Dump);
box2d.b2MouseJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_mouseJoint);
    this.target = new box2d.b2Vec2
};
goog.inherits(box2d.b2MouseJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2MouseJointDef", box2d.b2MouseJointDef);
box2d.b2MouseJointDef.prototype.target = null;
goog.exportProperty(box2d.b2MouseJointDef.prototype, "target", box2d.b2MouseJointDef.prototype.target);
box2d.b2MouseJointDef.prototype.maxForce = 0;
goog.exportProperty(box2d.b2MouseJointDef.prototype, "maxForce", box2d.b2MouseJointDef.prototype.maxForce);
box2d.b2MouseJointDef.prototype.frequencyHz = 5;
goog.exportProperty(box2d.b2MouseJointDef.prototype, "frequencyHz", box2d.b2MouseJointDef.prototype.frequencyHz);
box2d.b2MouseJointDef.prototype.dampingRatio = 0.7;
goog.exportProperty(box2d.b2MouseJointDef.prototype, "dampingRatio", box2d.b2MouseJointDef.prototype.dampingRatio);
box2d.b2MouseJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_localAnchorB = new box2d.b2Vec2;
    this.m_targetA = new box2d.b2Vec2;
    this.m_impulse = new box2d.b2Vec2;
    this.m_rB = new box2d.b2Vec2;
    this.m_localCenterB = new box2d.b2Vec2;
    this.m_mass = new box2d.b2Mat22;
    this.m_C = new box2d.b2Vec2;
    this.m_qB = new box2d.b2Rot;
    this.m_lalcB = new box2d.b2Vec2;
    this.m_K = new box2d.b2Mat22;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.target.IsValid());
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a.maxForce) && 0 <= a.maxForce);
    box2d.ENABLE_ASSERTS &&
            box2d.b2Assert(box2d.b2IsValid(a.frequencyHz) && 0 <= a.frequencyHz);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a.dampingRatio) && 0 <= a.dampingRatio);
    this.m_targetA.Copy(a.target);
    box2d.b2MulTXV(this.m_bodyB.GetTransform(), this.m_targetA, this.m_localAnchorB);
    this.m_maxForce = a.maxForce;
    this.m_impulse.SetZero();
    this.m_frequencyHz = a.frequencyHz;
    this.m_dampingRatio = a.dampingRatio;
    this.m_gamma = this.m_beta = 0
};
goog.inherits(box2d.b2MouseJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2MouseJoint", box2d.b2MouseJoint);
box2d.b2MouseJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_localAnchorB", box2d.b2MouseJoint.prototype.m_localAnchorB);
box2d.b2MouseJoint.prototype.m_targetA = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_targetA", box2d.b2MouseJoint.prototype.m_targetA);
box2d.b2MouseJoint.prototype.m_frequencyHz = 0;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_frequencyHz", box2d.b2MouseJoint.prototype.m_frequencyHz);
box2d.b2MouseJoint.prototype.m_dampingRatio = 0;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_dampingRatio", box2d.b2MouseJoint.prototype.m_dampingRatio);
box2d.b2MouseJoint.prototype.m_beta = 0;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_beta", box2d.b2MouseJoint.prototype.m_beta);
box2d.b2MouseJoint.prototype.m_impulse = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_impulse", box2d.b2MouseJoint.prototype.m_impulse);
box2d.b2MouseJoint.prototype.m_maxForce = 0;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_maxForce", box2d.b2MouseJoint.prototype.m_maxForce);
box2d.b2MouseJoint.prototype.m_gamma = 0;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_gamma", box2d.b2MouseJoint.prototype.m_gamma);
box2d.b2MouseJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_indexA", box2d.b2MouseJoint.prototype.m_indexA);
box2d.b2MouseJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_indexB", box2d.b2MouseJoint.prototype.m_indexB);
box2d.b2MouseJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_rB", box2d.b2MouseJoint.prototype.m_rB);
box2d.b2MouseJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_localCenterB", box2d.b2MouseJoint.prototype.m_localCenterB);
box2d.b2MouseJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_invMassB", box2d.b2MouseJoint.prototype.m_invMassB);
box2d.b2MouseJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_invIB", box2d.b2MouseJoint.prototype.m_invIB);
box2d.b2MouseJoint.prototype.m_mass = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_mass", box2d.b2MouseJoint.prototype.m_mass);
box2d.b2MouseJoint.prototype.m_C = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_C", box2d.b2MouseJoint.prototype.m_C);
box2d.b2MouseJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_qB", box2d.b2MouseJoint.prototype.m_qB);
box2d.b2MouseJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_lalcB", box2d.b2MouseJoint.prototype.m_lalcB);
box2d.b2MouseJoint.prototype.m_K = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_K", box2d.b2MouseJoint.prototype.m_K);
box2d.b2MouseJoint.prototype.SetTarget = function(a) {
    !1 == this.m_bodyB.IsAwake() && this.m_bodyB.SetAwake(!0);
    this.m_targetA.Copy(a)
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "SetTarget", box2d.b2MouseJoint.prototype.SetTarget);
box2d.b2MouseJoint.prototype.GetTarget = function(a) {
    return a.Copy(this.m_targetA)
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "GetTarget", box2d.b2MouseJoint.prototype.GetTarget);
box2d.b2MouseJoint.prototype.SetMaxForce = function(a) {
    this.m_maxForce = a
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "SetMaxForce", box2d.b2MouseJoint.prototype.SetMaxForce);
box2d.b2MouseJoint.prototype.GetMaxForce = function() {
    return this.m_maxForce
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "GetMaxForce", box2d.b2MouseJoint.prototype.GetMaxForce);
box2d.b2MouseJoint.prototype.SetFrequency = function(a) {
    this.m_frequencyHz = a
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "SetFrequency", box2d.b2MouseJoint.prototype.SetFrequency);
box2d.b2MouseJoint.prototype.GetFrequency = function() {
    return this.m_frequencyHz
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "GetFrequency", box2d.b2MouseJoint.prototype.GetFrequency);
box2d.b2MouseJoint.prototype.SetDampingRatio = function(a) {
    this.m_dampingRatio = a
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "SetDampingRatio", box2d.b2MouseJoint.prototype.SetDampingRatio);
box2d.b2MouseJoint.prototype.GetDampingRatio = function() {
    return this.m_dampingRatio
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "GetDampingRatio", box2d.b2MouseJoint.prototype.GetDampingRatio);
box2d.b2MouseJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = a.positions[this.m_indexB].c, c = a.velocities[this.m_indexB].v, e = a.velocities[this.m_indexB].w, d = this.m_qB.SetAngleRadians(a.positions[this.m_indexB].a), f = this.m_bodyB.GetMass(), g = 2 * box2d.b2_pi * this.m_frequencyHz, h = 2 * f * this.m_dampingRatio * g, f = f * g * g, g = a.step.dt;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(h + g * f > box2d.b2_epsilon);
    this.m_gamma = g * (h + g * f);
    0 != this.m_gamma && (this.m_gamma = 1 / this.m_gamma);
    this.m_beta = g * f * this.m_gamma;
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    box2d.b2MulRV(d, this.m_lalcB, this.m_rB);
    d = this.m_K;
    d.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y + this.m_gamma;
    d.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y;
    d.ey.x = d.ex.y;
    d.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x + this.m_gamma;
    d.GetInverse(this.m_mass);
    this.m_C.x = b.x + this.m_rB.x - this.m_targetA.x;
    this.m_C.y = b.y + this.m_rB.y - this.m_targetA.y;
    this.m_C.SelfMul(this.m_beta);
    e *= 0.98;
    a.step.warmStarting ? (this.m_impulse.SelfMul(a.step.dtRatio), c.x += this.m_invMassB * this.m_impulse.x, c.y += this.m_invMassB * this.m_impulse.y, e += this.m_invIB * box2d.b2CrossVV(this.m_rB, this.m_impulse)) : this.m_impulse.SetZero();
    a.velocities[this.m_indexB].w = e
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "InitVelocityConstraints", box2d.b2MouseJoint.prototype.InitVelocityConstraints);
box2d.b2MouseJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexB].v, c = a.velocities[this.m_indexB].w, e = box2d.b2AddVCrossSV(b, c, this.m_rB, box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_Cdot), e = box2d.b2MulMV(this.m_mass, box2d.b2AddVV(e, box2d.b2AddVV(this.m_C, box2d.b2MulSV(this.m_gamma, this.m_impulse, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0).SelfNeg(), box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_impulse), d = box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_oldImpulse.Copy(this.m_impulse);
    this.m_impulse.SelfAdd(e);
    var f = a.step.dt * this.m_maxForce;
    this.m_impulse.GetLengthSquared() > f * f && this.m_impulse.SelfMul(f / this.m_impulse.GetLength());
    box2d.b2SubVV(this.m_impulse, d, e);
    b.SelfMulAdd(this.m_invMassB, e);
    c += this.m_invIB * box2d.b2CrossVV(this.m_rB, e);
    a.velocities[this.m_indexB].w = c
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "SolveVelocityConstraints", box2d.b2MouseJoint.prototype.SolveVelocityConstraints);
box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2;
box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_impulse = new box2d.b2Vec2;
box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_oldImpulse = new box2d.b2Vec2;
box2d.b2MouseJoint.prototype.SolvePositionConstraints = function(a) {
    return!0
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "SolvePositionConstraints", box2d.b2MouseJoint.prototype.SolvePositionConstraints);
box2d.b2MouseJoint.prototype.GetAnchorA = function(a) {
    return a.Copy(this.m_targetA)
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "GetAnchorA", box2d.b2MouseJoint.prototype.GetAnchorA);
box2d.b2MouseJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "GetAnchorB", box2d.b2MouseJoint.prototype.GetAnchorB);
box2d.b2MouseJoint.prototype.GetReactionForce = function(a, b) {
    return box2d.b2MulSV(a, this.m_impulse, b)
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "GetReactionForce", box2d.b2MouseJoint.prototype.GetReactionForce);
box2d.b2MouseJoint.prototype.GetReactionTorque = function(a) {
    return 0
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "GetReactionTorque", box2d.b2MouseJoint.prototype.GetReactionTorque);
box2d.b2MouseJoint.prototype.Dump = function() {
    box2d.DEBUG && box2d.b2Log("Mouse joint dumping is not supported.\n")
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "Dump", box2d.b2MouseJoint.prototype.Dump);
box2d.b2MouseJoint.prototype.ShiftOrigin = function(a) {
    this.m_targetA.SelfSub(a)
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "ShiftOrigin", box2d.b2MouseJoint.prototype.ShiftOrigin);
box2d.b2ConstantForceController = function() {
    box2d.b2Controller.call(this);
    this.F = new box2d.b2Vec2(0, 0)
};
goog.inherits(box2d.b2ConstantForceController, box2d.b2Controller);
goog.exportSymbol("box2d.b2ConstantForceController", box2d.b2ConstantForceController);
box2d.b2ConstantAccelController.prototype.F = null;
goog.exportProperty(box2d.b2ConstantAccelController.prototype, "F", box2d.b2ConstantAccelController.prototype.F);
box2d.b2ConstantForceController.prototype.Step = function(a) {
    for (a = this.m_bodyList; a; a = a.nextBody) {
        var b = a.body;
        b.IsAwake() && b.ApplyForce(this.F, b.GetWorldCenter())
    }
};
goog.exportProperty(box2d.b2ConstantForceController.prototype, "Step", box2d.b2ConstantForceController.prototype.Step);
box2d.b2_minPulleyLength = 2;
goog.exportSymbol("box2d.b2_minPulleyLength", box2d.b2_minPulleyLength);
box2d.b2PulleyJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_pulleyJoint);
    this.collideConnected = !0;
    this.groundAnchorA = new box2d.b2Vec2(-1, 1);
    this.groundAnchorB = new box2d.b2Vec2(1, 1);
    this.localAnchorA = new box2d.b2Vec2(-1, 0);
    this.localAnchorB = new box2d.b2Vec2(1, 0)
};
goog.inherits(box2d.b2PulleyJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2PulleyJointDef", box2d.b2PulleyJointDef);
box2d.b2PulleyJointDef.prototype.groundAnchorA = null;
goog.exportProperty(box2d.b2PulleyJointDef.prototype, "groundAnchorA", box2d.b2PulleyJointDef.prototype.groundAnchorA);
box2d.b2PulleyJointDef.prototype.groundAnchorB = null;
goog.exportProperty(box2d.b2PulleyJointDef.prototype, "groundAnchorB", box2d.b2PulleyJointDef.prototype.groundAnchorB);
box2d.b2PulleyJointDef.prototype.localAnchorA = null;
goog.exportProperty(box2d.b2PulleyJointDef.prototype, "localAnchorA", box2d.b2PulleyJointDef.prototype.localAnchorA);
box2d.b2PulleyJointDef.prototype.localAnchorB = null;
goog.exportProperty(box2d.b2PulleyJointDef.prototype, "localAnchorB", box2d.b2PulleyJointDef.prototype.localAnchorB);
box2d.b2PulleyJointDef.prototype.lengthA = 0;
goog.exportProperty(box2d.b2PulleyJointDef.prototype, "lengthA", box2d.b2PulleyJointDef.prototype.lengthA);
box2d.b2PulleyJointDef.prototype.lengthB = 0;
goog.exportProperty(box2d.b2PulleyJointDef.prototype, "lengthB", box2d.b2PulleyJointDef.prototype.lengthB);
box2d.b2PulleyJointDef.prototype.ratio = 1;
goog.exportProperty(box2d.b2PulleyJointDef.prototype, "ratio", box2d.b2PulleyJointDef.prototype.ratio);
box2d.b2PulleyJointDef.prototype.Initialize = function(a, b, c, e, d, f, g) {
    this.bodyA = a;
    this.bodyB = b;
    this.groundAnchorA.Copy(c);
    this.groundAnchorB.Copy(e);
    this.bodyA.GetLocalPoint(d, this.localAnchorA);
    this.bodyB.GetLocalPoint(f, this.localAnchorB);
    this.lengthA = box2d.b2DistanceVV(d, c);
    this.lengthB = box2d.b2DistanceVV(f, e);
    this.ratio = g;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.ratio > box2d.b2_epsilon)
};
goog.exportProperty(box2d.b2PulleyJointDef.prototype, "Initialize", box2d.b2PulleyJointDef.prototype.Initialize);
box2d.b2PulleyJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_groundAnchorA = new box2d.b2Vec2;
    this.m_groundAnchorB = new box2d.b2Vec2;
    this.m_localAnchorA = new box2d.b2Vec2;
    this.m_localAnchorB = new box2d.b2Vec2;
    this.m_uA = new box2d.b2Vec2;
    this.m_uB = new box2d.b2Vec2;
    this.m_rA = new box2d.b2Vec2;
    this.m_rB = new box2d.b2Vec2;
    this.m_localCenterA = new box2d.b2Vec2;
    this.m_localCenterB = new box2d.b2Vec2;
    this.m_qA = new box2d.b2Rot;
    this.m_qB = new box2d.b2Rot;
    this.m_lalcA = new box2d.b2Vec2;
    this.m_lalcB = new box2d.b2Vec2;
    this.m_groundAnchorA.Copy(a.groundAnchorA);
    this.m_groundAnchorB.Copy(a.groundAnchorB);
    this.m_localAnchorA.Copy(a.localAnchorA);
    this.m_localAnchorB.Copy(a.localAnchorB);
    this.m_lengthA = a.lengthA;
    this.m_lengthB = a.lengthB;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 != a.ratio);
    this.m_ratio = a.ratio;
    this.m_constant = a.lengthA + this.m_ratio * a.lengthB;
    this.m_impulse = 0
};
goog.inherits(box2d.b2PulleyJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2PulleyJoint", box2d.b2PulleyJoint);
box2d.b2PulleyJoint.prototype.m_groundAnchorA = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_groundAnchorA", box2d.b2PulleyJoint.prototype.m_groundAnchorA);
box2d.b2PulleyJoint.prototype.m_groundAnchorB = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_groundAnchorB", box2d.b2PulleyJoint.prototype.m_groundAnchorB);
box2d.b2PulleyJoint.prototype.m_lengthA = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_lengthA", box2d.b2PulleyJoint.prototype.m_lengthA);
box2d.b2PulleyJoint.prototype.m_lengthB = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_lengthB", box2d.b2PulleyJoint.prototype.m_lengthB);
box2d.b2PulleyJoint.prototype.m_localAnchorA = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_localAnchorA", box2d.b2PulleyJoint.prototype.m_localAnchorA);
box2d.b2PulleyJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_localAnchorB", box2d.b2PulleyJoint.prototype.m_localAnchorB);
box2d.b2PulleyJoint.prototype.m_constant = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_constant", box2d.b2PulleyJoint.prototype.m_constant);
box2d.b2PulleyJoint.prototype.m_ratio = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_ratio", box2d.b2PulleyJoint.prototype.m_ratio);
box2d.b2PulleyJoint.prototype.m_impulse = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_impulse", box2d.b2PulleyJoint.prototype.m_impulse);
box2d.b2PulleyJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_indexA", box2d.b2PulleyJoint.prototype.m_indexA);
box2d.b2PulleyJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_indexB", box2d.b2PulleyJoint.prototype.m_indexB);
box2d.b2PulleyJoint.prototype.m_uA = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_uA", box2d.b2PulleyJoint.prototype.m_uA);
box2d.b2PulleyJoint.prototype.m_uB = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_uB", box2d.b2PulleyJoint.prototype.m_uB);
box2d.b2PulleyJoint.prototype.m_rA = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_rA", box2d.b2PulleyJoint.prototype.m_rA);
box2d.b2PulleyJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_rB", box2d.b2PulleyJoint.prototype.m_rB);
box2d.b2PulleyJoint.prototype.m_localCenterA = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_localCenterA", box2d.b2PulleyJoint.prototype.m_localCenterA);
box2d.b2PulleyJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_localCenterB", box2d.b2PulleyJoint.prototype.m_localCenterB);
box2d.b2PulleyJoint.prototype.m_invMassA = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_invMassA", box2d.b2PulleyJoint.prototype.m_invMassA);
box2d.b2PulleyJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_invMassB", box2d.b2PulleyJoint.prototype.m_invMassB);
box2d.b2PulleyJoint.prototype.m_invIA = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_invIA", box2d.b2PulleyJoint.prototype.m_invIA);
box2d.b2PulleyJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_invIB", box2d.b2PulleyJoint.prototype.m_invIB);
box2d.b2PulleyJoint.prototype.m_mass = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_mass", box2d.b2PulleyJoint.prototype.m_mass);
box2d.b2PulleyJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_qA", box2d.b2PulleyJoint.prototype.m_qA);
box2d.b2PulleyJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_qB", box2d.b2PulleyJoint.prototype.m_qB);
box2d.b2PulleyJoint.prototype.m_lalcA = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_lalcA", box2d.b2PulleyJoint.prototype.m_lalcA);
box2d.b2PulleyJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_lalcB", box2d.b2PulleyJoint.prototype.m_lalcB);
box2d.b2PulleyJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassA = this.m_bodyA.m_invMass;
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIA = this.m_bodyA.m_invI;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = a.positions[this.m_indexA].c, c = a.velocities[this.m_indexA].v, e = a.velocities[this.m_indexA].w,
            d = a.positions[this.m_indexB].c, f = a.positions[this.m_indexB].a, g = a.velocities[this.m_indexB].v, h = a.velocities[this.m_indexB].w, l = this.m_qA.SetAngleRadians(a.positions[this.m_indexA].a), f = this.m_qB.SetAngleRadians(f);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    box2d.b2MulRV(l, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    box2d.b2MulRV(f, this.m_lalcB, this.m_rB);
    this.m_uA.Copy(b).SelfAdd(this.m_rA).SelfSub(this.m_groundAnchorA);
    this.m_uB.Copy(d).SelfAdd(this.m_rB).SelfSub(this.m_groundAnchorB);
    b = this.m_uA.GetLength();
    d = this.m_uB.GetLength();
    b > 10 * box2d.b2_linearSlop ? this.m_uA.SelfMul(1 / b) : this.m_uA.SetZero();
    d > 10 * box2d.b2_linearSlop ? this.m_uB.SelfMul(1 / d) : this.m_uB.SetZero();
    b = box2d.b2CrossVV(this.m_rA, this.m_uA);
    d = box2d.b2CrossVV(this.m_rB, this.m_uB);
    this.m_mass = this.m_invMassA + this.m_invIA * b * b + this.m_ratio * this.m_ratio * (this.m_invMassB + this.m_invIB * d * d);
    0 < this.m_mass && (this.m_mass = 1 / this.m_mass);
    a.step.warmStarting ? (this.m_impulse *= a.step.dtRatio, b = box2d.b2MulSV(-this.m_impulse, this.m_uA,
            box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PA), d = box2d.b2MulSV(-this.m_ratio * this.m_impulse, this.m_uB, box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PB), c.SelfMulAdd(this.m_invMassA, b), e += this.m_invIA * box2d.b2CrossVV(this.m_rA, b), g.SelfMulAdd(this.m_invMassB, d), h += this.m_invIB * box2d.b2CrossVV(this.m_rB, d)) : this.m_impulse = 0;
    a.velocities[this.m_indexA].w = e;
    a.velocities[this.m_indexB].w = h
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "InitVelocityConstraints", box2d.b2PulleyJoint.prototype.InitVelocityConstraints);
box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PA = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PB = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.velocities[this.m_indexB].v, d = a.velocities[this.m_indexB].w, f = box2d.b2AddVCrossSV(b, c, this.m_rA, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpA), g = box2d.b2AddVCrossSV(e, d, this.m_rB, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpB), f = -box2d.b2DotVV(this.m_uA, f) - this.m_ratio * box2d.b2DotVV(this.m_uB, g), g = -this.m_mass * f;
    this.m_impulse += g;
    f =
            box2d.b2MulSV(-g, this.m_uA, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PA);
    g = box2d.b2MulSV(-this.m_ratio * g, this.m_uB, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PB);
    b.SelfMulAdd(this.m_invMassA, f);
    c += this.m_invIA * box2d.b2CrossVV(this.m_rA, f);
    e.SelfMulAdd(this.m_invMassB, g);
    d += this.m_invIB * box2d.b2CrossVV(this.m_rB, g);
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = d
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "SolveVelocityConstraints", box2d.b2PulleyJoint.prototype.SolveVelocityConstraints);
box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpA = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpB = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PA = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PB = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.SolvePositionConstraints = function(a) {
    var b = a.positions[this.m_indexA].c, c = a.positions[this.m_indexA].a, e = a.positions[this.m_indexB].c, d = a.positions[this.m_indexB].a, f = this.m_qA.SetAngleRadians(c), g = this.m_qB.SetAngleRadians(d);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    f = box2d.b2MulRV(f, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var g = box2d.b2MulRV(g, this.m_lalcB, this.m_rB), h = this.m_uA.Copy(b).SelfAdd(f).SelfSub(this.m_groundAnchorA),
            l = this.m_uB.Copy(e).SelfAdd(g).SelfSub(this.m_groundAnchorB), k = h.GetLength(), m = l.GetLength();
    k > 10 * box2d.b2_linearSlop ? h.SelfMul(1 / k) : h.SetZero();
    m > 10 * box2d.b2_linearSlop ? l.SelfMul(1 / m) : l.SetZero();
    var n = box2d.b2CrossVV(f, h), p = box2d.b2CrossVV(g, l), n = this.m_invMassA + this.m_invIA * n * n + this.m_ratio * this.m_ratio * (this.m_invMassB + this.m_invIB * p * p);
    0 < n && (n = 1 / n);
    m = this.m_constant - k - this.m_ratio * m;
    k = box2d.b2Abs(m);
    m *= -n;
    h = box2d.b2MulSV(-m, h, box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PA);
    l = box2d.b2MulSV(-this.m_ratio *
            m, l, box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PB);
    b.SelfMulAdd(this.m_invMassA, h);
    c += this.m_invIA * box2d.b2CrossVV(f, h);
    e.SelfMulAdd(this.m_invMassB, l);
    d += this.m_invIB * box2d.b2CrossVV(g, l);
    a.positions[this.m_indexA].a = c;
    a.positions[this.m_indexB].a = d;
    return k < box2d.b2_linearSlop
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "SolvePositionConstraints", box2d.b2PulleyJoint.prototype.SolvePositionConstraints);
box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PA = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PB = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, a)
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetAnchorA", box2d.b2PulleyJoint.prototype.GetAnchorA);
box2d.b2PulleyJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetAnchorB", box2d.b2PulleyJoint.prototype.GetAnchorB);
box2d.b2PulleyJoint.prototype.GetReactionForce = function(a, b) {
    return b.SetXY(a * this.m_impulse * this.m_uB.x, a * this.m_impulse * this.m_uB.y)
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetReactionForce", box2d.b2PulleyJoint.prototype.GetReactionForce);
box2d.b2PulleyJoint.prototype.GetReactionTorque = function(a) {
    return 0
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetReactionTorque", box2d.b2PulleyJoint.prototype.GetReactionTorque);
box2d.b2PulleyJoint.prototype.GetGroundAnchorA = function(a) {
    return a.Copy(this.m_groundAnchorA)
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetGroundAnchorA", box2d.b2PulleyJoint.prototype.GetGroundAnchorA);
box2d.b2PulleyJoint.prototype.GetGroundAnchorB = function(a) {
    return a.Copy(this.m_groundAnchorB)
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetGroundAnchorB", box2d.b2PulleyJoint.prototype.GetGroundAnchorB);
box2d.b2PulleyJoint.prototype.GetLengthA = function() {
    return this.m_lengthA
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetLengthA", box2d.b2PulleyJoint.prototype.GetLengthA);
box2d.b2PulleyJoint.prototype.GetLengthB = function() {
    return this.m_lengthB
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetLengthB", box2d.b2PulleyJoint.prototype.GetLengthB);
box2d.b2PulleyJoint.prototype.GetRatio = function() {
    return this.m_ratio
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetRatio", box2d.b2PulleyJoint.prototype.GetRatio);
box2d.b2PulleyJoint.prototype.GetCurrentLengthA = function() {
    var a = this.m_bodyA.GetWorldPoint(this.m_localAnchorA, box2d.b2PulleyJoint.prototype.GetCurrentLengthA.s_p);
    return box2d.b2DistanceVV(a, this.m_groundAnchorA)
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetCurrentLengthA", box2d.b2PulleyJoint.prototype.GetCurrentLengthA);
box2d.b2PulleyJoint.prototype.GetCurrentLengthA.s_p = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.GetCurrentLengthB = function() {
    var a = this.m_bodyB.GetWorldPoint(this.m_localAnchorB, box2d.b2PulleyJoint.prototype.GetCurrentLengthB.s_p);
    return box2d.b2DistanceVV(a, this.m_groundAnchorB)
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetCurrentLengthB", box2d.b2PulleyJoint.prototype.GetCurrentLengthB);
box2d.b2PulleyJoint.prototype.GetCurrentLengthB.s_p = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2PulleyJointDef*/ var jd = new box2d.b2PulleyJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.groundAnchorA.SetXY(%.15f, %.15f);\n", this.m_groundAnchorA.x, this.m_groundAnchorA.y);
        box2d.b2Log("  jd.groundAnchorB.SetXY(%.15f, %.15f);\n",
                this.m_groundAnchorB.x, this.m_groundAnchorB.y);
        box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
        box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y);
        box2d.b2Log("  jd.lengthA = %.15f;\n", this.m_lengthA);
        box2d.b2Log("  jd.lengthB = %.15f;\n", this.m_lengthB);
        box2d.b2Log("  jd.ratio = %.15f;\n", this.m_ratio);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "Dump", box2d.b2PulleyJoint.prototype.Dump);
box2d.b2PulleyJoint.prototype.ShiftOrigin = function(a) {
    this.m_groundAnchorA.SelfSub(a);
    this.m_groundAnchorB.SelfSub(a)
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "ShiftOrigin", box2d.b2PulleyJoint.prototype.ShiftOrigin);
box2d.b2CircleShape = function(a) {
    box2d.b2Shape.call(this, box2d.b2ShapeType.e_circleShape, a || 0);
    this.m_p = new box2d.b2Vec2
};
goog.inherits(box2d.b2CircleShape, box2d.b2Shape);
goog.exportSymbol("box2d.b2CircleShape", box2d.b2CircleShape);
box2d.b2CircleShape.prototype.m_p = null;
goog.exportProperty(box2d.b2CircleShape.prototype, "m_p", box2d.b2CircleShape.prototype.m_p);
box2d.b2CircleShape.prototype.Clone = function() {
    return(new box2d.b2CircleShape).Copy(this)
};
goog.exportProperty(box2d.b2CircleShape.prototype, "Clone", box2d.b2CircleShape.prototype.Clone);
box2d.b2CircleShape.prototype.Copy = function(a) {
    box2d.b2CircleShape.superClass_.Copy.call(this, a);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a instanceof box2d.b2CircleShape);
    this.m_p.Copy(a.m_p);
    return this
};
goog.exportProperty(box2d.b2CircleShape.prototype, "Copy", box2d.b2CircleShape.prototype.Copy);
box2d.b2CircleShape.prototype.GetChildCount = function() {
    return 1
};
goog.exportProperty(box2d.b2CircleShape.prototype, "GetChildCount", box2d.b2CircleShape.prototype.GetChildCount);
box2d.b2CircleShape.prototype.TestPoint = function(a, b) {
    var c = box2d.b2MulXV(a, this.m_p, box2d.b2CircleShape.prototype.TestPoint.s_center), c = box2d.b2SubVV(b, c, box2d.b2CircleShape.prototype.TestPoint.s_d);
    return box2d.b2DotVV(c, c) <= box2d.b2Sq(this.m_radius)
};
goog.exportProperty(box2d.b2CircleShape.prototype, "TestPoint", box2d.b2CircleShape.prototype.TestPoint);
box2d.b2CircleShape.prototype.TestPoint.s_center = new box2d.b2Vec2;
box2d.b2CircleShape.prototype.TestPoint.s_d = new box2d.b2Vec2;
box2d.b2CircleShape.prototype.RayCast = function(a, b, c, e) {
    c = box2d.b2MulXV(c, this.m_p, box2d.b2CircleShape.prototype.RayCast.s_position);
    c = box2d.b2SubVV(b.p1, c, box2d.b2CircleShape.prototype.RayCast.s_s);
    var d = box2d.b2DotVV(c, c) - box2d.b2Sq(this.m_radius);
    e = box2d.b2SubVV(b.p2, b.p1, box2d.b2CircleShape.prototype.RayCast.s_r);
    var f = box2d.b2DotVV(c, e), g = box2d.b2DotVV(e, e), d = f * f - g * d;
    if (0 > d || g < box2d.b2_epsilon)
        return!1;
    f = -(f + box2d.b2Sqrt(d));
    return 0 <= f && f <= b.maxFraction * g ? (f /= g, a.fraction = f, box2d.b2AddVMulSV(c,
            f, e, a.normal).SelfNormalize(), !0) : !1
};
goog.exportProperty(box2d.b2CircleShape.prototype, "RayCast", box2d.b2CircleShape.prototype.RayCast);
box2d.b2CircleShape.prototype.RayCast.s_position = new box2d.b2Vec2;
box2d.b2CircleShape.prototype.RayCast.s_s = new box2d.b2Vec2;
box2d.b2CircleShape.prototype.RayCast.s_r = new box2d.b2Vec2;
box2d.b2CircleShape.prototype.ComputeAABB = function(a, b, c) {
    b = box2d.b2MulXV(b, this.m_p, box2d.b2CircleShape.prototype.ComputeAABB.s_p);
    a.lowerBound.SetXY(b.x - this.m_radius, b.y - this.m_radius);
    a.upperBound.SetXY(b.x + this.m_radius, b.y + this.m_radius)
};
goog.exportProperty(box2d.b2CircleShape.prototype, "ComputeAABB", box2d.b2CircleShape.prototype.ComputeAABB);
box2d.b2CircleShape.prototype.ComputeAABB.s_p = new box2d.b2Vec2;
box2d.b2CircleShape.prototype.ComputeMass = function(a, b) {
    var c = box2d.b2Sq(this.m_radius);
    a.mass = b * box2d.b2_pi * c;
    a.center.Copy(this.m_p);
    a.I = a.mass * (0.5 * c + box2d.b2DotVV(this.m_p, this.m_p))
};
goog.exportProperty(box2d.b2CircleShape.prototype, "ComputeMass", box2d.b2CircleShape.prototype.ComputeMass);
box2d.b2CircleShape.prototype.SetupDistanceProxy = function(a, b) {
    a.m_vertices = [1, !0];
    a.m_vertices[0] = this.m_p;
    a.m_count = 1;
    a.m_radius = this.m_radius
};
box2d.b2CircleShape.prototype.ComputeSubmergedArea = function(a, b, c, e) {
    c = box2d.b2MulXV(c, this.m_p, new box2d.b2Vec2);
    var d = -(box2d.b2DotVV(a, c) - b);
    if (d < -this.m_radius + box2d.b2_epsilon)
        return 0;
    if (d > this.m_radius)
        return e.Copy(c), box2d.b2_pi * this.m_radius * this.m_radius;
    b = this.m_radius * this.m_radius;
    var f = d * d, d = b * (box2d.b2Asin(d / this.m_radius) + box2d.b2_pi / 2) + d * box2d.b2Sqrt(b - f);
    b = -2 / 3 * box2d.b2Pow(b - f, 1.5) / d;
    e.x = c.x + a.x * b;
    e.y = c.y + a.y * b;
    return d
};
goog.exportProperty(box2d.b2CircleShape.prototype, "ComputeSubmergedArea", box2d.b2CircleShape.prototype.ComputeSubmergedArea);
box2d.b2CircleShape.prototype.Dump = function() {
    box2d.b2Log("    /*box2d.b2CircleShape*/ var shape = new box2d.b2CircleShape();\n");
    box2d.b2Log("    shape.m_radius = %.15f;\n", this.m_radius);
    box2d.b2Log("    shape.m_p.SetXY(%.15f, %.15f);\n", this.m_p.x, this.m_p.y)
};
goog.exportProperty(box2d.b2CircleShape.prototype, "Dump", box2d.b2CircleShape.prototype.Dump);
box2d.b2RopeDef = function() {
    this.vertices = [];
    this.masses = [];
    this.gravity = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2RopeDef", box2d.b2RopeDef);
box2d.b2RopeDef.prototype.vertices = null;
box2d.b2RopeDef.prototype.count = 0;
box2d.b2RopeDef.prototype.masses = null;
box2d.b2RopeDef.prototype.gravity = null;
box2d.b2RopeDef.prototype.damping = 0.1;
box2d.b2RopeDef.prototype.k2 = 0.9;
box2d.b2RopeDef.prototype.k3 = 0.1;
box2d.b2Rope = function() {
    this.m_gravity = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2Rope", box2d.b2Rope);
box2d.b2Rope.prototype.m_count = 0;
box2d.b2Rope.prototype.m_ps = null;
box2d.b2Rope.prototype.m_p0s = null;
box2d.b2Rope.prototype.m_vs = null;
box2d.b2Rope.prototype.m_ims = null;
box2d.b2Rope.prototype.m_Ls = null;
box2d.b2Rope.prototype.m_as = null;
box2d.b2Rope.prototype.m_gravity = null;
box2d.b2Rope.prototype.m_damping = 0;
box2d.b2Rope.prototype.m_k2 = 1;
box2d.b2Rope.prototype.m_k3 = 0.1;
box2d.b2Rope.prototype.GetVertexCount = function() {
    return this.m_count
};
goog.exportProperty(box2d.b2Rope.prototype, "GetVertexCount", box2d.b2Rope.prototype.GetVertexCount);
box2d.b2Rope.prototype.GetVertices = function() {
    return this.m_ps
};
goog.exportProperty(box2d.b2Rope.prototype, "GetVertices", box2d.b2Rope.prototype.GetVertices);
box2d.b2Rope.prototype.Initialize = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(3 <= a.count);
    this.m_count = a.count;
    this.m_ps = box2d.b2Vec2.MakeArray(this.m_count);
    this.m_p0s = box2d.b2Vec2.MakeArray(this.m_count);
    this.m_vs = box2d.b2Vec2.MakeArray(this.m_count);
    this.m_ims = box2d.b2MakeNumberArray(this.m_count);
    for (var b = 0; b < this.m_count; ++b) {
        this.m_ps[b].Copy(a.vertices[b]);
        this.m_p0s[b].Copy(a.vertices[b]);
        this.m_vs[b].SetZero();
        var c = a.masses[b];
        this.m_ims[b] = 0 < c ? 1 / c : 0
    }
    var e = this.m_count - 1, c = this.m_count -
            2;
    this.m_Ls = box2d.b2MakeNumberArray(e);
    this.m_as = box2d.b2MakeNumberArray(c);
    for (b = 0; b < e; ++b) {
        var d = this.m_ps[b], f = this.m_ps[b + 1];
        this.m_Ls[b] = box2d.b2DistanceVV(d, f)
    }
    for (b = 0; b < c; ++b)
        d = this.m_ps[b], f = this.m_ps[b + 1], e = this.m_ps[b + 2], d = box2d.b2SubVV(f, d, box2d.b2Vec2.s_t0), e = box2d.b2SubVV(e, f, box2d.b2Vec2.s_t1), f = box2d.b2CrossVV(d, e), d = box2d.b2DotVV(d, e), this.m_as[b] = box2d.b2Atan2(f, d);
    this.m_gravity.Copy(a.gravity);
    this.m_damping = a.damping;
    this.m_k2 = a.k2;
    this.m_k3 = a.k3
};
goog.exportProperty(box2d.b2Rope.prototype, "Initialize", box2d.b2Rope.prototype.Initialize);
box2d.b2Rope.prototype.Step = function(a, b) {
    if (0 != a) {
        for (var c = Math.exp(-a * this.m_damping), e = 0; e < this.m_count; ++e)
            this.m_p0s[e].Copy(this.m_ps[e]), 0 < this.m_ims[e] && this.m_vs[e].SelfMulAdd(a, this.m_gravity), this.m_vs[e].SelfMul(c), this.m_ps[e].SelfMulAdd(a, this.m_vs[e]);
        for (e = 0; e < b; ++e)
            this.SolveC2(), this.SolveC3(), this.SolveC2();
        c = 1 / a;
        for (e = 0; e < this.m_count; ++e)
            box2d.b2MulSV(c, box2d.b2SubVV(this.m_ps[e], this.m_p0s[e], box2d.b2Vec2.s_t0), this.m_vs[e])
    }
};
goog.exportProperty(box2d.b2Rope.prototype, "Step", box2d.b2Rope.prototype.Step);
box2d.b2Rope.prototype.SolveC2 = function() {
    for (var a = this.m_count - 1, b = 0; b < a; ++b) {
        var c = this.m_ps[b], e = this.m_ps[b + 1], d = box2d.b2SubVV(e, c, box2d.b2Rope.s_d), f = d.Normalize(), g = this.m_ims[b], h = this.m_ims[b + 1];
        if (0 != g + h) {
            var l = h / (g + h);
            c.SelfMulSub(this.m_k2 * (g / (g + h)) * (this.m_Ls[b] - f), d);
            e.SelfMulAdd(this.m_k2 * l * (this.m_Ls[b] - f), d)
        }
    }
};
goog.exportProperty(box2d.b2Rope.prototype, "SolveC2", box2d.b2Rope.prototype.SolveC2);
box2d.b2Rope.s_d = new box2d.b2Vec2;
box2d.b2Rope.prototype.SetAngleRadians = function(a) {
    for (var b = this.m_count - 2, c = 0; c < b; ++c)
        this.m_as[c] = a
};
goog.exportProperty(box2d.b2Rope.prototype, "SetAngleRadians", box2d.b2Rope.prototype.SetAngleRadians);
box2d.b2Rope.prototype.SolveC3 = function() {
    for (var a = this.m_count - 2, b = 0; b < a; ++b) {
        var c = this.m_ps[b], e = this.m_ps[b + 1], d = this.m_ps[b + 2], f = this.m_ims[b], g = this.m_ims[b + 1], h = this.m_ims[b + 2], l = box2d.b2SubVV(e, c, box2d.b2Rope.s_d1), k = box2d.b2SubVV(d, e, box2d.b2Rope.s_d2), m = l.GetLengthSquared(), n = k.GetLengthSquared();
        if (0 != m * n) {
            var p = box2d.b2CrossVV(l, k), q = box2d.b2DotVV(l, k), p = box2d.b2Atan2(p, q), l = box2d.b2MulSV(-1 / m, l.SelfSkew(), box2d.b2Rope.s_Jd1), m = box2d.b2MulSV(1 / n, k.SelfSkew(), box2d.b2Rope.s_Jd2), k = box2d.b2NegV(l,
                    box2d.b2Rope.s_J1), n = box2d.b2SubVV(l, m, box2d.b2Rope.s_J2), l = m, m = f * box2d.b2DotVV(k, k) + g * box2d.b2DotVV(n, n) + h * box2d.b2DotVV(l, l);
            if (0 != m) {
                m = 1 / m;
                for (q = p - this.m_as[b]; q > box2d.b2_pi; )
                    p -= 2 * box2d.b2_pi, q = p - this.m_as[b];
                for (; q < - box2d.b2_pi; )
                    p += 2 * box2d.b2_pi, q = p - this.m_as[b];
                p = -this.m_k3 * m * q;
                c.SelfMulAdd(f * p, k);
                e.SelfMulAdd(g * p, n);
                d.SelfMulAdd(h * p, l)
            }
        }
    }
};
goog.exportProperty(box2d.b2Rope.prototype, "SolveC3", box2d.b2Rope.prototype.SolveC3);
box2d.b2Rope.s_d1 = new box2d.b2Vec2;
box2d.b2Rope.s_d2 = new box2d.b2Vec2;
box2d.b2Rope.s_Jd1 = new box2d.b2Vec2;
box2d.b2Rope.s_Jd2 = new box2d.b2Vec2;
box2d.b2Rope.s_J1 = new box2d.b2Vec2;
box2d.b2Rope.s_J2 = new box2d.b2Vec2;
box2d.b2Rope.prototype.Draw = function(a) {
    for (var b = new box2d.b2Color(0.4, 0.5, 0.7), c = 0; c < this.m_count - 1; ++c)
        a.DrawSegment(this.m_ps[c], this.m_ps[c + 1], b)
};
goog.exportProperty(box2d.b2Rope.prototype, "Draw", box2d.b2Rope.prototype.Draw);
box2d.b2WheelJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_wheelJoint);
    this.localAnchorA = new box2d.b2Vec2(0, 0);
    this.localAnchorB = new box2d.b2Vec2(0, 0);
    this.localAxisA = new box2d.b2Vec2(1, 0)
};
goog.inherits(box2d.b2WheelJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2WheelJointDef", box2d.b2WheelJointDef);
box2d.b2WheelJointDef.prototype.localAnchorA = null;
goog.exportProperty(box2d.b2WheelJointDef.prototype, "localAnchorA", box2d.b2WheelJointDef.prototype.localAnchorA);
box2d.b2WheelJointDef.prototype.localAnchorB = null;
goog.exportProperty(box2d.b2WheelJointDef.prototype, "localAnchorB", box2d.b2WheelJointDef.prototype.localAnchorB);
box2d.b2WheelJointDef.prototype.localAxisA = null;
goog.exportProperty(box2d.b2WheelJointDef.prototype, "localAxisA", box2d.b2WheelJointDef.prototype.localAxisA);
box2d.b2WheelJointDef.prototype.enableMotor = !1;
goog.exportProperty(box2d.b2WheelJointDef.prototype, "enableMotor", box2d.b2WheelJointDef.prototype.enableMotor);
box2d.b2WheelJointDef.prototype.maxMotorTorque = 0;
goog.exportProperty(box2d.b2WheelJointDef.prototype, "maxMotorTorque", box2d.b2WheelJointDef.prototype.maxMotorTorque);
box2d.b2WheelJointDef.prototype.motorSpeed = 0;
goog.exportProperty(box2d.b2WheelJointDef.prototype, "motorSpeed", box2d.b2WheelJointDef.prototype.motorSpeed);
box2d.b2WheelJointDef.prototype.frequencyHz = 2;
goog.exportProperty(box2d.b2WheelJointDef.prototype, "frequencyHz", box2d.b2WheelJointDef.prototype.frequencyHz);
box2d.b2WheelJointDef.prototype.dampingRatio = 0.7;
goog.exportProperty(box2d.b2WheelJointDef.prototype, "dampingRatio", box2d.b2WheelJointDef.prototype.dampingRatio);
box2d.b2WheelJointDef.prototype.Initialize = function(a, b, c, e) {
    this.bodyA = a;
    this.bodyB = b;
    this.bodyA.GetLocalPoint(c, this.localAnchorA);
    this.bodyB.GetLocalPoint(c, this.localAnchorB);
    this.bodyA.GetLocalVector(e, this.localAxisA)
};
goog.exportProperty(box2d.b2WheelJointDef.prototype, "Initialize", box2d.b2WheelJointDef.prototype.Initialize);
box2d.b2WheelJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_frequencyHz = a.frequencyHz;
    this.m_dampingRatio = a.dampingRatio;
    this.m_localAnchorA = a.localAnchorA.Clone();
    this.m_localAnchorB = a.localAnchorB.Clone();
    this.m_localXAxisA = a.localAxisA.Clone();
    this.m_localYAxisA = box2d.b2CrossOneV(this.m_localXAxisA, new box2d.b2Vec2);
    this.m_maxMotorTorque = a.maxMotorTorque;
    this.m_motorSpeed = a.motorSpeed;
    this.m_enableMotor = a.enableMotor;
    this.m_localCenterA = new box2d.b2Vec2;
    this.m_localCenterB = new box2d.b2Vec2;
    this.m_ax = new box2d.b2Vec2;
    this.m_ay = new box2d.b2Vec2;
    this.m_qA = new box2d.b2Rot;
    this.m_qB = new box2d.b2Rot;
    this.m_lalcA = new box2d.b2Vec2;
    this.m_lalcB = new box2d.b2Vec2;
    this.m_rA = new box2d.b2Vec2;
    this.m_rB = new box2d.b2Vec2;
    this.m_ax.SetZero();
    this.m_ay.SetZero()
};
goog.inherits(box2d.b2WheelJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2WheelJoint", box2d.b2WheelJoint);
box2d.b2WheelJoint.prototype.m_frequencyHz = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_frequencyHz", box2d.b2WheelJoint.prototype.m_frequencyHz);
box2d.b2WheelJoint.prototype.m_dampingRatio = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_dampingRatio", box2d.b2WheelJoint.prototype.m_dampingRatio);
box2d.b2WheelJoint.prototype.m_localAnchorA = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_localAnchorA", box2d.b2WheelJoint.prototype.m_localAnchorA);
box2d.b2WheelJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_localAnchorB", box2d.b2WheelJoint.prototype.m_localAnchorB);
box2d.b2WheelJoint.prototype.m_localXAxisA = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_localXAxisA", box2d.b2WheelJoint.prototype.m_localXAxisA);
box2d.b2WheelJoint.prototype.m_localYAxisA = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_localYAxisA", box2d.b2WheelJoint.prototype.m_localYAxisA);
box2d.b2WheelJoint.prototype.m_impulse = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_impulse", box2d.b2WheelJoint.prototype.m_impulse);
box2d.b2WheelJoint.prototype.m_motorImpulse = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_motorImpulse", box2d.b2WheelJoint.prototype.m_motorImpulse);
box2d.b2WheelJoint.prototype.m_springImpulse = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_springImpulse", box2d.b2WheelJoint.prototype.m_springImpulse);
box2d.b2WheelJoint.prototype.m_maxMotorTorque = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_maxMotorTorque", box2d.b2WheelJoint.prototype.m_maxMotorTorque);
box2d.b2WheelJoint.prototype.m_motorSpeed = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_motorSpeed", box2d.b2WheelJoint.prototype.m_motorSpeed);
box2d.b2WheelJoint.prototype.m_enableMotor = !1;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_enableMotor", box2d.b2WheelJoint.prototype.m_enableMotor);
box2d.b2WheelJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_indexA", box2d.b2WheelJoint.prototype.m_indexA);
box2d.b2WheelJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_indexB", box2d.b2WheelJoint.prototype.m_indexB);
box2d.b2WheelJoint.prototype.m_localCenterA = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_localCenterA", box2d.b2WheelJoint.prototype.m_localCenterA);
box2d.b2WheelJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_localCenterB", box2d.b2WheelJoint.prototype.m_localCenterB);
box2d.b2WheelJoint.prototype.m_invMassA = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_invMassA", box2d.b2WheelJoint.prototype.m_invMassA);
box2d.b2WheelJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_invMassB", box2d.b2WheelJoint.prototype.m_invMassB);
box2d.b2WheelJoint.prototype.m_invIA = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_invIA", box2d.b2WheelJoint.prototype.m_invIA);
box2d.b2WheelJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_invIB", box2d.b2WheelJoint.prototype.m_invIB);
box2d.b2WheelJoint.prototype.m_ax = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_ax", box2d.b2WheelJoint.prototype.m_ax);
box2d.b2WheelJoint.prototype.m_ay = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_ay", box2d.b2WheelJoint.prototype.m_ay);
box2d.b2WheelJoint.prototype.m_sAx = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_sAx", box2d.b2WheelJoint.prototype.m_sAx);
box2d.b2WheelJoint.prototype.m_sBx = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_sBx", box2d.b2WheelJoint.prototype.m_sBx);
box2d.b2WheelJoint.prototype.m_sAy = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_sAy", box2d.b2WheelJoint.prototype.m_sAy);
box2d.b2WheelJoint.prototype.m_sBy = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_sBy", box2d.b2WheelJoint.prototype.m_sBy);
box2d.b2WheelJoint.prototype.m_mass = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_mass", box2d.b2WheelJoint.prototype.m_mass);
box2d.b2WheelJoint.prototype.m_motorMass = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_motorMass", box2d.b2WheelJoint.prototype.m_motorMass);
box2d.b2WheelJoint.prototype.m_springMass = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_springMass", box2d.b2WheelJoint.prototype.m_springMass);
box2d.b2WheelJoint.prototype.m_bias = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_bias", box2d.b2WheelJoint.prototype.m_bias);
box2d.b2WheelJoint.prototype.m_gamma = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_gamma", box2d.b2WheelJoint.prototype.m_gamma);
box2d.b2WheelJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_qA", box2d.b2WheelJoint.prototype.m_qA);
box2d.b2WheelJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_qB", box2d.b2WheelJoint.prototype.m_qB);
box2d.b2WheelJoint.prototype.m_lalcA = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_lalcA", box2d.b2WheelJoint.prototype.m_lalcA);
box2d.b2WheelJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_lalcB", box2d.b2WheelJoint.prototype.m_lalcB);
box2d.b2WheelJoint.prototype.m_rA = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_rA", box2d.b2WheelJoint.prototype.m_rA);
box2d.b2WheelJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_rB", box2d.b2WheelJoint.prototype.m_rB);
box2d.b2WheelJoint.prototype.GetMotorSpeed = function() {
    return this.m_motorSpeed
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetMotorSpeed", box2d.b2WheelJoint.prototype.GetMotorSpeed);
box2d.b2WheelJoint.prototype.GetMaxMotorTorque = function() {
    return this.m_maxMotorTorque
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetMaxMotorTorque", box2d.b2WheelJoint.prototype.GetMaxMotorTorque);
box2d.b2WheelJoint.prototype.SetSpringFrequencyHz = function(a) {
    this.m_frequencyHz = a
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "SetSpringFrequencyHz", box2d.b2WheelJoint.prototype.SetSpringFrequencyHz);
box2d.b2WheelJoint.prototype.GetSpringFrequencyHz = function() {
    return this.m_frequencyHz
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetSpringFrequencyHz", box2d.b2WheelJoint.prototype.GetSpringFrequencyHz);
box2d.b2WheelJoint.prototype.SetSpringDampingRatio = function(a) {
    this.m_dampingRatio = a
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "SetSpringDampingRatio", box2d.b2WheelJoint.prototype.SetSpringDampingRatio);
box2d.b2WheelJoint.prototype.GetSpringDampingRatio = function() {
    return this.m_dampingRatio
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetSpringDampingRatio", box2d.b2WheelJoint.prototype.GetSpringDampingRatio);
box2d.b2WheelJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassA = this.m_bodyA.m_invMass;
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIA = this.m_bodyA.m_invI;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = this.m_invMassA, c = this.m_invMassB, e = this.m_invIA, d = this.m_invIB, f = a.positions[this.m_indexA].c,
            g = a.velocities[this.m_indexA].v, h = a.velocities[this.m_indexA].w, l = a.positions[this.m_indexB].c, k = a.positions[this.m_indexB].a, m = a.velocities[this.m_indexB].v, n = a.velocities[this.m_indexB].w, p = this.m_qA.SetAngleRadians(a.positions[this.m_indexA].a), q = this.m_qB.SetAngleRadians(k);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    k = box2d.b2MulRV(p, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    q = box2d.b2MulRV(q, this.m_lalcB, this.m_rB);
    f =
            box2d.b2SubVV(box2d.b2AddVV(l, q, box2d.b2Vec2.s_t0), box2d.b2AddVV(f, k, box2d.b2Vec2.s_t1), box2d.b2WheelJoint.prototype.InitVelocityConstraints.s_d);
    box2d.b2MulRV(p, this.m_localYAxisA, this.m_ay);
    this.m_sAy = box2d.b2CrossVV(box2d.b2AddVV(f, k, box2d.b2Vec2.s_t0), this.m_ay);
    this.m_sBy = box2d.b2CrossVV(q, this.m_ay);
    this.m_mass = b + c + e * this.m_sAy * this.m_sAy + d * this.m_sBy * this.m_sBy;
    0 < this.m_mass && (this.m_mass = 1 / this.m_mass);
    this.m_gamma = this.m_bias = this.m_springMass = 0;
    0 < this.m_frequencyHz ? (box2d.b2MulRV(p, this.m_localXAxisA,
            this.m_ax), this.m_sAx = box2d.b2CrossVV(box2d.b2AddVV(f, k, box2d.b2Vec2.s_t0), this.m_ax), this.m_sBx = box2d.b2CrossVV(q, this.m_ax), b = b + c + e * this.m_sAx * this.m_sAx + d * this.m_sBx * this.m_sBx, 0 < b && (this.m_springMass = 1 / b, c = box2d.b2DotVV(f, this.m_ax), p = 2 * box2d.b2_pi * this.m_frequencyHz, f = this.m_springMass * p * p, l = a.step.dt, this.m_gamma = l * (2 * this.m_springMass * this.m_dampingRatio * p + l * f), 0 < this.m_gamma && (this.m_gamma = 1 / this.m_gamma), this.m_bias = c * l * f * this.m_gamma, this.m_springMass = b + this.m_gamma, 0 < this.m_springMass &&
            (this.m_springMass = 1 / this.m_springMass))) : this.m_springImpulse = 0;
    this.m_enableMotor ? (this.m_motorMass = e + d, 0 < this.m_motorMass && (this.m_motorMass = 1 / this.m_motorMass)) : this.m_motorImpulse = this.m_motorMass = 0;
    a.step.warmStarting ? (this.m_impulse *= a.step.dtRatio, this.m_springImpulse *= a.step.dtRatio, this.m_motorImpulse *= a.step.dtRatio, e = box2d.b2AddVV(box2d.b2MulSV(this.m_impulse, this.m_ay, box2d.b2Vec2.s_t0), box2d.b2MulSV(this.m_springImpulse, this.m_ax, box2d.b2Vec2.s_t1), box2d.b2WheelJoint.prototype.InitVelocityConstraints.s_P),
            d = this.m_impulse * this.m_sAy + this.m_springImpulse * this.m_sAx + this.m_motorImpulse, b = this.m_impulse * this.m_sBy + this.m_springImpulse * this.m_sBx + this.m_motorImpulse, g.SelfMulSub(this.m_invMassA, e), h -= this.m_invIA * d, m.SelfMulAdd(this.m_invMassB, e), n += this.m_invIB * b) : this.m_motorImpulse = this.m_springImpulse = this.m_impulse = 0;
    a.velocities[this.m_indexA].w = h;
    a.velocities[this.m_indexB].w = n
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "InitVelocityConstraints", box2d.b2WheelJoint.prototype.InitVelocityConstraints);
box2d.b2WheelJoint.prototype.InitVelocityConstraints.s_d = new box2d.b2Vec2;
box2d.b2WheelJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2WheelJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = this.m_invMassA, c = this.m_invMassB, e = this.m_invIA, d = this.m_invIB, f = a.velocities[this.m_indexA].v, g = a.velocities[this.m_indexA].w, h = a.velocities[this.m_indexB].v, l = a.velocities[this.m_indexB].w, k = box2d.b2DotVV(this.m_ax, box2d.b2SubVV(h, f, box2d.b2Vec2.s_t0)) + this.m_sBx * l - this.m_sAx * g, k = -this.m_springMass * (k + this.m_bias + this.m_gamma * this.m_springImpulse);
    this.m_springImpulse += k;
    var m = box2d.b2MulSV(k, this.m_ax, box2d.b2WheelJoint.prototype.SolveVelocityConstraints.s_P),
            n = k * this.m_sAx, k = k * this.m_sBx;
    f.SelfMulSub(b, m);
    g -= e * n;
    h.SelfMulAdd(c, m);
    l += d * k;
    k = l - g - this.m_motorSpeed;
    k *= -this.m_motorMass;
    m = this.m_motorImpulse;
    n = a.step.dt * this.m_maxMotorTorque;
    this.m_motorImpulse = box2d.b2Clamp(this.m_motorImpulse + k, -n, n);
    k = this.m_motorImpulse - m;
    g -= e * k;
    l += d * k;
    k = box2d.b2DotVV(this.m_ay, box2d.b2SubVV(h, f, box2d.b2Vec2.s_t0)) + this.m_sBy * l - this.m_sAy * g;
    k *= -this.m_mass;
    this.m_impulse += k;
    m = box2d.b2MulSV(k, this.m_ay, box2d.b2WheelJoint.prototype.SolveVelocityConstraints.s_P);
    n = k * this.m_sAy;
    k *= this.m_sBy;
    f.SelfMulSub(b, m);
    g -= e * n;
    h.SelfMulAdd(c, m);
    a.velocities[this.m_indexA].w = g;
    a.velocities[this.m_indexB].w = l + d * k
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "SolveVelocityConstraints", box2d.b2WheelJoint.prototype.SolveVelocityConstraints);
box2d.b2WheelJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2WheelJoint.prototype.SolvePositionConstraints = function(a) {
    var b = a.positions[this.m_indexA].c, c = a.positions[this.m_indexA].a, e = a.positions[this.m_indexB].c, d = a.positions[this.m_indexB].a, f = this.m_qA.SetAngleRadians(c), g = this.m_qB.SetAngleRadians(d);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    var h = box2d.b2MulRV(f, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var g = box2d.b2MulRV(g, this.m_lalcB, this.m_rB), l = box2d.b2AddVV(box2d.b2SubVV(e,
            b, box2d.b2Vec2.s_t0), box2d.b2SubVV(g, h, box2d.b2Vec2.s_t1), box2d.b2WheelJoint.prototype.SolvePositionConstraints.s_d), f = box2d.b2MulRV(f, this.m_localYAxisA, this.m_ay), h = box2d.b2CrossVV(box2d.b2AddVV(l, h, box2d.b2Vec2.s_t0), f), g = box2d.b2CrossVV(g, f), l = box2d.b2DotVV(l, this.m_ay), k = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy, k = 0 != k ? -l / k : 0, f = box2d.b2MulSV(k, f, box2d.b2WheelJoint.prototype.SolvePositionConstraints.s_P), h = k * h, g = k * g;
    b.SelfMulSub(this.m_invMassA,
            f);
    c -= this.m_invIA * h;
    e.SelfMulAdd(this.m_invMassB, f);
    d += this.m_invIB * g;
    a.positions[this.m_indexA].a = c;
    a.positions[this.m_indexB].a = d;
    return box2d.b2Abs(l) <= box2d.b2_linearSlop
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "SolvePositionConstraints", box2d.b2WheelJoint.prototype.SolvePositionConstraints);
box2d.b2WheelJoint.prototype.SolvePositionConstraints.s_d = new box2d.b2Vec2;
box2d.b2WheelJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2;
box2d.b2WheelJoint.prototype.GetDefinition = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1);
    return a
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetDefinition", box2d.b2WheelJoint.prototype.GetDefinition);
box2d.b2WheelJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, a)
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetAnchorA", box2d.b2WheelJoint.prototype.GetAnchorA);
box2d.b2WheelJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetAnchorB", box2d.b2WheelJoint.prototype.GetAnchorB);
box2d.b2WheelJoint.prototype.GetReactionForce = function(a, b) {
    b.x = a * (this.m_impulse * this.m_ay.x + this.m_springImpulse * this.m_ax.x);
    b.y = a * (this.m_impulse * this.m_ay.y + this.m_springImpulse * this.m_ax.y);
    return b
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetReactionForce", box2d.b2WheelJoint.prototype.GetReactionForce);
box2d.b2WheelJoint.prototype.GetReactionTorque = function(a) {
    return a * this.m_motorImpulse
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetReactionTorque", box2d.b2WheelJoint.prototype.GetReactionTorque);
box2d.b2WheelJoint.prototype.GetLocalAnchorA = function(a) {
    return a.Copy(this.m_localAnchorA)
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetLocalAnchorA", box2d.b2WheelJoint.prototype.GetLocalAnchorA);
box2d.b2WheelJoint.prototype.GetLocalAnchorB = function(a) {
    return a.Copy(this.m_localAnchorB)
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetLocalAnchorB", box2d.b2WheelJoint.prototype.GetLocalAnchorB);
box2d.b2WheelJoint.prototype.GetLocalAxisA = function(a) {
    return a.Copy(this.m_localXAxisA)
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetLocalAxisA", box2d.b2WheelJoint.prototype.GetLocalAxisA);
box2d.b2WheelJoint.prototype.GetJointTranslation = function() {
    var a = this.m_bodyA, b = this.m_bodyB, c = a.GetWorldPoint(this.m_localAnchorA, new box2d.b2Vec2), b = b.GetWorldPoint(this.m_localAnchorB, new box2d.b2Vec2), c = box2d.b2SubVV(b, c, new box2d.b2Vec2), a = a.GetWorldVector(this.m_localXAxisA, new box2d.b2Vec2);
    return box2d.b2DotVV(c, a)
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetJointTranslation", box2d.b2WheelJoint.prototype.GetJointTranslation);
box2d.b2WheelJoint.prototype.GetJointSpeed = function() {
    return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetJointSpeed", box2d.b2WheelJoint.prototype.GetJointSpeed);
box2d.b2WheelJoint.prototype.IsMotorEnabled = function() {
    return this.m_enableMotor
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "IsMotorEnabled", box2d.b2WheelJoint.prototype.IsMotorEnabled);
box2d.b2WheelJoint.prototype.EnableMotor = function(a) {
    this.m_bodyA.SetAwake(!0);
    this.m_bodyB.SetAwake(!0);
    this.m_enableMotor = a
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "EnableMotor", box2d.b2WheelJoint.prototype.EnableMotor);
box2d.b2WheelJoint.prototype.SetMotorSpeed = function(a) {
    this.m_bodyA.SetAwake(!0);
    this.m_bodyB.SetAwake(!0);
    this.m_motorSpeed = a
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "SetMotorSpeed", box2d.b2WheelJoint.prototype.SetMotorSpeed);
box2d.b2WheelJoint.prototype.SetMaxMotorTorque = function(a) {
    this.m_bodyA.SetAwake(!0);
    this.m_bodyB.SetAwake(!0);
    this.m_maxMotorTorque = a
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "SetMaxMotorTorque", box2d.b2WheelJoint.prototype.SetMaxMotorTorque);
box2d.b2WheelJoint.prototype.GetMotorTorque = function(a) {
    return a * this.m_motorImpulse
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetMotorTorque", box2d.b2WheelJoint.prototype.GetMotorTorque);
box2d.b2WheelJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2WheelJointDef*/ var jd = new box2d.b2WheelJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
        box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n",
                this.m_localAnchorB.x, this.m_localAnchorB.y);
        box2d.b2Log("  jd.localAxisA.Set(%.15f, %.15f);\n", this.m_localXAxisA.x, this.m_localXAxisA.y);
        box2d.b2Log("  jd.enableMotor = %s;\n", this.m_enableMotor ? "true" : "false");
        box2d.b2Log("  jd.motorSpeed = %.15f;\n", this.m_motorSpeed);
        box2d.b2Log("  jd.maxMotorTorque = %.15f;\n", this.m_maxMotorTorque);
        box2d.b2Log("  jd.frequencyHz = %.15f;\n", this.m_frequencyHz);
        box2d.b2Log("  jd.dampingRatio = %.15f;\n", this.m_dampingRatio);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n",
                this.m_index)
    }
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "Dump", box2d.b2WheelJoint.prototype.Dump);
box2d.b2MotorJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_motorJoint);
    this.linearOffset = new box2d.b2Vec2(0, 0)
};
goog.inherits(box2d.b2MotorJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2MotorJointDef", box2d.b2MotorJointDef);
box2d.b2MotorJointDef.prototype.linearOffset = null;
goog.exportProperty(box2d.b2MotorJointDef.prototype, "linearOffset", box2d.b2MotorJointDef.prototype.linearOffset);
box2d.b2MotorJointDef.prototype.angularOffset = 0;
goog.exportProperty(box2d.b2MotorJointDef.prototype, "angularOffset", box2d.b2MotorJointDef.prototype.angularOffset);
box2d.b2MotorJointDef.prototype.maxForce = 1;
goog.exportProperty(box2d.b2MotorJointDef.prototype, "maxForce", box2d.b2MotorJointDef.prototype.maxForce);
box2d.b2MotorJointDef.prototype.maxTorque = 1;
goog.exportProperty(box2d.b2MotorJointDef.prototype, "maxTorque", box2d.b2MotorJointDef.prototype.maxTorque);
box2d.b2MotorJointDef.prototype.correctionFactor = 0.3;
goog.exportProperty(box2d.b2MotorJointDef.prototype, "correctionFactor", box2d.b2MotorJointDef.prototype.correctionFactor);
box2d.b2MotorJointDef.prototype.Initialize = function(a, b) {
    this.bodyA = a;
    this.bodyB = b;
    this.bodyA.GetLocalPoint(this.bodyB.GetPosition(), this.linearOffset);
    var c = this.bodyA.GetAngleRadians();
    this.angularOffset = this.bodyB.GetAngleRadians() - c
};
goog.exportProperty(box2d.b2MotorJointDef.prototype, "Initialize", box2d.b2MotorJointDef.prototype.Initialize);
box2d.b2MotorJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_linearOffset = a.linearOffset.Clone();
    this.m_linearImpulse = new box2d.b2Vec2(0, 0);
    this.m_maxForce = a.maxForce;
    this.m_maxTorque = a.maxTorque;
    this.m_correctionFactor = a.correctionFactor;
    this.m_rA = new box2d.b2Vec2(0, 0);
    this.m_rB = new box2d.b2Vec2(0, 0);
    this.m_localCenterA = new box2d.b2Vec2(0, 0);
    this.m_localCenterB = new box2d.b2Vec2(0, 0);
    this.m_linearError = new box2d.b2Vec2(0, 0);
    this.m_linearMass = new box2d.b2Mat22;
    this.m_qA = new box2d.b2Rot;
    this.m_qB =
            new box2d.b2Rot;
    this.m_K = new box2d.b2Mat22
};
goog.inherits(box2d.b2MotorJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2MotorJoint", box2d.b2MotorJoint);
box2d.b2MotorJoint.prototype.m_linearOffset = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_linearOffset", box2d.b2MotorJoint.prototype.m_linearOffset);
box2d.b2MotorJoint.prototype.m_angularOffset = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_angularOffset", box2d.b2MotorJoint.prototype.m_angularOffset);
box2d.b2MotorJoint.prototype.m_linearImpulse = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_linearImpulse", box2d.b2MotorJoint.prototype.m_linearImpulse);
box2d.b2MotorJoint.prototype.m_angularImpulse = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_angularImpulse", box2d.b2MotorJoint.prototype.m_angularImpulse);
box2d.b2MotorJoint.prototype.m_maxForce = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_maxForce", box2d.b2MotorJoint.prototype.m_maxForce);
box2d.b2MotorJoint.prototype.m_maxTorque = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_maxTorque", box2d.b2MotorJoint.prototype.m_maxTorque);
box2d.b2MotorJoint.prototype.m_correctionFactor = 0.3;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_correctionFactor", box2d.b2MotorJoint.prototype.m_correctionFactor);
box2d.b2MotorJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_indexA", box2d.b2MotorJoint.prototype.m_indexA);
box2d.b2MotorJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_indexB", box2d.b2MotorJoint.prototype.m_indexB);
box2d.b2MotorJoint.prototype.m_rA = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_rA", box2d.b2MotorJoint.prototype.m_rA);
box2d.b2MotorJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_rB", box2d.b2MotorJoint.prototype.m_rB);
box2d.b2MotorJoint.prototype.m_localCenterA = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_localCenterA", box2d.b2MotorJoint.prototype.m_localCenterA);
box2d.b2MotorJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_localCenterB", box2d.b2MotorJoint.prototype.m_localCenterB);
box2d.b2MotorJoint.prototype.m_linearError = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_linearError", box2d.b2MotorJoint.prototype.m_linearError);
box2d.b2MotorJoint.prototype.m_angularError = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_angularError", box2d.b2MotorJoint.prototype.m_angularError);
box2d.b2MotorJoint.prototype.m_invMassA = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_invMassA", box2d.b2MotorJoint.prototype.m_invMassA);
box2d.b2MotorJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_invMassB", box2d.b2MotorJoint.prototype.m_invMassB);
box2d.b2MotorJoint.prototype.m_invIA = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_invIA", box2d.b2MotorJoint.prototype.m_invIA);
box2d.b2MotorJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_invIB", box2d.b2MotorJoint.prototype.m_invIB);
box2d.b2MotorJoint.prototype.m_linearMass = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_linearMass", box2d.b2MotorJoint.prototype.m_linearMass);
box2d.b2MotorJoint.prototype.m_angularMass = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_angularMass", box2d.b2MotorJoint.prototype.m_angularMass);
box2d.b2MotorJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_qA", box2d.b2MotorJoint.prototype.m_qA);
box2d.b2MotorJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_qB", box2d.b2MotorJoint.prototype.m_qB);
box2d.b2MotorJoint.prototype.m_K = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_K", box2d.b2MotorJoint.prototype.m_K);
box2d.b2MotorJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetPosition(a)
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "GetAnchorA", box2d.b2MotorJoint.prototype.GetAnchorA);
box2d.b2MotorJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetPosition(a)
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "GetAnchorB", box2d.b2MotorJoint.prototype.GetAnchorB);
box2d.b2MotorJoint.prototype.GetReactionForce = function(a, b) {
    return box2d.b2MulSV(a, this.m_linearImpulse, b)
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "GetReactionForce", box2d.b2MotorJoint.prototype.GetReactionForce);
box2d.b2MotorJoint.prototype.GetReactionTorque = function(a) {
    return a * this.m_angularImpulse
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "GetReactionTorque", box2d.b2MotorJoint.prototype.GetReactionTorque);
box2d.b2MotorJoint.prototype.SetLinearOffset = function(a) {
    box2d.b2IsEqualToV(a, this.m_linearOffset) || (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_linearOffset.Copy(a))
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "SetLinearOffset", box2d.b2MotorJoint.prototype.SetLinearOffset);
box2d.b2MotorJoint.prototype.GetLinearOffset = function(a) {
    return a.Copy(this.m_linearOffset)
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "GetLinearOffset", box2d.b2MotorJoint.prototype.GetLinearOffset);
box2d.b2MotorJoint.prototype.SetAngularOffset = function(a) {
    a != this.m_angularOffset && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_angularOffset = a)
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "SetAngularOffset", box2d.b2MotorJoint.prototype.SetAngularOffset);
box2d.b2MotorJoint.prototype.GetAngularOffset = function() {
    return this.m_angularOffset
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "GetAngularOffset", box2d.b2MotorJoint.prototype.GetAngularOffset);
box2d.b2MotorJoint.prototype.SetMaxForce = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a) && 0 <= a);
    this.m_maxForce = a
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "SetMaxForce", box2d.b2MotorJoint.prototype.SetMaxForce);
box2d.b2MotorJoint.prototype.GetMaxForce = function() {
    return this.m_maxForce
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "GetMaxForce", box2d.b2MotorJoint.prototype.GetMaxForce);
box2d.b2MotorJoint.prototype.SetMaxTorque = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a) && 0 <= a);
    this.m_maxTorque = a
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "SetMaxTorque", box2d.b2MotorJoint.prototype.SetMaxTorque);
box2d.b2MotorJoint.prototype.GetMaxTorque = function() {
    return this.m_maxTorque
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "GetMaxTorque", box2d.b2MotorJoint.prototype.GetMaxTorque);
box2d.b2MotorJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassA = this.m_bodyA.m_invMass;
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIA = this.m_bodyA.m_invI;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = a.positions[this.m_indexA].c, c = a.positions[this.m_indexA].a, e = a.velocities[this.m_indexA].v,
            d = a.velocities[this.m_indexA].w, f = a.positions[this.m_indexB].c, g = a.positions[this.m_indexB].a, h = a.velocities[this.m_indexB].v, l = a.velocities[this.m_indexB].w, k = this.m_qA.SetAngleRadians(c), m = this.m_qB.SetAngleRadians(g), n = box2d.b2MulRV(k, box2d.b2NegV(this.m_localCenterA, box2d.b2Vec2.s_t0), this.m_rA), m = box2d.b2MulRV(m, box2d.b2NegV(this.m_localCenterB, box2d.b2Vec2.s_t0), this.m_rB), p = this.m_invMassA, q = this.m_invMassB, r = this.m_invIA, t = this.m_invIB, s = this.m_K;
    s.ex.x = p + q + r * n.y * n.y + t * m.y * m.y;
    s.ex.y = -r * n.x *
            n.y - t * m.x * m.y;
    s.ey.x = s.ex.y;
    s.ey.y = p + q + r * n.x * n.x + t * m.x * m.x;
    s.GetInverse(this.m_linearMass);
    this.m_angularMass = r + t;
    0 < this.m_angularMass && (this.m_angularMass = 1 / this.m_angularMass);
    box2d.b2SubVV(box2d.b2SubVV(box2d.b2AddVV(f, m, box2d.b2Vec2.s_t0), box2d.b2AddVV(b, n, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t2), box2d.b2MulRV(k, this.m_linearOffset, box2d.b2Vec2.s_t3), this.m_linearError);
    this.m_angularError = g - c - this.m_angularOffset;
    a.step.warmStarting ? (this.m_linearImpulse.SelfMul(a.step.dtRatio), this.m_angularImpulse *=
            a.step.dtRatio, b = this.m_linearImpulse, e.SelfMulSub(p, b), d -= r * (box2d.b2CrossVV(n, b) + this.m_angularImpulse), h.SelfMulAdd(q, b), l += t * (box2d.b2CrossVV(m, b) + this.m_angularImpulse)) : (this.m_linearImpulse.SetZero(), this.m_angularImpulse = 0);
    a.velocities[this.m_indexA].w = d;
    a.velocities[this.m_indexB].w = l
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "InitVelocityConstraints", box2d.b2MotorJoint.prototype.InitVelocityConstraints);
box2d.b2MotorJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.velocities[this.m_indexB].v, d = a.velocities[this.m_indexB].w, f = this.m_invMassA, g = this.m_invMassB, h = this.m_invIA, l = this.m_invIB, k = a.step.dt, m = a.step.inv_dt, n = d - c + m * this.m_correctionFactor * this.m_angularError, n = -this.m_angularMass * n, p = this.m_angularImpulse, q = k * this.m_maxTorque;
    this.m_angularImpulse = box2d.b2Clamp(this.m_angularImpulse + n, -q, q);
    var n = this.m_angularImpulse -
            p, c = c - h * n, d = d + l * n, r = this.m_rA, t = this.m_rB, n = box2d.b2AddVV(box2d.b2SubVV(box2d.b2AddVV(e, box2d.b2CrossSV(d, t, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), box2d.b2AddVV(b, box2d.b2CrossSV(c, r, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t2), box2d.b2MulSV(m * this.m_correctionFactor, this.m_linearError, box2d.b2Vec2.s_t3), box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_Cdot), n = box2d.b2MulMV(this.m_linearMass, n, box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_impulse).SelfNeg(), p = box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_oldImpulse.Copy(this.m_linearImpulse);
    this.m_linearImpulse.SelfAdd(n);
    q = k * this.m_maxForce;
    this.m_linearImpulse.GetLengthSquared() > q * q && (this.m_linearImpulse.Normalize(), this.m_linearImpulse.SelfMul(q));
    box2d.b2SubVV(this.m_linearImpulse, p, n);
    b.SelfMulSub(f, n);
    c -= h * box2d.b2CrossVV(r, n);
    e.SelfMulAdd(g, n);
    d += l * box2d.b2CrossVV(t, n);
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = d
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "SolveVelocityConstraints", box2d.b2MotorJoint.prototype.SolveVelocityConstraints);
box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2;
box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_impulse = new box2d.b2Vec2;
box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_oldImpulse = new box2d.b2Vec2;
box2d.b2MotorJoint.prototype.SolvePositionConstraints = function(a) {
    return!0
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "SolvePositionConstraints", box2d.b2MotorJoint.prototype.SolvePositionConstraints);
box2d.b2MotorJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2MotorJointDef*/ var jd = new box2d.b2MotorJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.linearOffset.SetXY(%.15f, %.15f);\n", this.m_linearOffset.x, this.m_linearOffset.y);
        box2d.b2Log("  jd.angularOffset = %.15f;\n",
                this.m_angularOffset);
        box2d.b2Log("  jd.maxForce = %.15f;\n", this.m_maxForce);
        box2d.b2Log("  jd.maxTorque = %.15f;\n", this.m_maxTorque);
        box2d.b2Log("  jd.correctionFactor = %.15f;\n", this.m_correctionFactor);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "Dump", box2d.b2MotorJoint.prototype.Dump);
/*
* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.Render');

//goog.require('box2d');

//goog.require('goog.string.format');

/**
 * This class implements debug drawing callbacks that are
 * invoked inside b2World::Step.
 * @export
 * @constructor
 * @extends {box2d.b2Draw}
 * @param {object} opts
 */
box2d.b2DebugDraw = function (opts)
{
	goog.base(this);

    this.scale = opts.scale
	this.m_canvas = opts.canvas || false
	this.m_ctx = opts.ctx || false
    this.m_settings = opts.flags || (box2d.b2DrawFlags.e_shapeBit | box2d.b2DrawFlags.e_centerOfMassBit)
    this.alpha = opts.alpha || 0.5
}

goog.inherits(box2d.b2DebugDraw, box2d.b2Draw);

/**
 * @export
 * @type {HTMLCanvasElement}
 */
box2d.b2DebugDraw.prototype.m_canvas = null;
/**
 * @export
 * @type {CanvasRenderingContext2D}
 */
box2d.b2DebugDraw.prototype.m_ctx = null;
/**
 * @export
 * @type {box2d.Settings}
 */
box2d.b2DebugDraw.prototype.m_settings = null;

box2d.b2DebugDraw.prototype.scale = 40;
box2d.b2DebugDraw.prototype.alpha = 0.5;


/**
 * @export
 * @return {void}
 * @param {box2d.b2Transform} xf
 */
box2d.b2DebugDraw.prototype.PushTransform = function (xf)
{
	var ctx = this.m_ctx;
	ctx.save();
    ctx.globalAlpha = this.alpha
	ctx.translate(xf.p.x * this.scale, xf.p.y * this.scale);
	ctx.rotate(xf.q.GetAngleRadians());
}

/**
 * @export
 * @return {void}
 * @param {box2d.b2Transform} xf
 */
box2d.b2DebugDraw.prototype.PopTransform = function (xf)
{
	var ctx = this.m_ctx;
	ctx.restore();
}

/**
 * @export
 * @return {void}
 * @param {Array.<box2d.b2Vec2>} vertices
 * @param {number} vertexCount
 * @param {box2d.b2Color} color
 */
box2d.b2DebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color)
{
	if (!vertexCount) return;

	var ctx = this.m_ctx;

    ctx.globalAlpha = 1
	ctx.beginPath();
	ctx.moveTo(vertices[0].x * this.scale, vertices[0].y * this.scale);
	for (var i = 1; i < vertexCount; i++)
	{
		ctx.lineTo(vertices[i].x * this.scale, vertices[i].y * this.scale);
	}
	ctx.closePath();
	ctx.strokeStyle = color.MakeStyleString(1);
	ctx.stroke();
};

/**
 * @export
 * @return {void}
 * @param {Array.<box2d.b2Vec2>} vertices
 * @param {number} vertexCount
 * @param {box2d.b2Color} color
 */
box2d.b2DebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color)
{
    if (!vertexCount) return;

	var ctx = this.m_ctx;

	ctx.beginPath();
	ctx.moveTo(vertices[0].x * this.scale, vertices[0].y * this.scale);
	for (var i = 1; i < vertexCount; i++)
	{
		ctx.lineTo(vertices[i].x * this.scale, vertices[i].y * this.scale);
	}
	ctx.closePath();
	ctx.fillStyle = color.MakeStyleString(0.5);
	ctx.fill();
	ctx.strokeStyle = color.MakeStyleString(1);
	ctx.stroke();
};

/**
 * @export
 * @return {void}
 * @param {box2d.b2Vec2} center
 * @param {number} radius
 * @param {box2d.b2Color} color
 */
box2d.b2DebugDraw.prototype.DrawCircle = function (center, radius, color)
{
    if (!radius) return;

	var ctx = this.m_ctx;

	ctx.beginPath();
	ctx.arc(center.x * this.scale, center.y * this.scale, radius * this.scale, 0, box2d.b2_pi * 2, true);
	ctx.strokeStyle = color.MakeStyleString(1);
	ctx.stroke();
};

/**
 * @export
 * @return {void}
 * @param {box2d.b2Vec2} center
 * @param {number} radius
 * @param {box2d.b2Vec2} axis
 * @param {box2d.b2Color} color
 */
box2d.b2DebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color)
{
	if (!radius) return;

	var ctx = this.m_ctx;

	var cx = center.x * this.scale;
	var cy = center.y * this.scale;
	ctx.beginPath();
	ctx.arc(cx, cy, radius, 0, box2d.b2_pi * 2, true);
	ctx.moveTo(cx, cy);
	ctx.lineTo((cx + axis.x * this.scale * radius), (cy + axis.y * this.scale * radius));
	ctx.fillStyle = color.MakeStyleString(0.5);
	ctx.fill();
	ctx.strokeStyle = color.MakeStyleString(1);
	ctx.stroke();
};

/**
 * @export
 * @return {void}
 * @param {box2d.b2Vec2} p1
 * @param {box2d.b2Vec2} p2
 * @param {box2d.b2Color} color
 */
box2d.b2DebugDraw.prototype.DrawSegment = function (p1, p2, color)
{
	var ctx = this.m_ctx;

	ctx.beginPath();
	ctx.moveTo(p1.x * this.scale, p1.y * this.scale);
	ctx.lineTo(p2.x * this.scale, p2.y * this.scale);
	ctx.strokeStyle = color.MakeStyleString(1);
	ctx.stroke();
};

/**
 * @export
 * @return {void}
 * @param {box2d.b2Transform} xf
 */
box2d.b2DebugDraw.prototype.DrawTransform = function (xf)
{
	var ctx = this.m_ctx;

	this.PushTransform(xf);

	ctx.beginPath();
	ctx.moveTo(0, 0);
	ctx.lineTo(10, 0);
	ctx.strokeStyle = box2d.b2Color.RED.MakeStyleString(1);
	ctx.stroke();

	ctx.beginPath();
	ctx.moveTo(0, 0);
	ctx.lineTo(0, 10);
	ctx.strokeStyle = box2d.b2Color.GREEN.MakeStyleString(1);
	ctx.stroke();

	this.PopTransform(xf);
};

/**
 * @export
 * @return {void}
 * @param {box2d.b2Vec2} p
 * @param {number} size
 * @param {box2d.b2Color} color
 */
box2d.b2DebugDraw.prototype.DrawPoint = function (p, size, color)
{
	var ctx = this.m_ctx;

	ctx.fillStyle = color.MakeStyleString();
	size /= this.m_settings.viewZoom;
	size /= this.m_settings.canvasScale;
	var hsize = size / 2;
	ctx.fillRect(p.x * this.scale - hsize, p.y * this.scale - hsize, size, size);
}

/**
 * @export
 * @param {number} x
 * @param {number} y
 * @param {string} format
 * @param {...string|number} var_args
 */
box2d.b2DebugDraw.prototype.DrawString = function (x, y, format, var_args)
{
	var ctx = this.m_ctx;

	var args = Array.prototype.slice.call(arguments);
	var string = goog.string.format.apply(null, args.slice(2));

	ctx.save();
		ctx.setTransform(1, 0, 0, 1, 0, 0);
		ctx.font = '18pt helvetica';//'9pt lucida console';
		var color = box2d.b2DebugDraw.prototype.DrawString.s_color;
		ctx.fillStyle = color.MakeStyleString();
		ctx.fillText(string, x * this.scale, y * this.scale);
	ctx.restore();
}
box2d.b2DebugDraw.prototype.DrawString.s_color = new box2d.b2Color(0.9, 0.6, 0.6);

/**
 * @export
 * @param {number} x
 * @param {number} y
 * @param {string} format
 * @param {...string|number} var_args
 */
box2d.b2DebugDraw.prototype.DrawStringWorld = function (x, y, format, var_args)
{
	var p = box2d.b2DebugDraw.prototype.DrawStringWorld.s_p.SetXY(x, y);

	// world -> viewport
	var vt = this.m_settings.viewCenter;
	box2d.b2SubVV(p, vt, p);
	var vr = this.m_settings.viewRotation;
	box2d.b2MulTRV(vr, p, p);
	var vs = this.m_settings.viewZoom;
	box2d.b2MulSV(vs, p, p);

	// viewport -> canvas
	var cs = this.m_settings.canvasScale;
	box2d.b2MulSV(cs, p, p);
	p.y *= -1;
	var cc = box2d.b2DebugDraw.prototype.DrawStringWorld.s_cc.SetXY(0.5 * this.m_canvas.width, 0.5 * this.m_canvas.height);
	box2d.b2AddVV(p, cc, p);

	var ctx = this.m_ctx;

	var args = Array.prototype.slice.call(arguments);
	var string = goog.string.format.apply(null, args.slice(2));

	ctx.save();
		ctx.setTransform(1, 0, 0, 1, 0, 0);
		ctx.font = '18pt helvetica';//'9pt lucida console';
		var color = box2d.b2DebugDraw.prototype.DrawStringWorld.s_color;
		ctx.fillStyle = color.MakeStyleString();
		ctx.fillText(string, p.x * this.scale, p.y * this.scale);
	ctx.restore();
}
box2d.b2DebugDraw.prototype.DrawStringWorld.s_p = new box2d.b2Vec2();
box2d.b2DebugDraw.prototype.DrawStringWorld.s_cc = new box2d.b2Vec2();
box2d.b2DebugDraw.prototype.DrawStringWorld.s_color = new box2d.b2Color(0.5, 0.9, 0.5);

/**
 * @export
 * @return {void} 
 * @param {box2d.b2AABB} aabb
 * @param {box2d.b2Color} color
 */
box2d.b2DebugDraw.prototype.DrawAABB = function (aabb, color)
{
	var ctx = this.m_ctx;

	ctx.strokeStyle = color.MakeStyleString();
	var x = aabb.lowerBound.x;
	var y = aabb.lowerBound.y;
	var w = aabb.upperBound.x - aabb.lowerBound.x;
	var h = aabb.upperBound.y - aabb.lowerBound.y;
	ctx.strokeRect(x * this.scale, y * this.scale, w * this.scale, h * this.scale);
}

box2d.b2DebugDraw.prototype.SetFlags = function (flags) {
    this.m_settings = flags
}

box2d.b2DebugDraw.prototype.GetFlags = function () {
    return this.m_settings
}
//'remove' namespace for less code writing ;o)
var b2AABB = box2d.b2AABB,
    b2Body = box2d.b2Body,
    b2BodyDef = box2d.b2BodyDef,
    b2ChainShape = box2d.b2ChainShape,
    b2CircleShape = box2d.b2CircleShape,
    b2ContactListener = box2d.b2ContactListener,
    b2DebugDraw = box2d.b2DebugDraw,
    b2EdgeChainDef = box2d.b2EdgeChainDef,
    b2EdgeShape = box2d.b2EdgeShape,
    b2Fixture = box2d.b2Fixture,
    b2FixtureDef = box2d.b2FixtureDef,
    b2Joint = box2d.b2Joint,
    b2MassData = box2d.b2MassData,
    b2Mat22 = box2d.b2Mat22,
    b2MouseJointDef = box2d.b2MouseJointDef,
    b2PolygonShape = box2d.b2PolygonShape,
    b2PrismaticJointDef = box2d.b2PrismaticJointDef,
    b2RevoluteJointDef = box2d.b2RevoluteJointDef,
    b2Settings = box2d.b2Settings,
    b2Shape = box2d.b2Shape,
    b2World = box2d.b2World,
    b2WorldManifold = box2d.b2WorldManifold,
    b2Vec2 = box2d.b2Vec2/**
 * @description
 *
 * B2DEntity is the base class with properties for all B2D objects.
 * This class handles also the drawings for all classes.
 *
 * @class CG.B2DEntity
 * @extends CG.Entity
 */

CG.Entity.extend('B2DEntity', {
    /**
     * Options:
     * name {string} id or name to identify
     * image {mixed} path to image, image or atlasimage from asset
     * world {object} reference to world of B2DWorld
     * x {number} the x position
     * y {number} the y position
     * scale {number} the world scale of B2DWorld
     *
     @example
     var e = new CG.B2DEntity({
           name: 'player',
           image: new CG.Point(100,100),
           world: b2world,
           x: 10,
           y: 20,
           scale: 40
         })
     *
     * @method init
     * @constructor
     * @param options {object}
     * @return {*}
     */

    init: function (options) {
        this._super()
        this.instanceOf = 'B2DEntity'

        CG._extend(this, {
            /**
             * @property body
             * @type {b2Body}
             */
            body: {},
            /**
             * @property body
             * @type {b2Body}
             */
            bodyType: box2d.b2BodyType.b2_dynamicBody,
            /**
             * @property bullet
             * @type {b2Body}
             */
            bullet: false,
            /**
             * @property alpha
             * @type {Number}
             */
            alpha: 1,
            /**
             * @property x
             * @type {Number}
             */
            x: 0,
            /**
             * @property y
             * @type {Number}
             */
            y: 0,
            /**
             * @property scale
             * @type {Number}
             */
            scale: 40,
            /**
             * @property id
             * @type {Object}
             */
            id: {name: '', uid: 0},
            /**
             * @property world
             * @type {b2World}
             */
            world: {},
            /**
             * @property isHit
             * @type {Boolean}
             */
            isHit: false,
            /**
             * @property strength
             * @type {Number}
             */
            strength: 100,
            /**
             * @property dead
             * @type {Boolean}
             */
            dead: false
        })

        if (options) {
            CG._extend(this, options)
        }


        if (!this.bodyDef) {
            /**
             * @property bodyDef
             * @type {b2BodyDef}
             */
            this.bodyDef = new b2BodyDef
            /**
             * @property bodyDef.alowSleep
             * @type {Boolean}
             */
            this.bodyDef.allowSleep = true
            /**
             * @property bodyDef.awake
             * @type {Boolean}
             */
            this.bodyDef.awake = true
        }

        if (!this.fixDef) {
            /**
             * @property fixDef
             * @type {b2FixtureDef}
             */
            this.fixDef = new b2FixtureDef
            /**
             * @property fixDef.density
             * @type {Number}
             */
            this.fixDef.density = 1.0
            /**
             * @property fixDef.friction
             * @type {Number}
             */
            this.fixDef.friction = 0.5
            /**
             * @property fixDef.restitution
             * @type {Number}
             */
            this.fixDef.restitution = 0.5
        }

        return this
    },
    /**
     * @method hit
     * @param impulse
     * @param source
     */
    hit: function (impulse, source) {
        this.isHit = true;
        if (this.strength) {
            this.strength -= impulse;
            if (this.strength <= 0) {
                this.dead = true
            }
        }
    },
    update: function () {
    },
    draw: function () {

        Game.renderer.draw(this)

    },
    /**
     * @method addVelocity
     * @param b2Vec2
     */
    addVelocity: function (b2Vec2) {
        var v = this.body.GetLinearVelocity();

        v.SelfAdd(b2Vec2);

        //check for max horizontal and vertical velocities and then set
        if (Math.abs(v.y) > this.max_ver_vel) {
            v.y = this.max_ver_vel * v.y / Math.abs(v.y);
        }

        if (Math.abs(v.x) > this.max_hor_vel) {
            v.x = this.max_hor_vel * v.x / Math.abs(v.x);
        }

        //set the new velocity
        this.body.SetLinearVelocity(v);

//        if (vel.y < 0) {
//            this.jump = true
//        }
    },
    /**
     * @method applyImpulse
     * @param degrees
     * @param power
     */
    applyImpulse: function (degrees, power) {
        if (this.body) {
            this.body.ApplyLinearImpulse(new b2Vec2(Math.cos(degrees * CG.Const_PI_180) * power,
                Math.sin(degrees * CG.Const_PI_180) * power),
                this.body.GetWorldCenter())
        }
    },
    /**
     * @method setType
     * @param b2BodyType
     */
    setType: function (b2BodyType) {
        this.body.SetType(b2BodyType)
    },
    /**
     * @method setPosition
     * @param b2Vec2
     */
    setPosition: function (b2Vec2) {
        this.body.SetPosition(b2Vec2)
    },
    /**
     * @method getPosition
     */
    getPosition: function () {
        return this.body.GetPosition()
    }

})


/**
 * @description
 *
 * B2DCircle is a simple b2CircleShape wrapper element with basic physics properties.
 *
 * @class CG.B2DCirlce
 * @extends CG.B2DEntity
 */

CG.B2DEntity.extend('B2DCircle', {
    /**
     * Options:
     * name {string}
     * image {mixed}
     * radius {number}
     * x {number}
     * y (number}
     * world {object}
     * scale {number}
     * bodyType {box2d.b2BodyType}
     *
     @example
     var e = new CG.B2DCircle({
           name: 'player',
           image: this.asset.getImageByName('glowball'),
           radius: 20,
           x: 100,
           y: 100,
           world: b2world,
           scale: 40,
           bodyType: box2d.b2BodyType.b2_staticBody
     })
     *
     *
     * @method init
     * @constructor
     * @param options     {Object}
     * @return {*}
     */
    init:function (options) {
        this._super()
        this.instanceOf = 'B2DCircle'

        CG._extend(this, {
            /**
             * @property radius
             * @type {Number}
             */
            radius: 0
        })

        if (options) {
            CG._extend(this, options)
            this.setImage(this.image)
        }

        /**
         * @property bodyDef.type
         * @type {box2d.b2BodyType.b2_staticBody/box2d.b2BodyType.b2_dynamicBody/box2d.b2BodyType.b2_kinematicBody/box2d.b2BodyType.b2_bulletBody}
         */
        this.bodyDef.type = this.bodyType

        /**
         * @property bodyDef.position.x
         * @type {Number}
         */
        this.bodyDef.position.x = this.x / this.scale
        /**
         * @property bodyDef.position.y
         * @type {Number}
         */
        this.bodyDef.position.y = this.y / this.scale
        /**
         * @property bdyDef.userData
         * @type {*}
         */
        this.bodyDef.userData = this.id
        /**
         * @property fixDef.shape
         * @type {b2CircleShape}
         */
        this.fixDef.shape = new b2CircleShape(this.radius / this.scale)

        /**
         * @property body
         * @type {b2Body}
         */
        this.body = this.world.CreateBody(this.bodyDef)
        this.body.CreateFixture(this.fixDef)

        return this

    }
})


/**
 * @description
 *
 * B2DLine is a simple b2PolygonShape wrapper. There is no visible drawing
 * now in the canvas for now. It can be used to build walls, ground,. ,.
 *
 * @class CG.B2DLine
 * @extends CG.B2DEntity
 */

CG.B2DEntity.extend('B2DLine', {
    /**
     * Options:
     * name {string} id or name to identify
     * startPoint {CG.Point}
     * endPoint {CG.Point}
     * world {object} reference to world of B2DWorld
     * scale {number} the world scale of B2DWorld
     *
     @example
     var e = new CG.B2DLine({
       name: 'groundline',
       startPoint: new CG.Point(10,10),
       endPoint: new CG.Point(500,10),
       world: b2world,
       scale: 40
     })
     *
     * @method init
     * @constructor
     * @param options {Object}
     * @return {*}
     */
    init: function (options) {
        this._super()
        this.instanceOf = 'B2DLine'

        CG._extend(this, {
            /**
             * @property startPoint
             * @type {b2Vec2}
             */
            startPoint: new b2Vec2(0, 0),
            /**
             * @property endPoint
             * @type {b2Vec2}
             */
            endPoint: new b2Vec2(0, 0)
        })

        if (options) {
            CG._extend(this, options)
        }

        this.convertPoints()

        /**
         * @property fixDef.shape
         * @type {b2PolygonShape}
         */
        this.fixDef.shape = new b2EdgeShape()
        this.fixDef.shape.Set(this.startPoint, this.endPoint)
        /**
         * @property bodyDef.type
         * @type {Number}
         */
        this.bodyDef.type = box2d.b2BodyType.b2_staticBody
        /**
         * @property bodyDef.position
         */
        this.bodyDef.position.SetXY(0 / this.scale, 0 / this.scale)
        /**
         * @property bodyDef.userData
         * @type {*}
         */
        this.bodyDef.userData = this.id
        /**
         * @property body
         * @type {b2Body}
         */
        this.body = this.world.CreateBody(this.bodyDef)
        this.body.CreateFixture(this.fixDef)

        return this
    },
    convertPoints: function () {
        this.startPoint.x = this.startPoint.x / this.scale
        this.startPoint.y = this.startPoint.y / this.scale
        this.endPoint.x = this.endPoint.x / this.scale
        this.endPoint.y = this.endPoint.y / this.scale
    },
    update: function () {

    },
    draw: function () {

    }
})


/**
 * @description
 *
 * B2DRectangle is a simple b2PolygonShape wrapper element with basic physics properties.
 *
 * @class CG.B2DRectangle
 * @extends CG.B2DEntity
 */

CG.B2DEntity.extend('B2DRectangle', {
    /**
     * Options:
     * name {string}
     * image {mixed}
     * x {number}
     * y (number}
     * world {object}
     * scale {number}
     * bodyType {box2d.b2BodyType}
     *
     @example
     var e = new CG.B2DRectangle({
           name: 'player',
           image: this.asset.getImageByName('glowball'),
           x: 100,
           y: 100,
           world: b2world,
           scale: 40,
           bodyType: box2d.b2BodyType.b2_staticBody
     })
     *
     * @method init
     * @constructor
     * @param options     {Object}
     * @return {*}
     */
    init:function (options) {
        this._super()
        this.instanceOf = 'B2DRectangle'

        if (options) {
            CG._extend(this, options)
            this.setImage(this.image)
        }

        /**
         * @property bodyDef.stat
         * @type {box2d.b2BodyType.b2_staticBody/box2d.b2BodyType.b2_dynamicBody/box2d.b2BodyType.b2_kinematicBody/box2d.b2BodyType.b2_bulletBody}
         */
        this.bodyDef.type = this.bodyType

        /**
         * @property fixDef.shape
         * @type {b2PolygonShape}
         */
        this.fixDef.shape = new b2PolygonShape
        this.fixDef.shape.SetAsBox(this.width / this.scale * 0.5, this.height / this.scale * 0.5)
        /**
         * @property bodyDef.position.x
         * @type {Number}
         */
        this.bodyDef.position.x = this.x / this.scale
        /**
         * @property bodyDef.position.y
         * @type {Number}
         */
        this.bodyDef.position.y = this.y / this.scale
        /**
         * @property bodyDef.userData
         * @type {*}
         */
        this.bodyDef.userData = this.id
        /**
         * @property body
         * @type {b2Body}
         */
        this.body = this.world.CreateBody(this.bodyDef)
        this.body.CreateFixture(this.fixDef)

        return this
    }
})


/**
 * @description
 *
 * B2DPolygon  is a simple b2PolygonShape wrapper element with basic physics properties.
 * It uses PhysicsEditor json files, use export Lime + Corona (json).
 * Supported options for now are friction, density and bounce and would be set to B2DPolygon.
 *
 * @class CG.B2DPolygon
 * @extends CG.B2DEntity
 */

CG.B2DEntity.extend('B2DPolygon', {
    /**
     * Options:
     * name {string}
     * image {mixed}
     * texturepacker {string}
     * x {number}
     * y (number}
     * world {object}
     * scale {number}
     * bodyType {box2d.b2BodyType}
     * bullet {boolean}
     *
     @example
     var e = new CG.B2DPolygon({
           name: 'player',
           image: this.asset.getImageByName('glowball'),
           texturepacker: this.asset.getJsonByName('powerstar75'),
           x: 100,
           y: 100,
           world: b2world,
           scale: 40,
           bodyType: box2d.b2BodyType.b2_staticBody,
           bullet: false
     })
     *
     *
     * @method init
     * @constructor
     * @param options {Object}
     * @return {*}
     */
    init: function (options) {
        this._super()
        this.instanceOf = 'B2DPolygon'
        CG._extend(this, {
            /**
             * @property polys
             * @type {Array}
             */
            polys: new Array(),
            /**
             * @property bullet
             * @type {*}
             */
            bullet: false
        })

        if (options) {
            CG._extend(this, options)
            this.setImage(this.image)
        }

        /**
         * @property jsondata
         * @type {*}
         */
//        this.jsondata = jsonpoly.data[jsonpoly.name]
        this.jsondata = this.texturepacker.data[this.name]
        /**
         * @property vecs
         * @type {Array}
         */
        this.vecs = new Array()
        this.vecs = this.getPolysFromJson(this.texturepacker) // build grouped b2vecs from physicseditor
        //@TODO get alternative polys from bitmap contourTrace & triangulation?

        /**
         * @property bodyDef.type
         * @type {box2d.b2BodyType.b2_staticBody/box2d.b2BodyType.b2_dynamicBody/box2d.b2BodyType.b2_kinematicBody/box2d.b2BodyType.b2_bulletBody}
         */
        this.bodyDef.type = this.bodyType

        /**
         * @property bodyDef.position
         */
        this.bodyDef.position.SetXY(this.x / this.scale, this.y / this.scale)
        /**
         * @property bodyDef.userData
         * @type {*}
         */
        this.bodyDef.userData = this.id
        /**
         * @property bodyDef.bullet
         * @type {*}
         */
        this.bodyDef.bullet = this.bullet

        //this.bodyDef.linearDamping = options.linearDamping
        //this.bodyDef.angularDamping = options.angularDamping
        //this.bodyDef.fixedRotation = true

        /**
         * @property body
         * @type {b2Body}
         */
        this.body = this.world.CreateBody(this.bodyDef)

        for (var i = 0, l = this.vecs.length; i < l; i++) {
            this.bodyShapePoly = new b2PolygonShape
            this.bodyShapePoly.bounce = this.jsondata[i].restitution        //value from physics editor
            this.makeVecsCentroid(this.vecs[i])
            this.bodyShapePoly.SetAsArray(this.vecs[i], this.vecs[i].length)
            this.fixDef.density = this.jsondata[i].density                  //value from physics editor
            this.fixDef.friction = this.jsondata[i].friction                //value from physics editor
            //this.fixDef.restitution = 0

            this.fixDef.shape = this.bodyShapePoly
            this.body.CreateFixture(this.fixDef)
        }
        return this

    },
    /**
     * @description extract the polygons out of the PhysicsEditor json file and collect them into an array
     *
     * Physicseditor json example
     @example
     {

         "ballon": [

                 {
                     "density": 0.05, "friction": 0.5, "bounce": 0,
                     "filter": { "categoryBits": 1, "maskBits": 65535 },
                     "shape": [   98.5, 210  ,  98.5, 212  ,  92, 215.5  ,  82.5, 205  ,  91.5, 206  ,  97, 207.5  ]
                 }  ,
                 {
                     "density": 0.05, "friction": 0.5, "bounce": 0,
                     "filter": { "categoryBits": 1, "maskBits": 65535 },
                     "shape": [   81.5, 213  ,  82.5, 205  ,  92, 215.5  ,  83, 215.5  ]
                 }  ,

     * @method getPolysFromJson
     * @return {Array}
     */
    getPolysFromJson: function () {
        var vecs = []
        for (var i = 0, l = this.jsondata.length; i < l; i++) {
            var poly = this.jsondata[i].shape
            var temp = []
            for (var i2 = 0, l2 = poly.length; i2 < l2; i2 = i2 + 2) {
                var vec = new b2Vec2(poly[i2] / this.scale, poly[i2 + 1] / this.scale)
                temp.push(vec)
            }
            vecs.push(temp)
        }
        return vecs
    },
    /**
     * @description use the CG.Bitmap traceContour method to get the shape of an bitmap. The result are 'only' triangulated polygons. Better results with concave polygons are calculated with Physicseditor, see getPolysFromJson.
     * @todo final implemenation
     *
     @example
     // example code from demo-bitmap-contour.js
     bitmap = new CG.Bitmap(Game.width, Game.height)
     bitmap.loadImage(Game.asset.getImageByName('star-contour-test'))
     var contour = bitmap.traceContour()
     var lightedContour = bitmap.lightenCountur(contour)
     var triangulatedContour = bitmap.triangulateContour(lightedContour)

     * @method getPolysFromBitmapTrace
     * @param image
     * @returns {Array}
     */
    getPolysFromBitmapTrace: function (image) {
        var vecs = []
        return vecs
    },
    /**
     * The origin of the vertices from physicseditor is top/left. This method makes the vecs centroid (centered origin) depending on image size.
     * @todo put this stuff into getPolysFromJson?
     *
     * @method makeVecsCentroid
     * @param vecs
     */
    makeVecsCentroid: function (vecs) {
        var xcenter = this.xhandle / this.scale,
            ycenter = this.yhandle / this.scale
        for (var p = 0, pl = vecs.length; p < pl; p++) {
            vecs[p].x = vecs[p].x - xcenter
            vecs[p].y = vecs[p].y - ycenter
        }
    }
})


/**
 * @description
 *
 * B2DTerrain looks similar to B2DPolygon but has more features for polygon manipulation like clipping and triangulation.
 *
 * @class CG.B2DTerrain
 * @extends CG.B2DEntity
 */


//@TODO code cleanup and description
//@TODO comment to polygon winding order for clipper (outer == CW; holes == CCW)

/*@TODO known pol2tri exceptions ;o(:
 'Cannot call method 'slice' of undefined',
 'poly2tri Intersecting Constraints',
 'poly2tri Invalid Triangle.index() call',
 '"null" is not an object (evaluating 'pb.y')',
 poly2tri Invalid Triangle.legalize() call
 */

CG.B2DEntity.extend('B2DTerrain', {
    /**
     * Options:
     * name {string}
     * image {mixed}
     * points {array}
     * x {number}
     * y {number}
     * world {object}
     * scale {number}
     *
     @example
     var terrainShapes =
     [{
        	outer: [{
        		x: 0,
        		y: 100.5
        	}, {
        		x: 1024,
        		y: 100.5
        	}, {
        		x: 1024,
        		y: 768
        	}, {
        		x: 0,
        		y: 768
        	}],
        	holes: []
        }]

     b2world.createTerrain({
         name: 'terrain',
         image: false
         terrainShape: terrainShapes,
         x:0,
         y:0,
         world: b2world,
         scale: 40
     })
     *
     *
     * @method init
     * @constructor
     * @param options {Object}
     * @return {*}
     */
    init: function (options) {
        this._super()
        this.instanceOf = 'B2DTerrain'

        CG._extend(this, {
            /**
             * @description bitmap for terrain
             * @property bitmap
             * @type {CG.Bitmap}
             */
            bitmap: new CG.Bitmap({width: Game.width, height: Game.height}),
            /**
             * @property image
             * @type {strng}
             */
            image: false,
            /**
             * @property polys
             * @type {Array}
             */
            polys: new Array(),
            /**
             * @property terrainShape
             * @type {*}
             */
            terrainShape: [],
            /**
             * @description the generated triangles generated thru clipper and poly2tri
             * @property terrainTriangles
             * @type {Array}
             */
            terrainTriangles: [],
            /**
             * @property holes
             * @type {Array}
             */
            holes: [],
            /**
             * @property bodyType
             * @type {box2d.b2BodyType}
             */
            bodyType: box2d.b2BodyType.b2_staticBody
        })


        if (options) {
            CG._extend(this, options)
            this.bitmap.loadImage(this.image)
        }


        /**
         * @property bodyDef.type
         * @type {box2d.b2BodyType.b2_staticBody/box2d.b2BodyType.b2_dynamicBody/box2d.b2BodyType.b2_kinematicBody/box2d.b2BodyType.b2_bulletBody}
         */
        this.bodyDef.type = this.bodyType
        /**
         * @property bodyDef.position
         */
        this.bodyDef.position.SetXY(this.x / this.scale, this.y / this.scale)
        /**
         * @property bodyDef.userData
         * @type {*}
         */
        this.bodyDef.userData = this.id
        /**
         * @property bodyDef.bullet
         * @type {*}
         */
        this.bodyDef.bullet = this.bullet

        this.createTerrain()

        return this

    },
    /**
     * @method createTerrain
     */
    createTerrain: function () {
        this.body = this.world.CreateBody(this.bodyDef)

        try {
            for (var part = 0, len = this.terrainShape.length; part < len; part++) {

                var outer = this.terrainShape[part].outer
                if (typeof outer === 'undefined')
                    continue

                var swctx = new poly2tri.SweepContext(outer, {cloneArrays: true})

                if (this.terrainShape[part].holes.length > 0) {
                    for (var i = 0, l = this.terrainShape[part].holes.length; i < l; i++) {
                        swctx.addHole(this.terrainShape[part].holes[i])
                    }
                }

                swctx.triangulate();

                this.terrainTriangles = this.terrainTriangles.concat(swctx.getTriangles() || [])

            }

            for (var i = 0, l = this.terrainTriangles.length; i < l; i++) {
                this.bodyShapePoly = new b2PolygonShape
                this.bodyShapePoly.bounce = 0.5
                this.bodyShapePoly.SetAsArray(this.getPolysFromTriangulation(this.terrainTriangles[i].points_), this.terrainTriangles[i].points_.length)

                this.fixDef.shape = this.bodyShapePoly
                this.body.CreateFixture(this.fixDef)
            }
        } catch (e) {
            console.log('error: createTerrain()', e)
            console.log(e.message)
            console.log(e.stack)
            console.log(this.terrainShape)
            console.log(this.terrainTriangles)
        }
    },
    /**
     * @description deletes the terrain
     * @method deleteTerrain
     */
    deleteTerrain: function () {
        //remove triangles
        this.terrainTriangles = []
        //remove body from b2world
        this.world.DestroyBody(this.body)
    },
    /**
     * @description Using Clipper to clip a hole in a given polygonshape. Important: the outer polygon points have to be in CW orientation, the hole polygons must ordered in CCW
     *
     * Options:
     * points - points for clipping,
     * radius - radius for clipping,
     * x - x pos for clipping,
     * y - y pos for clipping
     *
     * @method clipTerrain
     * @param {object} opt
     */
    clipTerrain: function (opt) {
        var newhole = this.createCircle(opt)

        //add new hole to all contour terrainShapes
        for (var part = 0, len = this.terrainShape.length; part < len; part++) {
            this.terrainShape[part].holes.push(newhole)
        }

        //use clipper to calculate new terrainShapes
        var tempPolys = []
        var subj_polygons = []
        var clip_polygons = []
        for (var part = 0, len = this.terrainShape.length; part < len; part++) {
            subj_polygons = [this.terrainShape[part].outer]
            clip_polygons = []
            if (this.terrainShape[part].holes.length > 0) {
                for (var i = 0, l = this.terrainShape[part].holes.length; i < l; i++) {
                    clip_polygons.push(this.terrainShape[part].holes[i])
                }
            }

//            var cpr = new ClipperLib.Clipper()
//            cpr.AddPolygons(subj_polygons, ClipperLib.PolyType.ptSubject)
//            cpr.AddPolygons(clip_polygons, ClipperLib.PolyType.ptClip)
//
//            var solution_polygons = new ClipperLib.ExPolygons()
//            cpr.Execute(ClipperLib.ClipType.ctDifference, solution_polygons, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero)


            var cpr = new ClipperLib.Clipper()
            cpr.PreserveCollinear = true
            cpr.StrictlySimple = true
            var polytree = new ClipperLib.PolyTree()
            cpr.AddPaths(subj_polygons, ClipperLib.PolyType.ptSubject, true)
            cpr.AddPaths(clip_polygons, ClipperLib.PolyType.ptClip, true)
            cpr.Execute(ClipperLib.ClipType.ctDifference, polytree, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero)

            var solution_polygons = ClipperLib.JS.PolyTreeToExPolygons(polytree);

//            console.log('clipTerrain:', subj_polygons, clip_polygons)
//            console.log('solution_polygons:', solution_polygons)

            if (solution_polygons.length > 0) {
                for (var spoly = 0, slen = solution_polygons.length; spoly < slen; spoly++) {
                    tempPolys.push(solution_polygons[spoly])
                }
            }
        }
        this.terrainShape = tempPolys
        this.lightenTerrain()
//        this.cleanTerrain()
        this.deleteTerrain()
        this.createTerrain()
        this.bitmap.clearCircle(opt.x, opt.y, opt.radius)
    },
    /**
     * @description this method uses the Clipper Lighten method to reduce vertices for better triangulation
     * @method lightenTerrain
     */
    lightenTerrain: function () {
        //use clipper to eliminate to much vertices
        var tolerance = 0.02

        for (var part = 0, len = this.terrainShape.length; part < len; part++) {
            var temp = ClipperLib.JS.Lighten(this.terrainShape[part].outer, tolerance * this.scale)
            this.terrainShape[part].outer = temp[0]
            if (this.terrainShape[part].holes.length > 0) {
                for (var i = 0, l = this.terrainShape[part].holes.length; i < l; i++) {
                    var temp = ClipperLib.JS.Lighten(this.terrainShape[part].holes[i], tolerance * this.scale)
                    this.terrainShape[part].holes[i] = temp[0]
                }
            }
        }
    },
    /**
     * @description Experimental not working yet. Try to use the Clipperlib Clean method
     * @method cleanTerrain
     */
    cleanTerrain: function () {
        //use clipper to eliminate to much vertices
        var cleandelta = 0.1

        for (var part = 0, len = this.terrainShape.length; part < len; part++) {
            var temp = ClipperLib.JS.Clean(this.terrainShape[part].outer, cleandelta * this.scale)
            this.terrainShape[part].outer = temp[0]
            if (this.terrainShape[part].holes.length > 0) {
                for (var i = 0, l = this.terrainShape[part].holes.length; i < l; i++) {
                    var temp = ClipperLib.JS.Clean(this.terrainShape[part].holes[i], cleandelta * this.scale)
                    this.terrainShape[part].holes[i] = temp[0]
                }
            }
        }
    },
    /**
     * @description extract the triangles out of poly2tri array
     *
     * @method getPolysFromJson
     * @return {Array}
     */
    getPolysFromTriangulation: function (pointsArray) {
        var vecs = []
        for (var i = 0, l = pointsArray.length; i < l; i++) {
            var poly = pointsArray[i]
            vecs.push(new b2Vec2(poly.x / this.scale, poly.y / this.scale))
        }
        return vecs
    },
    /**
     * @description creates a ccw wise circle vertices array for clipping
     *
     * Options:
     * points - number of points of circle,
     * radius - radius for circle,
     * x - x position for circle,
     * y - y position for circle
     *
     * @method createCircle
     * @param {object} opts example {points: 16, radius: 30, x: 320, y: 240}
     * @returns {Array}
     */
    createCircle: function (opts) {
        var angle = 2 * Math.PI / opts.points
        var circleArray = []
        for (var i = 0; i < opts.points; i++) {
            circleArray.push({x: opts.x + opts.radius * Math.cos(angle * i), y: opts.y + opts.radius * Math.sin(angle * i)})
        }
        return circleArray.reverse()
    },

    draw: function () {

        Game.renderer.draw(this.bitmap)

    },

    // converts polygons to SVG path string
    polys2SvgImage: function (poly, scale) {
        var path = "", i, j;
        if (!scale)
            scale = 1;
        for (i = 0; i < poly.length; i++) {
            for (j = 0; j < poly[i].length; j++) {
                if (!j)
                    path += "M";
                else
                    path += "L";
                path += (poly[i][j].X / scale) + ", " + (poly[i][j].Y / scale);
            }
            path += "Z";
        }
        return path;

        /*
         svg = '<svg style="" width="800" height="600">';
         svg += '<defs><pattern id="back" patternUnits="userSpaceOnUse" width="990" height="534"><image xlink:href="imagetest.png" x="0" y="0" width="990" height="534"/></pattern></defs>';
         svg += '<path stroke="" fill="url(#back)" stroke-width="" d="' + polys2path(solution_polygons, scale) + '"/>';
         svg += '</svg>';
         */
    }
})


/**
 * @description
 *
 * B2DChainShape
 *
 * @class CG.B2DChainShape
 * @extends CG.B2DEntity
 */

CG.B2DEntity.extend('B2DChainShape', {
    /**
     * Options:
     * name {string}
     * points {array}
     * x {number}
     * y (number}
     * world {object}
     * scale {number}
     *
     @example
     var e = new CG.B2DChainShape({
           name: 'player',
           points: [new CG.Point(10,10), new CG.Point(300,50), new CG.Point(450,10)],
           x: 100,
           y: 100,
           world: b2world,
           scale: 40
     })
     *
     *
     * @method init
     * @constructor
     * @param options {Object}
     * @return {*}
     */
    init:function (options) {
        this._super()
        this.instanceOf = 'B2DChainShape'

        CG._extend(this, {

            /**
             * @property polys
             * @type {Array}
             */
            vertices: [],
            /**
             * @property bodyType
             * @type {box2d.b2BodyType}
             */
            bodyType: box2d.b2BodyType.b2_staticBody
        })

        if (options) {
            CG._extend(this, options)
        }

        this.vertices = this.convertRealWorldPointToBox2DVec2(this.points)

        /**
         * @property bodyDef.type
         * @type {box2d.b2BodyType.b2_staticBody/box2d.b2BodyType.b2_dynamicBody/box2d.b2BodyType.b2_kinematicBody/box2d.b2BodyType.b2_bulletBody}
         */
        this.bodyDef.type = this.bodyType
        /**
         * @property bodyDef.position
         */
        this.bodyDef.position.SetXY(this.x / this.scale, this.y / this.scale)
        /**
         * @property bodyDef.userData
         * @type {*}
         */
        this.bodyDef.userData = this.id
        /**
         * @property fixDef.shape
         * @type {b2CircleShape}
         */
        this.fixDef.shape = new b2ChainShape()
        this.fixDef.shape.CreateChain(this.vertices, this.vertices.length)

        /**
         * @property body
         * @type {b2Body}
         */
        this.body = this.world.CreateBody(this.bodyDef)
        this.body.CreateFixture(this.fixDef)

        return this

    },
    /**
     * @description
     *
     * convertRealWorldPointToBox2DVec2 converts real world vectors to box2d world vecs depending on scale
     *
     * @method convertRealWorldPointToBox2DVec2
     * @param {Array} vertices CG.Point array
     * @return {Array} vecs b2Vec2  with box2d world scale
     */
    convertRealWorldPointToBox2DVec2:function (vertices) {
        var vecs = []
        for (var i = 0, l = vertices.length; i < l; i++) {
            var vec = new b2Vec2(vertices[i].x / this.scale, vertices[i].y / this.scale)
            vecs.push(vec)
        }
        return vecs
    },
    update:function () {

    },
    draw:function () {

    }

})


/**
 * @description
 *
 * B2DRope is a simple wrapper that creates a rope with segments.
 * Just play with the params to get a good result.
 *
 * @class CG.B2DRope
 * @extends CG.B2DEntity
 */

CG.B2DEntity.extend('B2DRope', {
    /**
     * Options:
     * name {string}
     * image {mixed}
     * x {number}
     * y (number}
     * length {number}
     * segments {number}
     * segmentHeight {number}
     * world {object}
     * scale {number}
     *
     @example
     var e = new CG.B2DRope({
           name: 'player',
           image: this.asset.getImageByName('glowball'),
           x: 100,
           y: 100,
           length: 600,
           segments: 20
           segmentWidth: 4,
           world: b2world,
           scale: 40
     })
     *
     * @method init
     * @constructor
     * @param options {Object}
     * @return {*}
     */
    init: function (options) {
        this._super()
        this.instanceOf = 'B2DRope'

        CG._extend(this, {
            /**
             * @property length
             * @type {Number}
             */
            length: 0,
            /**
             * @property segments
             * @type {Number}
             */
            segments: 0,
            /**
             * @property segmentHeight
             * @type {Number}
             */
            segmentHeight: 0,
            /**
             * @property segmentWidth
             * @type {*}
             */
            segmentWidth: 0,
            /**
             * @property anchor
             * @type {b2Vec2}
             */
            anchor: new b2Vec2(),
            /**
             * @property prevBody
             * @type {Object}
             */
            prevBody: {},
            /**
             * @property bodyGroup
             * @type {Array}
             */
            bodyGroup: [],
            /**
             * @property bodyCount
             * @type {Number}
             */
            bodyCount: 0,
            /**
             * @property body
             * @type {object}
             */
            body: {},
            /**
             * @property density
             * @type {Number}
             */
            density: 1.0,
            /**
             * @property restitution
             * @type {Number}
             */
            restitution: 0.2,
            /**
             * @property friction
             * @type {Number}
             */
            friction: 0.2,
            /**
             * @property lowerAngle
             * @type {Number}
             */
            lowerAngle: -25,
            /**
             * @property upperAngle
             * @type {Number}
             */
            upperAngle: 25

        })

        if (options) {
            CG._extend(this, options)
            this.setImage(this.image)
        }

        this.segmentHeight = ((this.length - this.y) / this.segments) / 2

        // RopeStart
        this.fixtureDef = new b2FixtureDef()
        this.bodyShapeCircle = new b2CircleShape()
        this.bodyDef = new b2BodyDef()
        this.bodyDef.userData = this.id
        this.bodyShapeCircle.m_radius = this.segmentWidth / this.scale
        this.fixtureDef.density = this.density
        this.fixtureDef.restitution = this.restitution
        this.fixtureDef.friction = this.friction
        this.fixtureDef.shape = this.bodyShapeCircle
        this.bodyDef.position.SetXY(this.x / this.scale, this.y / this.scale)
        this.body = this.bodyGroup[0] = this.world.CreateBody(this.bodyDef)
        this.bodyGroup[0].CreateFixture(this.fixtureDef)
        this.prevBody = this.bodyGroup[0]

        // RopeSegments
        this.fixtureDef = new b2FixtureDef()
        this.bodyShapePoly = new b2PolygonShape()
        this.bodyDef = new b2BodyDef()
        this.bodyDef.userData = this.id
        this.bodyShapePoly.SetAsBox(this.segmentWidth / this.scale, this.segmentHeight / this.scale)
        this.bodyDef.type = box2d.b2BodyType.b2_dynamicBody
        this.fixtureDef.shape = this.bodyShapePoly
        this.fixtureDef.density = this.density
        this.fixtureDef.restitution = this.restitution
        this.fixtureDef.friction = this.friction
        this.jointDef = new b2RevoluteJointDef()
        this.jointDef.lowerAngle = this.lowerAngle / CG.Const_180_PI
        this.jointDef.upperAngle = this.upperAngle / CG.Const_180_PI
        this.jointDef.enableLimit = true


        for (var i = 0, l = this.segments; i < l; i++) {
            this.bodyDef.position.SetXY(this.x / this.scale, ((this.y + this.segmentHeight) + (this.segmentHeight * 2) * i) / this.scale)
            this.bodyGroup[i + 1] = this.world.CreateBody(this.bodyDef)
            this.bodyGroup[i + 1].CreateFixture(this.fixtureDef)
            this.anchor.SetXY(this.x / this.scale, (this.y + (this.segmentHeight * 2) * i) / this.scale)
            this.jointDef.Initialize(this.prevBody, this.bodyGroup[i + 1], this.anchor)
            this.world.CreateJoint(this.jointDef)
            this.prevBody = this.bodyGroup[i + 1]
            this.bodyCount = i + 1
        }

        return this

    },

    draw: function () {
        for (var i = 1; i <= this.bodyCount; i++) {

            this.body = this.bodyGroup[i]

            Game.renderer.draw(this)

        }
    }
})


/**
 * @description
 *
 * B2DBridge is a simple wrapper that creates a bridge with segments.
 * Just play with the params to get a good result.
 *
 * @class CG.B2DBridge
 * @extends CG.B2DEntity
 */

CG.B2DEntity.extend('B2DBridge', {
    /**
     * Options:
     * name {string}
     * image {mixed}
     * x {number}
     * y (number}
     * length {number}
     * segments {number}
     * segmentHeight {number}
     * world {object}
     * scale {number}
     *
     @example
     var e = new CG.B2DBridge({
           name: 'player',
           image: this.asset.getImageByName('glowball'),
           x: 100,
           y: 100,
           length: 600,
           segments: 20
           segmentHeight: 4,
           world: b2world,
           scale: 40
     })
     *
     *
     * @method init
     * @constructor
     * @param options {Object}
     * @return {*}
     */
    init: function (options) {
        this._super()
        this.instanceOf = 'B2DBridge'

        CG._extend(this, {
            /**
             * @property x
             * @type {Number}
             */
            x: 0,
            /**
             * @property y
             * @type {Number}
             */
            y: 0,
            /**
             * @property length
             * @type {Number}
             */
            length: 0,
            /**
             * @property segments
             * @type {Number}
             */
            segments: 0,
            /**
             * @property segmentWidth
             * @type {Number}
             */
            segmentWidth: 0,
            /**
             * @property segmentHeight
             * @type {Number}
             */
            segmentHeight: 0,
            /**
             * @property anchor
             * @type {b2Vec2}
             */
            anchor: new b2Vec2(),
            /**
             * @property prevBodf
             * @type {Object}
             */
            prevBody: {},
            /**
             * @property bodyGroup
             * @type {Array}
             */
            bodyGroup: [],
            /**
             * @property bodyCount
             * @type {Number}
             */
            bodyCount: 0,
            /**
             * @property body
             * @type {object}
             */
            body: {},
            /**
             * @property density
             * @type {Number}
             */
            density: 20.0,
            /**
             * @property restitution
             * @type {Number}
             */
            restitution: 0.2,
            /**
             * @property friction
             * @type {Number}
             */
            friction: 0.2,
            /**
             * @property lowerAngle
             * @type {Number}
             */
            lowerAngle: -25,
            /**
             * @property upperAngle
             * @type {Number}
             */
            upperAngle: 25
        })

        if (options) {
            CG._extend(this, options)
            this.setImage(this.image)
        }

        /**
         * @property segmentWidth
         * @type {Number}
         */
        this.segmentWidth = ((this.length - this.x) / this.segments) / 2


        // BridgeStart

        this.fixtureDef = new b2FixtureDef()
        this.bodyShapeCircle = new b2CircleShape()
        this.bodyDef = new b2BodyDef()
        this.bodyDef.userData = this.id
        this.bodyShapeCircle.m_radius = this.segmentHeight / this.scale
        this.fixtureDef.density = this.density
        this.fixtureDef.restitution = this.restitution
        this.fixtureDef.friction = this.friction
        this.fixtureDef.shape = this.bodyShapeCircle
        this.bodyDef.position.SetXY(this.x / this.scale, this.y / this.scale)
        this.body = this.bodyGroup[0] = this.world.CreateBody(this.bodyDef)
        this.bodyGroup[0].CreateFixture(this.fixtureDef)
        this.prevBody = this.bodyGroup[0]

        // BridgeEnd
        this.bodyDef.position.SetXY(this.length / this.scale, this.y / this.scale)
        this.bodyDef.userData = this.id
        this.bodyGroup[1] = this.world.CreateBody(this.bodyDef)
        this.bodyGroup[1].CreateFixture(this.fixtureDef)

        // bridge elements
        this.fixtureDef = new b2FixtureDef()
        this.bodyShapePoly = new b2PolygonShape()
        this.bodyDef = new b2BodyDef()
        this.bodyDef.userData = this.id
        this.bodyShapePoly.SetAsBox(this.segmentWidth / this.scale, this.segmentHeight / this.scale)
        this.bodyDef.type = box2d.b2BodyType.b2_dynamicBody
        this.fixtureDef.shape = this.bodyShapePoly
        this.fixtureDef.density = this.density
        this.fixtureDef.restitution = this.restitution
        this.fixtureDef.friction = this.friction
        this.jointDef = new b2RevoluteJointDef()
        this.jointDef.lowerAngle = this.lowerAngle / CG.Const_180_PI
        this.jointDef.upperAngle = this.upperAngle / CG.Const_180_PI
        this.jointDef.enableLimit = true

        for (var i = 0, l = this.segments; i < l; i++) {
            this.bodyDef.position.SetXY(((this.x + this.segmentWidth) + (this.segmentWidth * 2) * i) / this.scale, this.y / this.scale)
            this.bodyGroup[i + 2] = this.world.CreateBody(this.bodyDef)
            this.bodyGroup[i + 2].CreateFixture(this.fixtureDef)
            this.anchor.SetXY((this.x + (this.segmentWidth * 2) * i) / this.scale, this.y / this.scale)
            this.jointDef.Initialize(this.prevBody, this.bodyGroup[i + 2], this.anchor)
            this.world.CreateJoint(this.jointDef)
            this.prevBody = this.bodyGroup[i + 2]
            this.bodyCount = i + 2
        }

        this.anchor.SetXY((this.x + (this.segmentWidth * 2) * this.segments - 1) / this.scale, this.y / this.scale)
        this.jointDef.Initialize(this.prevBody, this.bodyGroup[1], this.anchor)
        this.world.CreateJoint(this.jointDef)

        return this
    },
    draw: function () {
        for (var i = 2; i <= this.bodyCount; i++) {

            this.body = this.bodyGroup[i]

            Game.renderer.draw(this)

        }
    }
})


/**
 * @description
 *
 * B2DWorld is a Box2dWeb wrapper with basic and easy methods for creating Box2d Objects like
 * lines, circles, rectangles, polybodies, ropes and bridges. Custom B2D Objects that extends
 * one of the basic B2D objects can added to the B2DWorld with the addCustom method.
 * The CG.B2DWorld can attached to an CG.Screen object as layer. The B2DWorld will handle
 * all physics and drawings.
 *
 * @class CG.B2DWorld
 * @xtend CG.Layer
 */

CG.Layer.extend('B2DWorld', {
    /**
     * Options:
     * name {string}
     * sleep {boolean}
     * scale {number}
     * debug {boolean}
     *
     *
     @example
     var w = new CG.B2DWorld({
         name: 'box2d-world',
         scale: 40,
         debug: true,
         sleep: true
     })
     * @method init
     * @constructor
     * @param options {object}
     */
    init: function (options) {

        CG._extend(this, {
            /**
             * @property framerate
             * @type {number}
             */
            framerate: 1 / 30,

            /**
             * @property name
             * @type {String}
             */
            name: '',
            /**
             * @property debug
             * @type {Boolean}
             */
            debug: false,
            /**
             * @property x
             * @type {Number}
             */
            x: 0,
            /**
             * @property y
             * @type {Number}
             */
            y: 0,
            /**
             * @property elements
             * @type {Array}
             */
            elements: [],

            /**
             * @property uid
             * @type {Number}
             */
            uid: 0, //uid counter for elements
            /**
             * @property scale
             * @type {Number}
             */
            scale: 40,
            /**
             * @property sleep
             * @type {Boolean}
             */
            sleep: true
        })

        if (options) {
            CG._extend(this, options)
        }

        /**
         * @property world
         * @type {b2World}
         */
        this.world = new b2World(
            new b2Vec2(0, 10), //gravity
            this.sleep
        )

        // add m_groundBody for use with b2MouseJoint
        this.world.m_groundBody = this.world.CreateBody(new b2BodyDef());

        //setup debug draw
        var debugDraw = new b2DebugDraw({
            scale: this.scale,
            canvas: Game.b_canvas,
            ctx: Game.b_ctx,
            flags: box2d.b2DrawFlags.e_shapeBit | box2d.b2DrawFlags.e_jointBit | box2d.b2DrawFlags.e_centerOfMassBit
        })
        this.world.SetDebugDraw(debugDraw)

    },
    /**
     * @method update
     */
    update: function () {

        this.world.Step(
            this.framerate   //frame-rate
            , 10       //velocity iterations
            , 10       //position iterations
        )

        if (CG.mousedown) {
            this.mouseDownAt(mousex, mousey);
        } else if (this.isMouseDown()) {
            this.mouseUp();
        }

        for (var i = 0, l = this.elements.length; i < l; i++) {
            this.elements[i].update()
        }


    },
    /**
     * @method draw
     */
    draw: function () {
        Game.b_ctx.save()
        Game.b_ctx.translate(this.x, this.y)

        for (var i = 0, l = this.elements.length; i < l; i++) {
            this.elements[i].draw()
        }

        if (this.debug) {
            this.world.DrawDebugData()
            this.world.ClearForces()
        }

        Game.b_ctx.restore()
    },
    /**
     * @description
     *
     * Custom extended objects can be added to the B2DWorld with this method.
     *
     * @method addCustom
     * @param obj      object    custom B2D object
     * @return {Object}
     */
    addCustom: function (obj) {
        this.uid = this.uid + 1
        obj.id.uid = this.uid
        this.elements.push(obj)
        return obj
    },
    /**
     * @description
     *
     * Checks if a B2D body Exists
     *
     * @method deleteBodyAt
     * @param body {Object}
     * @return {Boolean}
     */
    checkIfBodyExists: function (body) {
        if (body) {
            for (var i = 0, l = this.elements.length; i < l; i++) {
                //if b2entity found delete entity and b2body
                if (this.elements[i].body.m_userData.uid == body.m_userData.uid) {
                    return true
                }
            }
        }
        return false
    },
    /**
     * Options:
     * name {string}
     * image {mixed}  path to image, image or atlasimage from asset
     * x {number}
     * y {number}
     * bodyType {number}
     *
     @example
     b2world.createBox({
        name: 'glowball',
        image: this.asset.getImageByName('glowball'),
        radius: 22,
        x: this.mouse.x,
        y: this.mouse.y,
        bodyType: box2d.b2BodyType.b2_dynamicBody
     })
     * @description
     *
     * createBox creates a basic Box2D rectangle with some default settings.
     *
     * @method createBox
     * @param options {object}
     * @return {CG.B2DRectangle}
     */
    createBox: function (options) {
        options.world = this.world
        options.scale = this.scale
        this.uid = this.uid + 1
        var entity = new CG.B2DRectangle(options)
        entity.id.uid = this.uid
        this.elements.push(entity)
        return entity
    },
    /**
     * Options:
     * name {string}
     * startPoint {CG.Point}
     * endPoint {CG.Point}
     *
     @example
     b2world.createLine({
        name:'testline2',
        startPoint: new CG.Point(630, 200),
        endPoint: new CG.Point(150, 250)
     })
     *
     * @description
     *
     * createLine creates a basic Box2D line with some default settings.
     *
     * @method createLine
     * @param options {object}
     * @return {CG.B2DLine}
     */
    createLine: function (options) {
        options.world = this.world
        options.scale = this.scale
        this.uid = this.uid + 1
        var entity = new CG.B2DLine(options)
        entity.id.uid = this.uid
        this.elements.push(entity)
        return entity
    },
    /**
     * Options:
     * name {string}
     * image {mixed}  path to image, image or atlasimage from asset
     * radius {number}
     * x {number}
     * y {number}
     * bodyType {number}
     *
     @example
     b2world.createCircle({
        name: 'glowball',
        image: this.asset.getImageByName('glowball'),
        radius: 22,
        x: this.mouse.x,
        y: this.mouse.y,
        bodyType: box2d.b2BodyType.b2_dynamicBody
     })
     * @description
     *
     * createCircle creates a basic Box2D circle with some default settings
     *
     * @method createCircle
     * @param options {object}
     * @return {CG.B2DCircle}
     */
    createCircle: function (options) {
        options.world = this.world
        options.scale = this.scale
        this.uid = this.uid + 1
        var entity = new CG.B2DCircle(options)
        entity.id.uid = this.uid
        this.elements.push(entity)
        return entity
    },
    /**
     * Options:
     * name {string}
     * image {mixed}  path to image, image or atlasimage from asset
     * texturepacker {String}
     * x {number}
     * y {number}
     * bodyType {number}
     * bullet {boolean}
     *
     @example
     b2world.createPolyBody({
        name: 'powerstar75',
        image: this.asset.getImageByName('powerstar75'),
        texturepacker: this.asset.getJsonByName('powerstar75'),
        x: 200,
        y: -150,
        bodyType: box2d.b2BodyType.b2_dynamicBody,
        bullet: false
     })
     *
     * @description
     *
     * createPolyBody creates a Box2D polybody. A PhysicsEditor json (Lime + Corona JSON Exporter) file is needed for this
     * Box2D object. The polygonshape and some settings like density, bounce and friction are
     * taken from the json file at the moment.
     *
     * @method createPolyBody
     * @param options {object}
     * @return {CG.B2DPolygon}
     */
    createPolyBody: function (options) {
        options.world = this.world
        options.scale = this.scale
        this.uid = this.uid + 1
        var entity = new CG.B2DPolygon(options)
        entity.id.uid = this.uid
        this.elements.push(entity)
        return entity
    },
    /**
     * Options:
     * name {string}
     * image {mixed}
     * points {array}
     * x {number}
     * y {number}
     *
     @example
     var terrainPolys =
     [{
        	outer: [{
        		x: 0,
        		y: 100.5
        	}, {
        		x: 1024,
        		y: 100.5
        	}, {
        		x: 1024,
        		y: 768
        	}, {
        		x: 0,
        		y: 768
        	}],
        	holes: []
        }]

     b2world.createTerrain({
         name: 'terrain',
         image: false
         terrainShape: terrainPolys,
         x:0,
         y:0
     })
     *
     *
     * @description
     *
     * createTerrain
     *
     * @method createPolyBody
     * @param options {String}
     * @return {CG.B2DTerrain}
     */
    createTerrain: function (options) {
        options.world = this.world
        options.scale = this.scale
        this.uid = this.uid + 1
        var entity = new CG.B2DTerrain(options)
        entity.id.uid = this.uid
        this.elements.push(entity)
        return entity
    },
    /**
     * Options:
     * name {string}
     * points {array}
     * x {number}
     * y {number}
     *
     @example
     chainArray = [
         new CG.Point(0, 0),
         new CG.Point(50, 10),
         new CG.Point(100, 100),
         new CG.Point(200, 100),
         new CG.Point(250, 50),
         new CG.Point(300, 70)
     ]

     b2world.createChainShape({
         name: 'chaneshape',
         points: chainArray,
         x: 0,
         y: 200
     })
     *
     * @description
     *
     * createChainShape
     *
     * @method createChainShape
     * @param options {object}
     * @return {CG.B2DChainShape}
     */
    createChainShape: function (options) {
        options.world = this.world
        options.scale = this.scale
        this.uid = this.uid + 1
        var entity = new CG.B2DChainShape(options)
        entity.id.uid = this.uid
        this.elements.push(entity)
        return entity
    },
    /**
     * Options:
     * name {string}
     * image {mixed}  path to image, image or atlasimage from asset
     * x {number}
     * y {number}
     * length {number}
     * segments {number}
     * segmentHeight {number}
     *
     @example
     b2world.createBridge({
        name:'chain',
        image:this.asset.getImageByName('chain'),
        x: 20,
        y: 280,
        length: 620,
        segments: 27,
        segmentHeight: 3
     })
     *
     *
     * @description
     *
     * This method creates a B2D bridge. Just play with the params to get a good result!
     *
     * @method createBridge
     * @param options {object}
     * @return {CG.B2DBridge}
     */
    createBridge: function (options) {
        options.world = this.world
        options.scale = this.scale
        this.uid = this.uid + 1
        var entity = new CG.B2DBridge(options)
        entity.id.uid = this.uid
        this.elements.push(entity)
        return entity
    },
    /**
     * Options:
     * name {string}
     * image {mixed}  path to image, image or atlasimage from asset
     * x {number}
     * y {number}
     * length {number}
     * segments {number}
     * segmentWidth {number}
     *
     @example
     b2world.createRope({
        name: 'chain-v',
        image: this.asset.getImageByName('chain-v'),
        x: 580,
        y: 0,
        length: 200,
        segments: 8,
        segmentWidth: 3
    })
     *
     *
     * @description
     *
     * This method creates a B2D rope. Just play with the params to get a good result!
     *
     * @method createRope
     * @param options {object}
     * @return {CG.B2DRope}
     */
    createRope: function (options) {
        options.world = this.world
        options.scale = this.scale
        this.uid = this.uid + 1
        var entity = new CG.B2DRope(options)
        entity.id.uid = this.uid
        this.elements.push(entity)
        return entity
    },
    /**
     * @description
     *
     * Enables dragging B2D objects with the mouse.
     *
     * @method mouseDownAt
     * @param x {Number}
     * @param y {Number}
     */
    mouseDownAt: function (x, y) {
        if (!this.mouseJoint) {
            var body = this.getBodyAt(x, y)

            if (body) {
                var md = new b2MouseJointDef()
                md.bodyA = this.world.m_groundBody
                md.bodyB = body
                md.target.SetXY((x - this.x) / this.scale, (y - this.y) / this.scale)
                md.collideConnected = true
                md.maxForce = 300.0 * body.GetMass()
                this.mouseJoint = this.world.CreateJoint(md)
                body.SetAwake(true);
            }
        } else {
            this.mouseJoint.SetTarget(new b2Vec2((x - this.x) / this.scale, (y - this.y) / this.scale))
        }
    },
    /**
     * @method mouseUp
     */
    mouseUp: function () {
        this.world.DestroyJoint(this.mouseJoint);
        this.mouseJoint = null;
    },
    /**
     * @description
     *
     * Get a B2D body at the give x, y position.
     *
     * @method getBodyAt
     * @param x {Number}
     * @param y {Number}
     * @return {*}
     */
    getBodyAt: function (x, y) {
        var worldx = (x - this.x) / this.scale;
        var worldy = (y - this.y) / this.scale

        var mousePVec = new b2Vec2(worldx, worldy)  //b2world offset for x and y!!!
        var aabb = new b2AABB()
        aabb.lowerBound.SetXY(worldx - 0.001, worldy - 0.001)
        aabb.upperBound.SetXY(worldx + 0.001, worldy + 0.001)

        // Query the world for overlapping shapes.

        var selectedBody = null;
        this.world.QueryAABB(function (fixture) {
            if (fixture.GetBody().GetType() != b2Body.b2_staticBody) {
                if (fixture.GetShape().TestPoint(fixture.GetBody().GetTransform(), mousePVec)) {
                    selectedBody = fixture.GetBody();
                    return false;
                }
            }
            return true;
        }, aabb);
        return selectedBody;
    },
    /**
     * @description
     *
     * Deletes a B2D body at the given x, y position
     *
     * @method deleteBodyAt
     * @param x {Number}
     * @param y (Number)
     * @return {Boolean}
     */
    deleteBodyAt: function (x, y) {
        body = this.getBodyAt(x, y)
        if (body) {
            for (var i = 0, l = this.elements.length; i < l; i++) {
                //if b2entity found delete entity and b2body
                if (this.elements[i].body.m_userData.uid == body.m_userData.uid) {
                    this.removeElementByIndex(i)
                    this.world.DestroyBody(body)
                    return true
                }
            }
        }
        return false
    },
    /**
     * @method isMouseDown
     * @return {Boolean}
     */
    isMouseDown: function () {
        return (this.mouseJoint != null);
    },
    /**
     * @method removeElementByIndex
     * @param index
     */
    removeElementByIndex: function (index) {
        this.elements.splice(index, 1);
    },
    /**
     * @method removeElementByUid
     * @param uid
     */
    removeElementByUid: function (uid) {
        for (var i = 0, l = this.elements.length; i < l; i++) {
            if (typeof this.elements[i] === 'object' && typeof this.elements[i].id !== 'undefined') {
                if (this.elements[i].id.uid === uid) {
                    this.elements.splice(i, 1);
                }
            }
        }
    },
    /**
     * @method applyImpulse
     * @param body
     * @param degrees
     * @param power
     */
    applyImpulse: function (body, degrees, power) {
        if (body) {
            body.ApplyLinearImpulse(new b2Vec2(Math.cos(degrees * CG.Const_PI_180) * power,
                Math.sin(degrees * CG.Const_PI_180) * power),
                body.GetWorldCenter());
        }
    },
    /**
     * @method addContactListener
     * @param callbacks
     */
    addContactListener: function (callbacks) {
        var listener = new box2d.b2ContactListener;
        if (callbacks.BeginContact) listener.BeginContact = function (contact) {
            callbacks.BeginContact(contact.GetFixtureA().GetBody(),
                contact.GetFixtureB().GetBody());
        }
        if (callbacks.EndContact) listener.EndContact = function (contact) {
            callbacks.EndContact(contact.GetFixtureA().GetBody(),
                contact.GetFixtureB().GetBody());
        }
        if (callbacks.PostSolve) listener.PostSolve = function (contact, impulse) {
            callbacks.PostSolve(contact.GetFixtureA().GetBody(),
                contact.GetFixtureB().GetBody(),
                impulse.normalImpulses[0]);
        }
        if (callbacks.PreSolve) listener.PreSolve = function (contact, oldManifold) {
            callbacks.PreSolve(contact, oldManifold);
        }
        this.world.SetContactListener(listener);
    },
    /**
     * @method getBodySpec
     * @param b
     * @return {Object}
     */
    getBodySpec: function (b) {
        return {x: b.GetPosition().x, y: b.GetPosition().y, a: b.GetAngle(), c: {x: b.GetWorldCenter().x, y: b.GetWorldCenter().y}};
    }
})


/**
 * @description
 *
 * CG.B2DFizzXLoader
 *
 * @class CG.B2DFizzXLoader
 * @extends CG.Class
 */

CG.Class.extend('B2DFizzXLoader', {
    /**
     * @constructor
     * @method init
     * @param json {string}
     * @param world {CG.B2DWorld}
     * @param offsetx {Number}
     * @param offsety {Number}
     */
    init: function (json, world, offsetx, offsety) {
        /**
         @property json {string}
         */
        this.json = JSON.parse(json, function (key, value) {
            if (typeof value === "string") {
                if (value.match(/^[-+]?\d+$/)) {      //check for integer
                    return parseInt(value)
                } else if (value.match(/^[-+]?\d+\.\d+$/)) {   //check for float
                    return parseFloat(value)
                } else {      //strings
                    switch (value) {
                        case "true":
                            return true
                            break
                        case "false":
                            return false
                            break
                        case "null":
                            return null
                            break
                    }
                }
            }
            return value
        })
        /**
         @property world {CG.B2DWorld}
         */
        this.world = world
        /**
         @property offsetx {Number}
         */
        this.offsetx = offsetx
        /**
         @property offsety {Number}
         */
        this.offsety = offsety

        this.bodiesMap = []
        this.jointsMap = []
        this.imageMap = []
        this.atlasMap = []

        this.loadImages()
        this.loadBodies()
        this.loadJoints()
    },
    /**
     * @description
     * @method loadBodies
     */
    loadBodies: function () {
        console.log('### start bodies')
        for (var b = 0, lb = this.json.box2d.bodies.body.length; b < lb; b++) {
            var body = this.json.box2d.bodies.body[b]
            console.log('body:', body.name, 'image:', body.image, body)
            var fixtures = body.fixtures.fixture
            console.log('-- fixtures', fixtures.length)
            for (var f = 0, fl = fixtures.length; f < fl; f++) {
                console.log('--- fixture #' + (f + 1), fixtures[f])
            }

        }

    },
    /**
     * @description is this method needed? use MediaAsset loader instead or extend MediaAsset with in game "preloading"?
     * @method loadImages
     */
    loadImages: function () {
        console.log('### start images')
        for (var i = 0, li = this.json.box2d.images.image.length; i < li; i++) {
            var image = this.json.box2d.images.image[i]
            console.log('-- image #' + ( i + 1 ), image)
        }
    },
    /**
     * @description
     * @method loadJoints
     */
    loadJoints: function () {
        console.log('### start joints')
        for (var j = 0, lj = this.json.box2d.joints.joint.length; j < lj; j++) {
            var joint = this.json.box2d.joints.joint[j]
            console.log('-- joint #' + (j + 1), joint)
        }
    }
})

/*

//Example is using LibGDX with the Artemis Entity System Framework
public class FizzXLoader {

    public float BOX_WORLD_TO = 30f;
    HashMap bodiesMap;
    HashMap jointsMap;
    HashMap imageMap;
    HashMap atlasMap;

    public void load(String path, World world, float xOffset, float yOffset) {
        FileHandle fileHandle = Gdx.files.internal(path);

        JsonReader reader = new JsonReader();
        JsonValue map = reader.parse(fileHandle);
        bodiesMap = new HashMap();
        jointsMap = new HashMap();
        imageMap = new HashMap();
        atlasMap = new HashMap();

        JsonValue box2dEntry = map.getChild("box2D");

        for (JsonValue entry = box2dEntry; entry != null; entry = entry.next()) {

            if (entry.name.equals("images")) {

                JsonValue joints = entry.getChild("image");
                for (JsonValue jointJsonValue = joints; jointJsonValue != null; jointJsonValue = jointJsonValue
                    .next()) {
                    JsonValue pathJsonValue = jointJsonValue.get("-path");
                    JsonValue nameJsonValue = jointJsonValue.get("-name");
                    JsonValue atlasJsonValue = jointJsonValue.get("-atlas");
                    String atlasString = atlasJsonValue.asString();
                    if (!atlasString.equals("null")) {
                        TextureAtlas textureAtlas = new TextureAtlas(
                            Gdx.files.internal("data/"
                                + atlasJsonValue.asString() + ".txt"));
                        String[] splitName = pathJsonValue.asString().split(
                            "\\.");
                        atlasMap.put(splitName[0], textureAtlas);
                    }

                    imageMap.put(nameJsonValue.asString(),
                        pathJsonValue.asString());
                }
            }

            else if (entry.name.equals("bodies")) {
                JsonValue bodies = entry.getChild("body");
                for (JsonValue bodyJsonValue = bodies; bodyJsonValue != null; bodyJsonValue = bodyJsonValue
                    .next()) {
                    Float xValue = bodyJsonValue.getFloat("-x");
                    Float yValue = bodyJsonValue.getFloat("-y");
                    String typeValue = bodyJsonValue.getString("-type");
                    boolean bulletValue = bodyJsonValue.getBoolean("-bullet");
                    String nameValue = bodyJsonValue.getString("-name");
                    String imagePath = bodyJsonValue.getString("-image");

                    imageMap.put(nameValue, imagePath);
                    JsonValue fixturesValue = bodyJsonValue
                        .getChild("fixtures");

                    BodyDef bodyDef = new BodyDef();

                    bodyDef.bullet = bulletValue;
                    bodyDef.position.x = xValue / BOX_WORLD_TO + xOffset;
                    bodyDef.position.y = yValue / BOX_WORLD_TO + yOffset;

                    if (typeValue.equals("kinematic")) {
                        bodyDef.type = BodyType.KinematicBody;
                    } else if (typeValue.equals("static")) {
                        bodyDef.type = BodyType.StaticBody;
                    } else if (typeValue.equals("dynamic")) {
                        bodyDef.type = BodyType.DynamicBody;
                    }

                    Entity entity = world.createEntity();
                    world.getManager(TagManager.class).register(nameValue,
                        entity);
                    SpatialComponent component = PhysicsFactory
                        .createBody(bodyDef);

                    entity.addComponent(component);
                    if (!imagePath.equals("null")) {
                        String[] splitName = imagePath.split("\\.");

                        if (atlasMap.containsKey(splitName[0])) {
                            TextureComponent textureComponent = new TextureComponent(
                                atlasMap.get(splitName[0]).findRegion(
                                    splitName[0]), new Vector2(0, 0));
                            entity.addComponent(textureComponent);
                        }
                    }

                    entity.addToWorld();
                    component.name = nameValue;
                    bodiesMap.put(nameValue, component.body);

                    JsonValue fixtureEntry = fixturesValue.child();

                    for (JsonValue fixture = fixtureEntry; fixture != null; fixture = fixture
                        .next()) {
                        String fixtureName = fixture.getString("-name");
                        String shapeType = fixture.getString("-shapeType");
                        float friction = fixture.getFloat("-friction");
                        float restitution = fixture.getFloat("-restitution");
                        float density = fixture.getFloat("-density");

                        JsonValue vertexValue = fixture.getChild("vertex");
                        FixtureDef fixtureDef = new FixtureDef();
                        fixtureDef.density = density;
                        fixtureDef.restitution = restitution;
                        fixtureDef.friction = friction;

                        Shape shape = null;
                        if (shapeType.equals("polygonShape")) {
                            ArrayList verticesList = new ArrayList();

                            JsonValue vertexEntry = vertexValue;

                            if (vertexEntry != null) {

                                for (JsonValue vertex = vertexEntry; vertex != null; vertex = vertex
                                    .next()) {

                                    Float vertexX = vertex.getFloat("-x");
                                    Float vertexY = vertex.getFloat("-y");

                                    Vector2 vector2 = new Vector2();
                                    vector2.x = vertexX / BOX_WORLD_TO;
                                    vector2.y = vertexY / BOX_WORLD_TO;

                                    verticesList.add(vector2);

                                }
                            }

                            shape = new PolygonShape();

                            Vector2[] vertices = new Vector2[verticesList
                                .size()];
                            vertices = verticesList.toArray(vertices);

                            float[] floatVertices = new float[vertices.length * 2];

                            ((PolygonShape) shape).set(vertices);

                            fixtureDef.isSensor = fixture
                                .getBoolean("-isSensor");

                        } else if (shapeType.equals("edgeShape")) {
                            shape = new ChainShape();

                            ArrayList verticesList = new ArrayList();

                            JsonValue vertexEntry = vertexValue;

                            if (vertexEntry != null) {

                                for (JsonValue vertex = vertexEntry; vertex != null; vertex = vertex
                                    .next()) {
                                    JsonValue vertexX = vertex.get("-x");
                                    JsonValue vertexY = vertex.get("-y");

                                    Vector2 vector2 = new Vector2();
                                    vector2.x = vertexX.asFloat()
                                        / BOX_WORLD_TO;
                                    vector2.y = vertexY.asFloat()
                                        / BOX_WORLD_TO;

                                    verticesList.add(vector2);

                                }
                            }

                            Vector2[] vertices = new Vector2[verticesList
                                .size()];
                            vertices = verticesList.toArray(vertices);

                            ((ChainShape) shape).createChain(vertices);

                        } else if (shapeType.equals("circleShape")) {
                            shape = new CircleShape();
                            JsonValue circleRadiusJsonValue = fixture
                                .get("-circleRadius");
                            ((CircleShape) shape)
                        .setRadius(circleRadiusJsonValue.asFloat()
                                / BOX_WORLD_TO);

                            float circleX = fixture.getFloat("-circleX");
                            float circleY = fixture.getFloat("-circleY");

                            ((CircleShape) shape).setPosition(new Vector2(
                                circleX / BOX_WORLD_TO, circleY
                                    / BOX_WORLD_TO));
                            fixtureDef.isSensor = fixture
                                .getBoolean("-isSensor");

                        }

                        fixtureDef.shape = shape;
                        PhysicsFactory.createFixture(fixtureDef, component);
                    }

                }
            } else if (entry.name.equals("joints")) {

                JsonValue joints = entry.getChild("joint");
                for (JsonValue jointJsonValue = joints; jointJsonValue != null; jointJsonValue = jointJsonValue
                    .next()) {
                    JsonValue nameJsonValue = jointJsonValue.get("-name");
                    JsonValue typeJsonValue = jointJsonValue.get("-type");
                    JsonValue collideConnected = jointJsonValue
                        .get("-collideConnected");
                    JsonValue xJsonValue = jointJsonValue.get("-x");
                    JsonValue yJsonValue = jointJsonValue.get("-y");
                    JsonValue bodyAJsonValue = jointJsonValue.get("-bodyA");
                    JsonValue bodyBJsonValue = jointJsonValue.get("-bodyB");

                    JointDef jointDef = null;
                    if (typeJsonValue.asString().equals("RevoluteJoint")) {
                        jointDef = new RevoluteJointDef();
                        RevoluteJointDef revoluteJointDef = (RevoluteJointDef) jointDef;

                        Body bodyA = bodiesMap.get(bodyAJsonValue.asString());
                        Body bodyB = bodiesMap.get(bodyBJsonValue.asString());

                        JsonValue enableLimit = jointJsonValue
                            .get("-enableLimit");
                        JsonValue lowerAngle = jointJsonValue
                            .get("-lowerAngle");
                        JsonValue upperAngle = jointJsonValue
                            .get("-upperAngle");

                        revoluteJointDef.enableLimit = enableLimit.asBoolean();
                        revoluteJointDef.lowerAngle = lowerAngle.asFloat();
                        revoluteJointDef.upperAngle = upperAngle.asFloat();

                        Vector2 anchor = new Vector2(xJsonValue.asFloat()
                            / BOX_WORLD_TO, yJsonValue.asFloat()
                            / BOX_WORLD_TO);
                        revoluteJointDef.initialize(bodyA, bodyB, anchor);

                    } else if (typeJsonValue.asString().equals("WeldJoint")) {
                        jointDef = new WeldJointDef();
                        WeldJointDef weldJointDef = (WeldJointDef) jointDef;

                        Body bodyA = bodiesMap.get(bodyAJsonValue.asString());
                        Body bodyB = bodiesMap.get(bodyBJsonValue.asString());
                        Vector2 anchor = new Vector2(xJsonValue.asFloat()
                            / BOX_WORLD_TO, yJsonValue.asFloat()
                            / BOX_WORLD_TO);
                        weldJointDef.initialize(bodyA, bodyB, anchor);

                    }

                    jointDef.collideConnected = collideConnected.asBoolean();

                    Joint joint = PhysicsFactory.createJoint(jointDef);

                    jointsMap.put(nameJsonValue.asString(), joint);
                }

            }

        }
    }
}
*/

