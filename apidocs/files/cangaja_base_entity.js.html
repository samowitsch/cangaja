<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>cangaja&#x2F;base&#x2F;entity.js - Cangaja API</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="Cangaja API"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/CG.Animation.html">CG.Animation</a></li>
            
                <li><a href="..&#x2F;classes/CG.AtlasImage.html">CG.AtlasImage</a></li>
            
                <li><a href="..&#x2F;classes/CG.AtlasTexturePacker.html">CG.AtlasTexturePacker</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DBridge.html">CG.B2DBridge</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DChainShape.html">CG.B2DChainShape</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DCirlce.html">CG.B2DCirlce</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DEntity.html">CG.B2DEntity</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DLine.html">CG.B2DLine</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DPolygon.html">CG.B2DPolygon</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DRectangle.html">CG.B2DRectangle</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DRope.html">CG.B2DRope</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DTerrain.html">CG.B2DTerrain</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DWorld.html">CG.B2DWorld</a></li>
            
                <li><a href="..&#x2F;classes/CG.Bitmap.html">CG.Bitmap</a></li>
            
                <li><a href="..&#x2F;classes/CG.Bound.html">CG.Bound</a></li>
            
                <li><a href="..&#x2F;classes/CG.Buffer.html">CG.Buffer</a></li>
            
                <li><a href="..&#x2F;classes/CG.Button.html">CG.Button</a></li>
            
                <li><a href="..&#x2F;classes/CG.CanvasRenderer.html">CG.CanvasRenderer</a></li>
            
                <li><a href="..&#x2F;classes/CG.Delta.html">CG.Delta</a></li>
            
                <li><a href="..&#x2F;classes/CG.Director.html">CG.Director</a></li>
            
                <li><a href="..&#x2F;classes/CG.Emitter.html">CG.Emitter</a></li>
            
                <li><a href="..&#x2F;classes/CG.Entity.html">CG.Entity</a></li>
            
                <li><a href="..&#x2F;classes/CG.Font.html">CG.Font</a></li>
            
                <li><a href="..&#x2F;classes/CG.Layer.html">CG.Layer</a></li>
            
                <li><a href="..&#x2F;classes/CG.Map.html">CG.Map</a></li>
            
                <li><a href="..&#x2F;classes/CG.MapArea.html">CG.MapArea</a></li>
            
                <li><a href="..&#x2F;classes/CG.MapPoint.html">CG.MapPoint</a></li>
            
                <li><a href="..&#x2F;classes/CG.MapTileLayer.html">CG.MapTileLayer</a></li>
            
                <li><a href="..&#x2F;classes/CG.MapTileProperties.html">CG.MapTileProperties</a></li>
            
                <li><a href="..&#x2F;classes/CG.MediaAsset.html">CG.MediaAsset</a></li>
            
                <li><a href="..&#x2F;classes/CG.Menu.html">CG.Menu</a></li>
            
                <li><a href="..&#x2F;classes/CG.Morph.html">CG.Morph</a></li>
            
                <li><a href="..&#x2F;classes/CG.Particle.html">CG.Particle</a></li>
            
                <li><a href="..&#x2F;classes/CG.Point.html">CG.Point</a></li>
            
                <li><a href="..&#x2F;classes/CG.Screen.html">CG.Screen</a></li>
            
                <li><a href="..&#x2F;classes/CG.Sequence.html">CG.Sequence</a></li>
            
                <li><a href="..&#x2F;classes/CG.SpineAnimation.html">CG.SpineAnimation</a></li>
            
                <li><a href="..&#x2F;classes/CG.Sprite.html">CG.Sprite</a></li>
            
                <li><a href="..&#x2F;classes/CG.Text.html">CG.Text</a></li>
            
                <li><a href="..&#x2F;classes/CG.Translate.html">CG.Translate</a></li>
            
                <li><a href="..&#x2F;classes/CG.Vector.html">CG.Vector</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/CG.html">CG</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: cangaja&#x2F;base&#x2F;entity.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * @description
 *
 * CG.Entity the base class of Cangaja
 *
 * @class CG.Entity
 * @extends CG.Class
 *&#x2F;

CG.Class.extend(&#x27;Entity&#x27;, {
    &#x2F;**
     * @constructor
     * @method init
     * @param name {string} the name of the Entity
     * @param position {CG.Point} position
     *&#x2F;
    init: function (name, position) {
        &#x2F;**
         @description name of the object
         @property name {string}
         *&#x2F;
        this.name = (name) ? name : &#x27;&#x27;
        &#x2F;**
         @description visibility option
         @property visible {boolean}
         *&#x2F;
        this.visible = true
        &#x2F;**
         @description Transform object for matrix transformation
         @property transform {Transform}
         *&#x2F;
        this.transform = new Transform()
        &#x2F;**
         @property position {CG.Point}
         *&#x2F;
        this.position = (position) ? position : new CG.Point(0, 0)
        &#x2F;**
         @property width {Number}
         *&#x2F;
        this.width = 0
        &#x2F;**
         @property height {Number}
         *&#x2F;
        this.height = 0
        &#x2F;**
         @property dragable {boolean}
         *&#x2F;
        this.dragable = true
        &#x2F;**
         @property rotation {Number}
         *&#x2F;
        this.rotation = 0
        &#x2F;**
         @property xscale {Number}
         *&#x2F;
        this.xscale = 1
        &#x2F;**
         @property yscale {Number}
         *&#x2F;
        this.yscale = 1
        &#x2F;**
         @property hover {boolean}
         *&#x2F;
        this.hover = false
        &#x2F;**
         @property boundingradius {Number}
         *&#x2F;
        this.boundingradius = 0     &#x2F;&#x2F;radius for circular collision bounds
        &#x2F;**
         @property mapcollision {boolean}
         *&#x2F;
        this.mapcollision = false

        return this
    },
    update: function () {
    },
    updateMatrix: function () {
        this.transform.reset()
        this.transform.translate(this.position.x, this.position.y)
        this.transform.rotate(this.rotation * CG.Const_PI_180)
        this.transform.scale(this.xscale, this.yscale)
    },
    draw: function () {
        throw {
            name: &#x27;Entity Error&#x27;,
            message: &#x27;Subclass has no draw method.&#x27;
        }
    },
    &#x2F;**
     * @description initialize image for object. for now =&gt; sprite, particle, buffer, bitmap and button use it
     * @method setImage
     * @param {image} image image path, image or atlasimage
     *&#x2F;
    setImage: function (image) {
        this.atlasimage = false
        if (image) {
            if (image instanceof CG.AtlasImage) {
                &#x2F;&#x2F;AtlasImage from MediaAsset
                this.image = Game.asset.getImageByName(image.atlasname)
                this.imagerotation = image.rotation &#x2F;&#x2F;|| 0
                this.xoffset = image.xoffset
                this.yoffset = image.yoffset
                this.width = image.width
                this.height = image.height
                this.atlasimage = true
                if (this.imagerotation !== 0) {
                    this.cutwidth = image.height
                    this.cutheight = image.width
                } else {
                    this.cutwidth = image.width
                    this.cutheight = image.height
                }
            } else if (typeof image == &#x27;string&#x27; &amp;&amp; image != &#x27;&#x27;) {
                &#x2F;&#x2F;path to image
                this.image = new Image()
                this.image.src = image
                this.width = this.image.width
                this.height = this.image.height
            } else {
                &#x2F;&#x2F;image from MediaAsset
                this.image = image
                this.width = this.image.width
                this.height = this.image.height
            }
        }
    },
    &#x2F;**
     * @description returns the bounds of rotated rectangle
     * @method AABB
     * @return {object} returns the calculated bounds
     *&#x2F;
    AABB: function () {
        &#x2F;&#x2F;http:&#x2F;&#x2F;willperone.net&#x2F;Code&#x2F;coderr.php
        var a = this.rotation * CG.Const_PI_180,
            s = Math.sin(a),
            c = Math.cos(a)

        if (s &lt; 0) s = -s
        if (c &lt; 0) c = -c
        return {
            bw: this.height * this.xscale * s + this.width * this.yscale * c,
            bh: this.height * this.xscale * c + this.width * this.yscale * s
        }
    },
    &#x2F;**
     * @description checks click inside of the rectangle, supports rotation
     * @method ifClicked
     * @return {true&#x2F;false}
     *&#x2F;
    ifClicked: function () {
        if (CG.mousedown &amp;&amp; this.clickable) {
            var dx = CG.mouse.x - this.position.x,
                dy = CG.mouse.y - this.position.y,
                h1 = Math.sqrt(dx * dx + dy * dy),
                currA = Math.atan2(dy, dx),
                newA = currA - (this.rotation * CG.Const_PI_180),
                x2 = Math.cos(newA) * h1,
                y2 = Math.sin(newA) * h1

            if (x2 &gt; -0.5 * (this.width * this.xscale) &amp;&amp;
                x2 &lt; 0.5 * (this.width * this.xscale) &amp;&amp;
                y2 &gt; -0.5 * (this.height * this.yscale) &amp;&amp;
                y2 &lt; 0.5 * (this.height * this.yscale)) {
                this.clicked = true
                CG.mousedown = false
            } else {
                this.clicked = false
            }
        }
    },
    &#x2F;**
     * @description checks if the mouse&#x2F;pointer is over the rectangle
     * @method ifMouseOver
     *&#x2F;
    ifMouseOver: function () {
        var dx = CG.mouse.x - this.position.x,
            dy = CG.mouse.y - this.position.y,
            h1 = Math.sqrt(dx * dx + dy * dy),
            currA = Math.atan2(dy, dx),
            newA = currA - (this.rotation * CG.Const_PI_180),
            x2 = Math.cos(newA) * h1,
            y2 = Math.sin(newA) * h1

        if (x2 &gt; -0.5 * (this.width * this.xscale) &amp;&amp;
            x2 &lt; 0.5 * (this.width * this.xscale) &amp;&amp;
            y2 &gt; -0.5 * (this.height * this.yscale) &amp;&amp;
            y2 &lt; 0.5 * (this.height * this.yscale)) {
            this.hover = true
        } else {
            this.hover = false
        }
    },
    &#x2F;**
     * @description checks if there is a collision of the given objects to this object http:&#x2F;&#x2F;devmag.org.za&#x2F;2009&#x2F;04&#x2F;13&#x2F;basic-collision-detection-in-2d-part-1&#x2F;
     * @method checkCollision
     * @param objects {array} a array of objects to check for collision =&gt; Sprites, Animations, MapAreas
     * @param callback {callback} what to do after collision?
     *&#x2F;
    checkCollision: function (objects, callback) {
        objects.forEach(function (obj, index) {
                if (obj.className == &#x27;MapArea&#x27;) {
                    if ((this.position.y + this.AABB().bh &#x2F; 2) &gt;= obj.bound.y &amp;&amp;
                        this.position.y - this.AABB().bh &#x2F; 2 &lt;= (obj.bound.y + obj.bound.height) &amp;&amp;
                        (this.position.x + this.AABB().bw &#x2F; 2) &gt;= obj.bound.x &amp;&amp;
                        this.position.x - this.AABB().bw &#x2F; 2 &lt;= (obj.bound.x + obj.bound.width )) {
                        if (obj.type === &#x27;outer&#x27;) {

                            w = 0.5 * (this.width + obj.bound.width)
                            h = 0.5 * (this.height + obj.bound.height)
                            dx = this.position.x - (obj.bound.width &#x2F; 2 + obj.bound.x)
                            dy = this.position.y - (obj.bound.height &#x2F; 2 + obj.bound.y)

                            if (Math.abs(dx) &lt;= w &amp;&amp; Math.abs(dy) &lt;= h) {
                                &#x2F;* collision! *&#x2F;
                                wy = w * dy;
                                hx = h * dx;

                                if (wy &gt; hx) {
                                    if (wy &gt; -hx) {
                                        direction = &#x27;bottom&#x27;
                                        overlap = ((this.position.y - this.AABB().bh &#x2F; 2) - (obj.bound.y + obj.bound.height)) &gt;&gt; 0
                                    } else {
                                        direction = &#x27;left&#x27;
                                        overlap = ((this.position.x + this.AABB().bw &#x2F; 2) - obj.bound.x) &gt;&gt; 0
                                    }
                                } else {
                                    if (wy &gt; -hx) {
                                        direction = &#x27;right&#x27;
                                        overlap = ((this.position.x - this.AABB().bw &#x2F; 2) - (obj.bound.x + obj.bound.width)) &gt;&gt; 0
                                    } else {
                                        direction = &#x27;top&#x27;
                                        overlap = ((this.position.y + this.AABB().bh &#x2F; 2) - obj.bound.y) &gt;&gt; 0
                                    }
                                }
                            }

                            collision = {
                                overlap: overlap,
                                direction: direction
                            }
                            &#x2F;&#x2F;callback arguments: this =&gt; the sprite, obj =&gt; the maparea if needed, collision =&gt; {collison direction, offset}
                            callback(this, obj, collision)
                        }
                    }
                }
                else if (this.boundingradius &gt; 0 &amp;&amp; obj.boundingradius &gt; 0) {
                    &#x2F;&#x2F;check boundingradius for circuar collision
                    distx = this.position.x - obj.position.x
                    disty = this.position.y - obj.position.y
                    dist = Math.sqrt((distx * distx) + (disty * disty))
                    if (dist &lt;= (this.boundingradius &#x2F; 2 * this.xscale + obj.boundingradius &#x2F; 2 * obj.yscale)) {
                        collision = false &#x2F;&#x2F;dummy
                        callback(this, obj, collision)
                    }
                }
                else {
                    &#x2F;&#x2F;if boundingradius is 0, fallback to bounding collision
                    if ((this.position.y + this.AABB().bh &#x2F; 2) &gt;= obj.position.y - obj.AABB().bh &#x2F; 2 &amp;&amp;
                        this.position.y - this.AABB().bh &#x2F; 2 &lt;= (obj.position.y + obj.AABB().bh &#x2F; 2) &amp;&amp;
                        (this.position.x + this.AABB().bw &#x2F; 2) &gt;= obj.position.x - obj.AABB().bw &#x2F; 2 &amp;&amp;
                        this.position.x - this.AABB().bw &#x2F; 2 &lt;= (obj.position.x + obj.AABB().bw &#x2F; 2)) {

                        w = 0.5 * (this.width + obj.width)
                        h = 0.5 * (this.height + obj.height)
                        dx = this.position.x - obj.position.x
                        dy = this.position.y - obj.position.y

                        if (Math.abs(dx) &lt;= w &amp;&amp; Math.abs(dy) &lt;= h) {
                            &#x2F;* collision! *&#x2F;
                            wy = w * dy;
                            hx = h * dx;

                            if (wy &gt; hx) {
                                if (wy &gt; -hx) {
                                    direction = &#x27;bottom&#x27;
                                    overlap = ((this.position.y - this.AABB().bh &#x2F; 2) - (obj.position.y - obj.AABB().bh &#x2F; 2)) &gt;&gt; 0
                                } else {
                                    direction = &#x27;left&#x27;
                                    overlap = ((this.position.x + this.AABB().bw &#x2F; 2) - (obj.position.x + obj.AABB().bw &#x2F; 2)) &gt;&gt; 0
                                }
                            } else {
                                if (wy &gt; -hx) {
                                    direction = &#x27;right&#x27;
                                    overlap = ((this.position.x - this.AABB().bw &#x2F; 2) - (obj.position.x - obj.AABB().bw &#x2F; 2)) &gt;&gt; 0
                                } else {
                                    direction = &#x27;top&#x27;
                                    overlap = ((this.position.y + this.AABB().bh &#x2F; 2) - (obj.position.y + obj.AABB().bh &#x2F; 2)) &gt;&gt; 0
                                }
                            }
                        }

                        collision = {
                            overlap: overlap,
                            direction: direction
                        }

                        callback(this, obj, collision)
                    }
                }
            },
            this
        )
        return this
    }
})



    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
