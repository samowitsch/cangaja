<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>cangaja/base/entity.js - Cangaja API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="Cangaja API" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Cangaja.html">Cangaja</a></li>
                                <li><a href="../classes/CG.Animation.html">CG.Animation</a></li>
                                <li><a href="../classes/CG.AtlasImage.html">CG.AtlasImage</a></li>
                                <li><a href="../classes/CG.AtlasTexturePacker.html">CG.AtlasTexturePacker</a></li>
                                <li><a href="../classes/CG.B2DBridge.html">CG.B2DBridge</a></li>
                                <li><a href="../classes/CG.B2DChainShape.html">CG.B2DChainShape</a></li>
                                <li><a href="../classes/CG.B2DCirlce.html">CG.B2DCirlce</a></li>
                                <li><a href="../classes/CG.B2DEntity.html">CG.B2DEntity</a></li>
                                <li><a href="../classes/CG.B2DFizzXLoader.html">CG.B2DFizzXLoader</a></li>
                                <li><a href="../classes/CG.B2DLine.html">CG.B2DLine</a></li>
                                <li><a href="../classes/CG.B2DPolygon.html">CG.B2DPolygon</a></li>
                                <li><a href="../classes/CG.B2DRectangle.html">CG.B2DRectangle</a></li>
                                <li><a href="../classes/CG.B2DRope.html">CG.B2DRope</a></li>
                                <li><a href="../classes/CG.B2DTerrain.html">CG.B2DTerrain</a></li>
                                <li><a href="../classes/CG.B2DWorld.html">CG.B2DWorld</a></li>
                                <li><a href="../classes/CG.Bitmap.html">CG.Bitmap</a></li>
                                <li><a href="../classes/CG.Bound.html">CG.Bound</a></li>
                                <li><a href="../classes/CG.Buffer.html">CG.Buffer</a></li>
                                <li><a href="../classes/CG.Button.html">CG.Button</a></li>
                                <li><a href="../classes/CG.CanvasRenderer.html">CG.CanvasRenderer</a></li>
                                <li><a href="../classes/CG.Delta.html">CG.Delta</a></li>
                                <li><a href="../classes/CG.Director.html">CG.Director</a></li>
                                <li><a href="../classes/CG.Emitter.html">CG.Emitter</a></li>
                                <li><a href="../classes/CG.Entity.html">CG.Entity</a></li>
                                <li><a href="../classes/CG.Font.html">CG.Font</a></li>
                                <li><a href="../classes/CG.Game.html">CG.Game</a></li>
                                <li><a href="../classes/CG.GameController.html">CG.GameController</a></li>
                                <li><a href="../classes/CG.Layer.html">CG.Layer</a></li>
                                <li><a href="../classes/CG.Map.html">CG.Map</a></li>
                                <li><a href="../classes/CG.MapArea.html">CG.MapArea</a></li>
                                <li><a href="../classes/CG.MapPoint.html">CG.MapPoint</a></li>
                                <li><a href="../classes/CG.MapTileLayer.html">CG.MapTileLayer</a></li>
                                <li><a href="../classes/CG.MapTileProperties.html">CG.MapTileProperties</a></li>
                                <li><a href="../classes/CG.MediaAsset.html">CG.MediaAsset</a></li>
                                <li><a href="../classes/CG.Menu.html">CG.Menu</a></li>
                                <li><a href="../classes/CG.Morph.html">CG.Morph</a></li>
                                <li><a href="../classes/CG.Particle.html">CG.Particle</a></li>
                                <li><a href="../classes/CG.Point.html">CG.Point</a></li>
                                <li><a href="../classes/CG.Screen.html">CG.Screen</a></li>
                                <li><a href="../classes/CG.Sequence.html">CG.Sequence</a></li>
                                <li><a href="../classes/CG.SpineAnimation.html">CG.SpineAnimation</a></li>
                                <li><a href="../classes/CG.Sprite.html">CG.Sprite</a></li>
                                <li><a href="../classes/CG.Stick.html">CG.Stick</a></li>
                                <li><a href="../classes/CG.Text.html">CG.Text</a></li>
                                <li><a href="../classes/CG.Translate.html">CG.Translate</a></li>
                                <li><a href="../classes/CG.Vector.html">CG.Vector</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/CG.html">CG</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: cangaja/base/entity.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * @description
 *
 * CG.Entity the base class of Cangaja
 *
 *
 &#x60;&#x60;&#x60;

        var e = new CG.Entity({
           name: &#x27;player&#x27;,
           position: new CG.Point(100,100)
         })

 &#x60;&#x60;&#x60;
 * @class CG.Entity
 * @extends CG.Class
 */

CG.Class.extend(&#x27;Entity&#x27;, {
    /**
     * Options:
     * name {string}
     * position {CG.Point}
     *
     * @constructor
     * @method init
     * @param options {Object} the name of the Entity
     */
    init: function (options) {

        CG._extend(this, {
            name: &#x27;&#x27;,
            position: new CG.Point(0, 0),
            /**
             @description visibility option
             @property visible {boolean}
             */
            visible: true,
            /**
             @description Transform object for matrix transformation
             @property transform {Transform}
             */
            transform: new Transform(),
            /**
             @property width {Number}
             */
            width: 0,
            /**
             @property height {Number}
             */
            height: 0,
            /**
             @property dragable {boolean}
             */
            dragable: true,
            /**
             @property rotation {Number}
             */
            rotation: 0,
            /**
             @property xscale {Number}
             */
            xscale: 1,
            /**
             @property xhandle {Number}
             */
            xhandle: 0,
            /**
             @property yscale {Number}
             */
            yscale: 1,
            /**
             @property yhandle {Number}
             */
            yhandle: 0,
            /**
             @property clicked {boolean}
             */
            clicked: false,
            /**
             @property hover {boolean}
             */
            hover: false,
            /**
             @property boundingradius {Number}
             */
            boundingradius: 0,     //radius for circular collision bounds
            /**
             @property mapcollision {boolean}
             */
            mapcollision: false
        })

        if (options) {
            CG._extend(this, options)
        }
        return this
    },
    update: function () {
    },
    updateMatrix: function () {
        this.transform.reset()
        this.transform.translate(this.position.x, this.position.y)
        this.transform.rotate(this.rotation * CG.Const_PI_180)
        this.transform.scale(this.xscale, this.yscale)
    },
    draw: function () {
        throw {
            name: &#x27;Entity Error&#x27;,
            message: &#x27;Subclass has no draw method.&#x27;
        }
    },
    /**
     * @description initialize image for object. for now =&gt; sprite, particle, buffer, bitmap and button use it
     * @method setImage
     * @param {image} image image path, image or atlasimage
     */
    setImage: function (image) {
        this.atlasimage = false
        if (image) {
            if (image instanceof CG.AtlasImage) {
                //AtlasImage from MediaAsset
                this.image = Game.asset.getImageByName(image.atlasname)
                this.imagerotation = image.rotation //|| 0
                this.xoffset = image.xoffset
                this.yoffset = image.yoffset
                this.width = image.width
                this.height = image.height
                this.atlasimage = true
                if (this.imagerotation !== 0) {
                    this.cutwidth = image.height
                    this.cutheight = image.width
                    this.xhandle = this.height / 2
                    this.yhandle = this.width / 2
                } else {
                    this.cutwidth = image.width
                    this.cutheight = image.height
                    this.xhandle = this.width / 2
                    this.yhandle = this.height / 2
                }
            } else if (typeof image == &#x27;string&#x27; &amp;&amp; image != &#x27;&#x27;) {
                //path to image
                this.image = new Image()
                this.image.src = image
                this.image.onload = function () {
                    this.width = this.image.width
                    this.height = this.image.height
                    this.xhandle = this.width / 2
                    this.yhandle = this.height / 2
                }
            } else {
                //image from MediaAsset
                this.image = image
                this.width = this.image.width
                this.height = this.image.height
                this.xhandle = this.width / 2
                this.yhandle = this.height / 2
            }
        }
    },
    /**
     * @description returns the bounds of rotated rectangle
     * @method AABB
     * @return {object} returns the calculated bounds
     */
    AABB: function () {
        //http://willperone.net/Code/coderr.php
        var a = this.rotation * CG.Const_PI_180,
            s = Math.sin(a),
            c = Math.cos(a)

        if (s &lt; 0) s = -s
        if (c &lt; 0) c = -c
        return {
            bw: this.height * this.xscale * s + this.width * this.yscale * c,
            bh: this.height * this.xscale * c + this.width * this.yscale * s
        }
    },
    /**
     * @description checks click inside of the rectangle, supports rotation
     * @method ifClicked
     * @return {true/false}
     */
    ifClicked: function () {
        if (CG.mousedown &amp;&amp; this.clickable) {
            var dx = CG.mouse.x - this.position.x,
                dy = CG.mouse.y - this.position.y,
                h1 = Math.sqrt(dx * dx + dy * dy),
                currA = Math.atan2(dy, dx),
                newA = currA - (this.rotation * CG.Const_PI_180),
                x2 = Math.cos(newA) * h1,
                y2 = Math.sin(newA) * h1

            if (x2 &gt; -0.5 * (this.width * this.xscale) &amp;&amp;
                x2 &lt; 0.5 * (this.width * this.xscale) &amp;&amp;
                y2 &gt; -0.5 * (this.height * this.yscale) &amp;&amp;
                y2 &lt; 0.5 * (this.height * this.yscale)) {
                this.clicked = true
                CG.mousedown = false
                return
            } else {
                this.clicked = false
            }
        }
    },
    /**
     * @description checks if the mouse/pointer is over the rectangle
     * @method ifMouseOver
     */
    ifMouseOver: function () {
        var dx = CG.mouse.x - this.position.x,
            dy = CG.mouse.y - this.position.y,
            h1 = Math.sqrt(dx * dx + dy * dy),
            currA = Math.atan2(dy, dx),
            newA = currA - (this.rotation * CG.Const_PI_180),
            x2 = Math.cos(newA) * h1,
            y2 = Math.sin(newA) * h1

        if (x2 &gt; -0.5 * (this.width * this.xscale) &amp;&amp;
            x2 &lt; 0.5 * (this.width * this.xscale) &amp;&amp;
            y2 &gt; -0.5 * (this.height * this.yscale) &amp;&amp;
            y2 &lt; 0.5 * (this.height * this.yscale)) {
            this.hover = true
            return
        } else {
            this.hover = false
        }
    },
    /**
     * @description checks if there is a collision of the given objects to this object http://devmag.org.za/2009/04/13/basic-collision-detection-in-2d-part-1/
     * @method checkCollision
     * @param objects {array} a array of objects to check for collision =&gt; Sprites, Animations, MapAreas
     * @param callback {callback} what to do after collision?
     */
    checkCollision: function (objects, callback) {
        objects.forEach(function (obj, index) {
                if (obj.className == &#x27;MapArea&#x27;) {
                    if ((this.position.y + this.AABB().bh / 2) &gt;= obj.bound.y &amp;&amp;
                        this.position.y - this.AABB().bh / 2 &lt;= (obj.bound.y + obj.bound.height) &amp;&amp;
                        (this.position.x + this.AABB().bw / 2) &gt;= obj.bound.x &amp;&amp;
                        this.position.x - this.AABB().bw / 2 &lt;= (obj.bound.x + obj.bound.width )) {
                        if (obj.type === &#x27;outer&#x27;) {

                            w = 0.5 * (this.width + obj.bound.width)
                            h = 0.5 * (this.height + obj.bound.height)
                            dx = this.position.x - (obj.bound.width / 2 + obj.bound.x)
                            dy = this.position.y - (obj.bound.height / 2 + obj.bound.y)

                            if (Math.abs(dx) &lt;= w &amp;&amp; Math.abs(dy) &lt;= h) {
                                /* collision! */
                                wy = w * dy;
                                hx = h * dx;

                                if (wy &gt; hx) {
                                    if (wy &gt; -hx) {
                                        direction = &#x27;bottom&#x27;
                                        overlap = ((this.position.y - this.AABB().bh / 2) - (obj.bound.y + obj.bound.height)) &gt;&gt; 0
                                    } else {
                                        direction = &#x27;left&#x27;
                                        overlap = ((this.position.x + this.AABB().bw / 2) - obj.bound.x) &gt;&gt; 0
                                    }
                                } else {
                                    if (wy &gt; -hx) {
                                        direction = &#x27;right&#x27;
                                        overlap = ((this.position.x - this.AABB().bw / 2) - (obj.bound.x + obj.bound.width)) &gt;&gt; 0
                                    } else {
                                        direction = &#x27;top&#x27;
                                        overlap = ((this.position.y + this.AABB().bh / 2) - obj.bound.y) &gt;&gt; 0
                                    }
                                }
                            }

                            collision = {
                                overlap: overlap,
                                direction: direction
                            }
                            //callback arguments: this =&gt; the sprite, obj =&gt; the maparea if needed, collision =&gt; {collison direction, offset}
                            callback(this, obj, collision)
                        }
                    }
                }
                else if (this.boundingradius &gt; 0 &amp;&amp; obj.boundingradius &gt; 0) {
                    //check boundingradius for circuar collision
                    distx = this.position.x - obj.position.x
                    disty = this.position.y - obj.position.y
                    dist = Math.sqrt((distx * distx) + (disty * disty))
                    if (dist &lt;= (this.boundingradius / 2 * this.xscale + obj.boundingradius / 2 * obj.yscale)) {
                        collision = false //dummy
                        callback(this, obj, collision)
                    }
                }
                else {
                    //if boundingradius is 0, fallback to bounding collision
                    if ((this.position.y + this.AABB().bh / 2) &gt;= obj.position.y - obj.AABB().bh / 2 &amp;&amp;
                        this.position.y - this.AABB().bh / 2 &lt;= (obj.position.y + obj.AABB().bh / 2) &amp;&amp;
                        (this.position.x + this.AABB().bw / 2) &gt;= obj.position.x - obj.AABB().bw / 2 &amp;&amp;
                        this.position.x - this.AABB().bw / 2 &lt;= (obj.position.x + obj.AABB().bw / 2)) {

                        w = 0.5 * (this.width + obj.width)
                        h = 0.5 * (this.height + obj.height)
                        dx = this.position.x - obj.position.x
                        dy = this.position.y - obj.position.y

                        if (Math.abs(dx) &lt;= w &amp;&amp; Math.abs(dy) &lt;= h) {
                            /* collision! */
                            wy = w * dy;
                            hx = h * dx;

                            if (wy &gt; hx) {
                                if (wy &gt; -hx) {
                                    direction = &#x27;bottom&#x27;
                                    overlap = ((this.position.y - this.AABB().bh / 2) - (obj.position.y - obj.AABB().bh / 2)) &gt;&gt; 0
                                } else {
                                    direction = &#x27;left&#x27;
                                    overlap = ((this.position.x + this.AABB().bw / 2) - (obj.position.x + obj.AABB().bw / 2)) &gt;&gt; 0
                                }
                            } else {
                                if (wy &gt; -hx) {
                                    direction = &#x27;right&#x27;
                                    overlap = ((this.position.x - this.AABB().bw / 2) - (obj.position.x - obj.AABB().bw / 2)) &gt;&gt; 0
                                } else {
                                    direction = &#x27;top&#x27;
                                    overlap = ((this.position.y + this.AABB().bh / 2) - (obj.position.y + obj.AABB().bh / 2)) &gt;&gt; 0
                                }
                            }
                        }

                        collision = {
                            overlap: overlap,
                            direction: direction
                        }

                        callback(this, obj, collision)
                    }
                }
            },
            this
        )
        return this
    }
})

function EntityException(msg) {
    this.msg = msg
    console.log(this.msg)
}

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
