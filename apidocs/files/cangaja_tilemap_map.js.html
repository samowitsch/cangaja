<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>cangaja/tilemap/map.js - Cangaja API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="Cangaja API" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Cangaja.html">Cangaja</a></li>
                                <li><a href="../classes/CG.Animation.html">CG.Animation</a></li>
                                <li><a href="../classes/CG.AtlasImage.html">CG.AtlasImage</a></li>
                                <li><a href="../classes/CG.AtlasTexturePacker.html">CG.AtlasTexturePacker</a></li>
                                <li><a href="../classes/CG.B2DBridge.html">CG.B2DBridge</a></li>
                                <li><a href="../classes/CG.B2DChainShape.html">CG.B2DChainShape</a></li>
                                <li><a href="../classes/CG.B2DCirlce.html">CG.B2DCirlce</a></li>
                                <li><a href="../classes/CG.B2DEntity.html">CG.B2DEntity</a></li>
                                <li><a href="../classes/CG.B2DLine.html">CG.B2DLine</a></li>
                                <li><a href="../classes/CG.B2DPolygon.html">CG.B2DPolygon</a></li>
                                <li><a href="../classes/CG.B2DRectangle.html">CG.B2DRectangle</a></li>
                                <li><a href="../classes/CG.B2DRope.html">CG.B2DRope</a></li>
                                <li><a href="../classes/CG.B2DTerrain.html">CG.B2DTerrain</a></li>
                                <li><a href="../classes/CG.B2DWorld.html">CG.B2DWorld</a></li>
                                <li><a href="../classes/CG.Bitmap.html">CG.Bitmap</a></li>
                                <li><a href="../classes/CG.Bound.html">CG.Bound</a></li>
                                <li><a href="../classes/CG.Buffer.html">CG.Buffer</a></li>
                                <li><a href="../classes/CG.Button.html">CG.Button</a></li>
                                <li><a href="../classes/CG.CanvasRenderer.html">CG.CanvasRenderer</a></li>
                                <li><a href="../classes/CG.Delta.html">CG.Delta</a></li>
                                <li><a href="../classes/CG.Director.html">CG.Director</a></li>
                                <li><a href="../classes/CG.Emitter.html">CG.Emitter</a></li>
                                <li><a href="../classes/CG.Entity.html">CG.Entity</a></li>
                                <li><a href="../classes/CG.Font.html">CG.Font</a></li>
                                <li><a href="../classes/CG.Game.html">CG.Game</a></li>
                                <li><a href="../classes/CG.GameController.html">CG.GameController</a></li>
                                <li><a href="../classes/CG.Layer.html">CG.Layer</a></li>
                                <li><a href="../classes/CG.Map.html">CG.Map</a></li>
                                <li><a href="../classes/CG.MapArea.html">CG.MapArea</a></li>
                                <li><a href="../classes/CG.MapPoint.html">CG.MapPoint</a></li>
                                <li><a href="../classes/CG.MapTileLayer.html">CG.MapTileLayer</a></li>
                                <li><a href="../classes/CG.MapTileProperties.html">CG.MapTileProperties</a></li>
                                <li><a href="../classes/CG.MediaAsset.html">CG.MediaAsset</a></li>
                                <li><a href="../classes/CG.Menu.html">CG.Menu</a></li>
                                <li><a href="../classes/CG.Morph.html">CG.Morph</a></li>
                                <li><a href="../classes/CG.Particle.html">CG.Particle</a></li>
                                <li><a href="../classes/CG.Point.html">CG.Point</a></li>
                                <li><a href="../classes/CG.Screen.html">CG.Screen</a></li>
                                <li><a href="../classes/CG.Sequence.html">CG.Sequence</a></li>
                                <li><a href="../classes/CG.SpineAnimation.html">CG.SpineAnimation</a></li>
                                <li><a href="../classes/CG.Sprite.html">CG.Sprite</a></li>
                                <li><a href="../classes/CG.Stick.html">CG.Stick</a></li>
                                <li><a href="../classes/CG.Text.html">CG.Text</a></li>
                                <li><a href="../classes/CG.Translate.html">CG.Translate</a></li>
                                <li><a href="../classes/CG.Vector.html">CG.Vector</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/CG.html">CG</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: cangaja/tilemap/map.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * @description
 *
 * CG.Map supports loading and rendering maps from the editor Tiled.
 * XML and JSON file types are supported.
 * XML =&gt; supported tiled encodings are csv and xml (see settings!). base64, base64(gzip) and base64(zlib) are not supported!
 *
 * Supported types of the object layer are:
 * - object/group (rectangle?)
 * - tile element, reference point is bottom/left of the tile in the editor
 *
 * These object layer types are used to generate Point and Bound objects and can be used to position sprites, what ever in the map.
 *
 * @class CG.Map
 * @extends CG.Entity
 *
 * TODO spacing and margin ?
 * TODO own buffer for drawing =&gt; split screen possible?
 * TODO update &amp; draw method 50%
 *
 */
CG.Entity.extend(&#x27;Map&#x27;, {
    /**
     * @method init
     * @constructor
     * @return {*}
     */
    init: function (options) {
        this._super()
        this.instanceOf = &#x27;Map&#x27;

        /**
         * @property elements
         * @type {Array}
         */
        this.elements = [] //how handle elements in maps? experimental collision detection at the moment with only one
        //point and areas from tilemap editor
        //using as references for external objects in layers?
        //how to handle the relative position to the position of the map?

        /**
         * @property points
         * @type {Array}
         */
        this.points = [] // position points (tiles) of tilemap editor =&gt; position point and type?
        /**
         * @property areas
         * @type {Array}
         */
        this.areas = [] // group objects e.g. area for objects of tilemap editor =&gt; bound and type?
        /**
         * @property position
         * @type {CG.Point}
         */
        this.position = new CG.Point(0, 0) // needed as relative point for points and areas
        /**
         * @property mapOffset
         * @type {CG.Point}
         */
        this.mapOffset = new CG.Point(0, 0)
        /**
         * @property animDelayFactor
         * @type {Number}
         */
        this.animDelayFactor = 20
        /**
         * @property atlas
         * @type {Image}
         */
        this.atlas = new Image()
        /**
         * @property atlaswidth
         * @type {Number}
         */
        this.atlaswidth = 0
        /**
         * @property atlasheight
         * @type {Number}
         */
        this.atlasheight = 0
        /**
         * @property atlastranscol
         * @type {String}
         */
        this.atlastranscol = &#x27;&#x27; //
        //ejecta and cocoonjs has no DOMParser!
        if (typeof ejecta === &#x27;undefined&#x27; &amp;&amp; !navigator.isCocoonJS) {
            /**
             * @property xml
             * @type {String}
             */
            this.xml = &#x27;&#x27;
            /**
             * @property parser
             * @type {DOMParser}
             */
            this.parser = new DOMParser()
            /**
             * @property xmlDoc
             * @type {String}
             */
            this.xmlDoc = &#x27;&#x27;
        }
        /**
         * @property json
         * @type {Object}
         */
        this.json = {}
        /**
         * @description
         *
         * The tiled layer are parsed into separate layers
         *
         * @property layers
         * @type {Array}
         */
        this.layers = [] //can contain maptilelayer or objectlayer
        /**
         * @description
         *
         * Defines the layer to draw:
         * all - for all layers
         * name - the name of layer to draw
         * index - array index of layer
         *
         * @property renderlayer
         * @type {String}
         */
        this.renderlayer = &#x27;all&#x27; //render layer: all for all layers, name of layer or array index for example 0 ;o)
        /**
         * @property tileproperties
         * @type {Array}
         */
        this.tileproperties = [] //properties of the tiles
        /**
         * @property orientation
         * @type {String}
         */
        this.orientation = &#x27;&#x27;
        /**
         * @property width
         * @type {Number}
         */
        this.width = 0
        /**
         * @property height
         * @type {Number}
         */
        this.height = 0
        /**
         * @property mapColumns
         * @type {Number}
         */
        this.mapColumns = 0
        /**
         * @property mapRows
         * @type {Number}
         */
        this.mapRows = 0
        /**
         * @property tilewidth
         * @type {Number}
         */
        this.tilewidth = 0
        /**
         * @property tileheight
         * @type {Number}
         */
        this.tileheight = 0
        /**
         * @property tileset
         * @type {Object}
         */
        this.tileset = {
            tilewidth: 0,
            tileheight: 0,
            offsetx: 0,
            offsety: 0,
            spacing: 0,
            margin: 0
        }
        /**
         * @property xspeed
         * @type {Number}
         */
        this.xspeed = 0
        /**
         * @property yspeed
         * @type {Number}
         */
        this.yspeed = 0
        /**
         * @property xscale
         * @type {Number}
         */
        this.xscale = 1
        /**
         * @property yscale
         * @type {Number}
         */
        this.yscale = 1
        /**
         * @property alpha
         * @type {Number}
         */
        this.alpha = 1
        /**
         * @property wrapX
         * @deprecated
         * @type {Boolean}
         */
        this.wrapX = false //stuff from diddy?
        /**
         * @property wrapY
         * @deprecated
         * @type {Boolean}
         */
        this.wrapY = false //stuff from diddy?
        /**
         * @property layertocheck
         * @type {Number}
         */
        this.layertocheck = 0 //as default use layer 0 for collision detection

        CG._extend(this, options)

        return this
    },
    /**
     * @description
     *
     * Load and parse an xml tilemap file. It can handle the tiled XML and CSV format.
     * All other formats are not supported!
     *
     * @method loadMapXml
     * @param xmlfile {string/object} xmlfile path or mediaasset object with data of tiled map xml
     */
    loadMapXml: function (xmlfile) {
        this.layers = []

        //from asset
        if (typeof xmlfile == &#x27;string&#x27;) {
            this.xml = loadString(xmlfile)
        } else {
            this.xml = xmlfile.data
        }
        this.removeJsonData()

        this.xmlDoc = this.parser.parseFromString(this.xml, &#x27;text/xml&#x27;)

        //get map
        var tilemap = map.xmlDoc.getElementsByTagName(&#x27;map&#x27;)[0]
        this.orientation = tilemap.getAttribute(&#x27;orientation&#x27;)
        this.mapColumns = parseInt(tilemap.getAttribute(&#x27;width&#x27;))
        this.mapRows = parseInt(tilemap.getAttribute(&#x27;height&#x27;))
        this.tilewidth = parseInt(tilemap.getAttribute(&#x27;tilewidth&#x27;))
        this.tileheight = parseInt(tilemap.getAttribute(&#x27;tileheight&#x27;))

        var childcount = tilemap.childElementCount

        //tilemap.firstElementChild.nextElementSibling.nextElementSibling
        var element = tilemap.firstElementChild
        for (var i = 0; i &lt; childcount; i++) {
            console.log(&#x27;&gt;&#x27; + element.nodeName)
            switch (element.nodeName) {
                case &#x27;tileset&#x27;:
                    //read tileset settings
                    //only one tileset for the moment
                    this.tileset.tilewidth = parseInt(element.getAttribute(&#x27;tilewidth&#x27;))
                    this.tileset.tileheight = parseInt(element.getAttribute(&#x27;tileheight&#x27;))
                    if (element.getAttribute(&#x27;spacing&#x27;)) {
                        this.tileset.spacing = parseInt(element.getAttribute(&#x27;spacing&#x27;))
                    }
                    if (element.getAttribute(&#x27;margin&#x27;)) {
                        this.tileset.margin = parseInt(element.getAttribute(&#x27;margin&#x27;))
                    }
                    if (element.getElementsByTagName(&#x27;tileoffset&#x27;)[0]) {
                        this.tileset.offsetx = parseInt(element.getElementsByTagName(&#x27;tileoffset&#x27;)[0].getAttribute(&#x27;x&#x27;))
                        this.tileset.offsety = parseInt(element.getElementsByTagName(&#x27;tileoffset&#x27;)[0].getAttribute(&#x27;y&#x27;))
                    }
                    var image = element.getElementsByTagName(&#x27;image&#x27;)[0]
                    this.atlas.src = &#x27;media/map/&#x27; + image.getAttribute(&#x27;source&#x27;)

                    this.atlaswidth = parseInt(image.getAttribute(&#x27;width&#x27;))
                    this.atlasheight = parseInt(image.getAttribute(&#x27;height&#x27;))
                    this.atlastranscol = image.getAttribute(&#x27;trans&#x27;)

                    break
                case &#x27;layer&#x27;:
                    //get tilemap data of layer
                    var tl = new CG.MapTileLayer()
                    data = element.getElementsByTagName(&#x27;data&#x27;)[0]

                    if (data.getAttribute(&#x27;encoding&#x27;) == &#x27;csv&#x27;) {
                        tl.tiles = data.textContent.replace(/(\r\n|\n|\r)/gm, &#x27;&#x27;).split(&#x27;,&#x27;)
                        console.log(&#x27;map encoding csv [layer &#x27; + i + &#x27;]&#x27;)
                    } else if (data.getAttribute(&#x27;encoding&#x27;) == &#x27;base64&#x27; &amp;&amp; data.getAttribute(&#x27;compression&#x27;) == &#x27;gzip&#x27;) {
                        throw &#x27;base64 gzip compressed map format not supported at the moment&#x27;
                    } else if (data.getAttribute(&#x27;encoding&#x27;) == &#x27;base64&#x27; &amp;&amp; data.getAttribute(&#x27;compression&#x27;) == &#x27;zlib&#x27;) {
                        throw &#x27;base64 zlib compressed map format not supported at the moment&#x27;
                    } else if (data.getAttribute(&#x27;encoding&#x27;) == &#x27;base64&#x27;) {
                        throw &#x27;base64 map format not supported at the moment&#x27;
                    } else {
                        console.log(&#x27;map encoding xml [layer &#x27; + i + &#x27;]&#x27;)
                        var tiles = element.getElementsByTagName(&#x27;tile&#x27;)
                        for (x in tiles) {
                            if (x &lt; tiles.length) {
                                tl.tiles[x] = parseInt(tiles[x].getAttribute(&#x27;gid&#x27;))
                            }
                        }
                    }

                    tl.name = element.getAttribute(&#x27;name&#x27;)
                    tl.width = parseInt(element.getAttribute(&#x27;width&#x27;))
                    tl.height = parseInt(element.getAttribute(&#x27;height&#x27;))
                    if (element.getAttribute(&#x27;opacity&#x27;)) {
                        tl.opacity = parseFloat(element.getAttribute(&#x27;opacity&#x27;))
                    }
                    if (element.getAttribute(&#x27;visible&#x27;) === &#x27;0&#x27;) {
                        tl.visible = false
                    }
                    this.layers.push(tl)
                    break
                case &#x27;objectgroup&#x27;:
                    //get tilemap data of grouplayer
                    console.log(&#x27;grouplayer found&#x27;)
                    var objects = element.getElementsByTagName(&#x27;object&#x27;)
                    for (o in objects) {
                        if (o &lt; objects.length) {
                            var obj = objects[o]
                            var name = obj.getAttribute(&#x27;name&#x27;)
                            if (obj.getAttribute(&#x27;gid&#x27;)) {
                                //tile as object/point
                                this.points.push(
                                    new CG.MapPoint({
                                        position: new CG.Point(
                                            parseInt(obj.getAttribute(&#x27;x&#x27;)),
                                            parseInt(obj.getAttribute(&#x27;y&#x27;))
                                        ),
                                        mapOffset: this.position,
                                        name: obj.getAttribute(&#x27;name&#x27;),
                                        gid: parseInt(obj.getAttribute(&#x27;gid&#x27;))
                                    })
                                )
                                console.log(&#x27;tile as oject found: &#x27; + name)
                                console.log(obj)
                            } else if (obj.getAttribute(&#x27;width&#x27;)) {
                                type = false
                                properties = obj.getElementsByTagName(&#x27;property&#x27;)
                                console.log(properties.length)
                                for (var p = 0, l = properties.length; p &lt; l; p++) {
                                    if (properties[p].getAttribute(&#x27;name&#x27;) == &#x27;type&#x27;) {
                                        type = properties[p].getAttribute(&#x27;value&#x27;)
                                    }
                                }

                                //object group
                                this.areas.push(
                                    new CG.MapArea({
                                        bound: new CG.Bound({
                                            x: parseInt(obj.getAttribute(&#x27;x&#x27;)),
                                            y: parseInt(obj.getAttribute(&#x27;y&#x27;)),
                                            width: parseInt(obj.getAttribute(&#x27;width&#x27;)),
                                            height: parseInt(obj.getAttribute(&#x27;height&#x27;))
                                        }),
                                        mapOffset: this.position,
                                        name: obj.getAttribute(&#x27;name&#x27;),
                                        type: type
                                    })
                                )
                                console.log(&#x27;group object found: &#x27; + name)
                                console.log(obj)
                            } else if (obj.getElementsByTagName(&#x27;polygon&#x27;).length &gt; 0) {
                                console.log(&#x27;polygon found: &#x27; + name)
                            } else if (obj.getElementsByTagName(&#x27;polyline&#x27;).length &gt; 0) {
                                console.log(&#x27;polyline found: &#x27; + name)
                            }
                        }
                    }
                    break

            }
            element = element.nextElementSibling
        }


        //get tile properties
        this.tileproperties = Array(parseInt((this.atlaswidth / this.tilewidth)) * parseInt((this.atlasheight / this.tileheight)))
        var tiles = map.xmlDoc.getElementsByTagName(&#x27;tileset&#x27;)[0].getElementsByTagName(&#x27;tile&#x27;)
        var time = new Date().getTime()
        for (i in tiles) {
            var tprop = new CG.MapTileProperties()
            var tile = tiles[i]

            if (i &lt; this.tileproperties.length) {
                var id = tile.getAttribute(&#x27;id&#x27;)
                var properties = tile.getElementsByTagName(&#x27;properties&#x27;)[0].getElementsByTagName(&#x27;property&#x27;)
                for (p in properties) {
                    if (p &lt; properties.length) {
                        var tp = properties[p]
                        var elem = tp.getAttribute(&#x27;name&#x27;)
                        var value = tp.getAttribute(&#x27;value&#x27;)
                        if (elem == &#x27;name&#x27;) {
                            tprop.name = value
                        } else if (elem == &#x27;anim_delay&#x27;) {
                            tprop.animDelay = parseInt(value)
                            tprop.delayTimer = time
                        } else if (elem == &#x27;anim_direction&#x27;) {
                            tprop.animDirection = parseInt(value)
                        } else if (elem == &#x27;anim_next&#x27;) {
                            tprop.animNext = parseInt(value)
                        }
                    }
                }
                this.tileproperties[id] = tprop
            }
        }
        return this
    },

    /**
     * @description
     *
     * Load and parse an tilemap json file. Use the tiled json export.
     * Hopefully the json format has the same functionality as the xml loader ;o)
     *
     * @method loadMapJson
     * @param jsonfile {string/object} jsonfile path or mediaasset object with data of tiled map xml
     */
    loadMapJson: function (jsonfile) {
        this.layers = []

        //from asset
        if (typeof jsonfile == &#x27;string&#x27;) {
            this.json = JSON.parse(loadString(jsonfile))
        } else {
            this.json = jsonfile.data
        }

        this.removeXmlData()

        //get map
        this.orientation = this.json.orientation
        this.mapColumns = this.json.width
        this.mapRows = this.json.height
        this.tilewidth = this.json.tilewidth
        this.tileheight = this.json.tileheight

        //tilesets
        for (i = 0, l = this.json.layers.length; i &lt; l; i++) {
            switch (this.json.layers[i].type) {
                case &#x27;tilelayer&#x27;:
                    //get tilemap data of layer
                    var tl = new CG.MapTileLayer()
                    tl.tiles = this.json.layers[i].data
                    tl.name = this.json.layers[i].name
                    tl.width = this.json.layers[i].width
                    tl.height = this.json.layers[i].height
                    tl.opacity = this.json.layers[i].opacity
                    tl.visible = this.json.layers[i].visible
                    this.layers.push(tl)
                    break
                case &#x27;objectgroup&#x27;:
                    //get tilemap data of grouplayer
                    console.log(&#x27;grouplayer found&#x27;)
                    var objects = this.json.layers[i].objects
                    for (o in objects) {
                        if (o &lt; objects.length) {
                            var obj = objects[o]
                            var name = obj.name
                            if (obj.gid) {
                                //tile as object/point
                                this.points.push(
                                    new CG.MapPoint({
                                        position: new CG.Point(
                                            parseInt(obj.x),
                                            parseInt(obj.y)
                                        ),
                                        mapOffset: this.position,
                                        name: obj.name,
                                        gid: parseInt(obj.gid)
                                    })
                                )

                                console.log(&#x27;tile as oject found: &#x27; + name)
                                console.log(obj)
                            } else if (obj.width) {
                                //object group
                                this.areas.push(
                                    new CG.MapArea({
                                        bound: new CG.Bound({
                                            x: parseInt(obj.x),
                                            y: parseInt(obj.y),
                                            width: parseInt(obj.width),
                                            height: parseInt(obj.height)
                                        }),
                                        mapOffset: this.position,
                                        name: obj.name,
                                        type: obj.properties.type
                                    })
                                )

                                console.log(&#x27;group object found: &#x27; + name)
                                console.log(obj)
                            } else if (obj.polygon) {
                                console.log(&#x27;polygon found: &#x27; + name)
                            } else if (obj.polyline) {
                                console.log(&#x27;polyline found: &#x27; + name)
                            }
                        }
                    }
                    break

            }
        }


        //get tile properties
        this.atlas.src = &#x27;media/map/&#x27; + this.json.tilesets[0].image

        this.atlaswidth = this.json.tilesets[0].imagewidth
        this.atlasheight = this.json.tilesets[0].imageheight
        this.atlastranscol = this.json.tilesets[0].transparentcolor

        this.tileproperties = Array(parseInt((this.atlaswidth / this.tilewidth)) * parseInt((this.atlasheight / this.tileheight)))
        var tiles = this.json.tilesets[0].tileproperties

        var time = new Date().getTime()

        for (id in tiles) {
            var tprop = new CG.MapTileProperties()
            var tile = tiles[id]
            tprop.name = tile.name
            tprop.animDelay = parseInt(tile.anim_delay)
            tprop.delayTimer = (tprop.animDelay &gt; 0) ? time : 0
            tprop.animNext = parseInt(tile.anim_next)
            tprop.animDirection = parseInt(tile.anim_direction)
            this.tileproperties[id] = tprop

        }
        return this
    },


    /**
     * @description
     *
     * This is the main method for map drawing. Orthogonal maps works very well. Isometric maps are not well implemented yet.
     *
     * @method drawMap
     *
     * @param sx {Number} sx top left coord for canvas drawing
     * @param sy {Number} sy top left coord for canvas drawing
     * @param bx {Number} bx top left x coord of bound in tilemap
     * @param by {Number} by top left y coord of bound in tilemap
     * @param bw {Number} bw width of bound in tilemap
     * @param bh {Number} bh height of bound in tilemap
     * @param callback {callback} callback for collision handling - callback(obj,maptileproperties)
     */
    drawMap: function (sx, sy, bx, by, bw, bh, callback) {
        this.bx = bx
        this.by = by
        this.bw = bw
        this.bh = bh
        this.sx = sx
        this.sy = sy
        this.callback = callback || false

        //for renderer
        this.rx = 0
        this.ry = 0
        this.cx = 0
        this.cy = 0
        this.xpos = 0
        this.ypos = 0
        this.layer = 0

        //update all points an areas
        this.updatePointsAndAreas()

        if (this.visible) {
            this.updateAnimation()
            if (this.layers.length &gt; 0) {
                for (var layer = 0, l = this.layers.length; layer &lt; l; layer++) {
                    var tl = this.layers[layer]
                    //render control, render by name, layer number or &#x27;all&#x27;&#x27;
                    if (this.renderlayer === tl.name || this.renderlayer === layer || this.renderlayer === &#x27;all&#x27;) {
                        // MAP ORTHOGONAL
                        if (this.orientation == &#x27;orthogonal&#x27; &amp;&amp; tl.visible == true) {
                            var modx = (this.bx * this.xscale) % this.tilewidth,
                                mody = (this.by * this.yscale) % this.tileheight,
                                y = this.by,
                                my = Math.floor(this.by / this.tileheight),
                                tmpy = (this.by + this.bh + this.tileheight)

                            while (y &lt; tmpy) {
                                var x = this.bx, //- this.tilewidth
                                    mx = Math.floor(this.bx / this.tilewidth),
                                    tmpx = this.bx + this.bw + this.tilewidth
                                while (x &lt; tmpx) {
                                    if ((this.wrapX || (mx &gt;= 0 &amp;&amp; mx &lt; this.mapColumns)) &amp;&amp; (this.wrapY || (my &gt;= 0 &amp;&amp; my &lt; this.mapRows))) {
                                        var mx2 = mx,
                                            my2 = my

                                        while (mx2 &lt; 0) {
                                            mx2 += this.width
                                        }

                                        while (mx2 &gt;= this.width) {
                                            mx2 -= this.width
                                        }

                                        while (my2 &lt; 0) {
                                            my2 += this.height
                                        }

                                        while (my2 &gt;= this.height) {
                                            my2 -= this.height
                                        }

                                        gid = tl.tiles[mx2 + my2 * tl.width] - 1

                                        if (gid &gt;= 0) {
                                            if (modx &lt; 0) {
                                                modx += this.tilewidth
                                            }
                                            if (mody &lt; 0) {
                                                mody += this.tileheight
                                            }
                                            this.rx = x - modx - this.bx
                                            this.ry = y - mody - this.by


                                            //time for collision detection?
                                            //limit to specific tilemap layer?
                                            //collision depending on bounds and direction (xspeed/yspeed)?
                                            //include some layer functionality here and render some sprites between map layers?
                                            if (this.elements.length &gt; 0 &amp;&amp; this.layertocheck == l) {
                                                for (var o = 0, l = this.elements.length; o &lt; l; o++) {
                                                    if (this.checkMapCollision(this.elements[0], this.rx, this.ry)) {
                                                        this.callback(this.elements[o], this.tileproperties[gid])
                                                    }
                                                }
                                            }


                                            //margin/spacing?
                                            this.cx = (gid % (this.atlaswidth / this.tilewidth)) * this.tilewidth
                                            this.cy = Math.floor(this.tilewidth * gid / this.atlaswidth) * this.tileheight

                                            Game.renderer.draw(this)
                                        }

                                    }
                                    x = x + this.tilewidth
                                    mx += 1
                                }
                                y = y + this.tileheight
                                my += 1
                            }
                        }
                        // MAP ISOMETRIC
                        else if (this.orientation == &#x27;isometric&#x27;) {
                            var t = tl.width + tl.height
                            for (var y = 0; y &lt; t; y++) {
                                var ry = y,
                                    rx = 0
                                while (ry &gt;= tl.height) {
                                    ry -= 1
                                    rx += 1
                                }


                                while (ry &gt;= 0 &amp;&amp; rx &lt; tl.width) {
                                    var gid = tl.tiles[rx + ry * tl.width]
                                    this.rx = (rx - ry - 1) * this.tilewidth / 2 - bx
                                    this.ry = (rx + ry + 1) * this.tileheight / 2 - by
                                    if (this.rx &gt; -this.tileset.tilewidth &amp;&amp; this.rx &lt; bw &amp;&amp; this.ry &gt; -this.tileset.tileheight &amp;&amp; this.ry &lt; bh) {
                                        if (gid &gt; 0) {
                                            this.cx = ((gid - 1) % (this.atlaswidth / this.tilewidth)) * this.tilewidth
                                            this.cy = Math.floor(this.tilewidth * (gid - 1) / this.atlaswidth) * this.tileset.tileheight

                                            Game.renderer.draw(this)

                                        }
                                    }
                                    ry -= 1
                                    rx += 1
                                }
                            }
                        }
                    }
                }
            }
        }
    },

    /**
     * @description
     *
     * Update all areas and points elements.
     *
     * @method updatePointsAndAreas
     */
    updatePointsAndAreas: function () {
        this.points.forEach(function (point, index) {
            point.update(this.mapOffset)
        }, this)
        this.areas.forEach(function (area, index) {
            area.update(this.mapOffset)
        }, this)
    },


    /**
     * @description
     *
     * Get all point(s) with the given name in the points
     *
     * @method getPointsByName
     *
     * @param name {string} name of the points to return
     * @return {false/array} returns false or an array with point(s)
     */
    getPointsByName: function (name) {
        points = []
        for (var i = 0, l = this.points.length; i &lt; l; i++) {
            if (this.points[i].name === name) {
                points.push(this.points[i])
            }
        }
        if (points.length &gt; 0) {
            return points
        }
        return false
    },

    /**
     * @description
     *
     * Get all areas with the given name
     *
     * @method getAreasByName
     *
     * @param name {string} name of the area(s) to return
     * @return {false/array} returns false or an array with area(s)
     */
    getAreasByName: function (name) {
        areas = []
        for (var i = 0, l = this.areas.length; i &lt; l; i++) {
            if (this.areas[i].name === name) {
                areas.push(this.areas[i])
            }
        }
        if (areas.length &gt; 0) {
            return areas
        }
        return false
    },


    /**
     * @description
     *
     * Defines layer drawing, See property options
     *
     * @method setLayerToRender
     *
     * @param mixed {mixed} mixed define the map layer(s) to render &#x27;all&#x27; (string) for all layers, array index (integer) for layer to render or &#x27;name&#x27; (string) of layer to render&#x27;
     */
    setLayerToRender: function (mixed) {
        this.renderlayer = mixed
        return this
    },

    /**
     * @description
     *
     * The update method is not complete yet and only experimental.
     * At the final stage the methods updateAnimation and updatePointsAndAreas have to be called from here!
     * Then also a map class can be added to a layer as an element for auto update/draw from Game.director!
     *
     * @method update
     */
    update: function () {
        ////TODO automatic movement of map or other stuff?
        //this.bx += this.xspeed
        //this.by += this.yspeed
        //if (this.getBounds().width - Game.bound.width &lt; this.mapOffset.x) {
        //    this.xspeed = this.xspeed * -1
        //}
        //if (this.mapOffset.x &lt; 0) {
        //    this.xspeed = this.xspeed * -1
        //}
        //if (this.getBounds().height - Game.bound.height &lt; this.mapOffset.y) {
        //    this.yspeed = this.yspeed * -1
        //}
        //if (this.mapOffset.y &lt; 0) {
        //    this.yspeed = this.yspeed * -1
        //}
        //return this
    },

    // just calls drawMap ;o)
    draw: function () {
        this.drawMap(this.position.x, this.position.y, this.mapOffset.x, this.mapOffset.y, this.width, this.height, this.callback)
        return this
    },

    /**
     * @description
     *
     * Get the bounds of the map
     *
     * @method getBounds
     */
    getBounds: function () {
        return {
            width: this.width * this.tilewidth,
            height: this.height * this.tileheight
        }
    },

    /**
     * @description
     *
     * Updates all tilemap properties of the map.
     *
     * Supported custom tiled map properties for now are (see also tilemap examples):
     * anim_delay       =&gt; time to used to display an switch to next tile
     * anim_direction   =&gt; direction for next tile 1 = jump forward, -1 = jump back
     * anim_next        =&gt; defines the offset
     *
     * With this tile properties it is possible to define tilemap animations.
     * These must be defined in the tilemap property window with key/value pairs
     *
     * @method updateAnimation
     */
    updateAnimation: function () {
        if (this.layers.length &gt; 0) {
            for (var layer = 0, l = this.layers.length; layer &lt; l; layer++) {
                var newtime = new Date().getTime()
                for (var t = 0, tl = this.layers[layer].tiles.length; t &lt; tl; t++) {
                    var tile = this.layers[layer].tiles[t]
                    if (tile &gt; 0) {
                        var tprop = this.tileproperties[tile - 1]
                        if (tprop) {
                            if (newtime &gt; (tprop.delayTimer + (tprop.animDelay / this.animDelayFactor))) {
                                switch (tprop.animDirection) {
                                    case 1:
                                        this.layers[layer].tiles[t] += tprop.animNext
                                        this.tileproperties[tile - 1 + tprop.animNext].delayTimer = newtime
                                        break
                                    case -1:
                                        this.layers[layer].tiles[t] -= tprop.animNext
                                        this.tileproperties[tile - 1 - tprop.animNext].delayTimer = newtime
                                        break
                                    default:
                                        break
                                }
                            }
                        }
                    }
                }
            }
        }
    },

    /**
     * @description
     *
     * Adds a object to the element array, used at the moment for collision detection to tilemap.
     *
     * @method addElement
     *
     * @param {obj} element to to add to elements array
     */
    addElement: function (element) {
        this.elements.push(element)
        return this
    },

    /**
     * @description
     * Checks if the attached element collides with an tile of the tilemap
     *
     * @method checkMapCollision
     *
     * @param {obj} element to check for
     * @param {Number} rx current rx of rendermap method
     * @param {Number} ry current ry of rendermap method
     *
     * @return {boolean} returns true or false
     */
    checkMapCollision: function (element, rx, ry) {
        //TODO return detailed collision object or offsets instead of true?
        if (element.boundingradius &gt; 0) {
            //circular collision
            var xr = element.boundingradius / 2 * element.xscale
            var yr = element.boundingradius / 2 * element.yscale
            if (element.position.x + xr &gt;= rx &amp;&amp; element.position.x - xr &lt;= rx + this.tilewidth &amp;&amp; element.position.y + yr &gt;= ry &amp;&amp; element.position.y - yr &lt;= ry + this.tileheight) {
                return true
            }
        } else {
            //bounding collision
            var xw = element.width / 2 * element.xscale
            var yh = element.height / 2 * element.yscale
            if (element.position.x + xw &gt;= rx &amp;&amp; element.position.x - xw &lt;= rx + this.tilewidth &amp;&amp; element.position.y + yh &gt;= ry &amp;&amp; element.position.y - yh &lt;= ry + this.tileheight) {
                return true
            }
        }
        return false
    },

    /**
     * @description
     * Checks if a external object(s) collides with the areas of the tiled map.
     * This can be elements from an layer or the map itself.
     *
     * @method checkElementsToAreasCollision
     *
     * @param {Array} objarray to check for a areas collision
     * @param {Callback} callback what should happen
     */
    checkElementsToAreasCollision: function (objarray, callback) {
        for (var o = 0, ol = objarray.length; o &lt; ol; o++) {

            obj = objarray[o].checkCollision(this.areas, callback)
        }
        return this
    },
    /**
     * @description removes the json data of the map object
     * @method removeJsonData
     */
    removeJsonData: function () {
        this.json = {}
        return this
    },
    /**
     * @description removes the xml data of the map object
     * @method removeXmlData
     */
    removeXmlData: function () {
        this.xml = &#x27;&#x27;
        //this.parser = new DOMParser()
        this.xmlDoc = &#x27;&#x27;
        return this
    }
})



    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
