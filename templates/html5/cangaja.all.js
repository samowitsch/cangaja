//     keymaster.js
//     (c) 2011-2012 Thomas Fuchs
//     keymaster.js may be freely distributed under the MIT license.

;(function(global){
  var k,
    _handlers = {},
    _mods = { 16: false, 18: false, 17: false, 91: false },
    _scope = 'all',
    // modifier keys
    _MODIFIERS = {
      '‚áß': 16, shift: 16,
      '‚å•': 18, alt: 18, option: 18,
      '‚åÉ': 17, ctrl: 17, control: 17,
      '‚åò': 91, command: 91
    },
    // special keys
    _MAP = {
      backspace: 8, tab: 9, clear: 12,
      enter: 13, 'return': 13,
      esc: 27, escape: 27, space: 32,
      left: 37, up: 38,
      right: 39, down: 40,
      del: 46, 'delete': 46,
      home: 36, end: 35,
      pageup: 33, pagedown: 34,
      ',': 188, '.': 190, '/': 191,
      '`': 192, '-': 189, '=': 187,
      ';': 186, '\'': 222,
      '[': 219, ']': 221, '\\': 220
    },
    code = function(x){
      return _MAP[x] || x.toUpperCase().charCodeAt(0);
    },
    _downKeys = [];

  for(k=1;k<20;k++) _MAP['f'+k] = 111+k;

  // IE doesn't support Array#indexOf, so have a simple replacement
  function index(array, item){
    var i = array.length;
    while(i--) if(array[i]===item) return i;
    return -1;
  }

  // for comparing mods before unassignment
  function compareArray(a1, a2) {
    if (a1.length != a2.length) return false;
    for (var i = 0; i < a1.length; i++) {
        if (a1[i] !== a2[i]) return false;
    }
    return true;
  }

  var modifierMap = {
      16:'shiftKey',
      18:'altKey',
      17:'ctrlKey',
      91:'metaKey'
  };
  function updateModifierKey(event) {
      for(k in _mods) _mods[k] = event[modifierMap[k]];
  };

  // handle keydown event
  function dispatch(event) {
    var key, handler, k, i, modifiersMatch, scope;
    key = event.keyCode;

    if (index(_downKeys, key) == -1) {
        _downKeys.push(key);
    }

    // if a modifier key, set the key.<modifierkeyname> property to true and return
    if(key == 93 || key == 224) key = 91; // right command on webkit, command on Gecko
    if(key in _mods) {
      _mods[key] = true;
      // 'assignKey' from inside this closure is exported to window.key
      for(k in _MODIFIERS) if(_MODIFIERS[k] == key) assignKey[k] = true;
      return;
    }
    updateModifierKey(event);

    // see if we need to ignore the keypress (filter() can can be overridden)
    // by default ignore key presses if a select, textarea, or input is focused
    if(!assignKey.filter.call(this, event)) return;

    // abort if no potentially matching shortcuts found
    if (!(key in _handlers)) return;

    scope = getScope();

    // for each potential shortcut
    for (i = 0; i < _handlers[key].length; i++) {
      handler = _handlers[key][i];

      // see if it's in the current scope
      if(handler.scope == scope || handler.scope == 'all'){
        // check if modifiers match if any
        modifiersMatch = handler.mods.length > 0;
        for(k in _mods)
          if((!_mods[k] && index(handler.mods, +k) > -1) ||
            (_mods[k] && index(handler.mods, +k) == -1)) modifiersMatch = false;
        // call the handler and stop the event if neccessary
        if((handler.mods.length == 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91]) || modifiersMatch){
          if(handler.method(event, handler)===false){
            if(event.preventDefault) event.preventDefault();
              else event.returnValue = false;
            if(event.stopPropagation) event.stopPropagation();
            if(event.cancelBubble) event.cancelBubble = true;
          }
        }
      }
    }
  };

  // unset modifier keys on keyup
  function clearModifier(event){
    var key = event.keyCode, k,
        i = index(_downKeys, key);

    // remove key from _downKeys
    if (i >= 0) {
        _downKeys.splice(i, 1);
    }

    if(key == 93 || key == 224) key = 91;
    if(key in _mods) {
      _mods[key] = false;
      for(k in _MODIFIERS) if(_MODIFIERS[k] == key) assignKey[k] = false;
    }
  };

  function resetModifiers() {
    for(k in _mods) _mods[k] = false;
    for(k in _MODIFIERS) assignKey[k] = false;
  };

  // parse and assign shortcut
  function assignKey(key, scope, method){
    var keys, mods;
    keys = getKeys(key);
    if (method === undefined) {
      method = scope;
      scope = 'all';
    }

    // for each shortcut
    for (var i = 0; i < keys.length; i++) {
      // set modifier keys if any
      mods = [];
      key = keys[i].split('+');
      if (key.length > 1){
        mods = getMods(key);
        key = [key[key.length-1]];
      }
      // convert to keycode and...
      key = key[0]
      key = code(key);
      // ...store handler
      if (!(key in _handlers)) _handlers[key] = [];
      _handlers[key].push({ shortcut: keys[i], scope: scope, method: method, key: keys[i], mods: mods });
    }
  };

  // unbind all handlers for given key in current scope
  function unbindKey(key, scope) {
    var multipleKeys, keys,
      mods = [],
      i, j, obj;

    multipleKeys = getKeys(key);

    for (j = 0; j < multipleKeys.length; j++) {
      keys = multipleKeys[j].split('+');

      if (keys.length > 1) {
        mods = getMods(keys);
        key = keys[keys.length - 1];
      }

      key = code(key);

      if (scope === undefined) {
        scope = getScope();
      }
      if (!_handlers[key]) {
        return;
      }
      for (i in _handlers[key]) {
        obj = _handlers[key][i];
        // only clear handlers if correct scope and mods match
        if (obj.scope === scope && compareArray(obj.mods, mods)) {
          _handlers[key][i] = {};
        }
      }
    }
  };

  // Returns true if the key with code 'keyCode' is currently down
  // Converts strings into key codes.
  function isPressed(keyCode) {
      if (typeof(keyCode)=='string') {
        keyCode = code(keyCode);
      }
      return index(_downKeys, keyCode) != -1;
  }

  function getPressedKeyCodes() {
      return _downKeys.slice(0);
  }

  function filter(event){
    var tagName = (event.target || event.srcElement).tagName;
    // ignore keypressed in any elements that support keyboard data input
    return !(tagName == 'INPUT' || tagName == 'SELECT' || tagName == 'TEXTAREA');
  }

  // initialize key.<modifier> to false
  for(k in _MODIFIERS) assignKey[k] = false;

  // set current scope (default 'all')
  function setScope(scope){ _scope = scope || 'all' };
  function getScope(){ return _scope || 'all' };

  // delete all handlers for a given scope
  function deleteScope(scope){
    var key, handlers, i;

    for (key in _handlers) {
      handlers = _handlers[key];
      for (i = 0; i < handlers.length; ) {
        if (handlers[i].scope === scope) handlers.splice(i, 1);
        else i++;
      }
    }
  };

  // abstract key logic for assign and unassign
  function getKeys(key) {
    var keys;
    key = key.replace(/\s/g, '');
    keys = key.split(',');
    if ((keys[keys.length - 1]) == '') {
      keys[keys.length - 2] += ',';
    }
    return keys;
  }

  // abstract mods logic for assign and unassign
  function getMods(key) {
    var mods = key.slice(0, key.length - 1);
    for (var mi = 0; mi < mods.length; mi++)
    mods[mi] = _MODIFIERS[mods[mi]];
    return mods;
  }

  // cross-browser events
  function addEvent(object, event, method) {
    if (object.addEventListener)
      object.addEventListener(event, method, false);
    else if(object.attachEvent)
      object.attachEvent('on'+event, function(){ method(window.event) });
  };

  // set the handlers globally on document
  addEvent(document, 'keydown', function(event) { dispatch(event) }); // Passing _scope to a callback to ensure it remains the same by execution. Fixes #48
  addEvent(document, 'keyup', clearModifier);

  // reset modifiers to false whenever the window is (re)focused.
  addEvent(window, 'focus', resetModifiers);

  // store previously defined key
  var previousKey = global.key;

  // restore previously defined key and return reference to our key object
  function noConflict() {
    var k = global.key;
    global.key = previousKey;
    return k;
  }

  // set window.key and window.key.set/get/deleteScope, and the default filter
  global.key = assignKey;
  global.key.setScope = setScope;
  global.key.getScope = getScope;
  global.key.deleteScope = deleteScope;
  global.key.filter = filter;
  global.key.isPressed = isPressed;
  global.key.getPressedKeyCodes = getPressedKeyCodes;
  global.key.noConflict = noConflict;
  global.key.unbind = unbindKey;

  if(typeof module !== 'undefined') module.exports = key;

})(this);
/*******************************************************************************
*                                                                              *
* Author    :  Angus Johnson                                                   *
* Version   :  5.0.2                                                           *
* Date      :  30 December 2012                                                *
* Website   :  http://www.angusj.com                                           *
* Copyright :  Angus Johnson 2010-2012                                         *
*                                                                              *
* License:                                                                     *
* Use, modification & distribution is subject to Boost Software License Ver 1. *
* http://www.boost.org/LICENSE_1_0.txt                                         *
*                                                                              *
* Attributions:                                                                *
* The code in this library is an extension of Bala Vatti's clipping algorithm: *
* "A generic solution to polygon clipping"                                     *
* Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *
* http://portal.acm.org/citation.cfm?id=129906                                 *
*                                                                              *
* Computer graphics and geometric modeling: implementation and algorithms      *
* By Max K. Agoston                                                            *
* Springer; 1 edition (January 4, 2005)                                        *
* http://books.google.com/books?q=vatti+clipping+agoston                       *
*                                                                              *
* See also:                                                                    *
* "Polygon Offsetting by Computing Winding Numbers"                            *
* Paper no. DETC2005-85513 pp. 565-575                                         *
* ASME 2005 International Design Engineering Technical Conferences             *
* and Computers and Information in Engineering Conference (IDETC/CIE2005)      *
* September 24ñ28, 2005 , Long Beach, California, USA                          *
* http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *
*                                                                              *
*******************************************************************************/

/*******************************************************************************
*                                                                              *
* Author    :  Timo                                                            *
* Version   :  5.0.2.2                                                         *
* Date      :  11 September 2013                                               *
*                                                                              *
* This is a translation of the C# Clipper library to Javascript.               *
* Int128 struct of C# is implemented using JSBN of Tom Wu.                     *
* Because Javascript lacks support for 64-bit integers, the space              *
* is a little more restricted than in C# version.                              *
*                                                                              *
* C# version has support for coordinate space:                                 *
* +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *
* while Javascript version has support for space:                              *
* +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *
*                                                                              *
* Tom Wu's JSBN proved to be the fastest big integer library:                  *
* http://jsperf.com/big-integer-library-test                                   *
*                                                                              *
* This class can be made simpler when (if ever) 64-bit integer support comes.  *
*                                                                              *
*******************************************************************************/

/*******************************************************************************
*                                                                              *
* Basic JavaScript BN library - subset useful for RSA encryption.              *
* http://www-cs-students.stanford.edu/~tjw/jsbn/                               *
* Copyright (c) 2005  Tom Wu                                                   *
* All Rights Reserved.                                                         *
* See "LICENSE" for details:                                                   *
* http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *
*                                                                              *
*******************************************************************************/
(function ()
{
  // "use strict";
  // Browser test to speedup performance critical functions
  var nav = navigator.userAgent.toString().toLowerCase();
  var browser = {};
  if ( nav.indexOf("chrome") != -1 && nav.indexOf("chromium") == -1 ) browser.chrome = 1; else browser.chrome = 0;
  if ( nav.indexOf("chromium") != -1 ) browser.chromium = 1; else browser.chromium = 0;
  if ( nav.indexOf("safari") != -1 && nav.indexOf("chrome") == -1 && nav.indexOf("chromium") == -1 ) browser.safari = 1; else browser.safari = 0;
  if ( nav.indexOf("firefox") != -1 ) browser.firefox = 1; else browser.firefox = 0;
  if ( nav.indexOf("firefox/17") != -1 ) browser.firefox17 = 1; else browser.firefox17 = 0;   
  if ( nav.indexOf("firefox/15") != -1 ) browser.firefox15 = 1; else browser.firefox15 = 0;
  if ( nav.indexOf("firefox/3") != -1 ) browser.firefox3 = 1; else browser.firefox3 = 0;
  if ( nav.indexOf("opera") != -1 ) browser.opera = 1; else browser.opera = 0;
  if ( nav.indexOf("msie 10") != -1 ) browser.msie10 = 1; else browser.msie10 = 0;
  if ( nav.indexOf("msie 9") != -1 ) browser.msie9 = 1; else browser.msie9 = 0;
  if ( nav.indexOf("msie 8") != -1 ) browser.msie8 = 1; else browser.msie8 = 0;
  if ( nav.indexOf("msie 7") != -1 ) browser.msie7 = 1; else browser.msie7 = 0;
  if ( nav.indexOf("msie ") != -1 ) browser.msie = 1; else browser.msie = 0;

  var ClipperLib = {};
  ClipperLib.biginteger_used = null;
  
  // Bits per digit
  var dbits;
  // JavaScript engine analysis
  var canary = 0xdeadbeefcafe;
  var j_lm = ((canary & 0xffffff) == 0xefcafe);
  // (public) Constructor
  function Int128(a, b, c)
  {
    // This test variable can be removed,
    // but at least for performance tests it is useful piece of knowledge
    // This is the only ClipperLib related variable in Int128 library
    ClipperLib.biginteger_used = 1;
    if (a != null) if ("number" == typeof a)
    {
    	this.fromString(Math.floor(a)
        .toString(), 10); //this.fromNumber(a,b,c);
    }
    else if (b == null && "string" != typeof a) this.fromString(a, 256);
    else
    {
      if (a.indexOf(".") != -1) a = a.substring(0, a.indexOf("."));
      this.fromString(a, b);
    }
  }
  // return new, unset Int128
  function nbi()
  {
    return new Int128(null);
  }
  // am: Compute w_j += (x*this_i), propagate carries,
  // c is initial carry, returns final carry.
  // c < 3*dvalue, x < 2*dvalue, this_i < dvalue
  // We need to select the fastest one that works in this environment.
  // am1: use a single mult and divide to get the high bits,
  // max digit bits should be 26 because
  // max internal value = 2*dvalue^2-2*dvalue (< 2^53)
  function am1(i, x, w, j, c, n)
  {
    while (--n >= 0)
    {
      var v = x * this[i++] + w[j] + c;
      c = Math.floor(v / 0x4000000);
      w[j++] = v & 0x3ffffff;
    }
    return c;
  }
  // am2 avoids a big mult-and-extract completely.
  // Max digit bits should be <= 30 because we do bitwise ops
  // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
  function am2(i, x, w, j, c, n)
  {
    var xl = x & 0x7fff,
      xh = x >> 15;
    while (--n >= 0)
    {
      var l = this[i] & 0x7fff;
      var h = this[i++] >> 15;
      var m = xh * l + h * xl;
      l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);
      c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
      w[j++] = l & 0x3fffffff;
    }
    return c;
  }
  // Alternately, set max digit bits to 28 since some
  // browsers slow down when dealing with 32-bit numbers.
  function am3(i, x, w, j, c, n)
  {
    var xl = x & 0x3fff,
      xh = x >> 14;
    while (--n >= 0)
    {
      var l = this[i] & 0x3fff;
      var h = this[i++] >> 14;
      var m = xh * l + h * xl;
      l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;
      c = (l >> 28) + (m >> 14) + xh * h;
      w[j++] = l & 0xfffffff;
    }
    return c;
  }
  if (j_lm && (navigator.appName == "Microsoft Internet Explorer"))
  {
    Int128.prototype.am = am2;
    dbits = 30;
  }
  else if (j_lm && (navigator.appName != "Netscape"))
  {
    Int128.prototype.am = am1;
    dbits = 26;
  }
  else
  { // Mozilla/Netscape seems to prefer am3
    Int128.prototype.am = am3;
    dbits = 28;
  }
  Int128.prototype.DB = dbits;
  Int128.prototype.DM = ((1 << dbits) - 1);
  Int128.prototype.DV = (1 << dbits);
  var BI_FP = 52;
  Int128.prototype.FV = Math.pow(2, BI_FP);
  Int128.prototype.F1 = BI_FP - dbits;
  Int128.prototype.F2 = 2 * dbits - BI_FP;
  // Digit conversions
  var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
  var BI_RC = [];
  var rr, vv;
  rr = "0".charCodeAt(0);
  for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
  rr = "a".charCodeAt(0);
  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
  rr = "A".charCodeAt(0);
  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

  function int2char(n)
  {
    return BI_RM.charAt(n);
  }

  function intAt(s, i)
  {
    var c = BI_RC[s.charCodeAt(i)];
    return (c == null) ? -1 : c;
  }
  // (protected) copy this to r
  function bnpCopyTo(r)
  {
    for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];
    r.t = this.t;
    r.s = this.s;
  }
  // (protected) set from integer value x, -DV <= x < DV
  function bnpFromInt(x)
  {
    this.t = 1;
    this.s = (x < 0) ? -1 : 0;
    if (x > 0) this[0] = x;
    else if (x < -1) this[0] = x + this.DV;
    else this.t = 0;
  }
  // return bigint initialized to value
  function nbv(i)
  {
    var r = nbi();
    r.fromInt(i);
    return r;
  }
  // (protected) set from string and radix
  function bnpFromString(s, b)
  {
    var k;
    if (b == 16) k = 4;
    else if (b == 8) k = 3;
    else if (b == 256) k = 8; // byte array
    else if (b == 2) k = 1;
    else if (b == 32) k = 5;
    else if (b == 4) k = 2;
    else
    {
      this.fromRadix(s, b);
      return;
    }
    this.t = 0;
    this.s = 0;
    var i = s.length,
      mi = false,
      sh = 0;
    while (--i >= 0)
    {
      var x = (k == 8) ? s[i] & 0xff : intAt(s, i);
      if (x < 0)
      {
        if (s.charAt(i) == "-") mi = true;
        continue;
      }
      mi = false;
      if (sh == 0) this[this.t++] = x;
      else if (sh + k > this.DB)
      {
        this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;
        this[this.t++] = (x >> (this.DB - sh));
      }
      else this[this.t - 1] |= x << sh;
      sh += k;
      if (sh >= this.DB) sh -= this.DB;
    }
    if (k == 8 && (s[0] & 0x80) != 0)
    {
      this.s = -1;
      if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;
    }
    this.clamp();
    if (mi) Int128.ZERO.subTo(this, this);
  }
  // (protected) clamp off excess high words
  function bnpClamp()
  {
    var c = this.s & this.DM;
    while (this.t > 0 && this[this.t - 1] == c)--this.t;
  }
  // (public) return string representation in given radix
  function bnToString(b)
  {
    if (this.s < 0) return "-" + this.negate()
      .toString(b);
    var k;
    if (b == 16) k = 4;
    else if (b == 8) k = 3;
    else if (b == 2) k = 1;
    else if (b == 32) k = 5;
    else if (b == 4) k = 2;
    else return this.toRadix(b);
    var km = (1 << k) - 1,
      d, m = false,
      r = "",
      i = this.t;
    var p = this.DB - (i * this.DB) % k;
    if (i-- > 0)
    {
      if (p < this.DB && (d = this[i] >> p) > 0)
      {
        m = true;
        r = int2char(d);
      }
      while (i >= 0)
      {
        if (p < k)
        {
          d = (this[i] & ((1 << p) - 1)) << (k - p);
          d |= this[--i] >> (p += this.DB - k);
        }
        else
        {
          d = (this[i] >> (p -= k)) & km;
          if (p <= 0)
          {
            p += this.DB;
            --i;
          }
        }
        if (d > 0) m = true;
        if (m) r += int2char(d);
      }
    }
    return m ? r : "0";
  }
  // (public) -this
  function bnNegate()
  {
    var r = nbi();
    Int128.ZERO.subTo(this, r);
    return r;
  }
  // (public) |this|
  function bnAbs()
  {
    return (this.s < 0) ? this.negate() : this;
  }
  // (public) return + if this > a, - if this < a, 0 if equal
  function bnCompareTo(a)
  {
    var r = this.s - a.s;
    if (r != 0) return r;
    var i = this.t;
    r = i - a.t;
    if (r != 0) return (this.s < 0) ? -r : r;
    while (--i >= 0) if ((r = this[i] - a[i]) != 0) return r;
    return 0;
  }
  // returns bit length of the integer x
  function nbits(x)
  {
    var r = 1,
      t;
    if ((t = x >>> 16) != 0)
    {
      x = t;
      r += 16;
    }
    if ((t = x >> 8) != 0)
    {
      x = t;
      r += 8;
    }
    if ((t = x >> 4) != 0)
    {
      x = t;
      r += 4;
    }
    if ((t = x >> 2) != 0)
    {
      x = t;
      r += 2;
    }
    if ((t = x >> 1) != 0)
    {
      x = t;
      r += 1;
    }
    return r;
  }
  // (public) return the number of bits in "this"
  function bnBitLength()
  {
    if (this.t <= 0) return 0;
    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));
  }
  // (protected) r = this << n*DB
  function bnpDLShiftTo(n, r)
  {
    var i;
    for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];
    for (i = n - 1; i >= 0; --i) r[i] = 0;
    r.t = this.t + n;
    r.s = this.s;
  }
  // (protected) r = this >> n*DB
  function bnpDRShiftTo(n, r)
  {
    for (var i = n; i < this.t; ++i) r[i - n] = this[i];
    r.t = Math.max(this.t - n, 0);
    r.s = this.s;
  }
  // (protected) r = this << n
  function bnpLShiftTo(n, r)
  {
    var bs = n % this.DB;
    var cbs = this.DB - bs;
    var bm = (1 << cbs) - 1;
    var ds = Math.floor(n / this.DB),
      c = (this.s << bs) & this.DM,
      i;
    for (i = this.t - 1; i >= 0; --i)
    {
      r[i + ds + 1] = (this[i] >> cbs) | c;
      c = (this[i] & bm) << bs;
    }
    for (i = ds - 1; i >= 0; --i) r[i] = 0;
    r[ds] = c;
    r.t = this.t + ds + 1;
    r.s = this.s;
    r.clamp();
  }
  // (protected) r = this >> n
  function bnpRShiftTo(n, r)
  {
    r.s = this.s;
    var ds = Math.floor(n / this.DB);
    if (ds >= this.t)
    {
      r.t = 0;
      return;
    }
    var bs = n % this.DB;
    var cbs = this.DB - bs;
    var bm = (1 << bs) - 1;
    r[0] = this[ds] >> bs;
    for (var i = ds + 1; i < this.t; ++i)
    {
      r[i - ds - 1] |= (this[i] & bm) << cbs;
      r[i - ds] = this[i] >> bs;
    }
    if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;
    r.t = this.t - ds;
    r.clamp();
  }
  // (protected) r = this - a
  function bnpSubTo(a, r)
  {
    var i = 0,
      c = 0,
      m = Math.min(a.t, this.t);
    while (i < m)
    {
      c += this[i] - a[i];
      r[i++] = c & this.DM;
      c >>= this.DB;
    }
    if (a.t < this.t)
    {
      c -= a.s;
      while (i < this.t)
      {
        c += this[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      c += this.s;
    }
    else
    {
      c += this.s;
      while (i < a.t)
      {
        c -= a[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      c -= a.s;
    }
    r.s = (c < 0) ? -1 : 0;
    if (c < -1) r[i++] = this.DV + c;
    else if (c > 0) r[i++] = c;
    r.t = i;
    r.clamp();
  }
  // (protected) r = this * a, r != this,a (HAC 14.12)
  // "this" should be the larger one if appropriate.
  function bnpMultiplyTo(a, r)
  {
    var x = this.abs(),
      y = a.abs();
    var i = x.t;
    r.t = i + y.t;
    while (--i >= 0) r[i] = 0;
    for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
    r.s = 0;
    r.clamp();
    if (this.s != a.s) Int128.ZERO.subTo(r, r);
  }
  // (protected) r = this^2, r != this (HAC 14.16)
  function bnpSquareTo(r)
  {
    var x = this.abs();
    var i = r.t = 2 * x.t;
    while (--i >= 0) r[i] = 0;
    for (i = 0; i < x.t - 1; ++i)
    {
      var c = x.am(i, x[i], r, 2 * i, 0, 1);
      if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV)
      {
        r[i + x.t] -= x.DV;
        r[i + x.t + 1] = 1;
      }
    }
    if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
    r.s = 0;
    r.clamp();
  }
  // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
  // r != q, this != m.  q or r may be null.
  function bnpDivRemTo(m, q, r)
  {
    var pm = m.abs();
    if (pm.t <= 0) return;
    var pt = this.abs();
    if (pt.t < pm.t)
    {
      if (q != null) q.fromInt(0);
      if (r != null) this.copyTo(r);
      return;
    }
    if (r == null) r = nbi();
    var y = nbi(),
      ts = this.s,
      ms = m.s;
    var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus
    if (nsh > 0)
    {
      pm.lShiftTo(nsh, y);
      pt.lShiftTo(nsh, r);
    }
    else
    {
      pm.copyTo(y);
      pt.copyTo(r);
    }
    var ys = y.t;
    var y0 = y[ys - 1];
    if (y0 == 0) return;
    var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);
    var d1 = this.FV / yt,
      d2 = (1 << this.F1) / yt,
      e = 1 << this.F2;
    var i = r.t,
      j = i - ys,
      t = (q == null) ? nbi() : q;
    y.dlShiftTo(j, t);
    if (r.compareTo(t) >= 0)
    {
      r[r.t++] = 1;
      r.subTo(t, r);
    }
    Int128.ONE.dlShiftTo(ys, t);
    t.subTo(y, y); // "negative" y so we can replace sub with am later
    while (y.t < ys) y[y.t++] = 0;
    while (--j >= 0)
    {
      // Estimate quotient digit
      var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
      if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd)
      { // Try it out
        y.dlShiftTo(j, t);
        r.subTo(t, r);
        while (r[i] < --qd) r.subTo(t, r);
      }
    }
    if (q != null)
    {
      r.drShiftTo(ys, q);
      if (ts != ms) Int128.ZERO.subTo(q, q);
    }
    r.t = ys;
    r.clamp();
    if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder
    if (ts < 0) Int128.ZERO.subTo(r, r);
  }
  // (public) this mod a
  function bnMod(a)
  {
    var r = nbi();
    this.abs()
      .divRemTo(a, null, r);
    if (this.s < 0 && r.compareTo(Int128.ZERO) > 0) a.subTo(r, r);
    return r;
  }
  // Modular reduction using "classic" algorithm
  function Classic(m)
  {
    this.m = m;
  }

  function cConvert(x)
  {
    if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
    else return x;
  }

  function cRevert(x)
  {
    return x;
  }

  function cReduce(x)
  {
    x.divRemTo(this.m, null, x);
  }

  function cMulTo(x, y, r)
  {
    x.multiplyTo(y, r);
    this.reduce(r);
  }

  function cSqrTo(x, r)
  {
    x.squareTo(r);
    this.reduce(r);
  }
  Classic.prototype.convert = cConvert;
  Classic.prototype.revert = cRevert;
  Classic.prototype.reduce = cReduce;
  Classic.prototype.mulTo = cMulTo;
  Classic.prototype.sqrTo = cSqrTo;
  // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
  // justification:
  //         xy == 1 (mod m)
  //         xy =  1+km
  //   xy(2-xy) = (1+km)(1-km)
  // x[y(2-xy)] = 1-k^2m^2
  // x[y(2-xy)] == 1 (mod m^2)
  // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
  // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
  // JS multiply "overflows" differently from C/C++, so care is needed here.
  function bnpInvDigit()
  {
    if (this.t < 1) return 0;
    var x = this[0];
    if ((x & 1) == 0) return 0;
    var y = x & 3; // y == 1/x mod 2^2
    y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4
    y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8
    y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16
    // last step - calculate inverse mod DV directly;
    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
    y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits
    // we really want the negative inverse, and -DV < y < DV
    return (y > 0) ? this.DV - y : -y;
  }
  // Montgomery reduction
  function Montgomery(m)
  {
    this.m = m;
    this.mp = m.invDigit();
    this.mpl = this.mp & 0x7fff;
    this.mph = this.mp >> 15;
    this.um = (1 << (m.DB - 15)) - 1;
    this.mt2 = 2 * m.t;
  }
  // xR mod m
  function montConvert(x)
  {
    var r = nbi();
    x.abs()
      .dlShiftTo(this.m.t, r);
    r.divRemTo(this.m, null, r);
    if (x.s < 0 && r.compareTo(Int128.ZERO) > 0) this.m.subTo(r, r);
    return r;
  }
  // x/R mod m
  function montRevert(x)
  {
    var r = nbi();
    x.copyTo(r);
    this.reduce(r);
    return r;
  }
  // x = x/R mod m (HAC 14.32)
  function montReduce(x)
  {
    while (x.t <= this.mt2) // pad x so am has enough room later
    x[x.t++] = 0;
    for (var i = 0; i < this.m.t; ++i)
    {
      // faster way of calculating u0 = x[i]*mp mod DV
      var j = x[i] & 0x7fff;
      var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;
      // use am to combine the multiply-shift-add into one call
      j = i + this.m.t;
      x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
      // propagate carry
      while (x[j] >= x.DV)
      {
        x[j] -= x.DV;
        x[++j]++;
      }
    }
    x.clamp();
    x.drShiftTo(this.m.t, x);
    if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
  }
  // r = "x^2/R mod m"; x != r
  function montSqrTo(x, r)
  {
    x.squareTo(r);
    this.reduce(r);
  }
  // r = "xy/R mod m"; x,y != r
  function montMulTo(x, y, r)
  {
    x.multiplyTo(y, r);
    this.reduce(r);
  }
  Montgomery.prototype.convert = montConvert;
  Montgomery.prototype.revert = montRevert;
  Montgomery.prototype.reduce = montReduce;
  Montgomery.prototype.mulTo = montMulTo;
  Montgomery.prototype.sqrTo = montSqrTo;
  // (protected) true iff this is even
  function bnpIsEven()
  {
    return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;
  }
  // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
  function bnpExp(e, z)
  {
    if (e > 0xffffffff || e < 1) return Int128.ONE;
    var r = nbi(),
      r2 = nbi(),
      g = z.convert(this),
      i = nbits(e) - 1;
    g.copyTo(r);
    while (--i >= 0)
    {
      z.sqrTo(r, r2);
      if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);
      else
      {
        var t = r;
        r = r2;
        r2 = t;
      }
    }
    return z.revert(r);
  }
  // (public) this^e % m, 0 <= e < 2^32
  function bnModPowInt(e, m)
  {
    var z;
    if (e < 256 || m.isEven()) z = new Classic(m);
    else z = new Montgomery(m);
    return this.exp(e, z);
  }
  // protected
  Int128.prototype.copyTo = bnpCopyTo;
  Int128.prototype.fromInt = bnpFromInt;
  Int128.prototype.fromString = bnpFromString;
  Int128.prototype.clamp = bnpClamp;
  Int128.prototype.dlShiftTo = bnpDLShiftTo;
  Int128.prototype.drShiftTo = bnpDRShiftTo;
  Int128.prototype.lShiftTo = bnpLShiftTo;
  Int128.prototype.rShiftTo = bnpRShiftTo;
  Int128.prototype.subTo = bnpSubTo;
  Int128.prototype.multiplyTo = bnpMultiplyTo;
  Int128.prototype.squareTo = bnpSquareTo;
  Int128.prototype.divRemTo = bnpDivRemTo;
  Int128.prototype.invDigit = bnpInvDigit;
  Int128.prototype.isEven = bnpIsEven;
  Int128.prototype.exp = bnpExp;
  // public
  Int128.prototype.toString = bnToString;
  Int128.prototype.negate = bnNegate;
  Int128.prototype.abs = bnAbs;
  Int128.prototype.compareTo = bnCompareTo;
  Int128.prototype.bitLength = bnBitLength;
  Int128.prototype.mod = bnMod;
  Int128.prototype.modPowInt = bnModPowInt;
  // "constants"
  Int128.ZERO = nbv(0);
  Int128.ONE = nbv(1);
  // Copyright (c) 2005-2009  Tom Wu
  // All Rights Reserved.
  // See "LICENSE" for details.
  // Extended JavaScript BN functions, required for RSA private ops.
  // Version 1.1: new Int128("0", 10) returns "proper" zero
  // Version 1.2: square() API, isProbablePrime fix
  // (public)
  function bnClone()
  {
    var r = nbi();
    this.copyTo(r);
    return r;
  }
  // (public) return value as integer
  function bnIntValue()
  {
    if (this.s < 0)
    {
      if (this.t == 1) return this[0] - this.DV;
      else if (this.t == 0) return -1;
    }
    else if (this.t == 1) return this[0];
    else if (this.t == 0) return 0;
    // assumes 16 < DB < 32
    return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];
  }
  // (public) return value as byte
  function bnByteValue()
  {
    return (this.t == 0) ? this.s : (this[0] << 24) >> 24;
  }
  // (public) return value as short (assumes DB>=16)
  function bnShortValue()
  {
    return (this.t == 0) ? this.s : (this[0] << 16) >> 16;
  }
  // (protected) return x s.t. r^x < DV
  function bnpChunkSize(r)
  {
    return Math.floor(Math.LN2 * this.DB / Math.log(r));
  }
  // (public) 0 if this == 0, 1 if this > 0
  function bnSigNum()
  {
    if (this.s < 0) return -1;
    else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
    else return 1;
  }
  // (protected) convert to radix string
  function bnpToRadix(b)
  {
    if (b == null) b = 10;
    if (this.signum() == 0 || b < 2 || b > 36) return "0";
    var cs = this.chunkSize(b);
    var a = Math.pow(b, cs);
    var d = nbv(a),
      y = nbi(),
      z = nbi(),
      r = "";
    this.divRemTo(d, y, z);
    while (y.signum() > 0)
    {
      r = (a + z.intValue())
        .toString(b)
        .substr(1) + r;
      y.divRemTo(d, y, z);
    }
    return z.intValue()
      .toString(b) + r;
  }
  // (protected) convert from radix string
  function bnpFromRadix(s, b)
  {
    this.fromInt(0);
    if (b == null) b = 10;
    var cs = this.chunkSize(b);
    var d = Math.pow(b, cs),
      mi = false,
      j = 0,
      w = 0;
    for (var i = 0; i < s.length; ++i)
    {
      var x = intAt(s, i);
      if (x < 0)
      {
        if (s.charAt(i) == "-" && this.signum() == 0) mi = true;
        continue;
      }
      w = b * w + x;
      if (++j >= cs)
      {
        this.dMultiply(d);
        this.dAddOffset(w, 0);
        j = 0;
        w = 0;
      }
    }
    if (j > 0)
    {
      this.dMultiply(Math.pow(b, j));
      this.dAddOffset(w, 0);
    }
    if (mi) Int128.ZERO.subTo(this, this);
  }
  // (protected) alternate constructor
  function bnpFromNumber(a, b, c)
  {
    if ("number" == typeof b)
    {
      // new Int128(int,int,RNG)
      if (a < 2) this.fromInt(1);
      else
      {
        this.fromNumber(a, c);
        if (!this.testBit(a - 1)) // force MSB set
        this.bitwiseTo(Int128.ONE.shiftLeft(a - 1), op_or, this);
        if (this.isEven()) this.dAddOffset(1, 0); // force odd
        while (!this.isProbablePrime(b))
        {
          this.dAddOffset(2, 0);
          if (this.bitLength() > a) this.subTo(Int128.ONE.shiftLeft(a - 1), this);
        }
      }
    }
    else
    {
      // new Int128(int,RNG)
      var x = [],
        t = a & 7;
      x.length = (a >> 3) + 1;
      b.nextBytes(x);
      if (t > 0) x[0] &= ((1 << t) - 1);
      else x[0] = 0;
      this.fromString(x, 256);
    }
  }
  // (public) convert to bigendian byte array
  function bnToByteArray()
  {
    var i = this.t,
      r = [];
    r[0] = this.s;
    var p = this.DB - (i * this.DB) % 8,
      d, k = 0;
    if (i-- > 0)
    {
      if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p) r[k++] = d | (this.s << (this.DB - p));
      while (i >= 0)
      {
        if (p < 8)
        {
          d = (this[i] & ((1 << p) - 1)) << (8 - p);
          d |= this[--i] >> (p += this.DB - 8);
        }
        else
        {
          d = (this[i] >> (p -= 8)) & 0xff;
          if (p <= 0)
          {
            p += this.DB;
            --i;
          }
        }
        if ((d & 0x80) != 0) d |= -256;
        if (k == 0 && (this.s & 0x80) != (d & 0x80))++k;
        if (k > 0 || d != this.s) r[k++] = d;
      }
    }
    return r;
  }

  function bnEquals(a)
  {
    return (this.compareTo(a) == 0);
  }

  function bnMin(a)
  {
    return (this.compareTo(a) < 0) ? this : a;
  }

  function bnMax(a)
  {
    return (this.compareTo(a) > 0) ? this : a;
  }
  // (protected) r = this op a (bitwise)
  function bnpBitwiseTo(a, op, r)
  {
    var i, f, m = Math.min(a.t, this.t);
    for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);
    if (a.t < this.t)
    {
      f = a.s & this.DM;
      for (i = m; i < this.t; ++i) r[i] = op(this[i], f);
      r.t = this.t;
    }
    else
    {
      f = this.s & this.DM;
      for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);
      r.t = a.t;
    }
    r.s = op(this.s, a.s);
    r.clamp();
  }
  // (public) this & a
  function op_and(x, y)
  {
    return x & y;
  }

  function bnAnd(a)
  {
    var r = nbi();
    this.bitwiseTo(a, op_and, r);
    return r;
  }
  // (public) this | a
  function op_or(x, y)
  {
    return x | y;
  }

  function bnOr(a)
  {
    var r = nbi();
    this.bitwiseTo(a, op_or, r);
    return r;
  }
  // (public) this ^ a
  function op_xor(x, y)
  {
    return x ^ y;
  }

  function bnXor(a)
  {
    var r = nbi();
    this.bitwiseTo(a, op_xor, r);
    return r;
  }
  // (public) this & ~a
  function op_andnot(x, y)
  {
    return x & ~y;
  }

  function bnAndNot(a)
  {
    var r = nbi();
    this.bitwiseTo(a, op_andnot, r);
    return r;
  }
  // (public) ~this
  function bnNot()
  {
    var r = nbi();
    for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];
    r.t = this.t;
    r.s = ~this.s;
    return r;
  }
  // (public) this << n
  function bnShiftLeft(n)
  {
    var r = nbi();
    if (n < 0) this.rShiftTo(-n, r);
    else this.lShiftTo(n, r);
    return r;
  }
  // (public) this >> n
  function bnShiftRight(n)
  {
    var r = nbi();
    if (n < 0) this.lShiftTo(-n, r);
    else this.rShiftTo(n, r);
    return r;
  }
  // return index of lowest 1-bit in x, x < 2^31
  function lbit(x)
  {
    if (x == 0) return -1;
    var r = 0;
    if ((x & 0xffff) == 0)
    {
      x >>= 16;
      r += 16;
    }
    if ((x & 0xff) == 0)
    {
      x >>= 8;
      r += 8;
    }
    if ((x & 0xf) == 0)
    {
      x >>= 4;
      r += 4;
    }
    if ((x & 3) == 0)
    {
      x >>= 2;
      r += 2;
    }
    if ((x & 1) == 0)++r;
    return r;
  }
  // (public) returns index of lowest 1-bit (or -1 if none)
  function bnGetLowestSetBit()
  {
    for (var i = 0; i < this.t; ++i)
    if (this[i] != 0) return i * this.DB + lbit(this[i]);
    if (this.s < 0) return this.t * this.DB;
    return -1;
  }
  // return number of 1 bits in x
  function cbit(x)
  {
    var r = 0;
    while (x != 0)
    {
      x &= x - 1;
      ++r;
    }
    return r;
  }
  // (public) return number of set bits
  function bnBitCount()
  {
    var r = 0,
      x = this.s & this.DM;
    for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);
    return r;
  }
  // (public) true iff nth bit is set
  function bnTestBit(n)
  {
    var j = Math.floor(n / this.DB);
    if (j >= this.t) return (this.s != 0);
    return ((this[j] & (1 << (n % this.DB))) != 0);
  }
  // (protected) this op (1<<n)
  function bnpChangeBit(n, op)
  {
    var r = Int128.ONE.shiftLeft(n);
    this.bitwiseTo(r, op, r);
    return r;
  }
  // (public) this | (1<<n)
  function bnSetBit(n)
  {
    return this.changeBit(n, op_or);
  }
  // (public) this & ~(1<<n)
  function bnClearBit(n)
  {
    return this.changeBit(n, op_andnot);
  }
  // (public) this ^ (1<<n)
  function bnFlipBit(n)
  {
    return this.changeBit(n, op_xor);
  }
  // (protected) r = this + a
  function bnpAddTo(a, r)
  {
    var i = 0,
      c = 0,
      m = Math.min(a.t, this.t);
    while (i < m)
    {
      c += this[i] + a[i];
      r[i++] = c & this.DM;
      c >>= this.DB;
    }
    if (a.t < this.t)
    {
      c += a.s;
      while (i < this.t)
      {
        c += this[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      c += this.s;
    }
    else
    {
      c += this.s;
      while (i < a.t)
      {
        c += a[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      c += a.s;
    }
    r.s = (c < 0) ? -1 : 0;
    if (c > 0) r[i++] = c;
    else if (c < -1) r[i++] = this.DV + c;
    r.t = i;
    r.clamp();
  }
  // (public) this + a
  function bnAdd(a)
  {
    var r = nbi();
    this.addTo(a, r);
    return r;
  }
  // (public) this - a
  function bnSubtract(a)
  {
    var r = nbi();
    this.subTo(a, r);
    return r;
  }
  // (public) this * a
  function bnMultiply(a)
  {
    var r = nbi();
    this.multiplyTo(a, r);
    return r;
  }
  // (public) this^2
  function bnSquare()
  {
    var r = nbi();
    this.squareTo(r);
    return r;
  }
  // (public) this / a
  function bnDivide(a)
  {
    var r = nbi();
    this.divRemTo(a, r, null);
    return r;
  }
  // (public) this % a
  function bnRemainder(a)
  {
    var r = nbi();
    this.divRemTo(a, null, r);
    return r;
  }
  // (public) [this/a,this%a]
  function bnDivideAndRemainder(a)
  {
    var q = nbi(),
      r = nbi();
    this.divRemTo(a, q, r);
    return new Array(q, r);
  }
  // (protected) this *= n, this >= 0, 1 < n < DV
  function bnpDMultiply(n)
  {
    this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
    ++this.t;
    this.clamp();
  }
  // (protected) this += n << w words, this >= 0
  function bnpDAddOffset(n, w)
  {
    if (n == 0) return;
    while (this.t <= w) this[this.t++] = 0;
    this[w] += n;
    while (this[w] >= this.DV)
    {
      this[w] -= this.DV;
      if (++w >= this.t) this[this.t++] = 0;
      ++this[w];
    }
  }
  // A "null" reducer
  function NullExp()
  {}

  function nNop(x)
  {
    return x;
  }

  function nMulTo(x, y, r)
  {
    x.multiplyTo(y, r);
  }

  function nSqrTo(x, r)
  {
    x.squareTo(r);
  }
  NullExp.prototype.convert = nNop;
  NullExp.prototype.revert = nNop;
  NullExp.prototype.mulTo = nMulTo;
  NullExp.prototype.sqrTo = nSqrTo;
  // (public) this^e
  function bnPow(e)
  {
    return this.exp(e, new NullExp());
  }
  // (protected) r = lower n words of "this * a", a.t <= n
  // "this" should be the larger one if appropriate.
  function bnpMultiplyLowerTo(a, n, r)
  {
    var i = Math.min(this.t + a.t, n);
    r.s = 0; // assumes a,this >= 0
    r.t = i;
    while (i > 0) r[--i] = 0;
    var j;
    for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
    for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);
    r.clamp();
  }
  // (protected) r = "this * a" without lower n words, n > 0
  // "this" should be the larger one if appropriate.
  function bnpMultiplyUpperTo(a, n, r)
  {
    --n;
    var i = r.t = this.t + a.t - n;
    r.s = 0; // assumes a,this >= 0
    while (--i >= 0) r[i] = 0;
    for (i = Math.max(n - this.t, 0); i < a.t; ++i)
    r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
    r.clamp();
    r.drShiftTo(1, r);
  }
  // Barrett modular reduction
  function Barrett(m)
  {
    // setup Barrett
    this.r2 = nbi();
    this.q3 = nbi();
    Int128.ONE.dlShiftTo(2 * m.t, this.r2);
    this.mu = this.r2.divide(m);
    this.m = m;
  }

  function barrettConvert(x)
  {
    if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
    else if (x.compareTo(this.m) < 0) return x;
    else
    {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }
  }

  function barrettRevert(x)
  {
    return x;
  }
  // x = x mod m (HAC 14.42)
  function barrettReduce(x)
  {
    x.drShiftTo(this.m.t - 1, this.r2);
    if (x.t > this.m.t + 1)
    {
      x.t = this.m.t + 1;
      x.clamp();
    }
    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
    while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
    x.subTo(this.r2, x);
    while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
  }
  // r = x^2 mod m; x != r
  function barrettSqrTo(x, r)
  {
    x.squareTo(r);
    this.reduce(r);
  }
  // r = x*y mod m; x,y != r
  function barrettMulTo(x, y, r)
  {
    x.multiplyTo(y, r);
    this.reduce(r);
  }
  Barrett.prototype.convert = barrettConvert;
  Barrett.prototype.revert = barrettRevert;
  Barrett.prototype.reduce = barrettReduce;
  Barrett.prototype.mulTo = barrettMulTo;
  Barrett.prototype.sqrTo = barrettSqrTo;
  // (public) this^e % m (HAC 14.85)
  function bnModPow(e, m)
  {
    var i = e.bitLength(),
      k, r = nbv(1),
      z;
    if (i <= 0) return r;
    else if (i < 18) k = 1;
    else if (i < 48) k = 3;
    else if (i < 144) k = 4;
    else if (i < 768) k = 5;
    else k = 6;
    if (i < 8) z = new Classic(m);
    else if (m.isEven()) z = new Barrett(m);
    else z = new Montgomery(m);
    // precomputation
    var g = [],
      n = 3,
      k1 = k - 1,
      km = (1 << k) - 1;
    g[1] = z.convert(this);
    if (k > 1)
    {
      var g2 = nbi();
      z.sqrTo(g[1], g2);
      while (n <= km)
      {
        g[n] = nbi();
        z.mulTo(g2, g[n - 2], g[n]);
        n += 2;
      }
    }
    var j = e.t - 1,
      w, is1 = true,
      r2 = nbi(),
      t;
    i = nbits(e[j]) - 1;
    while (j >= 0)
    {
      if (i >= k1) w = (e[j] >> (i - k1)) & km;
      else
      {
        w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);
        if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);
      }
      n = k;
      while ((w & 1) == 0)
      {
        w >>= 1;
        --n;
      }
      if ((i -= n) < 0)
      {
        i += this.DB;
        --j;
      }
      if (is1)
      { // ret == 1, don't bother squaring or multiplying it
        g[w].copyTo(r);
        is1 = false;
      }
      else
      {
        while (n > 1)
        {
          z.sqrTo(r, r2);
          z.sqrTo(r2, r);
          n -= 2;
        }
        if (n > 0) z.sqrTo(r, r2);
        else
        {
          t = r;
          r = r2;
          r2 = t;
        }
        z.mulTo(r2, g[w], r);
      }
      while (j >= 0 && (e[j] & (1 << i)) == 0)
      {
        z.sqrTo(r, r2);
        t = r;
        r = r2;
        r2 = t;
        if (--i < 0)
        {
          i = this.DB - 1;
          --j;
        }
      }
    }
    return z.revert(r);
  }
  // (public) gcd(this,a) (HAC 14.54)
  function bnGCD(a)
  {
    var x = (this.s < 0) ? this.negate() : this.clone();
    var y = (a.s < 0) ? a.negate() : a.clone();
    if (x.compareTo(y) < 0)
    {
      var t = x;
      x = y;
      y = t;
    }
    var i = x.getLowestSetBit(),
      g = y.getLowestSetBit();
    if (g < 0) return x;
    if (i < g) g = i;
    if (g > 0)
    {
      x.rShiftTo(g, x);
      y.rShiftTo(g, y);
    }
    while (x.signum() > 0)
    {
      if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
      if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
      if (x.compareTo(y) >= 0)
      {
        x.subTo(y, x);
        x.rShiftTo(1, x);
      }
      else
      {
        y.subTo(x, y);
        y.rShiftTo(1, y);
      }
    }
    if (g > 0) y.lShiftTo(g, y);
    return y;
  }
  // (protected) this % n, n < 2^26
  function bnpModInt(n)
  {
    if (n <= 0) return 0;
    var d = this.DV % n,
      r = (this.s < 0) ? n - 1 : 0;
    if (this.t > 0) if (d == 0) r = this[0] % n;
    else for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;
    return r;
  }
  // (public) 1/this % m (HAC 14.61)
  function bnModInverse(m)
  {
    var ac = m.isEven();
    if ((this.isEven() && ac) || m.signum() == 0) return Int128.ZERO;
    var u = m.clone(),
      v = this.clone();
    var a = nbv(1),
      b = nbv(0),
      c = nbv(0),
      d = nbv(1);
    while (u.signum() != 0)
    {
      while (u.isEven())
      {
        u.rShiftTo(1, u);
        if (ac)
        {
          if (!a.isEven() || !b.isEven())
          {
            a.addTo(this, a);
            b.subTo(m, b);
          }
          a.rShiftTo(1, a);
        }
        else if (!b.isEven()) b.subTo(m, b);
        b.rShiftTo(1, b);
      }
      while (v.isEven())
      {
        v.rShiftTo(1, v);
        if (ac)
        {
          if (!c.isEven() || !d.isEven())
          {
            c.addTo(this, c);
            d.subTo(m, d);
          }
          c.rShiftTo(1, c);
        }
        else if (!d.isEven()) d.subTo(m, d);
        d.rShiftTo(1, d);
      }
      if (u.compareTo(v) >= 0)
      {
        u.subTo(v, u);
        if (ac) a.subTo(c, a);
        b.subTo(d, b);
      }
      else
      {
        v.subTo(u, v);
        if (ac) c.subTo(a, c);
        d.subTo(b, d);
      }
    }
    if (v.compareTo(Int128.ONE) != 0) return Int128.ZERO;
    if (d.compareTo(m) >= 0) return d.subtract(m);
    if (d.signum() < 0) d.addTo(m, d);
    else return d;
    if (d.signum() < 0) return d.add(m);
    else return d;
  }
  var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
  var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
  // (public) test primality with certainty >= 1-.5^t
  function bnIsProbablePrime(t)
  {
    var i, x = this.abs();
    if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1])
    {
      for (i = 0; i < lowprimes.length; ++i)
      if (x[0] == lowprimes[i]) return true;
      return false;
    }
    if (x.isEven()) return false;
    i = 1;
    while (i < lowprimes.length)
    {
      var m = lowprimes[i],
        j = i + 1;
      while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
      m = x.modInt(m);
      while (i < j) if (m % lowprimes[i++] == 0) return false;
    }
    return x.millerRabin(t);
  }
  // (protected) true if probably prime (HAC 4.24, Miller-Rabin)
  function bnpMillerRabin(t)
  {
    var n1 = this.subtract(Int128.ONE);
    var k = n1.getLowestSetBit();
    if (k <= 0) return false;
    var r = n1.shiftRight(k);
    t = (t + 1) >> 1;
    if (t > lowprimes.length) t = lowprimes.length;
    var a = nbi();
    for (var i = 0; i < t; ++i)
    {
      //Pick bases at random, instead of starting at 2
      a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
      var y = a.modPow(r, this);
      if (y.compareTo(Int128.ONE) != 0 && y.compareTo(n1) != 0)
      {
        var j = 1;
        while (j++ < k && y.compareTo(n1) != 0)
        {
          y = y.modPowInt(2, this);
          if (y.compareTo(Int128.ONE) == 0) return false;
        }
        if (y.compareTo(n1) != 0) return false;
      }
    }
    return true;
  }
  // protected
  Int128.prototype.chunkSize = bnpChunkSize;
  Int128.prototype.toRadix = bnpToRadix;
  Int128.prototype.fromRadix = bnpFromRadix;
  Int128.prototype.fromNumber = bnpFromNumber;
  Int128.prototype.bitwiseTo = bnpBitwiseTo;
  Int128.prototype.changeBit = bnpChangeBit;
  Int128.prototype.addTo = bnpAddTo;
  Int128.prototype.dMultiply = bnpDMultiply;
  Int128.prototype.dAddOffset = bnpDAddOffset;
  Int128.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
  Int128.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
  Int128.prototype.modInt = bnpModInt;
  Int128.prototype.millerRabin = bnpMillerRabin;
  // public
  Int128.prototype.clone = bnClone;
  Int128.prototype.intValue = bnIntValue;
  Int128.prototype.byteValue = bnByteValue;
  Int128.prototype.shortValue = bnShortValue;
  Int128.prototype.signum = bnSigNum;
  Int128.prototype.toByteArray = bnToByteArray;
  Int128.prototype.equals = bnEquals;
  Int128.prototype.min = bnMin;
  Int128.prototype.max = bnMax;
  Int128.prototype.and = bnAnd;
  Int128.prototype.or = bnOr;
  Int128.prototype.xor = bnXor;
  Int128.prototype.andNot = bnAndNot;
  Int128.prototype.not = bnNot;
  Int128.prototype.shiftLeft = bnShiftLeft;
  Int128.prototype.shiftRight = bnShiftRight;
  Int128.prototype.getLowestSetBit = bnGetLowestSetBit;
  Int128.prototype.bitCount = bnBitCount;
  Int128.prototype.testBit = bnTestBit;
  Int128.prototype.setBit = bnSetBit;
  Int128.prototype.clearBit = bnClearBit;
  Int128.prototype.flipBit = bnFlipBit;
  Int128.prototype.add = bnAdd;
  Int128.prototype.subtract = bnSubtract;
  Int128.prototype.multiply = bnMultiply;
  Int128.prototype.divide = bnDivide;
  Int128.prototype.remainder = bnRemainder;
  Int128.prototype.divideAndRemainder = bnDivideAndRemainder;
  Int128.prototype.modPow = bnModPow;
  Int128.prototype.modInverse = bnModInverse;
  Int128.prototype.pow = bnPow;
  Int128.prototype.gcd = bnGCD;
  Int128.prototype.isProbablePrime = bnIsProbablePrime;
  // JSBN-specific extension
  Int128.prototype.square = bnSquare;
  
  // end of Int128 section
  
  /*
  // Uncomment the following two lines if you want to use Int128 outside ClipperLib
  if (typeof(document) !== "undefined") window.Int128 = Int128;
  else self.Int128 = Int128;
  */
  
  // Here starts the actual Clipper library:
  ClipperLib.Math_Abs_Int64 = ClipperLib.Math_Abs_Int32 = ClipperLib.Math_Abs_Double = function (a)
  {
    return Math.abs(a);
  };
  ClipperLib.Math_Max_Int32_Int32 = function (a, b)
  {
    return Math.max(a, b);
  };
  /*
  -----------------------------------
  cast_32 speedtest: http://jsperf.com/truncate-float-to-integer/2
  -----------------------------------
  */
  if (browser.msie || browser.opera || browser.safari) ClipperLib.Cast_Int32 = function (a) {
    return a | 0;
  };
  else ClipperLib.Cast_Int32 = function (a) { // eg. browser.chrome || browser.chromium || browser.firefox
    return ~~a;
  };
  /*
  --------------------------
  cast_64 speedtests: http://jsperf.com/truncate-float-to-integer
  Chrome: bitwise_not_floor
  Firefox17: toInteger (typeof test)
  IE9: bitwise_or_floor
  IE7 and IE8: to_parseint
  Chromium: to_floor_or_ceil
  Firefox3: to_floor_or_ceil
  Firefox15: to_floor_or_ceil
  Opera: to_floor_or_ceil
  Safari: to_floor_or_ceil
  --------------------------
  */
  if (browser.chrome) ClipperLib.Cast_Int64 = function (a) {
    if (a < -2147483648 || a > 2147483647)
    return a < 0 ? Math.ceil(a): Math.floor(a);
    else return ~~a;
  };
  else if (browser.firefox && typeof(Number.toInteger) == "function") ClipperLib.Cast_Int64 = function(a) {
    return Number.toInteger(a);
  };
  else if (browser.msie7 || browser.msie8) ClipperLib.Cast_Int64 = function(a) {
    return parseInt(a, 10);
  };
  else if (browser.msie) ClipperLib.Cast_Int64 = function (a) {
    if (a < -2147483648 || a > 2147483647)
    return a < 0 ? Math.ceil(a): Math.floor(a);
    return a | 0;
  };
  // eg. browser.chromium || browser.firefox || browser.opera || browser.safari
  else ClipperLib.Cast_Int64 = function(a) {
    return a < 0 ? Math.ceil(a): Math.floor(a);
  };
  ClipperLib.Clear = function (a)
  {
    a.length = 0;
  };
  ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function
  ClipperLib.PI = 3.141592653589793;
  ClipperLib.PI2 = 2 * 3.141592653589793;
  ClipperLib.IntPoint = function ()
  {
    var a = arguments;
    if (a.length == 1)
    {
      this.x = a[0].x;
      this.y = a[0].y;

    }
    if (a.length == 2)
    {
      this.x = a[0];
      this.y = a[1];
    }
  };
  ClipperLib.IntRect = function ()
  {
    var a = arguments;
    if (a.length == 4) // function (l, t, r, b)
    {
      var l = a[0],
        t = a[1],
        r = a[2],
        b = a[3];
      this.left = l;
      this.top = t;
      this.right = r;
      this.bottom = b;
    }
    else
    {
      this.left = 0;
      this.top = 0;
      this.right = 0;
      this.bottom = 0;
    }
  };
  ClipperLib.Polygon = function ()
  {
    return [];
  };
  ClipperLib.Polygons = function ()
  {
    return []; // Was previously [[]], but caused problems when pushed
  };
  ClipperLib.ExPolygons = function ()
  {
    var a = [];
    a.exPolygons = true; // this is needed to make "overloading" possible in Execute
    return a;
  }  
  ClipperLib.ExPolygon = function ()
  {
    this.outer = null;
    this.holes = null;
  };
  ClipperLib.ClipType = {
    ctIntersection: 0,
    ctUnion: 1,
    ctDifference: 2,
    ctXor: 3
  };
  ClipperLib.PolyType = {
    ptSubject: 0,
    ptClip: 1
  };
  ClipperLib.PolyFillType = {
    pftEvenOdd: 0,
    pftNonZero: 1,
    pftPositive: 2,
    pftNegative: 3
  };
  ClipperLib.JoinType = {
    jtSquare: 0,
    jtRound: 1,
    jtMiter: 2
  };
  
  ClipperLib.EdgeSide = {
    esLeft: 1,
    esRight: 2
  };
  ClipperLib.Protects = {
    ipNone: 0,
    ipLeft: 1,
    ipRight: 2,
    ipBoth: 3
  };
  ClipperLib.Direction = {
    dRightToLeft: 0,
    dLeftToRight: 1
  };
  ClipperLib.TEdge = function ()
  {
    this.xbot = 0;
    this.ybot = 0;
    this.xcurr = 0;
    this.ycurr = 0;
    this.xtop = 0;
    this.ytop = 0;
    this.dx = 0;
    this.deltaX = 0;
    this.deltaY = 0;
    this.tmpX = 0;
    this.polyType = ClipperLib.PolyType.ptSubject;
    this.side = null; //= ClipperLib.EdgeSide.esNeither;
    this.windDelta = 0;
    this.windCnt = 0;
    this.windCnt2 = 0;
    this.outIdx = 0;
    this.next = null;
    this.prev = null;
    this.nextInLML = null;
    this.nextInAEL = null;
    this.prevInAEL = null;
    this.nextInSEL = null;
    this.prevInSEL = null;
  };
  ClipperLib.IntersectNode = function ()
  {
    this.edge1 = null;
    this.edge2 = null;
    this.pt = null;
    this.next = null;
  };
  ClipperLib.LocalMinima = function ()
  {
    this.y = 0;
    this.leftBound = null;
    this.rightBound = null;
    this.next = null;
  };
  ClipperLib.Scanbeam = function ()
  {
    this.y = 0;
    this.next = null;
  };
  ClipperLib.OutRec = function ()
  {
    this.idx = 0;
    this.isHole = false;
    this.FirstLeft = null;
    this.AppendLink = null;
    this.pts = null;
    this.bottomPt = null;
  };
  ClipperLib.OutPt = function ()
  {
    this.idx = 0;
    this.pt = null;
    this.next = null;
    this.prev = null;
  };
  ClipperLib.JoinRec = function ()
  {
    this.pt1a = null;
    this.pt1b = null;
    this.poly1Idx = 0;
    this.pt2a = null;
    this.pt2b = null;
    this.poly2Idx = 0;
  };
  ClipperLib.HorzJoinRec = function ()
  {
    this.edge = null;
    this.savedIdx = 0;
  };
  ClipperLib.ClipperBase = function ()
  {
    this.m_MinimaList = null;
    this.m_CurrentLM = null;
    this.m_edges = [
      []
    ]; // 2-dimensional array
    this.m_UseFullRange = false;
  };
  // Ranges are in original C# too high for Javascript (in current state 2012 December):
  // protected const double horizontal = -3.4E+38;
  // internal const Int64 loRange = 0x3FFFFFFF; // = 1073741823 = sqrt(2^63 -1)/2
  // internal const Int64 hiRange = 0x3FFFFFFFFFFFFFFFL; // = 4611686018427387903 = sqrt(2^127 -1)/2
  // So had to adjust them to more suitable:
  ClipperLib.ClipperBase.horizontal = -9007199254740992; //-2^53
  ClipperLib.ClipperBase.loRange = 47453132; // sqrt(2^53 -1)/2
  ClipperLib.ClipperBase.hiRange = 4503599627370495; // sqrt(2^106 -1)/2
  // If JS some day supports truly 64-bit integers, then these ranges can be as in C#
  // and biginteger library can be more simpler (as then 128bit can be represented as two 64bit numbers)
  ClipperLib.ClipperBase.PointsEqual = function (pt1, pt2)
  {
    return (pt1.x == pt2.x && pt1.y == pt2.y);
  };
  ClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp)
  {
    var pp2 = pp;
    do {
      if (ClipperLib.ClipperBase.PointsEqual(pp2.pt, pt)) return true;
      pp2 = pp2.next;
    }
    while (pp2 != pp);
    return false;
  };
  ClipperLib.ClipperBase.prototype.PointInPolygon = function (pt, pp, UseFulllongRange)
  {
    var pp2 = pp;
    var result = false;
    if (UseFulllongRange)
    {
      do {
        if ((((pp2.pt.y <= pt.y) && (pt.y < pp2.prev.pt.y)) || ((pp2.prev.pt.y <= pt.y) && (pt.y < pp2.pt.y))) && new Int128(pt.x - pp2.pt.x)
          .compareTo(
        new Int128(pp2.prev.pt.x - pp2.pt.x)
          .multiply(new Int128(pt.y - pp2.pt.y))
          .divide(
        new Int128(pp2.prev.pt.y - pp2.pt.y))) < 0) result = !result;
        pp2 = pp2.next;
      }
      while (pp2 != pp);
    }
    else
    {
      do {
        if ((((pp2.pt.y <= pt.y) && (pt.y < pp2.prev.pt.y)) || ((pp2.prev.pt.y <= pt.y) && (pt.y < pp2.pt.y))) && (pt.x - pp2.pt.x < (pp2.prev.pt.x - pp2.pt.x) * (pt.y - pp2.pt.y) / (pp2.prev.pt.y - pp2.pt.y))) result = !result;
        pp2 = pp2.next;
      }
      while (pp2 != pp);
    }
    return result;
  };
  ClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function ()
  {
    var a = arguments;
    var e1, e2, pt1, pt2, pt3, pt4, UseFullRange;
    if (a.length == 3) // function (e1, e2, UseFullRange)
    {
      e1 = a[0], e2 = a[1], UseFullRange = a[2];
      if (UseFullRange) return new Int128(e1.deltaY)
        .multiply(new Int128(e2.deltaX))
        .toString() == new Int128(e1.deltaX)
        .multiply(new Int128(e2.deltaY))
        .toString();
      else return (e1.deltaY) * (e2.deltaX) == (e1.deltaX) * (e2.deltaY);
    }
    else if (a.length == 4) // function (pt1, pt2, pt3, UseFullRange)
    {
      pt1 = a[0], pt2 = a[1], pt3 = a[2], UseFullRange = a[3];
      if (UseFullRange) return new Int128(pt1.y - pt2.y)
        .multiply(new Int128(pt2.x - pt3.x))
        .toString() == new Int128(pt1.x - pt2.x)
        .multiply(new Int128(pt2.y - pt3.y))
        .toString();
      else return (pt1.y - pt2.y) * (pt2.x - pt3.x) - (pt1.x - pt2.x) * (pt2.y - pt3.y) == 0;
    }
    else if (a.length == 5) // function (pt1, pt2, pt3, pt4, UseFullRange)
    {
      pt1 = a[0], pt2 = a[1], pt3 = a[2], pt4 = a[3], UseFullRange = a[4];
      if (UseFullRange) return new Int128(pt1.y - pt2.y)
        .multiply(new Int128(pt3.x - pt4.x))
        .toString() == new Int128(pt1.x - pt2.x)
        .multiply(new Int128(pt3.y - pt4.y))
        .toString();
      else return (pt1.y - pt2.y) * (pt3.x - pt4.x) - (pt1.x - pt2.x) * (pt3.y - pt4.y) == 0;
    }
  };
  ClipperLib.ClipperBase.prototype.Clear = function ()
  {
    this.DisposeLocalMinimaList();
    for (var i = 0; i < this.m_edges.length; ++i)
    {
      for (var j = 0; j < this.m_edges[i].length; ++j)
      this.m_edges[i][j] = null;
      ClipperLib.Clear(this.m_edges[i]);
    }
    ClipperLib.Clear(this.m_edges);
    this.m_UseFullRange = false;
  };
  ClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function ()
  {
    while (this.m_MinimaList != null)
    {
      var tmpLm = this.m_MinimaList.next;
      this.m_MinimaList = null;
      this.m_MinimaList = tmpLm;
    }
    this.m_CurrentLM = null;
  };
  ClipperLib.ClipperBase.prototype.AddPolygons = function (ppg, polyType)
  {
    var result = false;
    var res = false;
    if (!(ppg instanceof Array)) return result;
    for (var i = 0; i < ppg.length; ++i)
    {
    	res = this.AddPolygon(ppg[i], polyType, true);
      if (res && res != "exceed") result = true;
      else if (res == "exceed") break;
    }
    if (res == "exceed") ClipperLib.Error("Coordinate exceeds range bounds in AddPolygons().");
    return result;
  };
  ClipperLib.ClipperBase.prototype.AddPolygon = function (pg, polyType, multiple)
  {
  	if (!(pg instanceof Array)) return false;
    var len = pg.length;
    if (len < 3) return false;
    var p = new ClipperLib.Polygon();
    p.push(new ClipperLib.IntPoint(pg[0].x, pg[0].y));
    var j = 0;
    var i;
  	var exceed = false;
    for (i = 1; i < len; ++i)
    {
      var maxVal;
      if (this.m_UseFullRange) maxVal = ClipperLib.ClipperBase.hiRange;
      else maxVal = ClipperLib.ClipperBase.loRange;
      if (ClipperLib.Math_Abs_Int64(pg[i].x) > maxVal || ClipperLib.Math_Abs_Int64(pg[i].y) > maxVal)
      {
        if (ClipperLib.Math_Abs_Int64(pg[i].x) > ClipperLib.ClipperBase.hiRange || ClipperLib.Math_Abs_Int64(pg[i].y) > ClipperLib.ClipperBase.hiRange)
        {
        	if (typeof(multiple) != "undefined") return "exceed"; 
        	exceed = true;
        	break;
        }
        maxVal = ClipperLib.ClipperBase.hiRange;
        this.m_UseFullRange = true;
      }
      if (ClipperLib.ClipperBase.PointsEqual(p[j], pg[i])) continue;
      else if (j > 0 && this.SlopesEqual(p[j - 1], p[j], pg[i], this.m_UseFullRange))
      {
        if (ClipperLib.ClipperBase.PointsEqual(p[j - 1], pg[i])) j--;
      }
      else j++;
      if (j < p.length) p[j] = pg[i];
      else p.push(new ClipperLib.IntPoint(pg[i].x, pg[i].y));
    }
  	if (exceed && typeof(multiple) == "undefined")
    ClipperLib.Error("Coordinate exceeds range bounds in AddPolygon()");

    if (j < 2) return false;
    len = j + 1;
    while (len > 2)
    {
      if (ClipperLib.ClipperBase.PointsEqual(p[j], p[0])) j--;
      else if (ClipperLib.ClipperBase.PointsEqual(p[0], p[1]) || this.SlopesEqual(p[j], p[0], p[1], this.m_UseFullRange)) p[0] = p[j--];
      else if (this.SlopesEqual(p[j - 1], p[j], p[0], this.m_UseFullRange)) j--;
      else if (this.SlopesEqual(p[0], p[1], p[2], this.m_UseFullRange))
      {
        for (i = 2; i <= j; ++i)
        p[i - 1] = p[i];
        j--;
      }
      else break;
      len--;
    }

    if (len < 3) return false;
    var edges = [];
    for (i = 0; i < len; i++)
    edges.push(new ClipperLib.TEdge());
    this.m_edges.push(edges);
    edges[0].xcurr = p[0].x;
    edges[0].ycurr = p[0].y;
    this.InitEdge(edges[len - 1], edges[0], edges[len - 2], p[len - 1], polyType);
    for (i = len - 2; i > 0; --i)
    this.InitEdge(edges[i], edges[i + 1], edges[i - 1], p[i], polyType);
    this.InitEdge(edges[0], edges[1], edges[len - 1], p[0], polyType);
    var e = edges[0];
    var eHighest = e;
    do {
      e.xcurr = e.xbot;
      e.ycurr = e.ybot;
      if (e.ytop < eHighest.ytop) eHighest = e;
      e = e.next;
    }
    while (e != edges[0]);
    if (eHighest.windDelta > 0) eHighest = eHighest.next;
    if (eHighest.dx == ClipperLib.ClipperBase.horizontal) eHighest = eHighest.next;
    e = eHighest;
    do {
      e = this.AddBoundsToLML(e);
    }
    while (e != eHighest);
    return true;
  };
  ClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt, polyType)
  {
    e.next = eNext;
    e.prev = ePrev;
    e.xcurr = pt.x;
    e.ycurr = pt.y;
    if (e.ycurr >= e.next.ycurr)
    {
      e.xbot = e.xcurr;
      e.ybot = e.ycurr;
      e.xtop = e.next.xcurr;
      e.ytop = e.next.ycurr;
      e.windDelta = 1;
    }
    else
    {
      e.xtop = e.xcurr;
      e.ytop = e.ycurr;
      e.xbot = e.next.xcurr;
      e.ybot = e.next.ycurr;
      e.windDelta = -1;
    }
    this.SetDx(e);
    e.polyType = polyType;
    e.outIdx = -1;
  };
  ClipperLib.ClipperBase.prototype.SetDx = function (e)
  {
    e.deltaX = (e.xtop - e.xbot);
    e.deltaY = (e.ytop - e.ybot);
    if (e.deltaY == 0) e.dx = ClipperLib.ClipperBase.horizontal;
    else e.dx = (e.deltaX) / (e.deltaY);
  };
  ClipperLib.ClipperBase.prototype.AddBoundsToLML = function (e)
  {
    e.nextInLML = null;
    e = e.next;
    for (;;)
    {
      if (e.dx == ClipperLib.ClipperBase.horizontal)
      {
        if (e.next.ytop < e.ytop && e.next.xbot > e.prev.xbot) break;
        if (e.xtop != e.prev.xbot) this.SwapX(e);
        e.nextInLML = e.prev;
      }
      else if (e.ycurr == e.prev.ycurr) break;
      else e.nextInLML = e.prev;
      e = e.next;
    }
    var newLm = new ClipperLib.LocalMinima();
    newLm.next = null;
    newLm.y = e.prev.ybot;
    if (e.dx == ClipperLib.ClipperBase.horizontal)
    {
      if (e.xbot != e.prev.xbot) this.SwapX(e);
      newLm.leftBound = e.prev;
      newLm.rightBound = e;
    }
    else if (e.dx < e.prev.dx)
    {
      newLm.leftBound = e.prev;
      newLm.rightBound = e;
    }
    else
    {
      newLm.leftBound = e;
      newLm.rightBound = e.prev;
    }
    newLm.leftBound.side = ClipperLib.EdgeSide.esLeft;
    newLm.rightBound.side = ClipperLib.EdgeSide.esRight;
    this.InsertLocalMinima(newLm);
    for (;;)
    {
      if (e.next.ytop == e.ytop && e.next.dx != ClipperLib.ClipperBase.horizontal) break;
      e.nextInLML = e.next;
      e = e.next;
      if (e.dx == ClipperLib.ClipperBase.horizontal && e.xbot != e.prev.xtop) this.SwapX(e);
    }
    return e.next;
  };
  ClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm)
  {
    if (this.m_MinimaList == null)
    {
      this.m_MinimaList = newLm;
    }
    else if (newLm.y >= this.m_MinimaList.y)
    {
      newLm.next = this.m_MinimaList;
      this.m_MinimaList = newLm;
    }
    else
    {
      var tmpLm = this.m_MinimaList;
      while (tmpLm.next != null && (newLm.y < tmpLm.next.y))
      tmpLm = tmpLm.next;
      newLm.next = tmpLm.next;
      tmpLm.next = newLm;
    }
  };
  ClipperLib.ClipperBase.prototype.PopLocalMinima = function ()
  {
    if (this.m_CurrentLM == null) return;
    this.m_CurrentLM = this.m_CurrentLM.next;
  };
  ClipperLib.ClipperBase.prototype.SwapX = function (e)
  {
    e.xcurr = e.xtop;
    e.xtop = e.xbot;
    e.xbot = e.xcurr;
  };
  ClipperLib.ClipperBase.prototype.Reset = function ()
  {
    this.m_CurrentLM = this.m_MinimaList;
    var lm = this.m_MinimaList;
    while (lm != null)
    {
      var e = lm.leftBound;
      while (e != null)
      {
        e.xcurr = e.xbot;
        e.ycurr = e.ybot;
        e.side = ClipperLib.EdgeSide.esLeft;
        e.outIdx = -1;
        e = e.nextInLML;
      }
      e = lm.rightBound;
      while (e != null)
      {
        e.xcurr = e.xbot;
        e.ycurr = e.ybot;
        e.side = ClipperLib.EdgeSide.esRight;
        e.outIdx = -1;
        e = e.nextInLML;
      }
      lm = lm.next;
    }
    return;
  };
  ClipperLib.ClipperBase.prototype.GetBounds = function ()
  {
    var result = new ClipperLib.IntRect();
    var lm = this.m_MinimaList;
    if (lm == null) return result;
    result.left = lm.leftBound.xbot;
    result.top = lm.leftBound.ybot;
    result.right = lm.leftBound.xbot;
    result.bottom = lm.leftBound.ybot;
    while (lm != null)
    {
      if (lm.leftBound.ybot > result.bottom) result.bottom = lm.leftBound.ybot;
      var e = lm.leftBound;
      for (;;)
      {
        var bottomE = e;
        while (e.nextInLML != null)
        {
          if (e.xbot < result.left) result.left = e.xbot;
          if (e.xbot > result.right) result.right = e.xbot;
          e = e.nextInLML;
        }
        if (e.xbot < result.left) result.left = e.xbot;
        if (e.xbot > result.right) result.right = e.xbot;
        if (e.xtop < result.left) result.left = e.xtop;
        if (e.xtop > result.right) result.right = e.xtop;
        if (e.ytop < result.top) result.top = e.ytop;
        if (bottomE == lm.leftBound) e = lm.rightBound;
        else break;
      }
      lm = lm.next;
    }
    return result;
  };
  ClipperLib.Clipper = function ()
  {
    this.m_PolyOuts = null;
    this.m_ClipType = ClipperLib.ClipType.ctIntersection;
    this.m_Scanbeam = null;
    this.m_ActiveEdges = null;
    this.m_SortedEdges = null;
    this.m_IntersectNodes = null;
    this.m_ExecuteLocked = false;
    this.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;
    this.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;
    this.m_Joins = null;
    this.m_HorizJoins = null;
    this.m_ReverseOutput = false;
    this.m_UsingExPolygons = false;
    ClipperLib.ClipperBase.call(this);
    this.m_Scanbeam = null;
    this.m_ActiveEdges = null;
    this.m_SortedEdges = null;
    this.m_IntersectNodes = null;
    this.m_ExecuteLocked = false;
    this.m_PolyOuts = [];
    this.m_Joins = [];
    this.m_HorizJoins = [];
    this.m_ReverseOutput = false;
    this.m_UsingExPolygons = false;
  };
  ClipperLib.Clipper.prototype.Clear = function ()
  {
    if (this.m_edges.length == 0) return;
    this.DisposeAllPolyPts();
    ClipperLib.ClipperBase.prototype.Clear.call(this);
  };
  ClipperLib.Clipper.prototype.DisposeScanbeamList = function ()
  {
    while (this.m_Scanbeam != null)
    {
      var sb2 = this.m_Scanbeam.next;
      this.m_Scanbeam = null;
      this.m_Scanbeam = sb2;
    }
  };
  ClipperLib.Clipper.prototype.Reset = function ()
  {
    ClipperLib.ClipperBase.prototype.Reset.call(this);
    this.m_Scanbeam = null;
    this.m_ActiveEdges = null;
    this.m_SortedEdges = null;
    this.DisposeAllPolyPts();
    var lm = this.m_MinimaList;
    while (lm != null)
    {
      this.InsertScanbeam(lm.y);
      this.InsertScanbeam(lm.leftBound.ytop);
      lm = lm.next;
    }
  };
  ClipperLib.Clipper.prototype.get_ReverseSolution = function ()
  {
    return this.m_ReverseOutput;
  };
  ClipperLib.Clipper.prototype.set_ReverseSolution = function (value)
  {
    this.m_ReverseOutput = value;
  };
  ClipperLib.Clipper.prototype.InsertScanbeam = function (Y)
  {
    var newSb;
    if (this.m_Scanbeam == null)
    {
      this.m_Scanbeam = new ClipperLib.Scanbeam();
      this.m_Scanbeam.next = null;
      this.m_Scanbeam.y = Y;
    }
    else if (Y > this.m_Scanbeam.y)
    {
      newSb = new ClipperLib.Scanbeam();
      newSb.y = Y;
      newSb.next = this.m_Scanbeam;
      this.m_Scanbeam = newSb;
    }
    else
    {
      var sb2 = this.m_Scanbeam;
      while (sb2.next != null && (Y <= sb2.next.y))
      sb2 = sb2.next;
      if (Y == sb2.y) return;
      newSb = new ClipperLib.Scanbeam();
      newSb.y = Y;
      newSb.next = sb2.next;
      sb2.next = newSb;
    }
  };
  ClipperLib.Clipper.prototype.Execute = function (clipType, solution, subjFillType, clipFillType)
  {
    var succeeded;
    if (arguments.length == 2)
    {
      subjFillType = ClipperLib.PolyFillType.pftEvenOdd;
      clipFillType = ClipperLib.PolyFillType.pftEvenOdd;
    }
    if ( typeof(solution.exPolygons) == "undefined") // hacky way to test if solution is not exPolygons
    {
      if (this.m_ExecuteLocked) return false;
      this.m_ExecuteLocked = true;
      ClipperLib.Clear(solution);
      this.m_SubjFillType = subjFillType;
      this.m_ClipFillType = clipFillType;
      this.m_ClipType = clipType;
      this.m_UsingExPolygons = false;
      succeeded = this.ExecuteInternal();
      if (succeeded)
      {
        this.BuildResult(solution);
      }
      this.m_ExecuteLocked = false;
      return succeeded;
    }
    else
    {
      if (this.m_ExecuteLocked) return false;
      this.m_ExecuteLocked = true;
      ClipperLib.Clear(solution);
      this.m_SubjFillType = subjFillType;
      this.m_ClipFillType = clipFillType;
      this.m_ClipType = clipType;
      this.m_UsingExPolygons = true;
      succeeded = this.ExecuteInternal();
      if (succeeded)
      {
        this.BuildResultEx(solution);
      }
      this.m_ExecuteLocked = false;
      return succeeded;
    }
  };
  ClipperLib.Clipper.prototype.PolySort = function (or1, or2)
  {
    if (or1 == or2) return 0;
    else if (or1.pts == null || or2.pts == null)
    {
      if ((or1.pts == null) != (or2.pts == null))
      {
        return or1.pts == null ? 1 : -1;
      }
      else return 0;
    }
    var i1, i2;
    if (or1.isHole) i1 = or1.FirstLeft.idx;
    else i1 = or1.idx;
    if (or2.isHole) i2 = or2.FirstLeft.idx;
    else i2 = or2.idx;
    var result = i1 - i2;
    if (result == 0 && (or1.isHole != or2.isHole))
    {
      return or1.isHole ? 1 : -1;
    }
    return result;
  };
  ClipperLib.Clipper.prototype.FindAppendLinkEnd = function (outRec)
  {
    while (outRec.AppendLink != null)
    outRec = outRec.AppendLink;
    return outRec;
  };
  ClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec)
  {
    var tmp;
    if (outRec.bottomPt != null) tmp = this.m_PolyOuts[outRec.bottomPt.idx].FirstLeft;
    else tmp = outRec.FirstLeft;
    if (outRec == tmp) ClipperLib.Error("HoleLinkage error");
    if (tmp != null)
    {
      if (tmp.AppendLink != null) tmp = this.FindAppendLinkEnd(tmp);
      if (tmp == outRec) tmp = null;
      else if (tmp.isHole)
      {
        this.FixHoleLinkage(tmp);
        tmp = tmp.FirstLeft;
      }
    }
    outRec.FirstLeft = tmp;
    if (tmp == null) outRec.isHole = false;
    outRec.AppendLink = null;
  };
  ClipperLib.Clipper.prototype.ExecuteInternal = function ()
  {
    var succeeded;
    try
    {
      this.Reset();
      if (this.m_CurrentLM == null) return true;
      var botY = this.PopScanbeam();
      do {
        this.InsertLocalMinimaIntoAEL(botY);
        ClipperLib.Clear(this.m_HorizJoins);
        this.ProcessHorizontals();
        var topY = this.PopScanbeam();
        succeeded = this.ProcessIntersections(botY, topY);
        if (!succeeded) break;
        this.ProcessEdgesAtTopOfScanbeam(topY);
        botY = topY;
      }
      while (this.m_Scanbeam != null);
    }
    catch ($$e1)
    {
      succeeded = false;
    }
    if (succeeded)
    {
      var outRec;
      for (var i = 0; i < this.m_PolyOuts.length; i++)
      {
        outRec = this.m_PolyOuts[i];
        if (outRec.pts == null) continue;
        this.FixupOutPolygon(outRec);
        if (outRec.pts == null) continue;
        if (outRec.isHole && this.m_UsingExPolygons) this.FixHoleLinkage(outRec);
        
        if ((outRec.isHole ^ this.m_ReverseOutput) ==  (this.Area(outRec, this.m_UseFullRange) > 0))
        this.ReversePolyPtLinks(outRec.pts);
      }
      this.JoinCommonEdges();
      if (this.m_UsingExPolygons) this.m_PolyOuts.sort(this.PolySort);
    }
    ClipperLib.Clear(this.m_Joins);
    ClipperLib.Clear(this.m_HorizJoins);
    return succeeded;
  };
  ClipperLib.Clipper.prototype.PopScanbeam = function ()
  {
    var Y = this.m_Scanbeam.y;
    var sb2 = this.m_Scanbeam;
    this.m_Scanbeam = this.m_Scanbeam.next;
    sb2 = null;
    return Y;
  };
  ClipperLib.Clipper.prototype.DisposeAllPolyPts = function ()
  {
    for (var i = 0; i < this.m_PolyOuts.length; ++i)
    this.DisposeOutRec(i);
    ClipperLib.Clear(this.m_PolyOuts);
  };
  ClipperLib.Clipper.prototype.DisposeOutRec = function (index)
  {
    var outRec = this.m_PolyOuts[index];
    if (outRec.pts != null) this.DisposeOutPts(outRec.pts);
    outRec = null;
    this.m_PolyOuts[index] = null;
  };
  ClipperLib.Clipper.prototype.DisposeOutPts = function (pp)
  {
    if (pp == null) return;
    var tmpPp = null;
    pp.prev.next = null;
    while (pp != null)
    {
      tmpPp = pp;
      pp = pp.next;
      tmpPp = null;
    }
  };
  ClipperLib.Clipper.prototype.AddJoin = function (e1, e2, e1OutIdx, e2OutIdx)
  {
    var jr = new ClipperLib.JoinRec();
    if (e1OutIdx >= 0) jr.poly1Idx = e1OutIdx;
    else jr.poly1Idx = e1.outIdx;
    jr.pt1a = new ClipperLib.IntPoint(e1.xcurr, e1.ycurr);
    jr.pt1b = new ClipperLib.IntPoint(e1.xtop, e1.ytop);
    if (e2OutIdx >= 0) jr.poly2Idx = e2OutIdx;
    else jr.poly2Idx = e2.outIdx;
    jr.pt2a = new ClipperLib.IntPoint(e2.xcurr, e2.ycurr);
    jr.pt2b = new ClipperLib.IntPoint(e2.xtop, e2.ytop);
    this.m_Joins.push(jr);
  };
  ClipperLib.Clipper.prototype.AddHorzJoin = function (e, idx)
  {
    var hj = new ClipperLib.HorzJoinRec();
    hj.edge = e;
    hj.savedIdx = idx;
    this.m_HorizJoins.push(hj);
  };
  ClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY)
  {
    var pt, pt2;
    while (this.m_CurrentLM != null && (this.m_CurrentLM.y == botY))
    {
      var lb = this.m_CurrentLM.leftBound;
      var rb = this.m_CurrentLM.rightBound;
      this.InsertEdgeIntoAEL(lb);
      this.InsertScanbeam(lb.ytop);
      this.InsertEdgeIntoAEL(rb);
      if (this.IsEvenOddFillType(lb))
      {
        lb.windDelta = 1;
        rb.windDelta = 1;
      }
      else
      {
        rb.windDelta = -lb.windDelta;
      }
      this.SetWindingCount(lb);
      rb.windCnt = lb.windCnt;
      rb.windCnt2 = lb.windCnt2;
      if (rb.dx == ClipperLib.ClipperBase.horizontal)
      {
        this.AddEdgeToSEL(rb);
        this.InsertScanbeam(rb.nextInLML.ytop);
      }
      else this.InsertScanbeam(rb.ytop);
      if (this.IsContributing(lb)) this.AddLocalMinPoly(lb, rb, new ClipperLib.IntPoint(lb.xcurr, this.m_CurrentLM.y));
      if (rb.outIdx >= 0)
      {
        if (rb.dx == ClipperLib.ClipperBase.horizontal)
        {
          for (var i = 0; i < this.m_HorizJoins.length; i++)
          {
            pt = new ClipperLib.IntPoint(), pt2 = new ClipperLib.IntPoint();
            var hj = this.m_HorizJoins[i];
            if ((function ()
            {
              pt = {
                Value: pt
              };
              pt2 = {
                Value: pt2
              };
              var $res = this.GetOverlapSegment(new ClipperLib.IntPoint(hj.edge.xbot, hj.edge.ybot),
              new ClipperLib.IntPoint(hj.edge.xtop, hj.edge.ytop),
              new ClipperLib.IntPoint(rb.xbot, rb.ybot),
              new ClipperLib.IntPoint(rb.xtop, rb.ytop),
              pt, pt2);
              pt = pt.Value;
              pt2 = pt2.Value;
              return $res;
            })
              .call(this)) this.AddJoin(hj.edge, rb, hj.savedIdx, -1);
          }
        }
      }
      if (lb.nextInAEL != rb)
      {
        if (rb.outIdx >= 0 && rb.prevInAEL.outIdx >= 0 && this.SlopesEqual(rb.prevInAEL, rb, this.m_UseFullRange)) this.AddJoin(rb, rb.prevInAEL, -1, -1);
        var e = lb.nextInAEL;
        pt = new ClipperLib.IntPoint(lb.xcurr, lb.ycurr);
        while (e != rb)
        {
          if (e == null) ClipperLib.Error("InsertLocalMinimaIntoAEL: missing rightbound!");
          this.IntersectEdges(rb, e, pt, ClipperLib.Protects.ipNone);
          e = e.nextInAEL;
        }
      }
      this.PopLocalMinima();
    }
  };
  ClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge)
  {
    edge.prevInAEL = null;
    edge.nextInAEL = null;
    if (this.m_ActiveEdges == null)
    {
      this.m_ActiveEdges = edge;
    }
    else if (this.E2InsertsBeforeE1(this.m_ActiveEdges, edge))
    {
      edge.nextInAEL = this.m_ActiveEdges;
      this.m_ActiveEdges.prevInAEL = edge;
      this.m_ActiveEdges = edge;
    }
    else
    {
      var e = this.m_ActiveEdges;
      while (e.nextInAEL != null && !this.E2InsertsBeforeE1(e.nextInAEL, edge))
      e = e.nextInAEL;
      edge.nextInAEL = e.nextInAEL;
      if (e.nextInAEL != null) e.nextInAEL.prevInAEL = edge;
      edge.prevInAEL = e;
      e.nextInAEL = edge;
    }
  };
  ClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2)
  {
    return e2.xcurr == e1.xcurr ? e2.dx > e1.dx : e2.xcurr < e1.xcurr;
  };
  ClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge)
  {
    if (edge.polyType == ClipperLib.PolyType.ptSubject) return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;
    else return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;
  };
  ClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge)
  {
    if (edge.polyType == ClipperLib.PolyType.ptSubject) return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;
    else return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;
  };
  ClipperLib.Clipper.prototype.IsContributing = function (edge)
  {
    var pft, pft2;
    if (edge.polyType == ClipperLib.PolyType.ptSubject)
    {
      pft = this.m_SubjFillType;
      pft2 = this.m_ClipFillType;
    }
    else
    {
      pft = this.m_ClipFillType;
      pft2 = this.m_SubjFillType;
    }
    switch (pft)
    {
      case ClipperLib.PolyFillType.pftEvenOdd:
      case ClipperLib.PolyFillType.pftNonZero:
        if (ClipperLib.Math_Abs_Int32(edge.windCnt) != 1) return false;
        break;
      case ClipperLib.PolyFillType.pftPositive:
        if (edge.windCnt != 1) return false;
        break;
      default:
        if (edge.windCnt != -1) return false;
        break;
    }
    switch (this.m_ClipType)
    {
      case ClipperLib.ClipType.ctIntersection:
        switch (pft2)
        {
          case ClipperLib.PolyFillType.pftEvenOdd:
          case ClipperLib.PolyFillType.pftNonZero:
            return (edge.windCnt2 != 0);
          case ClipperLib.PolyFillType.pftPositive:
            return (edge.windCnt2 > 0);
          default:
            return (edge.windCnt2 < 0);
        }
        break;
      case ClipperLib.ClipType.ctUnion:
        switch (pft2)
        {
          case ClipperLib.PolyFillType.pftEvenOdd:
          case ClipperLib.PolyFillType.pftNonZero:
            return (edge.windCnt2 == 0);
          case ClipperLib.PolyFillType.pftPositive:
            return (edge.windCnt2 <= 0);
          default:
            return (edge.windCnt2 >= 0);
        }
        break;
      case ClipperLib.ClipType.ctDifference:
        if (edge.polyType == ClipperLib.PolyType.ptSubject) switch (pft2)
        {
          case ClipperLib.PolyFillType.pftEvenOdd:
          case ClipperLib.PolyFillType.pftNonZero:
            return (edge.windCnt2 == 0);
          case ClipperLib.PolyFillType.pftPositive:
            return (edge.windCnt2 <= 0);
          default:
            return (edge.windCnt2 >= 0);
        }
        else switch (pft2)
        {
          case ClipperLib.PolyFillType.pftEvenOdd:
          case ClipperLib.PolyFillType.pftNonZero:
            return (edge.windCnt2 != 0);
          case ClipperLib.PolyFillType.pftPositive:
            return (edge.windCnt2 > 0);
          default:
            return (edge.windCnt2 < 0);
        }
    }
    return true;
  };
  ClipperLib.Clipper.prototype.SetWindingCount = function (edge)
  {
    var e = edge.prevInAEL;
    while (e != null && e.polyType != edge.polyType)
    e = e.prevInAEL;
    if (e == null)
    {
      edge.windCnt = edge.windDelta;
      edge.windCnt2 = 0;
      e = this.m_ActiveEdges;
    }
    else if (this.IsEvenOddFillType(edge))
    {
      edge.windCnt = 1;
      edge.windCnt2 = e.windCnt2;
      e = e.nextInAEL;
    }
    else
    {
      if (e.windCnt * e.windDelta < 0)
      {
        if (ClipperLib.Math_Abs_Int32(e.windCnt) > 1)
        {
          if (e.windDelta * edge.windDelta < 0) edge.windCnt = e.windCnt;
          else edge.windCnt = e.windCnt + edge.windDelta;
        }
        else edge.windCnt = e.windCnt + e.windDelta + edge.windDelta;
      }
      else
      {
        if (ClipperLib.Math_Abs_Int32(e.windCnt) > 1 && e.windDelta * edge.windDelta < 0) edge.windCnt = e.windCnt;
        else if (e.windCnt + edge.windDelta == 0) edge.windCnt = e.windCnt;
        else edge.windCnt = e.windCnt + edge.windDelta;
      }
      edge.windCnt2 = e.windCnt2;
      e = e.nextInAEL;
    }
    if (this.IsEvenOddAltFillType(edge))
    {
      while (e != edge)
      {
        edge.windCnt2 = (edge.windCnt2 == 0) ? 1 : 0;
        e = e.nextInAEL;
      }
    }
    else
    {
      while (e != edge)
      {
        edge.windCnt2 += e.windDelta;
        e = e.nextInAEL;
      }
    }
  };
  ClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge)
  {
    if (this.m_SortedEdges == null)
    {
      this.m_SortedEdges = edge;
      edge.prevInSEL = null;
      edge.nextInSEL = null;
    }
    else
    {
      edge.nextInSEL = this.m_SortedEdges;
      edge.prevInSEL = null;
      this.m_SortedEdges.prevInSEL = edge;
      this.m_SortedEdges = edge;
    }
  };
  ClipperLib.Clipper.prototype.CopyAELToSEL = function ()
  {
    var e = this.m_ActiveEdges;
    this.m_SortedEdges = e;
    if (this.m_ActiveEdges == null) return;
    this.m_SortedEdges.prevInSEL = null;
    e = e.nextInAEL;
    while (e != null)
    {
      e.prevInSEL = e.prevInAEL;
      e.prevInSEL.nextInSEL = e;
      e.nextInSEL = null;
      e = e.nextInAEL;
    }
  };
  ClipperLib.Clipper.prototype.SwapPositionsInAEL = function (edge1, edge2)
  {
    var next, prev;
    if (edge1.nextInAEL == null && edge1.prevInAEL == null) return;
    if (edge2.nextInAEL == null && edge2.prevInAEL == null) return;
    if (edge1.nextInAEL == edge2)
    {
      next = edge2.nextInAEL;
      if (next != null) next.prevInAEL = edge1;
      prev = edge1.prevInAEL;
      if (prev != null) prev.nextInAEL = edge2;
      edge2.prevInAEL = prev;
      edge2.nextInAEL = edge1;
      edge1.prevInAEL = edge2;
      edge1.nextInAEL = next;
    }
    else if (edge2.nextInAEL == edge1)
    {
      next = edge1.nextInAEL;
      if (next != null) next.prevInAEL = edge2;
      prev = edge2.prevInAEL;
      if (prev != null) prev.nextInAEL = edge1;
      edge1.prevInAEL = prev;
      edge1.nextInAEL = edge2;
      edge2.prevInAEL = edge1;
      edge2.nextInAEL = next;
    }
    else
    {
      next = edge1.nextInAEL;
      prev = edge1.prevInAEL;
      edge1.nextInAEL = edge2.nextInAEL;
      if (edge1.nextInAEL != null) edge1.nextInAEL.prevInAEL = edge1;
      edge1.prevInAEL = edge2.prevInAEL;
      if (edge1.prevInAEL != null) edge1.prevInAEL.nextInAEL = edge1;
      edge2.nextInAEL = next;
      if (edge2.nextInAEL != null) edge2.nextInAEL.prevInAEL = edge2;
      edge2.prevInAEL = prev;
      if (edge2.prevInAEL != null) edge2.prevInAEL.nextInAEL = edge2;
    }
    if (edge1.prevInAEL == null) this.m_ActiveEdges = edge1;
    else if (edge2.prevInAEL == null) this.m_ActiveEdges = edge2;
  };
  ClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2)
  {
    var next, prev;
    if (edge1.nextInSEL == null && edge1.prevInSEL == null) return;
    if (edge2.nextInSEL == null && edge2.prevInSEL == null) return;
    if (edge1.nextInSEL == edge2)
    {
      next = edge2.nextInSEL;
      if (next != null) next.prevInSEL = edge1;
      prev = edge1.prevInSEL;
      if (prev != null) prev.nextInSEL = edge2;
      edge2.prevInSEL = prev;
      edge2.nextInSEL = edge1;
      edge1.prevInSEL = edge2;
      edge1.nextInSEL = next;
    }
    else if (edge2.nextInSEL == edge1)
    {
      next = edge1.nextInSEL;
      if (next != null) next.prevInSEL = edge2;
      prev = edge2.prevInSEL;
      if (prev != null) prev.nextInSEL = edge1;
      edge1.prevInSEL = prev;
      edge1.nextInSEL = edge2;
      edge2.prevInSEL = edge1;
      edge2.nextInSEL = next;
    }
    else
    {
      next = edge1.nextInSEL;
      prev = edge1.prevInSEL;
      edge1.nextInSEL = edge2.nextInSEL;
      if (edge1.nextInSEL != null) edge1.nextInSEL.prevInSEL = edge1;
      edge1.prevInSEL = edge2.prevInSEL;
      if (edge1.prevInSEL != null) edge1.prevInSEL.nextInSEL = edge1;
      edge2.nextInSEL = next;
      if (edge2.nextInSEL != null) edge2.nextInSEL.prevInSEL = edge2;
      edge2.prevInSEL = prev;
      if (edge2.prevInSEL != null) edge2.prevInSEL.nextInSEL = edge2;
    }
    if (edge1.prevInSEL == null) this.m_SortedEdges = edge1;
    else if (edge2.prevInSEL == null) this.m_SortedEdges = edge2;
  };
  ClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt)
  {
    this.AddOutPt(e1, pt);
    if (e1.outIdx == e2.outIdx)
    {
      e1.outIdx = -1;
      e2.outIdx = -1;
    }
    else if (e1.outIdx < e2.outIdx) this.AppendPolygon(e1, e2);
    else this.AppendPolygon(e2, e1);
  };
  ClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt)
  {
    var e, prevE;
    if (e2.dx == ClipperLib.ClipperBase.horizontal || (e1.dx > e2.dx))
    {
      this.AddOutPt(e1, pt);
      e2.outIdx = e1.outIdx;
      e1.side = ClipperLib.EdgeSide.esLeft;
      e2.side = ClipperLib.EdgeSide.esRight;
      e = e1;
      if (e.prevInAEL == e2) prevE = e2.prevInAEL;
      else prevE = e.prevInAEL;
    }
    else
    {
      this.AddOutPt(e2, pt);
      e1.outIdx = e2.outIdx;
      e1.side = ClipperLib.EdgeSide.esRight;
      e2.side = ClipperLib.EdgeSide.esLeft;
      e = e2;
      if (e.prevInAEL == e1) prevE = e1.prevInAEL;
      else prevE = e.prevInAEL;
    }
    if (prevE != null && prevE.outIdx >= 0 && (ClipperLib.Clipper.TopX(prevE, pt.y) == ClipperLib.Clipper.TopX(e, pt.y)) && this.SlopesEqual(e, prevE, this.m_UseFullRange)) this.AddJoin(e, prevE, -1, -1);
  };
  ClipperLib.Clipper.prototype.CreateOutRec = function ()
  {
    var result = new ClipperLib.OutRec();
    result.idx = -1;
    result.isHole = false;
    result.FirstLeft = null;
    result.AppendLink = null;
    result.pts = null;
    result.bottomPt = null;
    return result;
  };
  ClipperLib.Clipper.prototype.AddOutPt = function (e, pt)
  {
    var outRec, op;
    var ToFront = (e.side == ClipperLib.EdgeSide.esLeft);
    if (e.outIdx < 0)
    {
      outRec = this.CreateOutRec();
      this.m_PolyOuts.push(outRec);
      outRec.idx = this.m_PolyOuts.length - 1;
      e.outIdx = outRec.idx;
      op = new ClipperLib.OutPt();
      outRec.pts = op;
      outRec.bottomPt = op;
      op.pt = pt;
      op.idx = outRec.idx;
      op.next = op;
      op.prev = op;
      this.SetHoleState(e, outRec);
    }
    else
    {
      outRec = this.m_PolyOuts[e.outIdx];
      op = outRec.pts;
      var op2;
      if (ToFront && ClipperLib.ClipperBase.PointsEqual(pt, op.pt) || (!ToFront && ClipperLib.ClipperBase.PointsEqual(pt, op.prev.pt))) return;
      op2 = new ClipperLib.OutPt();
      op2.pt = pt;
      op2.idx = outRec.idx;
      if (op2.pt.y == outRec.bottomPt.pt.y && op2.pt.x < outRec.bottomPt.pt.x) outRec.bottomPt = op2;
      op2.next = op;
      op2.prev = op.prev;
      op2.prev.next = op2;
      op.prev = op2;
      if (ToFront) outRec.pts = op2;
    }
  };
  ClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2)
  {
    var tmp = pt1.Value;
    pt1.Value = pt2.Value;
    pt2.Value = tmp;
  };
  ClipperLib.Clipper.prototype.GetOverlapSegment = function (pt1a, pt1b, pt2a, pt2b, pt1, pt2)
  {
    if (ClipperLib.Math_Abs_Int64(pt1a.x - pt1b.x) > ClipperLib.Math_Abs_Int64(pt1a.y - pt1b.y))
    {
      if (pt1a.x > pt1b.x)
      (function ()
      {
        pt1a = {
          Value: pt1a
        };
        pt1b = {
          Value: pt1b
        };
        var $res = this.SwapPoints(pt1a, pt1b);
        pt1a = pt1a.Value;
        pt1b = pt1b.Value;
        return $res;
      })
        .call(this);
      if (pt2a.x > pt2b.x)
      (function ()
      {
        pt2a = {
          Value: pt2a
        };
        pt2b = {
          Value: pt2b
        };
        var $res = this.SwapPoints(pt2a, pt2b);
        pt2a = pt2a.Value;
        pt2b = pt2b.Value;
        return $res;
      })
        .call(this);
      if (pt1a.x > pt2a.x) pt1.Value = pt1a;
      else pt1.Value = pt2a;
      if (pt1b.x < pt2b.x) pt2.Value = pt1b;
      else pt2.Value = pt2b;
      return pt1.Value.x < pt2.Value.x;
    }
    else
    {
      if (pt1a.y < pt1b.y)
      (function ()
      {
        pt1a = {
          Value: pt1a
        };
        pt1b = {
          Value: pt1b
        };
        var $res = this.SwapPoints(pt1a, pt1b);
        pt1a = pt1a.Value;
        pt1b = pt1b.Value;
        return $res;
      })
        .call(this);
      if (pt2a.y < pt2b.y)
      (function ()
      {
        pt2a = {
          Value: pt2a
        };
        pt2b = {
          Value: pt2b
        };
        var $res = this.SwapPoints(pt2a, pt2b);
        pt2a = pt2a.Value;
        pt2b = pt2b.Value;
        return $res;
      })
        .call(this);
      if (pt1a.y < pt2a.y) pt1.Value = pt1a;
      else pt1.Value = pt2a;
      if (pt1b.y > pt2b.y) pt2.Value = pt1b;
      else pt2.Value = pt2b;
      return pt1.Value.y > pt2.Value.y;
    }
  };
  ClipperLib.Clipper.prototype.FindSegment = function (pp, UseFullInt64Range, pt1, pt2)
  {
    if (pp.Value == null) return false;
    var pp2 = pp.Value;
    var pt1a = new ClipperLib.IntPoint(pt1.Value);
    var pt2a = new ClipperLib.IntPoint(pt2.Value);
    do {
        // Timo's comment: for some reason calling SlopesEqual() below uses big integers
        // So although coordinates are low (eg. 900), big integers are sometimes used.
        // => Fixed according to changes in original Clipper ver 5.1.2 (25 February 2013)
      if (this.SlopesEqual(pt1a, pt2a, pp.Value.pt, pp.Value.prev.pt, UseFullInt64Range) && this.SlopesEqual(pt1a, pt2a, pp.Value.pt, UseFullInt64Range) && this.GetOverlapSegment(pt1a, pt2a, pp.Value.pt, pp.Value.prev.pt, pt1, pt2)) return true;
      pp.Value = pp.Value.next;
    }
    while (pp.Value != pp2);
    return false;
  };
  ClipperLib.Clipper.prototype.Pt3IsBetweenPt1AndPt2 = function (pt1, pt2, pt3)
  {
    if (ClipperLib.ClipperBase.PointsEqual(pt1, pt3) || ClipperLib.ClipperBase.PointsEqual(pt2, pt3)) return true;
    else if (pt1.x != pt2.x) return (pt1.x < pt3.x) == (pt3.x < pt2.x);
    else return (pt1.y < pt3.y) == (pt3.y < pt2.y);
  };
  ClipperLib.Clipper.prototype.InsertPolyPtBetween = function (p1, p2, pt)
  {
    var result = new ClipperLib.OutPt();
    result.pt = pt;
    if (p2 == p1.next)
    {
      p1.next = result;
      p2.prev = result;
      result.next = p2;
      result.prev = p1;
    }
    else
    {
      p2.next = result;
      p1.prev = result;
      result.next = p1;
      result.prev = p2;
    }
    return result;
  };
  ClipperLib.Clipper.prototype.SetHoleState = function (e, outRec)
  {
    var isHole = false;
    var e2 = e.prevInAEL;
    while (e2 != null)
    {
      if (e2.outIdx >= 0)
      {
        isHole = !isHole;
        if (outRec.FirstLeft == null) outRec.FirstLeft = this.m_PolyOuts[e2.outIdx];
      }
      e2 = e2.prevInAEL;
    }
    if (isHole) outRec.isHole = true;
  };
  ClipperLib.Clipper.prototype.GetDx = function (pt1, pt2)
  {
    if (pt1.y == pt2.y) return ClipperLib.ClipperBase.horizontal;
    else return (pt2.x - pt1.x) / (pt2.y - pt1.y);
  };
  ClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2)
  {
    var p = btmPt1.prev;
    while (ClipperLib.ClipperBase.PointsEqual(p.pt, btmPt1.pt) && (p != btmPt1))
    p = p.prev;
    var dx1p = ClipperLib.Math_Abs_Double(this.GetDx(btmPt1.pt, p.pt));
    p = btmPt1.next;
    while (ClipperLib.ClipperBase.PointsEqual(p.pt, btmPt1.pt) && (p != btmPt1))
    p = p.next;
    var dx1n = ClipperLib.Math_Abs_Double(this.GetDx(btmPt1.pt, p.pt));
    p = btmPt2.prev;
    while (ClipperLib.ClipperBase.PointsEqual(p.pt, btmPt2.pt) && (p != btmPt2))
    p = p.prev;
    var dx2p = ClipperLib.Math_Abs_Double(this.GetDx(btmPt2.pt, p.pt));
    p = btmPt2.next;
    while (ClipperLib.ClipperBase.PointsEqual(p.pt, btmPt2.pt) && (p != btmPt2))
    p = p.next;
    var dx2n = ClipperLib.Math_Abs_Double(this.GetDx(btmPt2.pt, p.pt));
    return (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);
  };
  ClipperLib.Clipper.prototype.GetBottomPt = function (pp)
  {
    var dups = null;
    var p = pp.next;
    while (p != pp)
    {
      if (p.pt.y > pp.pt.y)
      {
        pp = p;
        dups = null;
      }
      else if (p.pt.y == pp.pt.y && p.pt.x <= pp.pt.x)
      {
        if (p.pt.x < pp.pt.x)
        {
          dups = null;
          pp = p;
        }
        else
        {
          if (p.next != pp && p.prev != pp) dups = p;
        }
      }
      p = p.next;
    }
    if (dups != null)
    {
      while (dups != p)
      {
        if (!this.FirstIsBottomPt(p, dups)) pp = dups;
        dups = dups.next;
        while (!ClipperLib.ClipperBase.PointsEqual(dups.pt, pp.pt))
        dups = dups.next;
      }
    }
    return pp;
  };
  ClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2)
  {
    var bPt1 = outRec1.bottomPt;
    var bPt2 = outRec2.bottomPt;
    if (bPt1.pt.y > bPt2.pt.y) return outRec1;
    else if (bPt1.pt.y < bPt2.pt.y) return outRec2;
    else if (bPt1.pt.x < bPt2.pt.x) return outRec1;
    else if (bPt1.pt.x > bPt2.pt.x) return outRec2;
    else if (bPt1.next == bPt1) return outRec2;
    else if (bPt2.next == bPt2) return outRec1;
    else if (this.FirstIsBottomPt(bPt1, bPt2)) return outRec1;
    else return outRec2;
  };
  ClipperLib.Clipper.prototype.Param1RightOfParam2 = function (outRec1, outRec2)
  {
    do {
      outRec1 = outRec1.FirstLeft;
      if (outRec1 == outRec2) return true;
    }
    while (outRec1 != null);
    return false;
  };
  ClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2)
  {
    var outRec1 = this.m_PolyOuts[e1.outIdx];
    var outRec2 = this.m_PolyOuts[e2.outIdx];
    var holeStateRec;
    if (this.Param1RightOfParam2(outRec1, outRec2)) holeStateRec = outRec2;
    else if (this.Param1RightOfParam2(outRec2, outRec1)) holeStateRec = outRec1;
    else holeStateRec = this.GetLowermostRec(outRec1, outRec2);
    var p1_lft = outRec1.pts;
    var p1_rt = p1_lft.prev;
    var p2_lft = outRec2.pts;
    var p2_rt = p2_lft.prev;
    var side;
    var i;
    if (e1.side == ClipperLib.EdgeSide.esLeft)
    {
      if (e2.side == ClipperLib.EdgeSide.esLeft)
      {
        this.ReversePolyPtLinks(p2_lft);
        p2_lft.next = p1_lft;
        p1_lft.prev = p2_lft;
        p1_rt.next = p2_rt;
        p2_rt.prev = p1_rt;
        outRec1.pts = p2_rt;
      }
      else
      {
        p2_rt.next = p1_lft;
        p1_lft.prev = p2_rt;
        p2_lft.prev = p1_rt;
        p1_rt.next = p2_lft;
        outRec1.pts = p2_lft;
      }
      side = ClipperLib.EdgeSide.esLeft;
    }
    else
    {
      if (e2.side == ClipperLib.EdgeSide.esRight)
      {
        this.ReversePolyPtLinks(p2_lft);
        p1_rt.next = p2_rt;
        p2_rt.prev = p1_rt;
        p2_lft.next = p1_lft;
        p1_lft.prev = p2_lft;
      }
      else
      {
        p1_rt.next = p2_lft;
        p2_lft.prev = p1_rt;
        p1_lft.prev = p2_rt;
        p2_rt.next = p1_lft;
      }
      side = ClipperLib.EdgeSide.esRight;
    }
    if (holeStateRec == outRec2)
    {
      outRec1.bottomPt = outRec2.bottomPt;
      outRec1.bottomPt.idx = outRec1.idx;
      if (outRec2.FirstLeft != outRec1) outRec1.FirstLeft = outRec2.FirstLeft;
      outRec1.isHole = outRec2.isHole;
    }
    outRec2.pts = null;
    outRec2.bottomPt = null;
    outRec2.AppendLink = outRec1;
    var OKIdx = e1.outIdx;
    var ObsoleteIdx = e2.outIdx;
    e1.outIdx = -1;
    e2.outIdx = -1;
    var e = this.m_ActiveEdges;
    while (e != null)
    {
      if (e.outIdx == ObsoleteIdx)
      {
        e.outIdx = OKIdx;
        e.side = side;
        break;
      }
      e = e.nextInAEL;
    }
    for (i = 0; i < this.m_Joins.length; ++i)
    {
      if (this.m_Joins[i].poly1Idx == ObsoleteIdx) this.m_Joins[i].poly1Idx = OKIdx;
      if (this.m_Joins[i].poly2Idx == ObsoleteIdx) this.m_Joins[i].poly2Idx = OKIdx;
    }
    for (i = 0; i < this.m_HorizJoins.length; ++i)
    {
      if (this.m_HorizJoins[i].savedIdx == ObsoleteIdx) this.m_HorizJoins[i].savedIdx = OKIdx;
    }
  };
  ClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp)
  {
    if (pp == null) return;
    var pp1;
    var pp2;
    pp1 = pp;
    do {
      pp2 = pp1.next;
      pp1.next = pp1.prev;
      pp1.prev = pp2;
      pp1 = pp2;
    }
    while (pp1 != pp);
  };
  ClipperLib.Clipper.SwapSides = function (edge1, edge2)
  {
    var side = edge1.side;
    edge1.side = edge2.side;
    edge2.side = side;
  };
  ClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2)
  {
    var outIdx = edge1.outIdx;
    edge1.outIdx = edge2.outIdx;
    edge2.outIdx = outIdx;
  };
  ClipperLib.Clipper.prototype.DoEdge1 = function (edge1, edge2, pt)
  {
    this.AddOutPt(edge1, pt);
    ClipperLib.Clipper.SwapSides(edge1, edge2);
    ClipperLib.Clipper.SwapPolyIndexes(edge1, edge2);
  };
  ClipperLib.Clipper.prototype.DoEdge2 = function (edge1, edge2, pt)
  {
    this.AddOutPt(edge2, pt);
    ClipperLib.Clipper.SwapSides(edge1, edge2);
    ClipperLib.Clipper.SwapPolyIndexes(edge1, edge2);
  };
  ClipperLib.Clipper.prototype.DoBothEdges = function (edge1, edge2, pt)
  {
    this.AddOutPt(edge1, pt);
    this.AddOutPt(edge2, pt);
    ClipperLib.Clipper.SwapSides(edge1, edge2);
    ClipperLib.Clipper.SwapPolyIndexes(edge1, edge2);
  };
  ClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt, protects)
  {
    var e1stops = (ClipperLib.Protects.ipLeft & protects) == 0 && e1.nextInLML == null && e1.xtop == pt.x && e1.ytop == pt.y;
    var e2stops = (ClipperLib.Protects.ipRight & protects) == 0 && e2.nextInLML == null && e2.xtop == pt.x && e2.ytop == pt.y;
    var e1Contributing = (e1.outIdx >= 0);
    var e2contributing = (e2.outIdx >= 0);
    if (e1.polyType == e2.polyType)
    {
      if (this.IsEvenOddFillType(e1))
      {
        var oldE1WindCnt = e1.windCnt;
        e1.windCnt = e2.windCnt;
        e2.windCnt = oldE1WindCnt;
      }
      else
      {
        if (e1.windCnt + e2.windDelta == 0) e1.windCnt = -e1.windCnt;
        else e1.windCnt += e2.windDelta;
        if (e2.windCnt - e1.windDelta == 0) e2.windCnt = -e2.windCnt;
        else e2.windCnt -= e1.windDelta;
      }
    }
    else
    {
      if (!this.IsEvenOddFillType(e2)) e1.windCnt2 += e2.windDelta;
      else e1.windCnt2 = (e1.windCnt2 == 0) ? 1 : 0;
      if (!this.IsEvenOddFillType(e1)) e2.windCnt2 -= e1.windDelta;
      else e2.windCnt2 = (e2.windCnt2 == 0) ? 1 : 0;
    }
    var e1FillType, e2FillType, e1FillType2, e2FillType2;
    if (e1.polyType == ClipperLib.PolyType.ptSubject)
    {
      e1FillType = this.m_SubjFillType;
      e1FillType2 = this.m_ClipFillType;
    }
    else
    {
      e1FillType = this.m_ClipFillType;
      e1FillType2 = this.m_SubjFillType;
    }
    if (e2.polyType == ClipperLib.PolyType.ptSubject)
    {
      e2FillType = this.m_SubjFillType;
      e2FillType2 = this.m_ClipFillType;
    }
    else
    {
      e2FillType = this.m_ClipFillType;
      e2FillType2 = this.m_SubjFillType;
    }
    var e1Wc, e2Wc;
    switch (e1FillType)
    {
      case ClipperLib.PolyFillType.pftPositive:
        e1Wc = e1.windCnt;
        break;
      case ClipperLib.PolyFillType.pftNegative:
        e1Wc = -e1.windCnt;
        break;
      default:
        e1Wc = ClipperLib.Math_Abs_Int32(e1.windCnt);
        break;
    }
    switch (e2FillType)
    {
      case ClipperLib.PolyFillType.pftPositive:
        e2Wc = e2.windCnt;
        break;
      case ClipperLib.PolyFillType.pftNegative:
        e2Wc = -e2.windCnt;
        break;
      default:
        e2Wc = ClipperLib.Math_Abs_Int32(e2.windCnt);
        break;
    }
    if (e1Contributing && e2contributing)
    {
      if (e1stops || e2stops || (e1Wc != 0 && e1Wc != 1) || (e2Wc != 0 && e2Wc != 1) || (e1.polyType != e2.polyType && this.m_ClipType != ClipperLib.ClipType.ctXor)) this.AddLocalMaxPoly(e1, e2, pt);
      else this.DoBothEdges(e1, e2, pt);
    }
    else if (e1Contributing)
    {
      if ((e2Wc == 0 || e2Wc == 1) && (this.m_ClipType != ClipperLib.ClipType.ctIntersection || e2.polyType == ClipperLib.PolyType.ptSubject || (e2.windCnt2 != 0))) this.DoEdge1(e1, e2, pt);
    }
    else if (e2contributing)
    {
      if ((e1Wc == 0 || e1Wc == 1) && (this.m_ClipType != ClipperLib.ClipType.ctIntersection || e1.polyType == ClipperLib.PolyType.ptSubject || (e1.windCnt2 != 0))) this.DoEdge2(e1, e2, pt);
    }
    else if ((e1Wc == 0 || e1Wc == 1) && (e2Wc == 0 || e2Wc == 1) && !e1stops && !e2stops)
    {
      var e1Wc2, e2Wc2;
      switch (e1FillType2)
      {
        case ClipperLib.PolyFillType.pftPositive:
          e1Wc2 = e1.windCnt2;
          break;
        case ClipperLib.PolyFillType.pftNegative:
          e1Wc2 = -e1.windCnt2;
          break;
        default:
          e1Wc2 = ClipperLib.Math_Abs_Int32(e1.windCnt2);
          break;
      }
      switch (e2FillType2)
      {
        case ClipperLib.PolyFillType.pftPositive:
          e2Wc2 = e2.windCnt2;
          break;
        case ClipperLib.PolyFillType.pftNegative:
          e2Wc2 = -e2.windCnt2;
          break;
        default:
          e2Wc2 = ClipperLib.Math_Abs_Int32(e2.windCnt2);
          break;
      }
      if (e1.polyType != e2.polyType) this.AddLocalMinPoly(e1, e2, pt);
      else if (e1Wc == 1 && e2Wc == 1) switch (this.m_ClipType)
      {
        case ClipperLib.ClipType.ctIntersection:
          if (e1Wc2 > 0 && e2Wc2 > 0) this.AddLocalMinPoly(e1, e2, pt);
          break;
        case ClipperLib.ClipType.ctUnion:
          if (e1Wc2 <= 0 && e2Wc2 <= 0) this.AddLocalMinPoly(e1, e2, pt);
          break;
        case ClipperLib.ClipType.ctDifference:
          if (((e1.polyType == ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) || ((e1.polyType == ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0))) this.AddLocalMinPoly(e1, e2, pt);
          break;
        case ClipperLib.ClipType.ctXor:
          this.AddLocalMinPoly(e1, e2, pt);
          break;
      }
      else ClipperLib.Clipper.SwapSides(e1, e2);
    }
    if ((e1stops != e2stops) && ((e1stops && (e1.outIdx >= 0)) || (e2stops && (e2.outIdx >= 0))))
    {
      ClipperLib.Clipper.SwapSides(e1, e2);
      ClipperLib.Clipper.SwapPolyIndexes(e1, e2);
    }
    if (e1stops) this.DeleteFromAEL(e1);
    if (e2stops) this.DeleteFromAEL(e2);
  };
  ClipperLib.Clipper.prototype.DeleteFromAEL = function (e)
  {
    var AelPrev = e.prevInAEL;
    var AelNext = e.nextInAEL;
    if (AelPrev == null && AelNext == null && (e != this.m_ActiveEdges)) return;
    if (AelPrev != null) AelPrev.nextInAEL = AelNext;
    else this.m_ActiveEdges = AelNext;
    if (AelNext != null) AelNext.prevInAEL = AelPrev;
    e.nextInAEL = null;
    e.prevInAEL = null;
  };
  ClipperLib.Clipper.prototype.DeleteFromSEL = function (e)
  {
    var SelPrev = e.prevInSEL;
    var SelNext = e.nextInSEL;
    if (SelPrev == null && SelNext == null && (e != this.m_SortedEdges)) return;
    if (SelPrev != null) SelPrev.nextInSEL = SelNext;
    else this.m_SortedEdges = SelNext;
    if (SelNext != null) SelNext.prevInSEL = SelPrev;
    e.nextInSEL = null;
    e.prevInSEL = null;
  };
  ClipperLib.Clipper.prototype.UpdateEdgeIntoAEL = function (e)
  {
    if (e.Value.nextInLML == null) ClipperLib.Error("UpdateEdgeIntoAEL: invalid call");
    var AelPrev = e.Value.prevInAEL;
    var AelNext = e.Value.nextInAEL;
    e.Value.nextInLML.outIdx = e.Value.outIdx;
    if (AelPrev != null) AelPrev.nextInAEL = e.Value.nextInLML;
    else this.m_ActiveEdges = e.Value.nextInLML;
    if (AelNext != null) AelNext.prevInAEL = e.Value.nextInLML;
    e.Value.nextInLML.side = e.Value.side;
    e.Value.nextInLML.windDelta = e.Value.windDelta;
    e.Value.nextInLML.windCnt = e.Value.windCnt;
    e.Value.nextInLML.windCnt2 = e.Value.windCnt2;
    e.Value = e.Value.nextInLML;
    e.Value.prevInAEL = AelPrev;
    e.Value.nextInAEL = AelNext;
    if (e.Value.dx != ClipperLib.ClipperBase.horizontal) this.InsertScanbeam(e.Value.ytop);
  };
  ClipperLib.Clipper.prototype.ProcessHorizontals = function ()
  {
    var horzEdge = this.m_SortedEdges;
    while (horzEdge != null)
    {
      this.DeleteFromSEL(horzEdge);
      this.ProcessHorizontal(horzEdge);
      horzEdge = this.m_SortedEdges;
    }
  };
  ClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge)
  {
    var Direction;
    var horzLeft, horzRight;
    if (horzEdge.xcurr < horzEdge.xtop)
    {
      horzLeft = horzEdge.xcurr;
      horzRight = horzEdge.xtop;
      Direction = ClipperLib.Direction.dLeftToRight;
    }
    else
    {
      horzLeft = horzEdge.xtop;
      horzRight = horzEdge.xcurr;
      Direction = ClipperLib.Direction.dRightToLeft;
    }
    var eMaxPair;
    if (horzEdge.nextInLML != null) eMaxPair = null;
    else eMaxPair = this.GetMaximaPair(horzEdge);
    var e = this.GetNextInAEL(horzEdge, Direction);
    while (e != null)
    {
      var eNext = this.GetNextInAEL(e, Direction);
      if (eMaxPair != null || ((Direction == ClipperLib.Direction.dLeftToRight) && (e.xcurr <= horzRight)) || ((Direction == ClipperLib.Direction.dRightToLeft) && (e.xcurr >= horzLeft)))
      {
        if (e.xcurr == horzEdge.xtop && eMaxPair == null)
        {
          if (this.SlopesEqual(e, horzEdge.nextInLML, this.m_UseFullRange))
          {
            if (horzEdge.outIdx >= 0 && e.outIdx >= 0) this.AddJoin(horzEdge.nextInLML, e, horzEdge.outIdx, -1);
            break;
          }
          else if (e.dx < horzEdge.nextInLML.dx) break;
        }
        if (e == eMaxPair)
        {
          if (Direction == ClipperLib.Direction.dLeftToRight) this.IntersectEdges(horzEdge, e, new ClipperLib.IntPoint(e.xcurr, horzEdge.ycurr), 0);
          else this.IntersectEdges(e, horzEdge, new ClipperLib.IntPoint(e.xcurr, horzEdge.ycurr), 0);
          if (eMaxPair.outIdx >= 0) ClipperLib.Error("ProcessHorizontal error");
          return;
        }
        else if (e.dx == ClipperLib.ClipperBase.horizontal && !this.IsMinima(e) && !(e.xcurr > e.xtop))
        {
          if (Direction == ClipperLib.Direction.dLeftToRight) this.IntersectEdges(horzEdge, e, new ClipperLib.IntPoint(e.xcurr, horzEdge.ycurr), (this.IsTopHorz(horzEdge, e.xcurr)) ? ClipperLib.Protects.ipLeft : ClipperLib.Protects.ipBoth);
          else this.IntersectEdges(e, horzEdge, new ClipperLib.IntPoint(e.xcurr, horzEdge.ycurr), (this.IsTopHorz(horzEdge, e.xcurr)) ? ClipperLib.Protects.ipRight : ClipperLib.Protects.ipBoth);
        }
        else if (Direction == ClipperLib.Direction.dLeftToRight)
        {
          this.IntersectEdges(horzEdge, e, new ClipperLib.IntPoint(e.xcurr, horzEdge.ycurr), (this.IsTopHorz(horzEdge, e.xcurr)) ? ClipperLib.Protects.ipLeft : ClipperLib.Protects.ipBoth);
        }
        else
        {
          this.IntersectEdges(e, horzEdge, new ClipperLib.IntPoint(e.xcurr, horzEdge.ycurr), (this.IsTopHorz(horzEdge, e.xcurr)) ? ClipperLib.Protects.ipRight : ClipperLib.Protects.ipBoth);
        }
        this.SwapPositionsInAEL(horzEdge, e);
      }
      else if ((Direction == ClipperLib.Direction.dLeftToRight && e.xcurr > horzRight && horzEdge.nextInSEL == null) || (Direction == ClipperLib.Direction.dRightToLeft && e.xcurr < horzLeft && horzEdge.nextInSEL == null)) break;
      e = eNext;
    }
    if (horzEdge.nextInLML != null)
    {
      if (horzEdge.outIdx >= 0) this.AddOutPt(horzEdge, new ClipperLib.IntPoint(horzEdge.xtop, horzEdge.ytop));
      (function ()
      {
        horzEdge = {
          Value: horzEdge
        };
        var $res = this.UpdateEdgeIntoAEL(horzEdge);
        horzEdge = horzEdge.Value;
        return $res;
      })
        .call(this);
    }
    else
    {
      if (horzEdge.outIdx >= 0) this.IntersectEdges(horzEdge, eMaxPair, new ClipperLib.IntPoint(horzEdge.xtop, horzEdge.ycurr), ClipperLib.Protects.ipBoth);
      this.DeleteFromAEL(eMaxPair);
      this.DeleteFromAEL(horzEdge);
    }
  };
  ClipperLib.Clipper.prototype.IsTopHorz = function (horzEdge, XPos)
  {
    var e = this.m_SortedEdges;
    while (e != null)
    {
      if ((XPos >= Math.min(e.xcurr, e.xtop)) && (XPos <= Math.max(e.xcurr, e.xtop))) return false;
      e = e.nextInSEL;
    }
    return true;
  };
  ClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction)
  {
    return Direction == ClipperLib.Direction.dLeftToRight ? e.nextInAEL : e.prevInAEL;
  };
  ClipperLib.Clipper.prototype.IsMinima = function (e)
  {
    return e != null && (e.prev.nextInLML != e) && (e.next.nextInLML != e);
  };
  ClipperLib.Clipper.prototype.IsMaxima = function (e, Y)
  {
    return (e != null && e.ytop == Y && e.nextInLML == null);
  };
  ClipperLib.Clipper.prototype.IsIntermediate = function (e, Y)
  {
    return (e.ytop == Y && e.nextInLML != null);
  };
  ClipperLib.Clipper.prototype.GetMaximaPair = function (e)
  {
    if (!this.IsMaxima(e.next, e.ytop) || (e.next.xtop != e.xtop)) return e.prev;
    else return e.next;
  };
  ClipperLib.Clipper.prototype.ProcessIntersections = function (botY, topY)
  {
    if (this.m_ActiveEdges == null) return true;
    try
    {
      this.BuildIntersectList(botY, topY);
      if (this.m_IntersectNodes == null) return true;
      if (this.FixupIntersections()) this.ProcessIntersectList();
      else return false;
    }
    catch ($$e2)
    {
      this.m_SortedEdges = null;
      this.DisposeIntersectNodes();
      ClipperLib.Error("ProcessIntersections error");
    }
    return true;
  };
  ClipperLib.Clipper.prototype.BuildIntersectList = function (botY, topY)
  {
    if (this.m_ActiveEdges == null) return;
    var e = this.m_ActiveEdges;
    e.tmpX = ClipperLib.Clipper.TopX(e, topY);
    this.m_SortedEdges = e;
    this.m_SortedEdges.prevInSEL = null;
    e = e.nextInAEL;
    while (e != null)
    {
      e.prevInSEL = e.prevInAEL;
      e.prevInSEL.nextInSEL = e;
      e.nextInSEL = null;
      e.tmpX = ClipperLib.Clipper.TopX(e, topY);
      e = e.nextInAEL;
    }
    var isModified = true;
    while (isModified && this.m_SortedEdges != null)
    {
      isModified = false;
      e = this.m_SortedEdges;
      while (e.nextInSEL != null)
      {
        var eNext = e.nextInSEL;
        var pt = new ClipperLib.IntPoint();
        if (e.tmpX > eNext.tmpX && (function ()
        {
          pt = {
            Value: pt
          };
          var $res = this.IntersectPoint(e, eNext, pt);
          pt = pt.Value;
          return $res;
        })
          .call(this))
        {
          if (pt.y > botY)
          {
            pt.y = botY;
            pt.x = ClipperLib.Clipper.TopX(e, pt.y);
          }
          this.AddIntersectNode(e, eNext, pt);
          this.SwapPositionsInSEL(e, eNext);
          isModified = true;
        }
        else e = eNext;
      }
      if (e.prevInSEL != null) e.prevInSEL.nextInSEL = null;
      else break;
    }
    this.m_SortedEdges = null;
  };
  ClipperLib.Clipper.prototype.FixupIntersections = function ()
  {
    if (this.m_IntersectNodes.next == null) return true;
    this.CopyAELToSEL();
    var int1 = this.m_IntersectNodes;
    var int2 = this.m_IntersectNodes.next;
    while (int2 != null)
    {
      var e1 = int1.edge1;
      var e2;
      if (e1.prevInSEL == int1.edge2) e2 = e1.prevInSEL;
      else if (e1.nextInSEL == int1.edge2) e2 = e1.nextInSEL;
      else
      {
        while (int2 != null)
        {
          if (int2.edge1.nextInSEL == int2.edge2 || int2.edge1.prevInSEL == int2.edge2) break;
          else int2 = int2.next;
        }
        if (int2 == null) return false;
        this.SwapIntersectNodes(int1, int2);
        e1 = int1.edge1;
        e2 = int1.edge2;
      }
      this.SwapPositionsInSEL(e1, e2);
      int1 = int1.next;
      int2 = int1.next;
    }
    this.m_SortedEdges = null;
    return (int1.edge1.prevInSEL == int1.edge2 || int1.edge1.nextInSEL == int1.edge2);
  };
  ClipperLib.Clipper.prototype.ProcessIntersectList = function ()
  {
    while (this.m_IntersectNodes != null)
    {
      var iNode = this.m_IntersectNodes.next;
      this.IntersectEdges(this.m_IntersectNodes.edge1, this.m_IntersectNodes.edge2, this.m_IntersectNodes.pt, ClipperLib.Protects.ipBoth);
      this.SwapPositionsInAEL(this.m_IntersectNodes.edge1, this.m_IntersectNodes.edge2);
      this.m_IntersectNodes = null;
      this.m_IntersectNodes = iNode;
    }
  };
  /*
  --------------------------------
  Round speedtest: http://jsperf.com/fastest-round
  --------------------------------
  */
  var R1=function(a) { return a < 0 ? Math.ceil(a - 0.5): Math.round(a)};
  var R2=function(a) { return a < 0 ? Math.ceil(a - 0.5): Math.floor(a + 0.5)};
  var R3=function(a) { return a < 0 ? -Math.round(Math.abs(a)): Math.round(a)};
  var R4=function(a) {
    if (a < 0) {
      a -= 0.5;
      return a < -2147483648 ? Math.ceil(a): a | 0;
    } else {
      a += 0.5;
      return a > 2147483647 ? Math.floor(a): a | 0;
    }
  };
  if (browser.msie) ClipperLib.Clipper.Round = R1;
  else if (browser.chromium) ClipperLib.Clipper.Round = R3;
  else if (browser.safari) ClipperLib.Clipper.Round = R4;
  else ClipperLib.Clipper.Round = R2; // eg. browser.chrome || browser.firefox || browser.opera

  ClipperLib.Clipper.TopX = function (edge, currentY)
  {
    if (currentY == edge.ytop) return edge.xtop;
    return edge.xbot + ClipperLib.Clipper.Round(edge.dx * (currentY - edge.ybot));
  };
  ClipperLib.Clipper.prototype.AddIntersectNode = function (e1, e2, pt)
  {
    var newNode = new ClipperLib.IntersectNode();
    newNode.edge1 = e1;
    newNode.edge2 = e2;
    newNode.pt = pt;
    newNode.next = null;
    if (this.m_IntersectNodes == null) this.m_IntersectNodes = newNode;
    else if (this.ProcessParam1BeforeParam2(newNode, this.m_IntersectNodes))
    {
      newNode.next = this.m_IntersectNodes;
      this.m_IntersectNodes = newNode;
    }
    else
    {
      var iNode = this.m_IntersectNodes;
      while (iNode.next != null && this.ProcessParam1BeforeParam2(iNode.next, newNode))
      iNode = iNode.next;
      newNode.next = iNode.next;
      iNode.next = newNode;
    }
  };
  ClipperLib.Clipper.prototype.ProcessParam1BeforeParam2 = function (node1, node2)
  {
    var result;
    if (node1.pt.y == node2.pt.y)
    {
      if (node1.edge1 == node2.edge1 || node1.edge2 == node2.edge1)
      {
        result = node2.pt.x > node1.pt.x;
        return node2.edge1.dx > 0 ? !result : result;
      }
      else if (node1.edge1 == node2.edge2 || node1.edge2 == node2.edge2)
      {
        result = node2.pt.x > node1.pt.x;
        return node2.edge2.dx > 0 ? !result : result;
      }
      else return node2.pt.x > node1.pt.x;
    }
    else return node1.pt.y > node2.pt.y;
  };
  ClipperLib.Clipper.prototype.SwapIntersectNodes = function (int1, int2)
  {
    var e1 = int1.edge1;
    var e2 = int1.edge2;
    var p = int1.pt;
    int1.edge1 = int2.edge1;
    int1.edge2 = int2.edge2;
    int1.pt = int2.pt;
    int2.edge1 = e1;
    int2.edge2 = e2;
    int2.pt = p;
  };
  ClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip)
  {
    var b1, b2;
    if (this.SlopesEqual(edge1, edge2, this.m_UseFullRange)) return false;
    else if (edge1.dx == 0)
    {
      ip.Value.x = edge1.xbot;
      if (edge2.dx == ClipperLib.ClipperBase.horizontal)
      {
        ip.Value.y = edge2.ybot;
      }
      else
      {
        b2 = edge2.ybot - (edge2.xbot / edge2.dx);
        ip.Value.y = ClipperLib.Clipper.Round(ip.Value.x / edge2.dx + b2);
      }
    }
    else if (edge2.dx == 0)
    {
      ip.Value.x = edge2.xbot;
      if (edge1.dx == ClipperLib.ClipperBase.horizontal)
      {
        ip.Value.y = edge1.ybot;
      }
      else
      {
        b1 = edge1.ybot - (edge1.xbot / edge1.dx);
        ip.Value.y = ClipperLib.Clipper.Round(ip.Value.x / edge1.dx + b1);
      }
    }
    else
    {
      b1 = edge1.xbot - edge1.ybot * edge1.dx;
      b2 = edge2.xbot - edge2.ybot * edge2.dx;
      var q = (b2 - b1) / (edge1.dx - edge2.dx);
      ip.Value.y = ClipperLib.Clipper.Round(q);
      if (ClipperLib.Math_Abs_Double(edge1.dx) < ClipperLib.Math_Abs_Double(edge2.dx)) ip.Value.x = ClipperLib.Clipper.Round(edge1.dx * q + b1);
      else ip.Value.x = ClipperLib.Clipper.Round(edge2.dx * q + b2);
    }
    if (ip.Value.y < edge1.ytop || ip.Value.y < edge2.ytop)
    {
      if (edge1.ytop > edge2.ytop)
      {
        ip.Value.x = edge1.xtop;
        ip.Value.y = edge1.ytop;
        return ClipperLib.Clipper.TopX(edge2, edge1.ytop) < edge1.xtop;
      }
      else
      {
        ip.Value.x = edge2.xtop;
        ip.Value.y = edge2.ytop;
        return ClipperLib.Clipper.TopX(edge1, edge2.ytop) > edge2.xtop;
      }
    }
    else return true;
  };
  ClipperLib.Clipper.prototype.DisposeIntersectNodes = function ()
  {
    while (this.m_IntersectNodes != null)
    {
      var iNode = this.m_IntersectNodes.next;
      this.m_IntersectNodes = null;
      this.m_IntersectNodes = iNode;
    }
  };
  ClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY)
  {
    var e = this.m_ActiveEdges;
    var ePrev;
    while (e != null)
    {
      if (this.IsMaxima(e, topY) && this.GetMaximaPair(e)
        .dx != ClipperLib.ClipperBase.horizontal)
      {
        ePrev = e.prevInAEL;
        this.DoMaxima(e, topY);
        if (ePrev == null) e = this.m_ActiveEdges;
        else e = ePrev.nextInAEL;
      }
      else
      {
        if (this.IsIntermediate(e, topY) && e.nextInLML.dx == ClipperLib.ClipperBase.horizontal)
        {
          if (e.outIdx >= 0)
          {
            this.AddOutPt(e, new ClipperLib.IntPoint(e.xtop, e.ytop));
            for (var i = 0; i < this.m_HorizJoins.length; ++i)
            {
              var pt = new ClipperLib.IntPoint(),
                pt2 = new ClipperLib.IntPoint();
              var hj = this.m_HorizJoins[i];
              if ((function ()
              {
                pt = {
                  Value: pt
                };
                pt2 = {
                  Value: pt2
                };
                var $res = this.GetOverlapSegment(new ClipperLib.IntPoint(hj.edge.xbot, hj.edge.ybot),
                new ClipperLib.IntPoint(hj.edge.xtop, hj.edge.ytop),
                new ClipperLib.IntPoint(e.nextInLML.xbot, e.nextInLML.ybot),
                new ClipperLib.IntPoint(e.nextInLML.xtop, e.nextInLML.ytop), pt, pt2);
                pt = pt.Value;
                pt2 = pt2.Value;
                return $res;
              })
                .call(this)) this.AddJoin(hj.edge, e.nextInLML, hj.savedIdx, e.outIdx);
            }
            this.AddHorzJoin(e.nextInLML, e.outIdx);
          }
          (function ()
          {
            e = {
              Value: e
            };
            var $res = this.UpdateEdgeIntoAEL(e);
            e = e.Value;
            return $res;
          })
            .call(this);
          this.AddEdgeToSEL(e);
        }
        else
        {
          e.xcurr = ClipperLib.Clipper.TopX(e, topY);
          e.ycurr = topY;
        }
        e = e.nextInAEL;
      }
    }
    this.ProcessHorizontals();
    e = this.m_ActiveEdges;
    while (e != null)
    {
      if (this.IsIntermediate(e, topY))
      {
        if (e.outIdx >= 0) this.AddOutPt(e, new ClipperLib.IntPoint(e.xtop, e.ytop));
        (function ()
        {
          e = {
            Value: e
          };
          var $res = this.UpdateEdgeIntoAEL(e);
          e = e.Value;
          return $res;
        })
          .call(this);
        ePrev = e.prevInAEL;
        var eNext = e.nextInAEL;
        if (ePrev != null && ePrev.xcurr == e.xbot && ePrev.ycurr == e.ybot && e.outIdx >= 0 && ePrev.outIdx >= 0 && ePrev.ycurr > ePrev.ytop && this.SlopesEqual(e, ePrev, this.m_UseFullRange))
        {
          this.AddOutPt(ePrev, new ClipperLib.IntPoint(e.xbot, e.ybot));
          this.AddJoin(e, ePrev, -1, -1);
        }
        else if (eNext != null && eNext.xcurr == e.xbot && eNext.ycurr == e.ybot && e.outIdx >= 0 && eNext.outIdx >= 0 && eNext.ycurr > eNext.ytop && this.SlopesEqual(e, eNext, this.m_UseFullRange))
        {
          this.AddOutPt(eNext, new ClipperLib.IntPoint(e.xbot, e.ybot));
          this.AddJoin(e, eNext, -1, -1);
        }
      }
      e = e.nextInAEL;
    }
  };
  ClipperLib.Clipper.prototype.DoMaxima = function (e, topY)
  {
    var eMaxPair = this.GetMaximaPair(e);
    var X = e.xtop;
    var eNext = e.nextInAEL;
    while (eNext != eMaxPair)
    {
      if (eNext == null) ClipperLib.Error("DoMaxima error");
      this.IntersectEdges(e, eNext, new ClipperLib.IntPoint(X, topY), ClipperLib.Protects.ipBoth);
      eNext = eNext.nextInAEL;
    }
    if (e.outIdx < 0 && eMaxPair.outIdx < 0)
    {
      this.DeleteFromAEL(e);
      this.DeleteFromAEL(eMaxPair);
    }
    else if (e.outIdx >= 0 && eMaxPair.outIdx >= 0)
    {
      this.IntersectEdges(e, eMaxPair, new ClipperLib.IntPoint(X, topY), ClipperLib.Protects.ipNone);
    }
    else ClipperLib.Error("DoMaxima error");
  };
  ClipperLib.Clipper.ReversePolygons = function (polys)
  {
    var len = polys.length,
      poly;
    for (var i = 0; i < len; i++)
    {
      if (polys[i] instanceof Array) polys[i].reverse();
    }
  };
  ClipperLib.Clipper.Orientation = function (poly)
  {
    return this.Area(poly) >= 0;
  };
  ClipperLib.Clipper.prototype.PointCount = function (pts)
  {
    if (pts == null) return 0;
    var result = 0;
    var p = pts;
    do {
      result++;
      p = p.next;
    }
    while (p != pts);
    return result;
  };
  ClipperLib.Clipper.prototype.BuildResult = function (polyg)
  {
    ClipperLib.Clear(polyg);
    var outRec, len = this.m_PolyOuts.length;
    for (var i = 0; i < len; i++)
    {
      outRec = this.m_PolyOuts[i];
      if (outRec.pts == null) continue;
      var p = outRec.pts;
      var cnt = this.PointCount(p);
      if (cnt < 3) continue;
      var pg = new ClipperLib.Polygon(cnt);
      for (var j = 0; j < cnt; j++)
      {
        //pg.push(p.pt);
        pg.push(new ClipperLib.IntPoint(p.pt.x, p.pt.y)); // Have to create new point, because the point can be a reference to other point
        p = p.prev;
      }
      polyg.push(pg);
    }
  };
  ClipperLib.Clipper.prototype.BuildResultEx = function (polyg)
  {
    ClipperLib.Clear(polyg);
    var i = 0;
    while (i < this.m_PolyOuts.length)
    {
      var outRec = this.m_PolyOuts[i++];
      if (outRec.pts == null) break;
      var p = outRec.pts;
      var cnt = this.PointCount(p);
      if (cnt < 3) continue;
      var epg = new ClipperLib.ExPolygon();
      epg.outer = new ClipperLib.Polygon();
      epg.holes = new ClipperLib.Polygons();
      for (var j = 0; j < cnt; j++)
      {
        //epg.outer.push(p.pt);
        epg.outer.push(new ClipperLib.IntPoint(p.pt.x, p.pt.y)); // Have to create new point, because the point can be a reference to other point
        p = p.prev;
      }
      while (i < this.m_PolyOuts.length)
      {
        outRec = this.m_PolyOuts[i];
        if (outRec.pts == null || !outRec.isHole) break;
        var pg = new ClipperLib.Polygon();
        p = outRec.pts;
        do {
          //pg.push(p.pt);
          pg.push(new ClipperLib.IntPoint(p.pt.x, p.pt.y)); // Have to create new point, because the point can be a reference to other point
          p = p.prev;
        }
        while (p != outRec.pts);
        epg.holes.push(pg);
        i++;
      }
      polyg.push(epg);
    }
  };
  ClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec)
  {
    var lastOK = null;
    outRec.pts = outRec.bottomPt;
    var pp = outRec.bottomPt;
    for (;;)
    {
      if (pp.prev == pp || pp.prev == pp.next)
      {
        this.DisposeOutPts(pp);
        outRec.pts = null;
        outRec.bottomPt = null;
        return;
      }
      if (ClipperLib.ClipperBase.PointsEqual(pp.pt, pp.next.pt) || this.SlopesEqual(pp.prev.pt, pp.pt, pp.next.pt, this.m_UseFullRange))
      {
        lastOK = null;
        var tmp = pp;
        if (pp == outRec.bottomPt) outRec.bottomPt = null;
        pp.prev.next = pp.next;
        pp.next.prev = pp.prev;
        pp = pp.prev;
        tmp = null;
      }
      else if (pp == lastOK) break;
      else
      {
        if (lastOK == null) lastOK = pp;
        pp = pp.next;
      }
    }
    if (outRec.bottomPt == null)
    {
      outRec.bottomPt = this.GetBottomPt(pp);
      outRec.bottomPt.idx = outRec.idx;
      outRec.pts = outRec.bottomPt;
    }
  };
  ClipperLib.Clipper.prototype.JoinPoints = function (j, p1, p2)
  {
    p1.Value = null;
    p2.Value = null;
    var outRec1 = this.m_PolyOuts[j.poly1Idx];
    var outRec2 = this.m_PolyOuts[j.poly2Idx];
    if (outRec1 == null || outRec2 == null) return false;
    var pp1a = outRec1.pts;
    var pp2a = outRec2.pts;
    var pt1 = j.pt2a,
      pt2 = j.pt2b;
    var pt3 = j.pt1a,
      pt4 = j.pt1b;
    if (!(function ()
    {
      pp1a = {
        Value: pp1a
      };
      pt1 = {
        Value: pt1
      };
      pt2 = {
        Value: pt2
      };
      var $res = this.FindSegment(pp1a, this.m_UseFullRange, pt1, pt2);
      pp1a = pp1a.Value;
      pt1 = pt1.Value;
      pt2 = pt2.Value;
      return $res;
    })
      .call(this)) return false;
    if (outRec1 == outRec2)
    {
      pp2a = pp1a.next;
      if (!(function ()
      {
        pp2a = {
          Value: pp2a
        };
        pt3 = {
          Value: pt3
        };
        pt4 = {
          Value: pt4
        };
        var $res = this.FindSegment(pp2a, this.m_UseFullRange, pt3, pt4);
        pp2a = pp2a.Value;
        pt3 = pt3.Value;
        pt4 = pt4.Value;
        return $res;
      })
        .call(this) || (pp2a == pp1a)) return false;
    }
    else if (!(function ()
    {
      pp2a = {
        Value: pp2a
      };
      pt3 = {
        Value: pt3
      };
      pt4 = {
        Value: pt4
      };
      var $res = this.FindSegment(pp2a, this.m_UseFullRange, pt3, pt4);
      pp2a = pp2a.Value;
      pt3 = pt3.Value;
      pt4 = pt4.Value;
      return $res;
    })
      .call(this)) return false;
    if (!(function ()
    {
      pt1 = {
        Value: pt1
      };
      pt2 = {
        Value: pt2
      };
      var $res = this.GetOverlapSegment(pt1.Value, pt2.Value, pt3, pt4, pt1, pt2);
      pt1 = pt1.Value;
      pt2 = pt2.Value;
      return $res;
    })
      .call(this))
    {
      return false;
    }
    var p3, p4, prev = pp1a.prev;
    if (ClipperLib.ClipperBase.PointsEqual(pp1a.pt, pt1)) p1.Value = pp1a;
    else if (ClipperLib.ClipperBase.PointsEqual(prev.pt, pt1)) p1.Value = prev;
    else p1.Value = this.InsertPolyPtBetween(pp1a, prev, pt1);
    if (ClipperLib.ClipperBase.PointsEqual(pp1a.pt, pt2)) p2.Value = pp1a;
    else if (ClipperLib.ClipperBase.PointsEqual(prev.pt, pt2)) p2.Value = prev;
    else if ((p1.Value == pp1a) || (p1.Value == prev)) p2.Value = this.InsertPolyPtBetween(pp1a, prev, pt2);
    else if (this.Pt3IsBetweenPt1AndPt2(pp1a.pt, p1.Value.pt, pt2)) p2.Value = this.InsertPolyPtBetween(pp1a, p1.Value, pt2);
    else p2.Value = this.InsertPolyPtBetween(p1.Value, prev, pt2);
    prev = pp2a.prev;
    if (ClipperLib.ClipperBase.PointsEqual(pp2a.pt, pt1)) p3 = pp2a;
    else if (ClipperLib.ClipperBase.PointsEqual(prev.pt, pt1)) p3 = prev;
    else p3 = this.InsertPolyPtBetween(pp2a, prev, pt1);
    if (ClipperLib.ClipperBase.PointsEqual(pp2a.pt, pt2)) p4 = pp2a;
    else if (ClipperLib.ClipperBase.PointsEqual(prev.pt, pt2)) p4 = prev;
    else if ((p3 == pp2a) || (p3 == prev)) p4 = this.InsertPolyPtBetween(pp2a, prev, pt2);
    else if (this.Pt3IsBetweenPt1AndPt2(pp2a.pt, p3.pt, pt2)) p4 = this.InsertPolyPtBetween(pp2a, p3, pt2);
    else p4 = this.InsertPolyPtBetween(p3, prev, pt2);
    if (p1.Value.next == p2.Value && p3.prev == p4)
    {
      p1.Value.next = p3;
      p3.prev = p1.Value;
      p2.Value.prev = p4;
      p4.next = p2.Value;
      return true;
    }
    else if (p1.Value.prev == p2.Value && p3.next == p4)
    {
      p1.Value.prev = p3;
      p3.next = p1.Value;
      p2.Value.next = p4;
      p4.prev = p2.Value;
      return true;
    }
    else return false;
  };
  ClipperLib.Clipper.prototype.FixupJoinRecs = function (j, pt, startIdx)
  {
    for (var k = startIdx; k < this.m_Joins.length; k++)
    {
      var j2 = this.m_Joins[k];
      if (j2.poly1Idx == j.poly1Idx && this.PointIsVertex(j2.pt1a, pt)) j2.poly1Idx = j.poly2Idx;
      if (j2.poly2Idx == j.poly1Idx && this.PointIsVertex(j2.pt2a, pt)) j2.poly2Idx = j.poly2Idx;
    }
  };
  ClipperLib.Clipper.prototype.JoinCommonEdges = function ()
  {
    var k, orec;
    for (var i = 0; i < this.m_Joins.length; i++)
    {
      var j = this.m_Joins[i];
      var p1, p2;
      if (!(function ()
      {
        p1 = {
          Value: p1
        };
        p2 = {
          Value: p2
        };
        var $res = this.JoinPoints(j, p1, p2);
        p1 = p1.Value;
        p2 = p2.Value;
        return $res;
      })
        .call(this)) continue;
      var outRec1 = this.m_PolyOuts[j.poly1Idx];
      var outRec2 = this.m_PolyOuts[j.poly2Idx];
      if (outRec1 == outRec2)
      {
        outRec1.pts = this.GetBottomPt(p1);
        outRec1.bottomPt = outRec1.pts;
        outRec1.bottomPt.idx = outRec1.idx;
        outRec2 = this.CreateOutRec();
        this.m_PolyOuts.push(outRec2);
        outRec2.idx = this.m_PolyOuts.length - 1;
        j.poly2Idx = outRec2.idx;
        outRec2.pts = this.GetBottomPt(p2);
        outRec2.bottomPt = outRec2.pts;
        outRec2.bottomPt.idx = outRec2.idx;
        if (this.PointInPolygon(outRec2.pts.pt, outRec1.pts, this.m_UseFullRange))
        {
          outRec2.isHole = !outRec1.isHole;
          outRec2.FirstLeft = outRec1;
          this.FixupJoinRecs(j, p2, i + 1);
          this.FixupOutPolygon(outRec1);
          this.FixupOutPolygon(outRec2);
          
          if ((outRec2.isHole ^ this.m_ReverseOutput) == (this.Area(outRec2, this.m_UseFullRange) > 0))
          this.ReversePolyPtLinks(outRec2.pts);
        }
        else if (this.PointInPolygon(outRec1.pts.pt, outRec2.pts, this.m_UseFullRange))
        {
          outRec2.isHole = outRec1.isHole;
          outRec1.isHole = !outRec2.isHole;
          outRec2.FirstLeft = outRec1.FirstLeft;
          outRec1.FirstLeft = outRec2;
          this.FixupJoinRecs(j, p2, i + 1);
          this.FixupOutPolygon(outRec1);
          this.FixupOutPolygon(outRec2);
          
          if ((outRec1.isHole ^ this.m_ReverseOutput) == (this.Area(outRec1, this.m_UseFullRange) > 0))
          this.ReversePolyPtLinks(outRec1.pts);

          if (this.m_UsingExPolygons && outRec1.isHole) for (k = 0; k < this.m_PolyOuts.length; ++k)
          {
            orec = this.m_PolyOuts[k];
            if (orec.isHole && orec.bottomPt != null && orec.FirstLeft == outRec1) orec.FirstLeft = outRec2;
          }
        }
        else
        {
          outRec2.isHole = outRec1.isHole;
          outRec2.FirstLeft = outRec1.FirstLeft;
          this.FixupJoinRecs(j, p2, i + 1);
          this.FixupOutPolygon(outRec1);
          this.FixupOutPolygon(outRec2);
          
          if (this.m_UsingExPolygons && outRec2.pts != null) for (k = 0; k < this.m_PolyOuts.length; ++k)
          {
            orec = this.m_PolyOuts[k];
            if (orec.isHole && orec.bottomPt != null && orec.FirstLeft == outRec1 && this.PointInPolygon(orec.bottomPt.pt, outRec2.pts, this.m_UseFullRange)) orec.FirstLeft = outRec2;
          }
        }
      }
      else
      {
        if (this.m_UsingExPolygons) for (k = 0; k < this.m_PolyOuts.length; ++k)
        if (this.m_PolyOuts[k].isHole && this.m_PolyOuts[k].bottomPt != null && this.m_PolyOuts[k].FirstLeft == outRec2) this.m_PolyOuts[k].FirstLeft = outRec1;
        this.FixupOutPolygon(outRec1);
        if (outRec1.pts != null)
        {
        	outRec1.isHole = this.Area(outRec1, this.m_UseFullRange) < 0;
          if (outRec1.isHole && outRec1.FirstLeft == null) outRec1.FirstLeft = outRec2.FirstLeft;
        }
        var OKIdx = outRec1.idx;
        var ObsoleteIdx = outRec2.idx;
        outRec2.pts = null;
        outRec2.bottomPt = null;
        outRec2.AppendLink = outRec1;
        for (k = i + 1; k < this.m_Joins.length; k++)
        {
          var j2 = this.m_Joins[k];
          if (j2.poly1Idx == ObsoleteIdx) j2.poly1Idx = OKIdx;
          if (j2.poly2Idx == ObsoleteIdx) j2.poly2Idx = OKIdx;
        }
      }
    }
  };
  ClipperLib.Clipper.FullRangeNeeded = function (pts)
  {
    var result = false;
    for (var i = 0; i < pts.length; i++) {
      if (ClipperLib.Math_Abs_Int64(pts[i].x) > ClipperLib.ClipperBase.hiRange || ClipperLib.Math_Abs_Int64(pts[i].y) > ClipperLib.ClipperBase.hiRange) 
      ClipperLib.Error("Coordinate exceeds range bounds in FullRangeNeeded().");
      else if (ClipperLib.Math_Abs_Int64(pts[i].x) > ClipperLib.ClipperBase.loRange || ClipperLib.Math_Abs_Int64(pts[i].y) > ClipperLib.ClipperBase.loRange)
      {
        result = true;
      }
    }
    return result;
  };
  ClipperLib.Clipper.prototype.Area = ClipperLib.Clipper.Area = function ()
  {
    var arg = arguments;
    var i, a;
    if (arg.length == 1) // function ( poly )
    {
      var poly = arg[0];
      var highI = poly.length - 1;
      if (highI < 2) return 0;
      if (ClipperLib.Clipper.FullRangeNeeded(poly))
      {
        a = new Int128( poly[highI].x + poly[0].x ).multiply( new Int128(poly[0].y - poly[highI].y) );
        for (i = 1; i <= highI; ++i)
        a = a.add( new Int128( poly[i - 1].x + poly[i].x ).multiply( new Int128( poly[i].y - poly[i - 1].y ) ) );
        return parseFloat(a.toString()) / 2;
      }
      else
      {
        var area = (poly[highI].x + poly[0].x) * (poly[0].y - poly[highI].y);
        for (i = 1; i <= highI; ++i)
          area += (poly[i - 1].x + poly[i].x) * (poly[i].y - poly[i -1].y);
        return area / 2;
      }
    }
    else if (arg.length == 2) //  function (outRec, UseFull64BitRange)
    {
      var outRec = arg[0];
      var UseFull64BitRange = arg[1];
      var op = outRec.pts;
      if (op == null) return 0;
      if (UseFull64BitRange)
      {
        a = new Int128(Int128.ZERO);
        do {
      	  a = a.add(new Int128( op.pt.x + op.prev.pt.x ).multiply( new Int128 ( op.prev.pt.y - op.pt.y ) ) );
          op = op.next;
        } while (op != outRec.pts);
        return parseFloat(a.toString()) / 2; // This could be something faster!
      }
      else
      {
        a = 0;
        do {
          a = a + (op.pt.x + op.prev.pt.x) * (op.prev.pt.y - op.pt.y);
          op = op.next;
        }
        while (op != outRec.pts);
        return a / 2;
      }
    }
  };
  ClipperLib.Clipper.BuildArc = function (pt, a1, a2, r)
  {
  	var steps = Math.sqrt(ClipperLib.Math_Abs_Double(r)) * ClipperLib.Math_Abs_Double(a2 - a1);
    
    steps = steps / 4; // to avoid overload
    
    // If you want to make steps independent of scaling factor (scale have to be set),
    // the following line does the trick:
    // steps = steps / Math.sqrt(scale) * 2;
    
    // If you want that changing scale factor has some influence to steps, uncomment also the following line:
    // It may be desirable, that bigger precision ( = bigger scaling factor) needs more steps.
    // steps += Math.pow(scale, 0.2);

    if (steps < 6) steps = 6;
    if (steps > 64) steps = ClipperLib.MaxSteps; // to avoid overload
    
    // if (steps > 1048576) steps = 1048576; // 0x100000
    // if (steps > ClipperLib.MaxSteps) steps = ClipperLib.MaxSteps; // 0x100000
    // Had to change 1048576 to lower value, because when coordinates are near or above lorange, program starts hanging
    // Adjust this value to meet your needs, maybe 10 is enough for most purposes
    var n = ClipperLib.Cast_Int32(steps);
    var result = new ClipperLib.Polygon();
    var da = (a2 - a1) / (n - 1);
    var a = a1;
    for (var i = 0; i < n; ++i)
    {
      result.push(new ClipperLib.IntPoint(pt.x + ClipperLib.Clipper.Round(Math.cos(a) * r), pt.y + ClipperLib.Clipper.Round(Math.sin(a) * r)));
      a += da;
    }
    return result;
  };

  ClipperLib.Clipper.GetUnitNormal = function (pt1, pt2)
  {
    var dx = (pt2.x - pt1.x);
    var dy = (pt2.y - pt1.y);
    if ((dx == 0) && (dy == 0)) return new ClipperLib.Clipper.DoublePoint(0, 0);
    var f = 1 / Math.sqrt(dx * dx + dy * dy);
    dx *= f;
    dy *= f;
    return new ClipperLib.Clipper.DoublePoint(dy, -dx);
  };
  ClipperLib.Clipper.prototype.OffsetPolygons = function (poly, delta, jointype, MiterLimit, AutoFix)
  {
    var a = arguments;
    if (a.length == 4) AutoFix = true;
    else if (a.length == 3)
    {
      MiterLimit = 2;
      AutoFix = true;
    }
    else if (a.length == 2)
    {
      jointype = ClipperLib.JoinType.jtSquare;
      MiterLimit = 2;
      AutoFix = true;
    }
    if (isNaN(delta)) ClipperLib.Error("Delta is not a number");
    else if (isNaN(MiterLimit)) ClipperLib.Error("MiterLimit is not a number");
    var result = {};
    new ClipperLib.Clipper.PolyOffsetBuilder(poly, result, delta, jointype, MiterLimit, AutoFix);
    if (result.Value) result = result.Value;
    else result = [[]];
    return result;
  };
  ClipperLib.Clipper.prototype.SimplifyPolygon = function (poly, fillType)
  {
    var result = new ClipperLib.Polygons();
    var c = new ClipperLib.Clipper();
    if (c.AddPolygon(poly, ClipperLib.PolyType.ptSubject))
    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);
    return result;
  };
  ClipperLib.Clipper.prototype.SimplifyPolygons = function (polys, fillType)
  {
    var result = new ClipperLib.Polygons();
    var c = new ClipperLib.Clipper();
    if(c.AddPolygons(polys, ClipperLib.PolyType.ptSubject))
    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);
    return result;
  };
  var ce = ClipperLib.Clipper;
  var ce2 = ClipperLib.ClipperBase;
  var p;
  if (typeof (Object.getOwnPropertyNames) == 'undefined')
  {
    for (p in ce2.prototype)
    if (typeof (ce.prototype[p]) == 'undefined' || ce.prototype[p] == Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];
    for (p in ce2)
    if (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];
    ce.$baseCtor = ce2;
  }
  else
  {
    var props = Object.getOwnPropertyNames(ce2.prototype);
    for (var i = 0; i < props.length; i++)
    if (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) == 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));
    for (p in ce2)
    if (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];
    ce.$baseCtor = ce2;
  }
  ClipperLib.Clipper.DoublePoint = function (x, y)
  {
    this.x = x;
    this.y = y;
  };
  
  ClipperLib.Clipper.PolyOffsetBuilder = function (pts, solution, delta, jointype, MiterLimit, AutoFix)
  {
    this.pts = null; // Polygons
    this.currentPoly = null; // Polygon
    this.normals = null;
    this.delta = 0;
    this.m_R = 0;
    this.m_i = 0;
    this.m_j = 0;
    this.m_k = 0;
    this.botPt = null; // This is "this." because it is ref in original c# code
    if (delta == 0)
    {
      solution.Value = pts;
      return;
    }
    this.pts = pts;
    this.delta = delta;
    var i, j;
    //AutoFix - fixes polygon orientation if necessary and removes 
    //duplicate vertices. Can be set false when you're sure that polygon
    //orientation is correct and that there are no duplicate vertices.
    if (AutoFix)
    {
      var Len = this.pts.length,
        botI = 0;
      while (botI < Len && this.pts[botI].length == 0) botI++;
      if (botI == Len)
      {
        //solution.Value = new ClipperLib.Polygons();
        return;
      }
      //botPt: used to find the lowermost (in inverted Y-axis) & leftmost point
      //This point (on pts[botI]) must be on an outer polygon ring and if 
      //its orientation is false (counterclockwise) then assume all polygons 
      //need reversing ...
      this.botPt = this.pts[botI][0]; // This is ported with different logic than other C# refs
      // adding botPt to object's property it's accessible through object's
      // methods
      // => All other ref's are now ported using rather complex object.Value
      // technique, which seems to work.
      for (i = botI; i < Len; ++i)
      {
        if (this.UpdateBotPt(this.pts[i][0])) botI = i;
        for (j = this.pts[i].length - 1; j > 0; j--)
        {
          if (ClipperLib.ClipperBase.PointsEqual(this.pts[i][j], this.pts[i][j - 1]))
          {
            this.pts[i].splice(j, 1);
          }
          else if (this.UpdateBotPt(this.pts[i][j])) botI = i;
        }
      }
      if (!ClipperLib.Clipper.Orientation(this.pts[botI])) ClipperLib.Clipper.ReversePolygons(this.pts);
    }
    if (MiterLimit <= 1) MiterLimit = 1;
    var RMin = 2 / (MiterLimit * MiterLimit);
    this.normals = [];
    var deltaSq = delta * delta;
    solution.Value = new ClipperLib.Polygons();
    //ClipperLib.Clear(solution.Value);
    var len;
    for (this.m_i = 0; this.m_i < this.pts.length; this.m_i++)
    {
      len = this.pts[this.m_i].length;
      if (len > 1 && this.pts[this.m_i][0].x == this.pts[this.m_i][len - 1].x && 
      this.pts[this.m_i][0].y == this.pts[this.m_i][len - 1].y)
      {
        len--;
      }
      if (len == 0 || (len < 3 && delta <= 0))
      {
        continue;
      }
      else if (len == 1)
      {
        var arc;
        arc = ClipperLib.Clipper.BuildArc(this.pts[this.m_i][len - 1], 0, ClipperLib.PI2, delta);
        solution.Value.push(arc);
        continue;
      }
      
      //build normals ...
      ClipperLib.Clear(this.normals);
      for (j = 0; j < len - 1; ++j)
      this.normals.push(ClipperLib.Clipper.GetUnitNormal(this.pts[this.m_i][j], this.pts[this.m_i][j + 1]));
      this.normals.push(ClipperLib.Clipper.GetUnitNormal(this.pts[this.m_i][len - 1], this.pts[this.m_i][0]));

      this.currentPoly = new ClipperLib.Polygon();
      this.m_k = len - 1;
      for (this.m_j = 0; this.m_j < len; ++this.m_j)
      {
        switch (jointype)
        {
          case ClipperLib.JoinType.jtMiter:
            this.m_R = 1 + (this.normals[this.m_j].x * this.normals[this.m_k].x + this.normals[this.m_j].y * this.normals[this.m_k].y);
            if (this.m_R >= RMin) this.DoMiter();
            else this.DoSquare(MiterLimit);
            break;
          case ClipperLib.JoinType.jtRound:
            this.DoRound();
            break;
          case ClipperLib.JoinType.jtSquare:
            this.DoSquare(1);
            break;
        }
        this.m_k = this.m_j;
      }
      solution.Value.push(this.currentPoly);
    }
    
    //finally, clean up untidy corners ...
    var clpr = new ClipperLib.Clipper();
    clpr.AddPolygons(solution.Value, ClipperLib.PolyType.ptSubject);
    if (delta > 0)
    {
      clpr.Execute(ClipperLib.ClipType.ctUnion, solution.Value, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);
    }
    else
    {
      var r = clpr.GetBounds();
      var outer = new ClipperLib.Polygon();
      outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));
      outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));
      outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));
      outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));
      clpr.AddPolygon(outer, ClipperLib.PolyType.ptSubject);
      clpr.Execute(ClipperLib.ClipType.ctUnion, solution.Value, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);
      if (solution.Value.length > 0)
      {
        solution.Value.splice(0, 1);
        for (i = 0; i < solution.Value.length; i++)
        solution.Value[i].reverse();
      }
    }
  };
  //ClipperLib.Clipper.PolyOffsetBuilder.buffLength = 128;
  ClipperLib.Clipper.PolyOffsetBuilder.prototype.UpdateBotPt = function (pt)
  {
    if (pt.y > this.botPt.y || (pt.y == this.botPt.y && pt.x < this.botPt.x))
    {
      this.botPt = pt;
      return true;
    }
    else return false;
  };
  ClipperLib.Clipper.PolyOffsetBuilder.prototype.AddPoint = function (pt)
  {
    this.currentPoly.push(pt);
  };
  ClipperLib.Clipper.PolyOffsetBuilder.prototype.DoSquare = function (mul)
  {
    var pt1 = new ClipperLib.IntPoint(ClipperLib.Cast_Int64(ClipperLib.Clipper.Round(this.pts[this.m_i][this.m_j].x + this.normals[this.m_k].x * this.delta)),
    ClipperLib.Cast_Int64(ClipperLib.Clipper.Round(this.pts[this.m_i][this.m_j].y + this.normals[this.m_k].y * this.delta)));
    var pt2 = new ClipperLib.IntPoint(ClipperLib.Cast_Int64(ClipperLib.Clipper.Round(this.pts[this.m_i][this.m_j].x + this.normals[this.m_j].x * this.delta)),
    ClipperLib.Cast_Int64(ClipperLib.Clipper.Round(this.pts[this.m_i][this.m_j].y + this.normals[this.m_j].y * this.delta)));
    if ((this.normals[this.m_k].x * this.normals[this.m_j].y - this.normals[this.m_j].x * this.normals[this.m_k].y) * this.delta >= 0)
    {
      var a1 = Math.atan2(this.normals[this.m_k].y, this.normals[this.m_k].x);
      var a2 = Math.atan2(-this.normals[this.m_j].y, -this.normals[this.m_j].x);
      a1 = Math.abs(a2 - a1);
      if (a1 > ClipperLib.PI) a1 = ClipperLib.PI2 - a1;
      var dx = Math.tan((ClipperLib.PI - a1) / 4) * Math.abs(this.delta * mul);
      pt1 = new ClipperLib.IntPoint(ClipperLib.Cast_Int64((pt1.x - this.normals[this.m_k].y * dx)),
      ClipperLib.Cast_Int64((pt1.y + this.normals[this.m_k].x * dx)));
      this.AddPoint(pt1);
      pt2 = new ClipperLib.IntPoint(ClipperLib.Cast_Int64((pt2.x + this.normals[this.m_j].y * dx)),
      ClipperLib.Cast_Int64((pt2.y - this.normals[this.m_j].x * dx)));
      this.AddPoint(pt2);
    }
    else
    {
      this.AddPoint(pt1);
      this.AddPoint(this.pts[this.m_i][this.m_j]);
      this.AddPoint(pt2);
    }
  };
  ClipperLib.Clipper.PolyOffsetBuilder.prototype.DoMiter = function ()
  {
    if ((this.normals[this.m_k].x * this.normals[this.m_j].y - this.normals[this.m_j].x * this.normals[this.m_k].y) * this.delta >= 0)
    {
      var q = this.delta / this.m_R;
      this.AddPoint(new ClipperLib.IntPoint(
      ClipperLib.Cast_Int64(
      ClipperLib.Clipper.Round(this.pts[this.m_i][this.m_j].x + (this.normals[this.m_k].x + this.normals[this.m_j].x) * q)),
      ClipperLib.Cast_Int64(
      ClipperLib.Clipper.Round(this.pts[this.m_i][this.m_j].y + (this.normals[this.m_k].y + this.normals[this.m_j].y) * q))));
    }
    else
    {
      var pt1 = new ClipperLib.IntPoint(ClipperLib.Cast_Int64(ClipperLib.Clipper.Round(this.pts[this.m_i][this.m_j].x + this.normals[this.m_k].x * this.delta)),
      ClipperLib.Cast_Int64(ClipperLib.Clipper.Round(this.pts[this.m_i][this.m_j].y + this.normals[this.m_k].y * this.delta)));
      var pt2 = new ClipperLib.IntPoint(ClipperLib.Cast_Int64(ClipperLib.Clipper.Round(this.pts[this.m_i][this.m_j].x + this.normals[this.m_j].x * this.delta)),
      ClipperLib.Cast_Int64(ClipperLib.Clipper.Round(this.pts[this.m_i][this.m_j].y + this.normals[this.m_j].y * this.delta)));
      this.AddPoint(pt1);
      this.AddPoint(this.pts[this.m_i][this.m_j]);
      this.AddPoint(pt2);
    }
  };
  ClipperLib.Clipper.PolyOffsetBuilder.prototype.DoRound = function ()
  {
    var pt1 = new ClipperLib.IntPoint(ClipperLib.Clipper.Round(this.pts[this.m_i][this.m_j].x + this.normals[this.m_k].x * this.delta),
    ClipperLib.Clipper.Round(this.pts[this.m_i][this.m_j].y + this.normals[this.m_k].y * this.delta));
    var pt2 = new ClipperLib.IntPoint(ClipperLib.Clipper.Round(this.pts[this.m_i][this.m_j].x + this.normals[this.m_j].x * this.delta),
    ClipperLib.Clipper.Round(this.pts[this.m_i][this.m_j].y + this.normals[this.m_j].y * this.delta));
    this.AddPoint(pt1);
    //round off reflex angles (ie > 180 deg) unless almost flat (ie < 10deg).
    //cross product normals < 0 . angle > 180 deg.
    //dot product normals == 1 . no angle
    if ((this.normals[this.m_k].x * this.normals[this.m_j].y - this.normals[this.m_j].x * this.normals[this.m_k].y) * this.delta >= 0)
    {
      if ((this.normals[this.m_j].x * this.normals[this.m_k].x + this.normals[this.m_j].y * this.normals[this.m_k].y) < 0.985)
      {
        var a1 = Math.atan2(this.normals[this.m_k].y, this.normals[this.m_k].x);
        var a2 = Math.atan2(this.normals[this.m_j].y, this.normals[this.m_j].x);
        if (this.delta > 0 && a2 < a1) a2 += ClipperLib.PI2;
        else if (this.delta < 0 && a2 > a1) a2 -= ClipperLib.PI2;
        var arc = ClipperLib.Clipper.BuildArc(this.pts[this.m_i][this.m_j], a1, a2, this.delta);
        for (var m = 0; m < arc.length; m++)
        this.AddPoint(arc[m]);
      }
    }
    else this.AddPoint(this.pts[this.m_i][this.m_j]);
    this.AddPoint(pt2);
  };
  ClipperLib.Error = function(message)
  {
	  try {
      throw new Error(message);
    }
    catch(err) {
      alert(err.message);
    }
  };
  // Make deep copy of Polygons or Polygon
  // so that also IntPoint objects are cloned and not only referenced
  // This should be the fastest way
  ClipperLib.Clone = function (polygon)
  {
  	if (!(polygon instanceof Array)) return [];
    if (polygon.length == 0) return [];
    else if (polygon.length == 1 && polygon[0].length == 0) return [[]];
  	var isPolygons = polygon[0] instanceof Array;
    if (!isPolygons) polygon = [polygon];
  	var len = polygon.length, plen, i, j, result;
  	var results = [];
    for(i = 0; i < len; i++)
    {
      plen = polygon[i].length;
      result = [];
      for(j = 0; j < plen; j++)
      {
        result.push({x: polygon[i][j].x, y: polygon[i][j].y});
      }
      results.push(result);
    }
    if (!isPolygons) results = results[0];
    return results;
  };
  
  // Clean() joins vertices that are too near each other
  // and causes distortion to offsetted polygons without cleaning
  ClipperLib.Clean = function (polygon, delta)
  {
    if (!(polygon instanceof Array)) return [];
    var isPolygons = polygon[0] instanceof Array;
    var polygon = ClipperLib.Clone(polygon);
    if (typeof delta != "number" || delta === null) 
    {
      ClipperLib.Error("Delta is not a number in Clean().");
      return polygon;
    }
    if (polygon.length == 0 || (polygon.length == 1 && polygon[0].length == 0) || delta < 0) return polygon;
    if (!isPolygons) polygon = [polygon];
    var k_length = polygon.length;
    var len, poly, result, d, p, j, i;
    var results = [];
    for(var k = 0; k < k_length; k++)
    {
      poly = polygon[k];
      len = poly.length;
      if (len == 0) continue;
      else if (len < 3) {
        result = poly;
        results.push(result);
        continue;
      }
      result = poly;
      d = delta * delta;
      //d = Math.floor(c_delta * c_delta);
      p = poly[0];
      j = 1;
      for (i = 1; i < len; i++)
      {
        if ((poly[i].x - p.x) * (poly[i].x - p.x) +
            (poly[i].y - p.y) * (poly[i].y - p.y) <= d)
          continue;
        result[j] = poly[i];
        p = poly[i];
        j++;
      }
      p = poly[j - 1];
      if ((poly[0].x - p.x) * (poly[0].x - p.x) +
          (poly[0].y - p.y) * (poly[0].y - p.y) <= d)
        j--;
      if (j < len)
            result.splice(j, len - j);
      if (result.length) results.push(result);
    }
    if (!isPolygons && results.length) results = results[0];
    else if (!isPolygons && results.length == 0) results = [];
    else if (isPolygons && results.length ==0) results = [[]];
    return results;
  }

  // Removes points that doesn't affect much to the visual appearance.
  // If middle point is at or under certain distance (tolerance) of the line between 
  // start and end point, the middle point is removed.
  ClipperLib.Lighten = function (polygon, tolerance)
  {
    if (!(polygon instanceof Array)) return [];
    
    if (typeof tolerance != "number" || tolerance === null)
    {
      ClipperLib.Error("Tolerance is not a number in Lighten().")
      return ClipperLib.Clone(polygon);
    }
    if (polygon.length === 0 || (polygon.length==1 && polygon[0].length === 0) || tolerance < 0)
    {
      return ClipperLib.Clone(polygon);
    }

	  if (!(polygon[0] instanceof Array)) polygon = [polygon];
	  var i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;
	  var bxax, byay, nL;
	  var len = polygon.length;
	  var results = [];
	  for(i = 0; i < len; i++)
	  {
	    poly = polygon[i];
	    for (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count
	    {
	    	poly2 = [];
	      plen = poly.length;
	      // the first have to added to the end, if first and last are not the same
	      // this way we ensure that also the actual last point can be removed if needed
	      if (poly[plen-1].x != poly[0].x || poly[plen-1].y != poly[0].y)
	      {
	        addlast = 1;
	        poly.push({x:poly[0].x, y:poly[0].y});
	        plen = poly.length;
	      }
	      else addlast = 0;
	      rem = []; // Indexes of removed points
	      for(j = 0; j < plen - 2; j++)
	      {
	        A = poly[j]; // Start point of line segment
	        P = poly[j+1]; // Middle point. This is the one to be removed.
	        B = poly[j+2]; // End point of line segment
	        bxax = B.x - A.x;
	        byay = B.y - A.y;
	        d = 0;
	        if (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.
	        {
	          nL = Math.sqrt(bxax * bxax + byay * byay);
	          // d is the perpendicular distance from P to (infinite) line AB.
	          d = Math.abs((P.x - A.x) * byay - (P.y - A.y) * bxax) / nL;
	        }
	        if (d <= tolerance)
	        {
	          rem[j+1] = 1;
	          j++; // when removed, transfer the pointer to the next one
	        }
	      }
	      // add all unremoved points to poly2
	      poly2.push({x:poly[0].x, y:poly[0].y});
	      for(j = 1; j < plen-1; j++)
	        if (!rem[j]) poly2.push({x:poly[j].x,y:poly[j].y});
	      poly2.push({x:poly[plen-1].x,y:poly[plen-1].y});
	      // if the first point was added to the end, remove it
	      if (addlast) poly.pop();
	      // break, if there was not anymore removed points
	      if (!rem.length) break;
	      // else continue looping using poly2, to check if there are points to remove
	      else poly = poly2;
	    }
	    plen = poly2.length;
	    // remove duplicate from end, if needed
	    if (poly2[plen-1].x == poly2[0].x && poly2[plen-1].y == poly2[0].y)
	    {
	      poly2.pop();
	    }
	    if (poly2.length > 2) // to avoid two-point-polygons
	    results.push(poly2);
    }
    if (!polygon[0] instanceof Array) results = results[0];
    if (typeof (results) == "undefined") results = [[]];
    return results;
  }
  if (typeof(document) !== "undefined") window.ClipperLib = ClipperLib;
  else self['ClipperLib'] = ClipperLib;
})();
/*
 * Poly2Tri Copyright (c) 2009-2013, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * * Neither the name of Poly2Tri nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without specific
 *   prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* jshint browser:false, forin:true, noarg:true, noempty:true, eqeqeq:true, bitwise:true, 
   strict:true, undef:true, unused:true, curly:true, immed:true, latedef:true, 
   newcap:true, trailing:true, maxcomplexity:11, indent:4 
 */


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionnaly follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */


/**
 * Module encapsulation
 * @param {Object} global a reference to the global object :
 *                      window in the browser, global on the server
 */
(function(global) {
    "use strict";

// --------------------------------------------------------------poly2tri module

    // Save the previous value of the poly2tri variable, 
    // so that it can be restored later on, if noConflict is used.
    var previousPoly2tri = global.poly2tri;

    // The top-level namespace. All public poly2tri classes and functions will
    // be attached to it. Exported for both the browser and the server (Node.js).
    var poly2tri;
    /* global exports */
    if (typeof exports !== 'undefined') {
        poly2tri = exports;
    } else {
        poly2tri = global.poly2tri = {};
    }

    // Runs the library in noConflict mode, returning the poly2tri variable 
    // to its previous owner. Returns a reference to this library object.
    poly2tri.noConflict = function() {
        global.poly2tri = previousPoly2tri;
        return this;
    };

// -------------------------------------------------------------------PointError

    /**
     * Custom exception class to indicate invalid Point values
     * @param {String} message          error message
     * @param {array<Point>} points     invalid points
     */
    // Class added in the JavaScript version (was not present in the c++ version)
    var PointError = function (message, points) {
        this.name    = "PointError";
        this.points  = points = points || [];
        this.message = message || "Invalid Points!";
        for (var i = 0; i < points.length; i++) {
            this.message += " " + Point.toString(points[i]);
        }
    };
    PointError.prototype = new Error();
    PointError.prototype.constructor = PointError;


// ------------------------------------------------------------------------Point
    /**
     * Construct a point
     * @param {Number} x    coordinate (0 if undefined)
     * @param {Number} y    coordinate (0 if undefined)
     */
    var Point = function(x, y) {
        this.x = +x || 0;
        this.y = +y || 0;

        // All extra fields added to Point are prefixed with _p2t_
        // to avoid collisions if custom Point class is used.

        // The edges this point constitutes an upper ending point
        this._p2t_edge_list = null;
    };

    /**
     * For pretty printing ex. <i>"(5;42)"</i>)
     */
    Point.prototype.toString = function() {
        return ("(" + this.x + ";" + this.y + ")");
    };

    /**
     * Creates a copy of this Point object.
     * @returns Point
     */
    Point.prototype.clone = function() {
        return new Point(this.x, this.y);
    };

    /**
     * Set this Point instance to the origo. <code>(0; 0)</code>
     */
    Point.prototype.set_zero = function() {
        this.x = 0.0;
        this.y = 0.0;
        return this; // for chaining
    };

    /**
     * Set the coordinates of this instance.
     * @param   x   number.
     * @param   y   number;
     */
    Point.prototype.set = function(x, y) {
        this.x = +x || 0;
        this.y = +y || 0;
        return this; // for chaining
    };

    /**
     * Negate this Point instance. (component-wise)
     */
    Point.prototype.negate = function() {
        this.x = -this.x;
        this.y = -this.y;
        return this; // for chaining
    };

    /**
     * Add another Point object to this instance. (component-wise)
     * @param   n   Point object.
     */
    Point.prototype.add = function(n) {
        this.x += n.x;
        this.y += n.y;
        return this; // for chaining
    };

    /**
     * Subtract this Point instance with another point given. (component-wise)
     * @param   n   Point object.
     */
    Point.prototype.sub = function(n) {
        this.x -= n.x;
        this.y -= n.y;
        return this; // for chaining
    };

    /**
     * Multiply this Point instance by a scalar. (component-wise)
     * @param   s   scalar.
     */
    Point.prototype.mul = function(s) {
        this.x *= s;
        this.y *= s;
        return this; // for chaining
    };

    /**
     * Return the distance of this Point instance from the origo.
     */
    Point.prototype.length = function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    };

    /**
     * Normalize this Point instance (as a vector).
     * @return The original distance of this instance from the origo.
     */
    Point.prototype.normalize = function() {
        var len = this.length();
        this.x /= len;
        this.y /= len;
        return len;
    };

    /**
     * Test this Point object with another for equality.
     * @param   p   any "Point like" object with {x,y} (duck typing)
     * @return <code>True</code> if <code>this == p</code>, <code>false</code> otherwise.
     */
    Point.prototype.equals = function(p) {
        return this.x === p.x && this.y === p.y;
    };

// -----------------------------------------------------Point ("static" methods)

    /**
     * Negate a point component-wise and return the result as a new Point object.
     * @param   p   Point object.
     * @return the resulting Point object.
     */
    Point.negate = function(p) {
        return new Point(-p.x, -p.y);
    };

    /**
     * Add two points component-wise and return the result as a new Point object.
     * @param   a   Point object.
     * @param   b   Point object.
     * @return the resulting Point object.
     */
    Point.add = function(a, b) {
        return new Point(a.x + b.x, a.y + b.y);
    };

    /**
     * Subtract two points component-wise and return the result as a new Point object.
     * @param   a   Point object.
     * @param   b   Point object.
     * @return the resulting Point object.
     */
    Point.sub = function(a, b) {
        return new Point(a.x - b.x, a.y - b.y);
    };

    /**
     * Multiply a point by a scalar and return the result as a new Point object.
     * @param   s   the scalar (a number).
     * @param   p   Point object.
     * @return the resulting Point object.
     */
    Point.mul = function(s, p) {
        return new Point(s * p.x, s * p.y);
    };

    /**
     * Perform the cross product on either two points (this produces a scalar)
     * or a point and a scalar (this produces a point).
     * This function requires two parameters, either may be a Point object or a
     * number.
     * @param   a   Point object or scalar.
     * @param   b   Point object or scalar.
     * @return  a   Point object or a number, depending on the parameters.
     */
    Point.cross = function(a, b) {
        if (typeof(a) === 'number') {
            if (typeof(b) === 'number') {
                return a * b;
            } else {
                return new Point(-a * b.y, a * b.x);
            }
        } else {
            if (typeof(b) === 'number') {
                return new Point(b * a.y, -b * a.x);
            } else {
                return a.x * b.y - a.y * b.x;
            }
        }
    };


// -----------------------------------------------------------------"Point-Like"
    /*
     * The following functions operate on "Point" or any "Point like" object 
     * with {x,y} (duck typing).
     */


    /**
     * Point pretty printing ex. <i>"(5;42)"</i>)
     * @param   p   any "Point like" object with {x,y} 
     * @returns {String}
     */
    Point.toString = function(p) {
        // Try a custom toString first, and fallback to Point.prototype.toString if none
        var s = p.toString();
        return (s === '[object Object]' ? Point.prototype.toString.call(p) : s);
    };

    /**
     * Compare two points component-wise.
     * @param   a,b   any "Point like" objects with {x,y} 
     * @return <code>&lt; 0</code> if <code>a &lt; b</code>, 
     *         <code>&gt; 0</code> if <code>a &gt; b</code>, 
     *         <code>0</code> otherwise.
     */
    Point.compare = function(a, b) {
        if (a.y === b.y) {
            return a.x - b.x;
        } else {
            return a.y - b.y;
        }
    };
    Point.cmp = Point.compare; // backward compatibility

    /**
     * Test two Point objects for equality.
     * @param   a,b   any "Point like" objects with {x,y} 
     * @return <code>True</code> if <code>a == b</code>, <code>false</code> otherwise.
     */
    Point.equals = function(a, b) {
        return a.x === b.x && a.y === b.y;
    };

    /**
     * Peform the dot product on two vectors.
     * @param   a,b   any "Point like" objects with {x,y} 
     * @return The dot product (as a number).
     */
    Point.dot = function(a, b) {
        return a.x * b.x + a.y * b.y;
    };


// -------------------------------------------------------------------------Edge
    /**
     * Represents a simple polygon's edge
     * @param {Point} p1
     * @param {Point} p2
     */
    var Edge = function(p1, p2) {
        this.p = p1;
        this.q = p2;

        if (p1.y > p2.y) {
            this.q = p1;
            this.p = p2;
        } else if (p1.y === p2.y) {
            if (p1.x > p2.x) {
                this.q = p1;
                this.p = p2;
            } else if (p1.x === p2.x) {
                throw new PointError('poly2tri Invalid Edge constructor: repeated points!', [p1]);
            }
        }

        if (! this.q._p2t_edge_list) {
            this.q._p2t_edge_list = [];
        }
        this.q._p2t_edge_list.push(this);
    };

// ---------------------------------------------------------------------Triangle
    /**
     * Triangle class.<br>
     * Triangle-based data structures are known to have better performance than
     * quad-edge structures.
     * See: J. Shewchuk, "Triangle: Engineering a 2D Quality Mesh Generator and
     * Delaunay Triangulator", "Triangulations in CGAL"
     * 
     * @param   a,b,c   any "Point like" objects with {x,y} (duck typing)
     */
    var Triangle = function(a, b, c) {
        // Triangle points
        this.points_ = [a, b, c];
        // Neighbor list
        this.neighbors_ = [null, null, null];
        // Has this triangle been marked as an interior triangle?
        this.interior_ = false;
        // Flags to determine if an edge is a Constrained edge
        this.constrained_edge = [false, false, false];
        // Flags to determine if an edge is a Delauney edge
        this.delaunay_edge = [false, false, false];
    };

    /**
     * For pretty printing ex. <i>"[(5;42)(10;20)(21;30)]"</i>)
     */
    Triangle.prototype.toString = function() {
        var p2s = Point.toString;
        return ("[" + p2s(this.points_[0]) + p2s(this.points_[1]) + p2s(this.points_[2]) + "]");
    };

    Triangle.prototype.getPoint = function(index) {
        return this.points_[index];
    };
    // for backward compatibility
    Triangle.prototype.GetPoint = Triangle.prototype.getPoint;

    Triangle.prototype.getNeighbor = function(index) {
        return this.neighbors_[index];
    };

    /**
     * Test if this Triangle contains the Point object given as parameters as its
     * vertices. Only point references are compared, not values.
     * @return <code>True</code> if the Point object is of the Triangle's vertices,
     *         <code>false</code> otherwise.
     */
    Triangle.prototype.containsPoint = function(point) {
        var points = this.points_;
        // Here we are comparing point references, not values
        return (point === points[0] || point === points[1] || point === points[2]);
    };

    /**
     * Test if this Triangle contains the Edge object given as parameter as its
     * bounding edges. Only point references are compared, not values.
     * @return <code>True</code> if the Edge object is of the Triangle's bounding
     *         edges, <code>false</code> otherwise.
     */
    Triangle.prototype.containsEdge = function(edge) {
        return this.containsPoint(edge.p) && this.containsPoint(edge.q);
    };
    Triangle.prototype.containsPoints = function(p1, p2) {
        return this.containsPoint(p1) && this.containsPoint(p2);
    };


    Triangle.prototype.isInterior = function() {
        return this.interior_;
    };
    Triangle.prototype.setInterior = function(interior) {
        this.interior_ = interior;
        return this;
    };

    /**
     * Update neighbor pointers.
     * @param {Point} p1 Point object.
     * @param {Point} p2 Point object.
     * @param {Triangle} t Triangle object.
     */
    Triangle.prototype.markNeighborPointers = function(p1, p2, t) {
        var points = this.points_;
        // Here we are comparing point references, not values
        if ((p1 === points[2] && p2 === points[1]) || (p1 === points[1] && p2 === points[2])) {
            this.neighbors_[0] = t;
        } else if ((p1 === points[0] && p2 === points[2]) || (p1 === points[2] && p2 === points[0])) {
            this.neighbors_[1] = t;
        } else if ((p1 === points[0] && p2 === points[1]) || (p1 === points[1] && p2 === points[0])) {
            this.neighbors_[2] = t;
        } else {
            throw new Error('poly2tri Invalid Triangle.markNeighborPointers() call');
        }
    };

    /**
     * Exhaustive search to update neighbor pointers
     * @param {Triangle} t
     */
    Triangle.prototype.markNeighbor = function(t) {
        var points = this.points_;
        if (t.containsPoints(points[1], points[2])) {
            this.neighbors_[0] = t;
            t.markNeighborPointers(points[1], points[2], this);
        } else if (t.containsPoints(points[0], points[2])) {
            this.neighbors_[1] = t;
            t.markNeighborPointers(points[0], points[2], this);
        } else if (t.containsPoints(points[0], points[1])) {
            this.neighbors_[2] = t;
            t.markNeighborPointers(points[0], points[1], this);
        }
    };


    Triangle.prototype.clearNeigbors = function() {
        this.neighbors_[0] = null;
        this.neighbors_[1] = null;
        this.neighbors_[2] = null;
    };

    Triangle.prototype.clearDelunayEdges = function() {
        this.delaunay_edge[0] = false;
        this.delaunay_edge[1] = false;
        this.delaunay_edge[2] = false;
    };

    /**
     * Returns the point clockwise to the given point.
     */
    Triangle.prototype.pointCW = function(p) {
        var points = this.points_;
        // Here we are comparing point references, not values
        if (p === points[0]) {
            return points[2];
        } else if (p === points[1]) {
            return points[0];
        } else if (p === points[2]) {
            return points[1];
        } else {
            return null;
        }
    };

    /**
     * Returns the point counter-clockwise to the given point.
     */
    Triangle.prototype.pointCCW = function(p) {
        var points = this.points_;
        // Here we are comparing point references, not values
        if (p === points[0]) {
            return points[1];
        } else if (p === points[1]) {
            return points[2];
        } else if (p === points[2]) {
            return points[0];
        } else {
            return null;
        }
    };

    /**
     * Returns the neighbor clockwise to given point.
     */
    Triangle.prototype.neighborCW = function(p) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            return this.neighbors_[1];
        } else if (p === this.points_[1]) {
            return this.neighbors_[2];
        } else {
            return this.neighbors_[0];
        }
    };

    /**
     * Returns the neighbor counter-clockwise to given point.
     */
    Triangle.prototype.neighborCCW = function(p) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            return this.neighbors_[2];
        } else if (p === this.points_[1]) {
            return this.neighbors_[0];
        } else {
            return this.neighbors_[1];
        }
    };

    Triangle.prototype.getConstrainedEdgeCW = function(p) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            return this.constrained_edge[1];
        } else if (p === this.points_[1]) {
            return this.constrained_edge[2];
        } else {
            return this.constrained_edge[0];
        }
    };

    Triangle.prototype.getConstrainedEdgeCCW = function(p) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            return this.constrained_edge[2];
        } else if (p === this.points_[1]) {
            return this.constrained_edge[0];
        } else {
            return this.constrained_edge[1];
        }
    };

    Triangle.prototype.setConstrainedEdgeCW = function(p, ce) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            this.constrained_edge[1] = ce;
        } else if (p === this.points_[1]) {
            this.constrained_edge[2] = ce;
        } else {
            this.constrained_edge[0] = ce;
        }
    };

    Triangle.prototype.setConstrainedEdgeCCW = function(p, ce) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            this.constrained_edge[2] = ce;
        } else if (p === this.points_[1]) {
            this.constrained_edge[0] = ce;
        } else {
            this.constrained_edge[1] = ce;
        }
    };

    Triangle.prototype.getDelaunayEdgeCW = function(p) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            return this.delaunay_edge[1];
        } else if (p === this.points_[1]) {
            return this.delaunay_edge[2];
        } else {
            return this.delaunay_edge[0];
        }
    };

    Triangle.prototype.getDelaunayEdgeCCW = function(p) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            return this.delaunay_edge[2];
        } else if (p === this.points_[1]) {
            return this.delaunay_edge[0];
        } else {
            return this.delaunay_edge[1];
        }
    };

    Triangle.prototype.setDelaunayEdgeCW = function(p, e) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            this.delaunay_edge[1] = e;
        } else if (p === this.points_[1]) {
            this.delaunay_edge[2] = e;
        } else {
            this.delaunay_edge[0] = e;
        }
    };

    Triangle.prototype.setDelaunayEdgeCCW = function(p, e) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            this.delaunay_edge[2] = e;
        } else if (p === this.points_[1]) {
            this.delaunay_edge[0] = e;
        } else {
            this.delaunay_edge[1] = e;
        }
    };

    /**
     * The neighbor across to given point.
     */
    Triangle.prototype.neighborAcross = function(p) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            return this.neighbors_[0];
        } else if (p === this.points_[1]) {
            return this.neighbors_[1];
        } else {
            return this.neighbors_[2];
        }
    };

    Triangle.prototype.oppositePoint = function(t, p) {
        var cw = t.pointCW(p);
        return this.pointCW(cw);
    };

    /**
     * Legalize triangle by rotating clockwise around oPoint
     * @param {Point} opoint
     * @param {Point} npoint
     */
    Triangle.prototype.legalize = function(opoint, npoint) {
        var points = this.points_;
        // Here we are comparing point references, not values
        if (opoint === points[0]) {
            points[1] = points[0];
            points[0] = points[2];
            points[2] = npoint;
        } else if (opoint === points[1]) {
            points[2] = points[1];
            points[1] = points[0];
            points[0] = npoint;
        } else if (opoint === points[2]) {
            points[0] = points[2];
            points[2] = points[1];
            points[1] = npoint;
        } else {
            throw new Error('poly2tri Invalid Triangle.legalize() call');
        }
    };

    /**
     * Returns the index of a point in the triangle. 
     * The point *must* be a reference to one of the triangle's vertices.
     * @param {Point} p Point object
     * @returns {Number} index 0, 1 or 2
     */
    Triangle.prototype.index = function(p) {
        var points = this.points_;
        // Here we are comparing point references, not values
        if (p === points[0]) {
            return 0;
        } else if (p === points[1]) {
            return 1;
        } else if (p === points[2]) {
            return 2;
        } else {
            throw new Error('poly2tri Invalid Triangle.index() call');
        }
    };

    Triangle.prototype.edgeIndex = function(p1, p2) {
        var points = this.points_;
        // Here we are comparing point references, not values
        if (p1 === points[0]) {
            if (p2 === points[1]) {
                return 2;
            } else if (p2 === points[2]) {
                return 1;
            }
        } else if (p1 === points[1]) {
            if (p2 === points[2]) {
                return 0;
            } else if (p2 === points[0]) {
                return 2;
            }
        } else if (p1 === points[2]) {
            if (p2 === points[0]) {
                return 1;
            } else if (p2 === points[1]) {
                return 0;
            }
        }
        return -1;
    };

    /**
     * Mark an edge of this triangle as constrained.<br>
     * This method takes either 1 parameter (an edge index or an Edge instance) or
     * 2 parameters (two Point instances defining the edge of the triangle).
     */
    Triangle.prototype.markConstrainedEdgeByIndex = function(index) {
        this.constrained_edge[index] = true;
    };
    Triangle.prototype.markConstrainedEdgeByEdge = function(edge) {
        this.markConstrainedEdgeByPoints(edge.p, edge.q);
    };
    Triangle.prototype.markConstrainedEdgeByPoints = function(p, q) {
        var points = this.points_;
        // Here we are comparing point references, not values        
        if ((q === points[0] && p === points[1]) || (q === points[1] && p === points[0])) {
            this.constrained_edge[2] = true;
        } else if ((q === points[0] && p === points[2]) || (q === points[2] && p === points[0])) {
            this.constrained_edge[1] = true;
        } else if ((q === points[1] && p === points[2]) || (q === points[2] && p === points[1])) {
            this.constrained_edge[0] = true;
        }
    };

// ------------------------------------------------------------------------utils
    var PI_3div4 = 3 * Math.PI / 4;
    var PI_2 = Math.PI / 2;
    var EPSILON = 1e-12;

    /* 
     * Inital triangle factor, seed triangle will extend 30% of
     * PointSet width to both left and right.
     */
    var kAlpha = 0.3;

    var Orientation = {
        "CW": 1,
        "CCW": -1,
        "COLLINEAR": 0
    };

    /**
     * Forumla to calculate signed area<br>
     * Positive if CCW<br>
     * Negative if CW<br>
     * 0 if collinear<br>
     * <pre>
     * A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)
     *              =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)
     * </pre>
     */
    function orient2d(pa, pb, pc) {
        var detleft = (pa.x - pc.x) * (pb.y - pc.y);
        var detright = (pa.y - pc.y) * (pb.x - pc.x);
        var val = detleft - detright;
        if (val > -(EPSILON) && val < (EPSILON)) {
            return Orientation.COLLINEAR;
        } else if (val > 0) {
            return Orientation.CCW;
        } else {
            return Orientation.CW;
        }
    }

    function inScanArea(pa, pb, pc, pd) {
        var pdx = pd.x;
        var pdy = pd.y;
        var adx = pa.x - pdx;
        var ady = pa.y - pdy;
        var bdx = pb.x - pdx;
        var bdy = pb.y - pdy;

        var adxbdy = adx * bdy;
        var bdxady = bdx * ady;
        var oabd = adxbdy - bdxady;

        if (oabd <= (EPSILON)) {
            return false;
        }

        var cdx = pc.x - pdx;
        var cdy = pc.y - pdy;

        var cdxady = cdx * ady;
        var adxcdy = adx * cdy;
        var ocad = cdxady - adxcdy;

        if (ocad <= (EPSILON)) {
            return false;
        }

        return true;
    }

// ---------------------------------------------------------------AdvancingFront
    /**
     * Advancing front node
     * @param {Point} p any "Point like" object with {x,y} (duck typing)
     * @param {Triangle} t triangle (optionnal)
     */
    var Node = function(p, t) {
        this.point = p;
        this.triangle = t || null;

        this.next = null; // Node
        this.prev = null; // Node

        this.value = p.x;
    };

    var AdvancingFront = function(head, tail) {
        this.head_ = head; // Node
        this.tail_ = tail; // Node
        this.search_node_ = head; // Node
    };

    AdvancingFront.prototype.head = function() {
        return this.head_;
    };

    AdvancingFront.prototype.setHead = function(node) {
        this.head_ = node;
    };

    AdvancingFront.prototype.tail = function() {
        return this.tail_;
    };

    AdvancingFront.prototype.setTail = function(node) {
        this.tail_ = node;
    };

    AdvancingFront.prototype.search = function() {
        return this.search_node_;
    };

    AdvancingFront.prototype.setSearch = function(node) {
        this.search_node_ = node;
    };

    AdvancingFront.prototype.findSearchNode = function(/*x*/) {
        // TODO: implement BST index
        return this.search_node_;
    };

    AdvancingFront.prototype.locateNode = function(x) {
        var node = this.search_node_;

        /* jshint boss:true */
        if (x < node.value) {
            while (node = node.prev) {
                if (x >= node.value) {
                    this.search_node_ = node;
                    return node;
                }
            }
        } else {
            while (node = node.next) {
                if (x < node.value) {
                    this.search_node_ = node.prev;
                    return node.prev;
                }
            }
        }
        return null;
    };

    AdvancingFront.prototype.locatePoint = function(point) {
        var px = point.x;
        var node = this.findSearchNode(px);
        var nx = node.point.x;

        if (px === nx) {
            // Here we are comparing point references, not values
            if (point !== node.point) {
                // We might have two nodes with same x value for a short time
                if (point === node.prev.point) {
                    node = node.prev;
                } else if (point === node.next.point) {
                    node = node.next;
                } else {
                    throw new Error('poly2tri Invalid AdvancingFront.locatePoint() call');
                }
            }
        } else if (px < nx) {
            /* jshint boss:true */
            while (node = node.prev) {
                if (point === node.point) {
                    break;
                }
            }
        } else {
            while (node = node.next) {
                if (point === node.point) {
                    break;
                }
            }
        }

        if (node) {
            this.search_node_ = node;
        }
        return node;
    };

// ------------------------------------------------------------------------Basin
    var Basin = function() {
        this.left_node = null; // Node
        this.bottom_node = null; // Node
        this.right_node = null; // Node
        this.width = 0.0; // number
        this.left_highest = false;
    };

    Basin.prototype.clear = function() {
        this.left_node = null;
        this.bottom_node = null;
        this.right_node = null;
        this.width = 0.0;
        this.left_highest = false;
    };

// --------------------------------------------------------------------EdgeEvent
    var EdgeEvent = function() {
        this.constrained_edge = null; // Edge
        this.right = false;
    };

// ----------------------------------------------------SweepContext (public API)
    /**
     * Constructor for the triangulation context.
     * It accepts a simple polyline, which defines the constrained edges.
     * Possible options are:
     *    cloneArrays:  if true, do a shallow copy of the Array parameters 
     *                  (contour, holes). Points inside arrays are never copied.
     *                  Default is false : keep a reference to the array arguments,
     *                  who will be modified in place.
     * @param {Array} contour  array of "Point like" objects with {x,y} (duck typing)
     * @param {Object} options  constructor options
     */
    var SweepContext = function(contour, options) {
        options = options || {};
        this.triangles_ = [];
        this.map_ = [];
        this.points_ = (options.cloneArrays ? contour.slice(0) : contour);
        this.edge_list = [];

        // Bounding box of all points. Computed at the start of the triangulation, 
        // it is stored in case it is needed by the caller.
        this.pmin_ = this.pmax_ = null;

        // Advancing front
        this.front_ = null; // AdvancingFront
        // head point used with advancing front
        this.head_ = null; // Point
        // tail point used with advancing front
        this.tail_ = null; // Point

        this.af_head_ = null; // Node
        this.af_middle_ = null; // Node
        this.af_tail_ = null; // Node

        this.basin = new Basin();
        this.edge_event = new EdgeEvent();

        this.initEdges(this.points_);
    };


    /**
     * Add a hole to the constraints
     * @param {Array} polyline  array of "Point like" objects with {x,y} (duck typing)
     */
    SweepContext.prototype.addHole = function(polyline) {
        this.initEdges(polyline);
        var i, len = polyline.length;
        for (i = 0; i < len; i++) {
            this.points_.push(polyline[i]);
        }
        return this; // for chaining
    };
    // Backward compatibility
    SweepContext.prototype.AddHole = SweepContext.prototype.addHole;


    /**
     * Add a Steiner point to the constraints
     * @param {Point} point     any "Point like" object with {x,y} (duck typing)
     */
    SweepContext.prototype.addPoint = function(point) {
        this.points_.push(point);
        return this; // for chaining
    };
    // Backward compatibility
    SweepContext.prototype.AddPoint = SweepContext.prototype.addPoint;


    /**
     * Add several Steiner points to the constraints
     * @param {array<Point>} points     array of "Point like" object with {x,y} 
     */
    // Method added in the JavaScript version (was not present in the c++ version)
    SweepContext.prototype.addPoints = function(points) {
        this.points_ = this.points_.concat(points);
        return this; // for chaining
    };


    /**
     * Triangulate the polygon with holes and Steiner points.
     */
    // Shortcut method for Sweep.triangulate(SweepContext).
    // Method added in the JavaScript version (was not present in the c++ version)
    SweepContext.prototype.triangulate = function() {
        Sweep.triangulate(this);
        return this; // for chaining
    };


    /**
     * Get the bounding box of the provided constraints (contour, holes and 
     * Steinter points). Warning : these values are not available if the triangulation 
     * has not been done yet.
     * @returns {Object} object with 'min' and 'max' Point
     */
    // Method added in the JavaScript version (was not present in the c++ version)
    SweepContext.prototype.getBoundingBox = function() {
        return {min: this.pmin_, max: this.pmax_};
    };

    /**
     * Get result of triangulation
     * @returns {array<Triangle>}   array of triangles
     */
    SweepContext.prototype.getTriangles = function() {
        return this.triangles_;
    };
    // Backward compatibility
    SweepContext.prototype.GetTriangles = SweepContext.prototype.getTriangles;


// ---------------------------------------------------SweepContext (private API)

    SweepContext.prototype.front = function() {
        return this.front_;
    };

    SweepContext.prototype.pointCount = function() {
        return this.points_.length;
    };

    SweepContext.prototype.head = function() {
        return this.head_;
    };

    SweepContext.prototype.setHead = function(p1) {
        this.head_ = p1;
    };

    SweepContext.prototype.tail = function() {
        return this.tail_;
    };

    SweepContext.prototype.setTail = function(p1) {
        this.tail_ = p1;
    };

    SweepContext.prototype.getMap = function() {
        return this.map_;
    };

    SweepContext.prototype.initTriangulation = function() {
        var xmax = this.points_[0].x;
        var xmin = this.points_[0].x;
        var ymax = this.points_[0].y;
        var ymin = this.points_[0].y;

        // Calculate bounds
        var i, len = this.points_.length;
        for (i = 1; i < len; i++) {
            var p = this.points_[i];
            /* jshint expr:true */
            (p.x > xmax) && (xmax = p.x);
            (p.x < xmin) && (xmin = p.x);
            (p.y > ymax) && (ymax = p.y);
            (p.y < ymin) && (ymin = p.y);
        }
        this.pmin_ = new Point(xmin, ymin);
        this.pmax_ = new Point(xmax, ymax);

        var dx = kAlpha * (xmax - xmin);
        var dy = kAlpha * (ymax - ymin);
        this.head_ = new Point(xmax + dx, ymin - dy);
        this.tail_ = new Point(xmin - dx, ymin - dy);

        // Sort points along y-axis
        this.points_.sort(Point.compare);
    };

    SweepContext.prototype.initEdges = function(polyline) {
        var i, len = polyline.length;
        for (i = 0; i < len; ++i) {
            this.edge_list.push(new Edge(polyline[i], polyline[(i + 1) % len]));
        }
    };

    SweepContext.prototype.getPoint = function(index) {
        return this.points_[index];
    };

    SweepContext.prototype.addToMap = function(triangle) {
        this.map_.push(triangle);
    };

    SweepContext.prototype.locateNode = function(point) {
        return this.front_.locateNode(point.x);
    };

    SweepContext.prototype.createAdvancingFront = function() {
        var head;
        var middle;
        var tail;
        // Initial triangle
        var triangle = new Triangle(this.points_[0], this.tail_, this.head_);

        this.map_.push(triangle);

        head = new Node(triangle.getPoint(1), triangle);
        middle = new Node(triangle.getPoint(0), triangle);
        tail = new Node(triangle.getPoint(2));

        this.front_ = new AdvancingFront(head, tail);

        head.next = middle;
        middle.next = tail;
        middle.prev = head;
        tail.prev = middle;
    };

    SweepContext.prototype.removeNode = function(node) {
        // do nothing
        /* jshint unused:false */
    };

    SweepContext.prototype.mapTriangleToNodes = function(t) {
        for (var i = 0; i < 3; ++i) {
            if (! t.getNeighbor(i)) {
                var n = this.front_.locatePoint(t.pointCW(t.getPoint(i)));
                if (n) {
                    n.triangle = t;
                }
            }
        }
    };

    SweepContext.prototype.removeFromMap = function(triangle) {
        var i, map = this.map_, len = map.length;
        for (i = 0; i < len; i++) {
            if (map[i] === triangle) {
                map.splice(i, 1);
                break;
            }
        }
    };

    /**
     * Do a depth first traversal to collect triangles
     * @param {Triangle} triangle start
     */
    SweepContext.prototype.meshClean = function(triangle) {
        // New implementation avoids recursive calls and use a loop instead.
        // Cf. issues # 57, 65 and 69.
        var triangles = [triangle], t, i;
        /* jshint boss:true */
        while (t = triangles.pop()) {
            if (!t.isInterior()) {
                t.setInterior(true);
                this.triangles_.push(t);
                for (i = 0; i < 3; i++) {
                    if (!t.constrained_edge[i]) {
                        triangles.push(t.getNeighbor(i));
                    }
                }
            }
        }
    };

// ------------------------------------------------------------------------Sweep

    /**
     * The 'Sweep' object is present in order to keep this JavaScript version 
     * as close as possible to the reference C++ version, even though almost
     * all Sweep methods could be declared as members of the SweepContext object.
     */
    var Sweep = {};


    /**
     * Triangulate the polygon with holes and Steiner points.
     * @param   tcx SweepContext object.
     */
    Sweep.triangulate = function(tcx) {
        tcx.initTriangulation();
        tcx.createAdvancingFront();
        // Sweep points; build mesh
        Sweep.sweepPoints(tcx);
        // Clean up
        Sweep.finalizationPolygon(tcx);
    };

    Sweep.sweepPoints = function(tcx) {
        var i, len = tcx.pointCount();
        for (i = 1; i < len; ++i) {
            var point = tcx.getPoint(i);
            var node = Sweep.pointEvent(tcx, point);
            var edges = point._p2t_edge_list;
            for (var j = 0; edges && j < edges.length; ++j) {
                Sweep.edgeEventByEdge(tcx, edges[j], node);
            }
        }
    };

    Sweep.finalizationPolygon = function(tcx) {
        // Get an Internal triangle to start with
        var t = tcx.front().head().next.triangle;
        var p = tcx.front().head().next.point;
        while (!t.getConstrainedEdgeCW(p)) {
            t = t.neighborCCW(p);
        }

        // Collect interior triangles constrained by edges
        tcx.meshClean(t);
    };

    /**
     * Find closes node to the left of the new point and
     * create a new triangle. If needed new holes and basins
     * will be filled to.
     */
    Sweep.pointEvent = function(tcx, point) {
        var node = tcx.locateNode(point);
        var new_node = Sweep.newFrontTriangle(tcx, point, node);

        // Only need to check +epsilon since point never have smaller
        // x value than node due to how we fetch nodes from the front
        if (point.x <= node.point.x + (EPSILON)) {
            Sweep.fill(tcx, node);
        }

        //tcx.AddNode(new_node);

        Sweep.fillAdvancingFront(tcx, new_node);
        return new_node;
    };

    Sweep.edgeEventByEdge = function(tcx, edge, node) {
        tcx.edge_event.constrained_edge = edge;
        tcx.edge_event.right = (edge.p.x > edge.q.x);

        if (Sweep.isEdgeSideOfTriangle(node.triangle, edge.p, edge.q)) {
            return;
        }

        // For now we will do all needed filling
        // TODO: integrate with flip process might give some better performance
        //       but for now this avoid the issue with cases that needs both flips and fills
        Sweep.fillEdgeEvent(tcx, edge, node);
        Sweep.edgeEventByPoints(tcx, edge.p, edge.q, node.triangle, edge.q);
    };

    Sweep.edgeEventByPoints = function(tcx, ep, eq, triangle, point) {
        if (Sweep.isEdgeSideOfTriangle(triangle, ep, eq)) {
            return;
        }

        var p1 = triangle.pointCCW(point);
        var o1 = orient2d(eq, p1, ep);
        if (o1 === Orientation.COLLINEAR) {
            // TODO integrate here changes from C++ version
            throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p1, ep]);
        }

        var p2 = triangle.pointCW(point);
        var o2 = orient2d(eq, p2, ep);
        if (o2 === Orientation.COLLINEAR) {
            // TODO integrate here changes from C++ version
            throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p2, ep]);
        }

        if (o1 === o2) {
            // Need to decide if we are rotating CW or CCW to get to a triangle
            // that will cross edge
            if (o1 === Orientation.CW) {
                triangle = triangle.neighborCCW(point);
            } else {
                triangle = triangle.neighborCW(point);
            }
            Sweep.edgeEventByPoints(tcx, ep, eq, triangle, point);
        } else {
            // This triangle crosses constraint so lets flippin start!
            Sweep.flipEdgeEvent(tcx, ep, eq, triangle, point);
        }
    };

    Sweep.isEdgeSideOfTriangle = function(triangle, ep, eq) {
        var index = triangle.edgeIndex(ep, eq);
        if (index !== -1) {
            triangle.markConstrainedEdgeByIndex(index);
            var t = triangle.getNeighbor(index);
            if (t) {
                t.markConstrainedEdgeByPoints(ep, eq);
            }
            return true;
        }
        return false;
    };

    Sweep.newFrontTriangle = function(tcx, point, node) {
        var triangle = new Triangle(point, node.point, node.next.point);

        triangle.markNeighbor(node.triangle);
        tcx.addToMap(triangle);

        var new_node = new Node(point);
        new_node.next = node.next;
        new_node.prev = node;
        node.next.prev = new_node;
        node.next = new_node;

        if (!Sweep.legalize(tcx, triangle)) {
            tcx.mapTriangleToNodes(triangle);
        }

        return new_node;
    };

    /**
     * Adds a triangle to the advancing front to fill a hole.
     * @param tcx
     * @param node - middle node, that is the bottom of the hole
     */
    Sweep.fill = function(tcx, node) {
        var triangle = new Triangle(node.prev.point, node.point, node.next.point);

        // TODO: should copy the constrained_edge value from neighbor triangles
        //       for now constrained_edge values are copied during the legalize
        triangle.markNeighbor(node.prev.triangle);
        triangle.markNeighbor(node.triangle);

        tcx.addToMap(triangle);

        // Update the advancing front
        node.prev.next = node.next;
        node.next.prev = node.prev;


        // If it was legalized the triangle has already been mapped
        if (!Sweep.legalize(tcx, triangle)) {
            tcx.mapTriangleToNodes(triangle);
        }

        //tcx.removeNode(node);
    };

    /**
     * Fills holes in the Advancing Front
     */
    Sweep.fillAdvancingFront = function(tcx, n) {
        // Fill right holes
        var node = n.next;
        var angle;
        while (node.next) {
            angle = Sweep.holeAngle(node);
            if (angle > PI_2 || angle < -(PI_2)) {
                break;
            }
            Sweep.fill(tcx, node);
            node = node.next;
        }

        // Fill left holes
        node = n.prev;
        while (node.prev) {
            angle = Sweep.holeAngle(node);
            if (angle > PI_2 || angle < -(PI_2)) {
                break;
            }
            Sweep.fill(tcx, node);
            node = node.prev;
        }

        // Fill right basins
        if (n.next && n.next.next) {
            angle = Sweep.basinAngle(n);
            if (angle < PI_3div4) {
                Sweep.fillBasin(tcx, n);
            }
        }
    };

    Sweep.basinAngle = function(node) {
        var ax = node.point.x - node.next.next.point.x;
        var ay = node.point.y - node.next.next.point.y;
        return Math.atan2(ay, ax);
    };

    /**
     *
     * @param node - middle node
     * @return the angle between 3 front nodes
     */
    Sweep.holeAngle = function(node) {
        /* Complex plane
         * ab = cosA +i*sinA
         * ab = (ax + ay*i)(bx + by*i) = (ax*bx + ay*by) + i(ax*by-ay*bx)
         * atan2(y,x) computes the principal value of the argument function
         * applied to the complex number x+iy
         * Where x = ax*bx + ay*by
         *       y = ax*by - ay*bx
         */
        var ax = node.next.point.x - node.point.x;
        var ay = node.next.point.y - node.point.y;
        var bx = node.prev.point.x - node.point.x;
        var by = node.prev.point.y - node.point.y;
        return Math.atan2(ax * by - ay * bx, ax * bx + ay * by);
    };

    /**
     * Returns true if triangle was legalized
     */
    Sweep.legalize = function(tcx, t) {
        // To legalize a triangle we start by finding if any of the three edges
        // violate the Delaunay condition
        for (var i = 0; i < 3; ++i) {
            if (t.delaunay_edge[i]) {
                continue;
            }
            var ot = t.getNeighbor(i);
            if (ot) {
                var p = t.getPoint(i);
                var op = ot.oppositePoint(t, p);
                var oi = ot.index(op);

                // If this is a Constrained Edge or a Delaunay Edge(only during recursive legalization)
                // then we should not try to legalize
                if (ot.constrained_edge[oi] || ot.delaunay_edge[oi]) {
                    t.constrained_edge[i] = ot.constrained_edge[oi];
                    continue;
                }

                var inside = Sweep.inCircle(p, t.pointCCW(p), t.pointCW(p), op);
                if (inside) {
                    // Lets mark this shared edge as Delaunay
                    t.delaunay_edge[i] = true;
                    ot.delaunay_edge[oi] = true;

                    // Lets rotate shared edge one vertex CW to legalize it
                    Sweep.rotateTrianglePair(t, p, ot, op);

                    // We now got one valid Delaunay Edge shared by two triangles
                    // This gives us 4 new edges to check for Delaunay

                    // Make sure that triangle to node mapping is done only one time for a specific triangle
                    var not_legalized = !Sweep.legalize(tcx, t);
                    if (not_legalized) {
                        tcx.mapTriangleToNodes(t);
                    }

                    not_legalized = !Sweep.legalize(tcx, ot);
                    if (not_legalized) {
                        tcx.mapTriangleToNodes(ot);
                    }
                    // Reset the Delaunay edges, since they only are valid Delaunay edges
                    // until we add a new triangle or point.
                    // XXX: need to think about this. Can these edges be tried after we
                    //      return to previous recursive level?
                    t.delaunay_edge[i] = false;
                    ot.delaunay_edge[oi] = false;

                    // If triangle have been legalized no need to check the other edges since
                    // the recursive legalization will handles those so we can end here.
                    return true;
                }
            }
        }
        return false;
    };

    /**
     * <b>Requirement</b>:<br>
     * 1. a,b and c form a triangle.<br>
     * 2. a and d is know to be on opposite side of bc<br>
     * <pre>
     *                a
     *                +
     *               / \
     *              /   \
     *            b/     \c
     *            +-------+
     *           /    d    \
     *          /           \
     * </pre>
     * <b>Fact</b>: d has to be in area B to have a chance to be inside the circle formed by
     *  a,b and c<br>
     *  d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW<br>
     *  This preknowledge gives us a way to optimize the incircle test
     * @param pa - triangle point, opposite d
     * @param pb - triangle point
     * @param pc - triangle point
     * @param pd - point opposite a
     * @return true if d is inside circle, false if on circle edge
     */
    Sweep.inCircle = function(pa, pb, pc, pd) {
        var adx = pa.x - pd.x;
        var ady = pa.y - pd.y;
        var bdx = pb.x - pd.x;
        var bdy = pb.y - pd.y;

        var adxbdy = adx * bdy;
        var bdxady = bdx * ady;
        var oabd = adxbdy - bdxady;
        if (oabd <= 0) {
            return false;
        }

        var cdx = pc.x - pd.x;
        var cdy = pc.y - pd.y;

        var cdxady = cdx * ady;
        var adxcdy = adx * cdy;
        var ocad = cdxady - adxcdy;
        if (ocad <= 0) {
            return false;
        }

        var bdxcdy = bdx * cdy;
        var cdxbdy = cdx * bdy;

        var alift = adx * adx + ady * ady;
        var blift = bdx * bdx + bdy * bdy;
        var clift = cdx * cdx + cdy * cdy;

        var det = alift * (bdxcdy - cdxbdy) + blift * ocad + clift * oabd;
        return det > 0;
    };

    /**
     * Rotates a triangle pair one vertex CW
     *<pre>
     *       n2                    n2
     *  P +-----+             P +-----+
     *    | t  /|               |\  t |
     *    |   / |               | \   |
     *  n1|  /  |n3           n1|  \  |n3
     *    | /   |    after CW   |   \ |
     *    |/ oT |               | oT \|
     *    +-----+ oP            +-----+
     *       n4                    n4
     * </pre>
     */
    Sweep.rotateTrianglePair = function(t, p, ot, op) {
        var n1, n2, n3, n4;
        n1 = t.neighborCCW(p);
        n2 = t.neighborCW(p);
        n3 = ot.neighborCCW(op);
        n4 = ot.neighborCW(op);

        var ce1, ce2, ce3, ce4;
        ce1 = t.getConstrainedEdgeCCW(p);
        ce2 = t.getConstrainedEdgeCW(p);
        ce3 = ot.getConstrainedEdgeCCW(op);
        ce4 = ot.getConstrainedEdgeCW(op);

        var de1, de2, de3, de4;
        de1 = t.getDelaunayEdgeCCW(p);
        de2 = t.getDelaunayEdgeCW(p);
        de3 = ot.getDelaunayEdgeCCW(op);
        de4 = ot.getDelaunayEdgeCW(op);

        t.legalize(p, op);
        ot.legalize(op, p);

        // Remap delaunay_edge
        ot.setDelaunayEdgeCCW(p, de1);
        t.setDelaunayEdgeCW(p, de2);
        t.setDelaunayEdgeCCW(op, de3);
        ot.setDelaunayEdgeCW(op, de4);

        // Remap constrained_edge
        ot.setConstrainedEdgeCCW(p, ce1);
        t.setConstrainedEdgeCW(p, ce2);
        t.setConstrainedEdgeCCW(op, ce3);
        ot.setConstrainedEdgeCW(op, ce4);

        // Remap neighbors
        // XXX: might optimize the markNeighbor by keeping track of
        //      what side should be assigned to what neighbor after the
        //      rotation. Now mark neighbor does lots of testing to find
        //      the right side.
        t.clearNeigbors();
        ot.clearNeigbors();
        if (n1) {
            ot.markNeighbor(n1);
        }
        if (n2) {
            t.markNeighbor(n2);
        }
        if (n3) {
            t.markNeighbor(n3);
        }
        if (n4) {
            ot.markNeighbor(n4);
        }
        t.markNeighbor(ot);
    };

    /**
     * Fills a basin that has formed on the Advancing Front to the right
     * of given node.<br>
     * First we decide a left,bottom and right node that forms the
     * boundaries of the basin. Then we do a reqursive fill.
     *
     * @param tcx
     * @param node - starting node, this or next node will be left node
     */
    Sweep.fillBasin = function(tcx, node) {
        if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
            tcx.basin.left_node = node.next.next;
        } else {
            tcx.basin.left_node = node.next;
        }

        // Find the bottom and right node
        tcx.basin.bottom_node = tcx.basin.left_node;
        while (tcx.basin.bottom_node.next && tcx.basin.bottom_node.point.y >= tcx.basin.bottom_node.next.point.y) {
            tcx.basin.bottom_node = tcx.basin.bottom_node.next;
        }
        if (tcx.basin.bottom_node === tcx.basin.left_node) {
            // No valid basin
            return;
        }

        tcx.basin.right_node = tcx.basin.bottom_node;
        while (tcx.basin.right_node.next && tcx.basin.right_node.point.y < tcx.basin.right_node.next.point.y) {
            tcx.basin.right_node = tcx.basin.right_node.next;
        }
        if (tcx.basin.right_node === tcx.basin.bottom_node) {
            // No valid basins
            return;
        }

        tcx.basin.width = tcx.basin.right_node.point.x - tcx.basin.left_node.point.x;
        tcx.basin.left_highest = tcx.basin.left_node.point.y > tcx.basin.right_node.point.y;

        Sweep.fillBasinReq(tcx, tcx.basin.bottom_node);
    };

    /**
     * Recursive algorithm to fill a Basin with triangles
     *
     * @param tcx
     * @param node - bottom_node
     */
    Sweep.fillBasinReq = function(tcx, node) {
        // if shallow stop filling
        if (Sweep.isShallow(tcx, node)) {
            return;
        }

        Sweep.fill(tcx, node);

        var o;
        if (node.prev === tcx.basin.left_node && node.next === tcx.basin.right_node) {
            return;
        } else if (node.prev === tcx.basin.left_node) {
            o = orient2d(node.point, node.next.point, node.next.next.point);
            if (o === Orientation.CW) {
                return;
            }
            node = node.next;
        } else if (node.next === tcx.basin.right_node) {
            o = orient2d(node.point, node.prev.point, node.prev.prev.point);
            if (o === Orientation.CCW) {
                return;
            }
            node = node.prev;
        } else {
            // Continue with the neighbor node with lowest Y value
            if (node.prev.point.y < node.next.point.y) {
                node = node.prev;
            } else {
                node = node.next;
            }
        }

        Sweep.fillBasinReq(tcx, node);
    };

    Sweep.isShallow = function(tcx, node) {
        var height;
        if (tcx.basin.left_highest) {
            height = tcx.basin.left_node.point.y - node.point.y;
        } else {
            height = tcx.basin.right_node.point.y - node.point.y;
        }

        // if shallow stop filling
        if (tcx.basin.width > height) {
            return true;
        }
        return false;
    };

    Sweep.fillEdgeEvent = function(tcx, edge, node) {
        if (tcx.edge_event.right) {
            Sweep.fillRightAboveEdgeEvent(tcx, edge, node);
        } else {
            Sweep.fillLeftAboveEdgeEvent(tcx, edge, node);
        }
    };

    Sweep.fillRightAboveEdgeEvent = function(tcx, edge, node) {
        while (node.next.point.x < edge.p.x) {
            // Check if next node is below the edge
            if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
                Sweep.fillRightBelowEdgeEvent(tcx, edge, node);
            } else {
                node = node.next;
            }
        }
    };

    Sweep.fillRightBelowEdgeEvent = function(tcx, edge, node) {
        if (node.point.x < edge.p.x) {
            if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
                // Concave
                Sweep.fillRightConcaveEdgeEvent(tcx, edge, node);
            } else {
                // Convex
                Sweep.fillRightConvexEdgeEvent(tcx, edge, node);
                // Retry this one
                Sweep.fillRightBelowEdgeEvent(tcx, edge, node);
            }
        }
    };

    Sweep.fillRightConcaveEdgeEvent = function(tcx, edge, node) {
        Sweep.fill(tcx, node.next);
        if (node.next.point !== edge.p) {
            // Next above or below edge?
            if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
                // Below
                if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
                    // Next is concave
                    Sweep.fillRightConcaveEdgeEvent(tcx, edge, node);
                } else {
                    // Next is convex
                    /* jshint noempty:false */
                }
            }
        }
    };

    Sweep.fillRightConvexEdgeEvent = function(tcx, edge, node) {
        // Next concave or convex?
        if (orient2d(node.next.point, node.next.next.point, node.next.next.next.point) === Orientation.CCW) {
            // Concave
            Sweep.fillRightConcaveEdgeEvent(tcx, edge, node.next);
        } else {
            // Convex
            // Next above or below edge?
            if (orient2d(edge.q, node.next.next.point, edge.p) === Orientation.CCW) {
                // Below
                Sweep.fillRightConvexEdgeEvent(tcx, edge, node.next);
            } else {
                // Above
                /* jshint noempty:false */
            }
        }
    };

    Sweep.fillLeftAboveEdgeEvent = function(tcx, edge, node) {
        while (node.prev.point.x > edge.p.x) {
            // Check if next node is below the edge
            if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
                Sweep.fillLeftBelowEdgeEvent(tcx, edge, node);
            } else {
                node = node.prev;
            }
        }
    };

    Sweep.fillLeftBelowEdgeEvent = function(tcx, edge, node) {
        if (node.point.x > edge.p.x) {
            if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
                // Concave
                Sweep.fillLeftConcaveEdgeEvent(tcx, edge, node);
            } else {
                // Convex
                Sweep.fillLeftConvexEdgeEvent(tcx, edge, node);
                // Retry this one
                Sweep.fillLeftBelowEdgeEvent(tcx, edge, node);
            }
        }
    };

    Sweep.fillLeftConvexEdgeEvent = function(tcx, edge, node) {
        // Next concave or convex?
        if (orient2d(node.prev.point, node.prev.prev.point, node.prev.prev.prev.point) === Orientation.CW) {
            // Concave
            Sweep.fillLeftConcaveEdgeEvent(tcx, edge, node.prev);
        } else {
            // Convex
            // Next above or below edge?
            if (orient2d(edge.q, node.prev.prev.point, edge.p) === Orientation.CW) {
                // Below
                Sweep.fillLeftConvexEdgeEvent(tcx, edge, node.prev);
            } else {
                // Above
                /* jshint noempty:false */
            }
        }
    };

    Sweep.fillLeftConcaveEdgeEvent = function(tcx, edge, node) {
        Sweep.fill(tcx, node.prev);
        if (node.prev.point !== edge.p) {
            // Next above or below edge?
            if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
                // Below
                if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
                    // Next is concave
                    Sweep.fillLeftConcaveEdgeEvent(tcx, edge, node);
                } else {
                    // Next is convex
                    /* jshint noempty:false */
                }
            }
        }
    };

    Sweep.flipEdgeEvent = function(tcx, ep, eq, t, p) {
        var ot = t.neighborAcross(p);
        if (!ot) {
            // If we want to integrate the fillEdgeEvent do it here
            // With current implementation we should never get here
            throw new Error('poly2tri [BUG:FIXME] FLIP failed due to missing triangle!');
        }
        var op = ot.oppositePoint(t, p);

        if (inScanArea(p, t.pointCCW(p), t.pointCW(p), op)) {
            // Lets rotate shared edge one vertex CW
            Sweep.rotateTrianglePair(t, p, ot, op);
            tcx.mapTriangleToNodes(t);
            tcx.mapTriangleToNodes(ot);

            // XXX: in the original C++ code for the next 2 lines, we are
            // comparing point values (and not pointers). In this JavaScript
            // code, we are comparing point references (pointers). This works
            // because we can't have 2 different points with the same values.
            // But to be really equivalent, we should use "Point.equals" here.
            if (p === eq && op === ep) {
                if (eq === tcx.edge_event.constrained_edge.q && ep === tcx.edge_event.constrained_edge.p) {
                    t.markConstrainedEdgeByPoints(ep, eq);
                    ot.markConstrainedEdgeByPoints(ep, eq);
                    Sweep.legalize(tcx, t);
                    Sweep.legalize(tcx, ot);
                } else {
                    // XXX: I think one of the triangles should be legalized here?
                    /* jshint noempty:false */
                }
            } else {
                var o = orient2d(eq, op, ep);
                t = Sweep.nextFlipTriangle(tcx, o, t, ot, p, op);
                Sweep.flipEdgeEvent(tcx, ep, eq, t, p);
            }
        } else {
            var newP = Sweep.nextFlipPoint(ep, eq, ot, op);
            Sweep.flipScanEdgeEvent(tcx, ep, eq, t, ot, newP);
            Sweep.edgeEventByPoints(tcx, ep, eq, t, p);
        }
    };

    Sweep.nextFlipTriangle = function(tcx, o, t, ot, p, op) {
        var edge_index;
        if (o === Orientation.CCW) {
            // ot is not crossing edge after flip
            edge_index = ot.edgeIndex(p, op);
            ot.delaunay_edge[edge_index] = true;
            Sweep.legalize(tcx, ot);
            ot.clearDelunayEdges();
            return t;
        }

        // t is not crossing edge after flip
        edge_index = t.edgeIndex(p, op);

        t.delaunay_edge[edge_index] = true;
        Sweep.legalize(tcx, t);
        t.clearDelunayEdges();
        return ot;
    };

    Sweep.nextFlipPoint = function(ep, eq, ot, op) {
        var o2d = orient2d(eq, op, ep);
        if (o2d === Orientation.CW) {
            // Right
            return ot.pointCCW(op);
        } else if (o2d === Orientation.CCW) {
            // Left
            return ot.pointCW(op);
        } else {
            throw new PointError("poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!", [eq, op, ep]);
        }
    };

    Sweep.flipScanEdgeEvent = function(tcx, ep, eq, flip_triangle, t, p) {
        var ot = t.neighborAcross(p);
        if (!ot) {
            // If we want to integrate the fillEdgeEvent do it here
            // With current implementation we should never get here
            throw new Error('poly2tri [BUG:FIXME] FLIP failed due to missing triangle');
        }
        var op = ot.oppositePoint(t, p);

        if (inScanArea(eq, flip_triangle.pointCCW(eq), flip_triangle.pointCW(eq), op)) {
            // flip with new edge op.eq
            Sweep.flipEdgeEvent(tcx, eq, op, ot, op);
            // TODO: Actually I just figured out that it should be possible to
            //       improve this by getting the next ot and op before the the above
            //       flip and continue the flipScanEdgeEvent here
            // set new ot and op here and loop back to inScanArea test
            // also need to set a new flip_triangle first
            // Turns out at first glance that this is somewhat complicated
            // so it will have to wait.
        } else {
            var newP = Sweep.nextFlipPoint(ep, eq, ot, op);
            Sweep.flipScanEdgeEvent(tcx, ep, eq, flip_triangle, ot, newP);
        }
    };

// ---------------------------------------------------------Exports (public API)

    poly2tri.PointError     = PointError;
    poly2tri.Point          = Point;
    poly2tri.Triangle       = Triangle;
    poly2tri.SweepContext   = SweepContext;

    // Backward compatibility
    poly2tri.triangulate    = Sweep.triangulate;
    poly2tri.sweep = {Triangulate: Sweep.triangulate};

}(this));


// ----------------------------------------------------Namespace.js (deprecated)

(function() { // to scope jshint directives
    "use strict";
    /* jshint newcap:false */
    /* global Namespace, js, poly2tri */

    // Tests "Namespace.js" support, for backward compatilibilty
    if (typeof Namespace === 'function') {
        // Put in the "js.poly2tri" namespace
        Namespace('js.poly2tri');
        js.poly2tri = poly2tri;
        Namespace.provide('js.poly2tri');
    }
}());

/******************************************************************************
 * Spine Runtime Software License - Version 1.1
 * 
 * Copyright (c) 2013, Esoteric Software
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms in whole or in part, with
 * or without modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. A Spine Essential, Professional, Enterprise, or Education License must
 *    be purchased from Esoteric Software and the license must remain valid:
 *    http://esotericsoftware.com/
 * 2. Redistributions of source code must retain this license, which is the
 *    above copyright notice, this declaration of conditions and the following
 *    disclaimer.
 * 3. Redistributions in binary form must reproduce this license, which is the
 *    above copyright notice, this declaration of conditions and the following
 *    disclaimer, in the documentation and/or other materials provided with the
 *    distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

var spine = {};

spine.BoneData = function (name, parent) {
	this.name = name;
	this.parent = parent;
};
spine.BoneData.prototype = {
	length: 0,
	x: 0, y: 0,
	rotation: 0,
	scaleX: 1, scaleY: 1,
	inheritScale: true,
	inheritRotation: true
};

spine.SlotData = function (name, boneData) {
	this.name = name;
	this.boneData = boneData;
};
spine.SlotData.prototype = {
	r: 1, g: 1, b: 1, a: 1,
	attachmentName: null,
	additiveBlending: false
};

spine.Bone = function (boneData, parent) {
	this.data = boneData;
	this.parent = parent;
	this.setToSetupPose();
};
spine.Bone.yDown = false;
spine.Bone.prototype = {
	x: 0, y: 0,
	rotation: 0,
	scaleX: 1, scaleY: 1,
	m00: 0, m01: 0, worldX: 0, // a b x
	m10: 0, m11: 0, worldY: 0, // c d y
	worldRotation: 0,
	worldScaleX: 1, worldScaleY: 1,
	updateWorldTransform: function (flipX, flipY) {
		var parent = this.parent;
		if (parent != null) {
			this.worldX = this.x * parent.m00 + this.y * parent.m01 + parent.worldX;
			this.worldY = this.x * parent.m10 + this.y * parent.m11 + parent.worldY;
			if (this.data.inheritScale) {
				this.worldScaleX = parent.worldScaleX * this.scaleX;
				this.worldScaleY = parent.worldScaleY * this.scaleY;
			} else {
				this.worldScaleX = this.scaleX;
				this.worldScaleY = this.scaleY;
			}
			this.worldRotation = this.data.inheritRotation ? parent.worldRotation + this.rotation : this.rotation;
		} else {
			this.worldX = this.x;
			this.worldY = this.y;
			this.worldScaleX = this.scaleX;
			this.worldScaleY = this.scaleY;
			this.worldRotation = this.rotation;
		}
		var radians = this.worldRotation * Math.PI / 180;
		var cos = Math.cos(radians);
		var sin = Math.sin(radians);
		this.m00 = cos * this.worldScaleX;
		this.m10 = sin * this.worldScaleX;
		this.m01 = -sin * this.worldScaleY;
		this.m11 = cos * this.worldScaleY;
		if (flipX) {
			this.m00 = -this.m00;
			this.m01 = -this.m01;
		}
		if (flipY != spine.Bone.yDown) {
			this.m10 = -this.m10;
			this.m11 = -this.m11;
		}
	},
	setToSetupPose: function () {
		var data = this.data;
		this.x = data.x;
		this.y = data.y;
		this.rotation = data.rotation;
		this.scaleX = data.scaleX;
		this.scaleY = data.scaleY;
	}
};

spine.Slot = function (slotData, skeleton, bone) {
	this.data = slotData;
	this.skeleton = skeleton;
	this.bone = bone;
	this.setToSetupPose();
};
spine.Slot.prototype = {
	r: 1, g: 1, b: 1, a: 1,
	_attachmentTime: 0,
	attachment: null,
	setAttachment: function (attachment) {
		this.attachment = attachment;
		this._attachmentTime = this.skeleton.time;
	},
	setAttachmentTime: function (time) {
		this._attachmentTime = this.skeleton.time - time;
	},
	getAttachmentTime: function () {
		return this.skeleton.time - this._attachmentTime;
	},
	setToSetupPose: function () {
		var data = this.data;
		this.r = data.r;
		this.g = data.g;
		this.b = data.b;
		this.a = data.a;

		var slotDatas = this.skeleton.data.slots;
		for (var i = 0, n = slotDatas.length; i < n; i++) {
			if (slotDatas[i] == data) {
				this.setAttachment(!data.attachmentName ? null : this.skeleton.getAttachmentBySlotIndex(i, data.attachmentName));
				break;
			}
		}
	}
};

spine.Skin = function (name) {
	this.name = name;
	this.attachments = {};
};
spine.Skin.prototype = {
	addAttachment: function (slotIndex, name, attachment) {
		this.attachments[slotIndex + ":" + name] = attachment;
	},
	getAttachment: function (slotIndex, name) {
		return this.attachments[slotIndex + ":" + name];
	},
	_attachAll: function (skeleton, oldSkin) {
		for (var key in oldSkin.attachments) {
			var colon = key.indexOf(":");
			var slotIndex = parseInt(key.substring(0, colon));
			var name = key.substring(colon + 1);
			var slot = skeleton.slots[slotIndex];
			if (slot.attachment && slot.attachment.name == name) {
				var attachment = this.getAttachment(slotIndex, name);
				if (attachment) slot.setAttachment(attachment);
			}
		}
	}
};

spine.Animation = function (name, timelines, duration) {
	this.name = name;
	this.timelines = timelines;
	this.duration = duration;
};
spine.Animation.prototype = {
	apply: function (skeleton, lastTime, time, loop, events) {
		if (loop && this.duration != 0) {
			time %= this.duration;
			lastTime %= this.duration;
		}
		var timelines = this.timelines;
		for (var i = 0, n = timelines.length; i < n; i++)
			timelines[i].apply(skeleton, lastTime, time, events, 1);
	},
	mix: function (skeleton, lastTime, time, loop, events, alpha) {
		if (loop && this.duration != 0) {
			time %= this.duration;
			lastTime %= this.duration;
		}
		var timelines = this.timelines;
		for (var i = 0, n = timelines.length; i < n; i++)
			timelines[i].apply(skeleton, lastTime, time, events, alpha);
	}
};

spine.binarySearch = function (values, target, step) {
	var low = 0;
	var high = Math.floor(values.length / step) - 2;
	if (high == 0) return step;
	var current = high >>> 1;
	while (true) {
		if (values[(current + 1) * step] <= target)
			low = current + 1;
		else
			high = current;
		if (low == high) return (low + 1) * step;
		current = (low + high) >>> 1;
	}
};
spine.linearSearch = function (values, target, step) {
	for (var i = 0, last = values.length - step; i <= last; i += step)
		if (values[i] > target) return i;
	return -1;
};

spine.Curves = function (frameCount) {
	this.curves = []; // dfx, dfy, ddfx, ddfy, dddfx, dddfy, ...
	this.curves.length = (frameCount - 1) * 6;
};
spine.Curves.prototype = {
	setLinear: function (frameIndex) {
		this.curves[frameIndex * 6] = 0/*LINEAR*/;
	},
	setStepped: function (frameIndex) {
		this.curves[frameIndex * 6] = -1/*STEPPED*/;
	},
	/** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.
	 * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of
	 * the difference between the keyframe's values. */
	setCurve: function (frameIndex, cx1, cy1, cx2, cy2) {
		var subdiv_step = 1 / 10/*BEZIER_SEGMENTS*/;
		var subdiv_step2 = subdiv_step * subdiv_step;
		var subdiv_step3 = subdiv_step2 * subdiv_step;
		var pre1 = 3 * subdiv_step;
		var pre2 = 3 * subdiv_step2;
		var pre4 = 6 * subdiv_step2;
		var pre5 = 6 * subdiv_step3;
		var tmp1x = -cx1 * 2 + cx2;
		var tmp1y = -cy1 * 2 + cy2;
		var tmp2x = (cx1 - cx2) * 3 + 1;
		var tmp2y = (cy1 - cy2) * 3 + 1;
		var i = frameIndex * 6;
		var curves = this.curves;
		curves[i] = cx1 * pre1 + tmp1x * pre2 + tmp2x * subdiv_step3;
		curves[i + 1] = cy1 * pre1 + tmp1y * pre2 + tmp2y * subdiv_step3;
		curves[i + 2] = tmp1x * pre4 + tmp2x * pre5;
		curves[i + 3] = tmp1y * pre4 + tmp2y * pre5;
		curves[i + 4] = tmp2x * pre5;
		curves[i + 5] = tmp2y * pre5;
	},
	getCurvePercent: function (frameIndex, percent) {
		percent = percent < 0 ? 0 : (percent > 1 ? 1 : percent);
		var curveIndex = frameIndex * 6;
		var curves = this.curves;
		var dfx = curves[curveIndex];
		if (!dfx/*LINEAR*/) return percent;
		if (dfx == -1/*STEPPED*/) return 0;
		var dfy = curves[curveIndex + 1];
		var ddfx = curves[curveIndex + 2];
		var ddfy = curves[curveIndex + 3];
		var dddfx = curves[curveIndex + 4];
		var dddfy = curves[curveIndex + 5];
		var x = dfx, y = dfy;
		var i = 10/*BEZIER_SEGMENTS*/ - 2;
		while (true) {
			if (x >= percent) {
				var lastX = x - dfx;
				var lastY = y - dfy;
				return lastY + (y - lastY) * (percent - lastX) / (x - lastX);
			}
			if (i == 0) break;
			i--;
			dfx += ddfx;
			dfy += ddfy;
			ddfx += dddfx;
			ddfy += dddfy;
			x += dfx;
			y += dfy;
		}
		return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.
	}
};

spine.RotateTimeline = function (frameCount) {
	this.curves = new spine.Curves(frameCount);
	this.frames = []; // time, angle, ...
	this.frames.length = frameCount * 2;
};
spine.RotateTimeline.prototype = {
	boneIndex: 0,
	getFrameCount: function () {
		return this.frames.length / 2;
	},
	setFrame: function (frameIndex, time, angle) {
		frameIndex *= 2;
		this.frames[frameIndex] = time;
		this.frames[frameIndex + 1] = angle;
	},
	apply: function (skeleton, lastTime, time, firedEvents, alpha) {
		var frames = this.frames;
		if (time < frames[0]) return; // Time is before first frame.

		var bone = skeleton.bones[this.boneIndex];

		if (time >= frames[frames.length - 2]) { // Time is after last frame.
			var amount = bone.data.rotation + frames[frames.length - 1] - bone.rotation;
			while (amount > 180)
				amount -= 360;
			while (amount < -180)
				amount += 360;
			bone.rotation += amount * alpha;
			return;
		}

		// Interpolate between the last frame and the current frame.
		var frameIndex = spine.binarySearch(frames, time, 2);
		var lastFrameValue = frames[frameIndex - 1];
		var frameTime = frames[frameIndex];
		var percent = 1 - (time - frameTime) / (frames[frameIndex - 2/*LAST_FRAME_TIME*/] - frameTime);
		percent = this.curves.getCurvePercent(frameIndex / 2 - 1, percent);

		var amount = frames[frameIndex + 1/*FRAME_VALUE*/] - lastFrameValue;
		while (amount > 180)
			amount -= 360;
		while (amount < -180)
			amount += 360;
		amount = bone.data.rotation + (lastFrameValue + amount * percent) - bone.rotation;
		while (amount > 180)
			amount -= 360;
		while (amount < -180)
			amount += 360;
		bone.rotation += amount * alpha;
	}
};

spine.TranslateTimeline = function (frameCount) {
	this.curves = new spine.Curves(frameCount);
	this.frames = []; // time, x, y, ...
	this.frames.length = frameCount * 3;
};
spine.TranslateTimeline.prototype = {
	boneIndex: 0,
	getFrameCount: function () {
		return this.frames.length / 3;
	},
	setFrame: function (frameIndex, time, x, y) {
		frameIndex *= 3;
		this.frames[frameIndex] = time;
		this.frames[frameIndex + 1] = x;
		this.frames[frameIndex + 2] = y;
	},
	apply: function (skeleton, lastTime, time, firedEvents, alpha) {
		var frames = this.frames;
		if (time < frames[0]) return; // Time is before first frame.

		var bone = skeleton.bones[this.boneIndex];

		if (time >= frames[frames.length - 3]) { // Time is after last frame.
			bone.x += (bone.data.x + frames[frames.length - 2] - bone.x) * alpha;
			bone.y += (bone.data.y + frames[frames.length - 1] - bone.y) * alpha;
			return;
		}

		// Interpolate between the last frame and the current frame.
		var frameIndex = spine.binarySearch(frames, time, 3);
		var lastFrameX = frames[frameIndex - 2];
		var lastFrameY = frames[frameIndex - 1];
		var frameTime = frames[frameIndex];
		var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*LAST_FRAME_TIME*/] - frameTime);
		percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);

		bone.x += (bone.data.x + lastFrameX + (frames[frameIndex + 1/*FRAME_X*/] - lastFrameX) * percent - bone.x) * alpha;
		bone.y += (bone.data.y + lastFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - lastFrameY) * percent - bone.y) * alpha;
	}
};

spine.ScaleTimeline = function (frameCount) {
	this.curves = new spine.Curves(frameCount);
	this.frames = []; // time, x, y, ...
	this.frames.length = frameCount * 3;
};
spine.ScaleTimeline.prototype = {
	boneIndex: 0,
	getFrameCount: function () {
		return this.frames.length / 3;
	},
	setFrame: function (frameIndex, time, x, y) {
		frameIndex *= 3;
		this.frames[frameIndex] = time;
		this.frames[frameIndex + 1] = x;
		this.frames[frameIndex + 2] = y;
	},
	apply: function (skeleton, lastTime, time, firedEvents, alpha) {
		var frames = this.frames;
		if (time < frames[0]) return; // Time is before first frame.

		var bone = skeleton.bones[this.boneIndex];

		if (time >= frames[frames.length - 3]) { // Time is after last frame.
			bone.scaleX += (bone.data.scaleX - 1 + frames[frames.length - 2] - bone.scaleX) * alpha;
			bone.scaleY += (bone.data.scaleY - 1 + frames[frames.length - 1] - bone.scaleY) * alpha;
			return;
		}

		// Interpolate between the last frame and the current frame.
		var frameIndex = spine.binarySearch(frames, time, 3);
		var lastFrameX = frames[frameIndex - 2];
		var lastFrameY = frames[frameIndex - 1];
		var frameTime = frames[frameIndex];
		var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*LAST_FRAME_TIME*/] - frameTime);
		percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);

		bone.scaleX += (bone.data.scaleX - 1 + lastFrameX + (frames[frameIndex + 1/*FRAME_X*/] - lastFrameX) * percent - bone.scaleX) * alpha;
		bone.scaleY += (bone.data.scaleY - 1 + lastFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - lastFrameY) * percent - bone.scaleY) * alpha;
	}
};

spine.ColorTimeline = function (frameCount) {
	this.curves = new spine.Curves(frameCount);
	this.frames = []; // time, r, g, b, a, ...
	this.frames.length = frameCount * 5;
};
spine.ColorTimeline.prototype = {
	slotIndex: 0,
	getFrameCount: function () {
		return this.frames.length / 5;
	},
	setFrame: function (frameIndex, time, r, g, b, a) {
		frameIndex *= 5;
		this.frames[frameIndex] = time;
		this.frames[frameIndex + 1] = r;
		this.frames[frameIndex + 2] = g;
		this.frames[frameIndex + 3] = b;
		this.frames[frameIndex + 4] = a;
	},
	apply: function (skeleton, lastTime, time, firedEvents, alpha) {
		var frames = this.frames;
		if (time < frames[0]) return; // Time is before first frame.

		var slot = skeleton.slots[this.slotIndex];

		if (time >= frames[frames.length - 5]) { // Time is after last frame.
			var i = frames.length - 1;
			slot.r = frames[i - 3];
			slot.g = frames[i - 2];
			slot.b = frames[i - 1];
			slot.a = frames[i];
			return;
		}

		// Interpolate between the last frame and the current frame.
		var frameIndex = spine.binarySearch(frames, time, 5);
		var lastFrameR = frames[frameIndex - 4];
		var lastFrameG = frames[frameIndex - 3];
		var lastFrameB = frames[frameIndex - 2];
		var lastFrameA = frames[frameIndex - 1];
		var frameTime = frames[frameIndex];
		var percent = 1 - (time - frameTime) / (frames[frameIndex - 5/*LAST_FRAME_TIME*/] - frameTime);
		percent = this.curves.getCurvePercent(frameIndex / 5 - 1, percent);

		var r = lastFrameR + (frames[frameIndex + 1/*FRAME_R*/] - lastFrameR) * percent;
		var g = lastFrameG + (frames[frameIndex + 2/*FRAME_G*/] - lastFrameG) * percent;
		var b = lastFrameB + (frames[frameIndex + 3/*FRAME_B*/] - lastFrameB) * percent;
		var a = lastFrameA + (frames[frameIndex + 4/*FRAME_A*/] - lastFrameA) * percent;
		if (alpha < 1) {
			slot.r += (r - slot.r) * alpha;
			slot.g += (g - slot.g) * alpha;
			slot.b += (b - slot.b) * alpha;
			slot.a += (a - slot.a) * alpha;
		} else {
			slot.r = r;
			slot.g = g;
			slot.b = b;
			slot.a = a;
		}
	}
};

spine.AttachmentTimeline = function (frameCount) {
	this.curves = new spine.Curves(frameCount);
	this.frames = []; // time, ...
	this.frames.length = frameCount;
	this.attachmentNames = [];
	this.attachmentNames.length = frameCount;
};
spine.AttachmentTimeline.prototype = {
	slotIndex: 0,
	getFrameCount: function () {
		return this.frames.length;
	},
	setFrame: function (frameIndex, time, attachmentName) {
		this.frames[frameIndex] = time;
		this.attachmentNames[frameIndex] = attachmentName;
	},
	apply: function (skeleton, lastTime, time, firedEvents, alpha) {
		var frames = this.frames;
		if (time < frames[0]) return; // Time is before first frame.

		var frameIndex;
		if (time >= frames[frames.length - 1]) // Time is after last frame.
			frameIndex = frames.length - 1;
		else
			frameIndex = spine.binarySearch(frames, time, 1) - 1;

		var attachmentName = this.attachmentNames[frameIndex];
		skeleton.slots[this.slotIndex].setAttachment(!attachmentName ? null : skeleton.getAttachmentBySlotIndex(this.slotIndex, attachmentName));
	}
};

spine.EventTimeline = function (frameCount) {
	this.frames = []; // time, ...
	this.frames.length = frameCount;
	this.events = [];
	this.events.length = frameCount;
};
spine.EventTimeline.prototype = {
	getFrameCount: function () {
		return this.frames.length;
	},
	setFrame: function (frameIndex, time, event) {
		this.frames[frameIndex] = time;
		this.events[frameIndex] = event;
	},
	/** Fires events for frames > lastTime and <= time. */
	apply: function (skeleton, lastTime, time, firedEvents, alpha) {
		if (!firedEvents) return;

		var frames = this.frames;
		var frameCount = frames.length;

		if (lastTime > time) { // Fire events after last time for looped animations.
			apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha);
			lastTime = -1;
		} else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.
			return;
		if (time < frames[0]) return; // Time is before first frame.

		var frameIndex;
		if (lastTime < frames[0])
			frameIndex = 0;
		else {
			frameIndex = spine.binarySearch(frames, lastTime, 1);
			var frame = frames[frameIndex];
			while (frameIndex > 0) { // Fire multiple events with the same frame.
				if (frames[frameIndex - 1] != frame) break;
				frameIndex--;
			}
		}
		var events = this.events;
		for (; frameIndex < frameCount && time >= frames[frameIndex]; frameIndex++)
			firedEvents.push(events[frameIndex]);
	}
};

spine.DrawOrderTimeline = function (frameCount) {
	this.frames = []; // time, ...
	this.frames.length = frameCount;
	this.drawOrders = [];
	this.drawOrders.length = frameCount;
};
spine.DrawOrderTimeline.prototype = {
	getFrameCount: function () {
		return this.frames.length;
	},
	setFrame: function (frameIndex, time, drawOrder) {
		this.frames[frameIndex] = time;
		this.drawOrders[frameIndex] = drawOrder;
	},
	apply: function (skeleton, lastTime, time, firedEvents, alpha) {
		var frames = this.frames;
		if (time < frames[0]) return; // Time is before first frame.

		var frameIndex;
		if (time >= frames[frames.length - 1]) // Time is after last frame.
			frameIndex = frames.length - 1;
		else
			frameIndex = spine.binarySearch(frames, time, 1) - 1;

		var drawOrder = skeleton.drawOrder;
		var slots = skeleton.slots;
		var drawOrderToSetupIndex = this.drawOrders[frameIndex];
		if (!drawOrderToSetupIndex) {
			for (var i = 0, n = slots.length; i < n; i++)
				drawOrder[i] = slots[i];
		} else {
			for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)
				drawOrder[i] = skeleton.slots[drawOrderToSetupIndex[i]];
		}

	}
};

spine.SkeletonData = function () {
	this.bones = [];
	this.slots = [];
	this.skins = [];
	this.events = [];
	this.animations = [];
};
spine.SkeletonData.prototype = {
	defaultSkin: null,
	/** @return May be null. */
	findBone: function (boneName) {
		var bones = this.bones;
		for (var i = 0, n = bones.length; i < n; i++)
			if (bones[i].name == boneName) return bones[i];
		return null;
	},
	/** @return -1 if the bone was not found. */
	findBoneIndex: function (boneName) {
		var bones = this.bones;
		for (var i = 0, n = bones.length; i < n; i++)
			if (bones[i].name == boneName) return i;
		return -1;
	},
	/** @return May be null. */
	findSlot: function (slotName) {
		var slots = this.slots;
		for (var i = 0, n = slots.length; i < n; i++) {
			if (slots[i].name == slotName) return slot[i];
		}
		return null;
	},
	/** @return -1 if the bone was not found. */
	findSlotIndex: function (slotName) {
		var slots = this.slots;
		for (var i = 0, n = slots.length; i < n; i++)
			if (slots[i].name == slotName) return i;
		return -1;
	},
	/** @return May be null. */
	findSkin: function (skinName) {
		var skins = this.skins;
		for (var i = 0, n = skins.length; i < n; i++)
			if (skins[i].name == skinName) return skins[i];
		return null;
	},
	/** @return May be null. */
	findEvent: function (eventName) {
		var events = this.events;
		for (var i = 0, n = events.length; i < n; i++)
			if (events[i].name == eventName) return events[i];
		return null;
	},
	/** @return May be null. */
	findAnimation: function (animationName) {
		var animations = this.animations;
		for (var i = 0, n = animations.length; i < n; i++)
			if (animations[i].name == animationName) return animations[i];
		return null;
	}
};

spine.Skeleton = function (skeletonData) {
	this.data = skeletonData;

	this.bones = [];
	for (var i = 0, n = skeletonData.bones.length; i < n; i++) {
		var boneData = skeletonData.bones[i];
		var parent = !boneData.parent ? null : this.bones[skeletonData.bones.indexOf(boneData.parent)];
		this.bones.push(new spine.Bone(boneData, parent));
	}

	this.slots = [];
	this.drawOrder = [];
	for (var i = 0, n = skeletonData.slots.length; i < n; i++) {
		var slotData = skeletonData.slots[i];
		var bone = this.bones[skeletonData.bones.indexOf(slotData.boneData)];
		var slot = new spine.Slot(slotData, this, bone);
		this.slots.push(slot);
		this.drawOrder.push(slot);
	}
};
spine.Skeleton.prototype = {
	x: 0, y: 0,
	skin: null,
	r: 1, g: 1, b: 1, a: 1,
	time: 0,
	flipX: false, flipY: false,
	/** Updates the world transform for each bone. */
	updateWorldTransform: function () {
		var flipX = this.flipX;
		var flipY = this.flipY;
		var bones = this.bones;
		for (var i = 0, n = bones.length; i < n; i++)
			bones[i].updateWorldTransform(flipX, flipY);
	},
	/** Sets the bones and slots to their setup pose values. */
	setToSetupPose: function () {
		this.setBonesToSetupPose();
		this.setSlotsToSetupPose();
	},
	setBonesToSetupPose: function () {
		var bones = this.bones;
		for (var i = 0, n = bones.length; i < n; i++)
			bones[i].setToSetupPose();
	},
	setSlotsToSetupPose: function () {
		var slots = this.slots;
		for (var i = 0, n = slots.length; i < n; i++)
			slots[i].setToSetupPose(i);
	},
	/** @return May return null. */
	getRootBone: function () {
		return this.bones.length == 0 ? null : this.bones[0];
	},
	/** @return May be null. */
	findBone: function (boneName) {
		var bones = this.bones;
		for (var i = 0, n = bones.length; i < n; i++)
			if (bones[i].data.name == boneName) return bones[i];
		return null;
	},
	/** @return -1 if the bone was not found. */
	findBoneIndex: function (boneName) {
		var bones = this.bones;
		for (var i = 0, n = bones.length; i < n; i++)
			if (bones[i].data.name == boneName) return i;
		return -1;
	},
	/** @return May be null. */
	findSlot: function (slotName) {
		var slots = this.slots;
		for (var i = 0, n = slots.length; i < n; i++)
			if (slots[i].data.name == slotName) return slots[i];
		return null;
	},
	/** @return -1 if the bone was not found. */
	findSlotIndex: function (slotName) {
		var slots = this.slots;
		for (var i = 0, n = slots.length; i < n; i++)
			if (slots[i].data.name == slotName) return i;
		return -1;
	},
	setSkinByName: function (skinName) {
		var skin = this.data.findSkin(skinName);
		if (!skin) throw "Skin not found: " + skinName;
		this.setSkin(skin);
	},
	/** Sets the skin used to look up attachments not found in the {@link SkeletonData#getDefaultSkin() default skin}. Attachments
	 * from the new skin are attached if the corresponding attachment from the old skin was attached.
	 * @param newSkin May be null. */
	setSkin: function (newSkin) {
		if (this.skin && newSkin) newSkin._attachAll(this, this.skin);
		this.skin = newSkin;
	},
	/** @return May be null. */
	getAttachmentBySlotName: function (slotName, attachmentName) {
		return this.getAttachmentBySlotIndex(this.data.findSlotIndex(slotName), attachmentName);
	},
	/** @return May be null. */
	getAttachmentBySlotIndex: function (slotIndex, attachmentName) {
		if (this.skin) {
			var attachment = this.skin.getAttachment(slotIndex, attachmentName);
			if (attachment) return attachment;
		}
		if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
		return null;
	},
	/** @param attachmentName May be null. */
	setAttachment: function (slotName, attachmentName) {
		var slots = this.slots;
		for (var i = 0, n = slots.size; i < n; i++) {
			var slot = slots[i];
			if (slot.data.name == slotName) {
				var attachment = null;
				if (attachmentName) {
					attachment = this.getAttachment(i, attachmentName);
					if (!attachment) throw "Attachment not found: " + attachmentName + ", for slot: " + slotName;
				}
				slot.setAttachment(attachment);
				return;
			}
		}
		throw "Slot not found: " + slotName;
	},
	update: function (delta) {
		time += delta;
	}
};

spine.EventData = function (name) {
	this.name = name;
}
spine.EventData.prototype = {
	intValue: 0,
	floatValue: 0,
	stringValue: null
};

spine.Event = function (data) {
	this.data = data;
}
spine.Event.prototype = {
	intValue: 0,
	floatValue: 0,
	stringValue: null
};

spine.AttachmentType = {
	region: 0,
	boundingbox: 1
};

spine.RegionAttachment = function (name) {
	this.name = name;
	this.offset = [];
	this.offset.length = 8;
	this.uvs = [];
	this.uvs.length = 8;
};
spine.RegionAttachment.prototype = {
	type: spine.AttachmentType.region,
	x: 0, y: 0,
	rotation: 0,
	scaleX: 1, scaleY: 1,
	width: 0, height: 0,
	rendererObject: null,
	regionOffsetX: 0, regionOffsetY: 0,
	regionWidth: 0, regionHeight: 0,
	regionOriginalWidth: 0, regionOriginalHeight: 0,
	setUVs: function (u, v, u2, v2, rotate) {
		var uvs = this.uvs;
		if (rotate) {
			uvs[2/*X2*/] = u;
			uvs[3/*Y2*/] = v2;
			uvs[4/*X3*/] = u;
			uvs[5/*Y3*/] = v;
			uvs[6/*X4*/] = u2;
			uvs[7/*Y4*/] = v;
			uvs[0/*X1*/] = u2;
			uvs[1/*Y1*/] = v2;
		} else {
			uvs[0/*X1*/] = u;
			uvs[1/*Y1*/] = v2;
			uvs[2/*X2*/] = u;
			uvs[3/*Y2*/] = v;
			uvs[4/*X3*/] = u2;
			uvs[5/*Y3*/] = v;
			uvs[6/*X4*/] = u2;
			uvs[7/*Y4*/] = v2;
		}
	},
	updateOffset: function () {
		var regionScaleX = this.width / this.regionOriginalWidth * this.scaleX;
		var regionScaleY = this.height / this.regionOriginalHeight * this.scaleY;
		var localX = -this.width / 2 * this.scaleX + this.regionOffsetX * regionScaleX;
		var localY = -this.height / 2 * this.scaleY + this.regionOffsetY * regionScaleY;
		var localX2 = localX + this.regionWidth * regionScaleX;
		var localY2 = localY + this.regionHeight * regionScaleY;
		var radians = this.rotation * Math.PI / 180;
		var cos = Math.cos(radians);
		var sin = Math.sin(radians);
		var localXCos = localX * cos + this.x;
		var localXSin = localX * sin;
		var localYCos = localY * cos + this.y;
		var localYSin = localY * sin;
		var localX2Cos = localX2 * cos + this.x;
		var localX2Sin = localX2 * sin;
		var localY2Cos = localY2 * cos + this.y;
		var localY2Sin = localY2 * sin;
		var offset = this.offset;
		offset[0/*X1*/] = localXCos - localYSin;
		offset[1/*Y1*/] = localYCos + localXSin;
		offset[2/*X2*/] = localXCos - localY2Sin;
		offset[3/*Y2*/] = localY2Cos + localXSin;
		offset[4/*X3*/] = localX2Cos - localY2Sin;
		offset[5/*Y3*/] = localY2Cos + localX2Sin;
		offset[6/*X4*/] = localX2Cos - localYSin;
		offset[7/*Y4*/] = localYCos + localX2Sin;
	},
	computeVertices: function (x, y, bone, vertices) {
		x += bone.worldX;
		y += bone.worldY;
		var m00 = bone.m00;
		var m01 = bone.m01;
		var m10 = bone.m10;
		var m11 = bone.m11;
		var offset = this.offset;
		vertices[0/*X1*/] = offset[0/*X1*/] * m00 + offset[1/*Y1*/] * m01 + x;
		vertices[1/*Y1*/] = offset[0/*X1*/] * m10 + offset[1/*Y1*/] * m11 + y;
		vertices[2/*X2*/] = offset[2/*X2*/] * m00 + offset[3/*Y2*/] * m01 + x;
		vertices[3/*Y2*/] = offset[2/*X2*/] * m10 + offset[3/*Y2*/] * m11 + y;
		vertices[4/*X3*/] = offset[4/*X3*/] * m00 + offset[5/*X3*/] * m01 + x;
		vertices[5/*X3*/] = offset[4/*X3*/] * m10 + offset[5/*X3*/] * m11 + y;
		vertices[6/*X4*/] = offset[6/*X4*/] * m00 + offset[7/*Y4*/] * m01 + x;
		vertices[7/*Y4*/] = offset[6/*X4*/] * m10 + offset[7/*Y4*/] * m11 + y;
	}
};

spine.BoundingBoxAttachment = function (name) {
	this.name = name;
	this.vertices = [];
};
spine.BoundingBoxAttachment.prototype = {
	type: spine.AttachmentType.boundingBox,
	computeWorldVertices: function (x, y, bone, worldVertices) {
		x += bone.worldX;
		y += bone.worldY;
		var m00 = bone.m00;
		var m01 = bone.m01;
		var m10 = bone.m10;
		var m11 = bone.m11;
		var vertices = this.vertices;
		for (var i = 0, n = vertices.length; i < n; i += 2) {
			var px = vertices[i];
			var py = vertices[i + 1];
			worldVertices[i] = px * m00 + py * m01 + x;
			worldVertices[i + 1] = px * m10 + py * m11 + y;
		}
	}
};

spine.AnimationStateData = function (skeletonData) {
	this.skeletonData = skeletonData;
	this.animationToMixTime = {};
};
spine.AnimationStateData.prototype = {
	defaultMix: 0,
	setMixByName: function (fromName, toName, duration) {
		var from = this.skeletonData.findAnimation(fromName);
		if (!from) throw "Animation not found: " + fromName;
		var to = this.skeletonData.findAnimation(toName);
		if (!to) throw "Animation not found: " + toName;
		this.setMix(from, to, duration);
	},
	setMix: function (from, to, duration) {
		this.animationToMixTime[from.name + ":" + to.name] = duration;
	},
	getMix: function (from, to) {
		var time = this.animationToMixTime[from.name + ":" + to.name];
		return time ? time : this.defaultMix;
	}
};

spine.TrackEntry = function () {};
spine.TrackEntry.prototype = {
	next: null, previous: null,
	animation: null,
	loop: false,
	delay: 0, time: 0, lastTime: -1, endTime: 0,
	timeScale: 1,
	mixTime: 0, mixDuration: 0,
	onStart: null, onEnd: null, onComplete: null, onEvent: null
}

spine.AnimationState = function (stateData) {
	this.data = stateData;
	this.tracks = [];
	this.events = [];
};
spine.AnimationState.prototype = {
	onStart: null,
	onEnd: null,
	onComplete: null,
	onEvent: null,
	timeScale: 1,
	update: function (delta) {
		delta *= this.timeScale;
		for (var i = 0; i < this.tracks.length; i++) {
			var current = this.tracks[i];
			if (!current) continue;

			var trackDelta = delta * current.timeScale;
			current.time += trackDelta;
			if (current.previous) {
				current.previous.time += trackDelta;
				current.mixTime += trackDelta;
			}

			var next = current.next;
			if (next) {
				if (current.lastTime >= next.delay) this.setCurrent(i, next);
			} else {
				// End non-looping animation when it reaches its end time and there is no next entry.
				if (!current.loop && current.lastTime >= current.endTime) this.clearTrack(i);
			}
		}
	},
	apply: function (skeleton) {
		for (var i = 0; i < this.tracks.length; i++) {
			var current = this.tracks[i];
			if (!current) continue;

			this.events.length = 0;

			var time = current.time;
			var lastTime = current.lastTime;
			var endTime = current.endTime;
			var loop = current.loop;
			if (!loop && time > endTime) time = endTime;

			var previous = current.previous;
			if (!previous)
				current.animation.apply(skeleton, current.lastTime, time, loop, this.events);
			else {
				var previousTime = previous.time;
				if (!previous.loop && previousTime > previous.endTime) previousTime = previous.endTime;
				previous.animation.apply(skeleton, previousTime, previousTime, previous.loop, null);

				var alpha = current.mixTime / current.mixDuration;
				if (alpha >= 1) {
					alpha = 1;
					current.previous = null;
				}
				current.animation.mix(skeleton, current.lastTime, time, loop, this.events, alpha);
			}

			for (var ii = 0, nn = this.events.length; ii < nn; ii++) {
				var event = this.events[ii];
				if (current.onEvent != null) current.onEvent(i, event);
				if (this.onEvent != null) this.onEvent(i, event);
			}

			// Check if completed the animation or a loop iteration.
			if (loop ? (lastTime % endTime > time % endTime) : (lastTime < endTime && time >= endTime)) {
				var count = Math.floor(time / endTime);
				if (current.onComplete) current.onComplete(i, count);
				if (this.onComplete) this.onComplete(i, count);
			}

			current.lastTime = current.time;
		}
	},
	clearTracks: function () {
		for (var i = 0, n = this.tracks.length; i < n; i++)
			this.clearTrack(i);
		this.tracks.length = 0; 
	},
	clearTrack: function (trackIndex) {
		if (trackIndex >= this.tracks.length) return;
		var current = this.tracks[trackIndex];
		if (!current) return;

		if (current.onEnd != null) current.onEnd(trackIndex);
		if (this.onEnd != null) this.onEnd(trackIndex);

		this.tracks[trackIndex] = null;
	},
	_expandToIndex: function (index) {
		if (index < this.tracks.length) return this.tracks[index];
		while (index >= this.tracks.length)
			this.tracks.push(null);
		return null;
	},
	setCurrent: function (index, entry) {
		var current = this._expandToIndex(index);
		if (current) {
			current.previous = null;

			if (current.onEnd != null) current.onEnd(index);
			if (this.onEnd != null) this.onEnd(index);

			entry.mixDuration = this.data.getMix(current.animation, entry.animation);
			if (entry.mixDuration > 0) {
				entry.mixTime = 0;
				entry.previous = current;
			}
		}

		this.tracks[index] = entry;

		if (entry.onStart != null) entry.onStart(index);
		if (this.onStart != null) this.onStart(index);
	},
	setAnimationByName: function (trackIndex, animationName, loop) {
		var animation = this.data.skeletonData.findAnimation(animationName);
		if (!animation) throw "Animation not found: " + animationName;
		return this.setAnimation(trackIndex, animation, loop);
	},
	/** Set the current animation. Any queued animations are cleared. */
	setAnimation: function (trackIndex, animation, loop) {
		var entry = new spine.TrackEntry();
		entry.animation = animation;
		entry.loop = loop;
		entry.endTime = animation.duration;
		this.setCurrent(trackIndex, entry);
		return entry;
	},
	addAnimationByName: function (trackIndex, animationName, loop, delay) {
		var animation = this.data.skeletonData.findAnimation(animationName);
		if (!animation) throw "Animation not found: " + animationName;
		return this.addAnimation(trackIndex, animation, loop, delay);
	},
	/** Adds an animation to be played delay seconds after the current or last queued animation.
	 * @param delay May be <= 0 to use duration of previous animation minus any mix duration plus the negative delay. */
	addAnimation: function (trackIndex, animation, loop, delay) {
		var entry = new spine.TrackEntry();
		entry.animation = animation;
		entry.loop = loop;
		entry.endTime = animation.duration;

		var last = this._expandToIndex(trackIndex);
		if (last) {
			while (last.next)
				last = last.next;
			last.next = entry;
		} else
			this.tracks[trackIndex] = entry;

		if (delay <= 0) {
			if (last)
				delay += last.endTime - this.data.getMix(last.animation, animation);
			else
				delay = 0;
		}
		entry.delay = delay;

		return entry;
	},
	/** May be null. */
	getCurrent: function (trackIndex) {
		if (trackIndex >= this.tracks.length) return null;
		return this.tracks[trackIndex];
	}
};

spine.SkeletonJson = function (attachmentLoader) {
	this.attachmentLoader = attachmentLoader;
};
spine.SkeletonJson.prototype = {
	scale: 1,
	readSkeletonData: function (root) {
		var skeletonData = new spine.SkeletonData();

		// Bones.
		var bones = root["bones"];
		for (var i = 0, n = bones.length; i < n; i++) {
			var boneMap = bones[i];
			var parent = null;
			if (boneMap["parent"]) {
				parent = skeletonData.findBone(boneMap["parent"]);
				if (!parent) throw "Parent bone not found: " + boneMap["parent"];
			}
			var boneData = new spine.BoneData(boneMap["name"], parent);
			boneData.length = (boneMap["length"] || 0) * this.scale;
			boneData.x = (boneMap["x"] || 0) * this.scale;
			boneData.y = (boneMap["y"] || 0) * this.scale;
			boneData.rotation = (boneMap["rotation"] || 0);
			boneData.scaleX = boneMap["scaleX"] || 1;
			boneData.scaleY = boneMap["scaleY"] || 1;
			boneData.inheritScale = boneMap["inheritScale"] || true;
			boneData.inheritRotation = boneMap["inheritRotation"] || true;
			skeletonData.bones.push(boneData);
		}

		// Slots.
		var slots = root["slots"];
		for (var i = 0, n = slots.length; i < n; i++) {
			var slotMap = slots[i];
			var boneData = skeletonData.findBone(slotMap["bone"]);
			if (!boneData) throw "Slot bone not found: " + slotMap["bone"];
			var slotData = new spine.SlotData(slotMap["name"], boneData);

			var color = slotMap["color"];
			if (color) {
				slotData.r = spine.SkeletonJson.toColor(color, 0);
				slotData.g = spine.SkeletonJson.toColor(color, 1);
				slotData.b = spine.SkeletonJson.toColor(color, 2);
				slotData.a = spine.SkeletonJson.toColor(color, 3);
			}

			slotData.attachmentName = slotMap["attachment"];
			slotData.additiveBlending = slotMap["additive"];

			skeletonData.slots.push(slotData);
		}

		// Skins.
		var skins = root["skins"];
		for (var skinName in skins) {
			if (!skins.hasOwnProperty(skinName)) continue;
			var skinMap = skins[skinName];
			var skin = new spine.Skin(skinName);
			for (var slotName in skinMap) {
				if (!skinMap.hasOwnProperty(slotName)) continue;
				var slotIndex = skeletonData.findSlotIndex(slotName);
				var slotEntry = skinMap[slotName];
				for (var attachmentName in slotEntry) {
					if (!slotEntry.hasOwnProperty(attachmentName)) continue;
					var attachment = this.readAttachment(skin, attachmentName, slotEntry[attachmentName]);
					if (attachment != null) skin.addAttachment(slotIndex, attachmentName, attachment);
				}
			}
			skeletonData.skins.push(skin);
			if (skin.name == "default") skeletonData.defaultSkin = skin;
		}

		// Events.
		var events = root["events"];
		for (var eventName in events) {
			if (!events.hasOwnProperty(eventName)) continue;
			var eventMap = events[eventName];
			var eventData = new spine.EventData(eventName);
			eventData.intValue = eventMap["int"] || 0;
			eventData.floatValue = eventMap["float"] || 0;
			eventData.stringValue = eventMap["string"] || null;
			skeletonData.events.push(eventData);
		}

		// Animations.
		var animations = root["animations"];
		for (var animationName in animations) {
			if (!animations.hasOwnProperty(animationName)) continue;
			this.readAnimation(animationName, animations[animationName], skeletonData);
		}

		return skeletonData;
	},
	readAttachment: function (skin, name, map) {
		name = map["name"] || name;

		var type = spine.AttachmentType[map["type"] || "region"];
		var attachment = this.attachmentLoader.newAttachment(skin, type, name);

		if (type == spine.AttachmentType.region) {
			attachment.x = (map["x"] || 0) * this.scale;
			attachment.y = (map["y"] || 0) * this.scale;
			attachment.scaleX = map["scaleX"] || 1;
			attachment.scaleY = map["scaleY"] || 1;
			attachment.rotation = map["rotation"] || 0;
			attachment.width = (map["width"] || 32) * this.scale;
			attachment.height = (map["height"] || 32) * this.scale;
			attachment.updateOffset();
		} else if (type == spine.AttachmentType.boundingBox) {
			var vertices = map["vertices"];
			for (var i = 0, n = vertices.length; i < n; i++)
				attachment.vertices.push(vertices[i] * scale);
		}

		return attachment;
	},
	readAnimation: function (name, map, skeletonData) {
		var timelines = [];
		var duration = 0;

		var bones = map["bones"];
		for (var boneName in bones) {
			if (!bones.hasOwnProperty(boneName)) continue;
			var boneIndex = skeletonData.findBoneIndex(boneName);
			if (boneIndex == -1) throw "Bone not found: " + boneName;
			var boneMap = bones[boneName];

			for (var timelineName in boneMap) {
				if (!boneMap.hasOwnProperty(timelineName)) continue;
				var values = boneMap[timelineName];
				if (timelineName == "rotate") {
					var timeline = new spine.RotateTimeline(values.length);
					timeline.boneIndex = boneIndex;

					var frameIndex = 0;
					for (var i = 0, n = values.length; i < n; i++) {
						var valueMap = values[i];
						timeline.setFrame(frameIndex, valueMap["time"], valueMap["angle"]);
						spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);
						frameIndex++;
					}
					timelines.push(timeline);
					duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]);

				} else if (timelineName == "translate" || timelineName == "scale") {
					var timeline;
					var timelineScale = 1;
					if (timelineName == "scale")
						timeline = new spine.ScaleTimeline(values.length);
					else {
						timeline = new spine.TranslateTimeline(values.length);
						timelineScale = this.scale;
					}
					timeline.boneIndex = boneIndex;

					var frameIndex = 0;
					for (var i = 0, n = values.length; i < n; i++) {
						var valueMap = values[i];
						var x = (valueMap["x"] || 0) * timelineScale;
						var y = (valueMap["y"] || 0) * timelineScale;
						timeline.setFrame(frameIndex, valueMap["time"], x, y);
						spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);
						frameIndex++;
					}
					timelines.push(timeline);
					duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);

				} else
					throw "Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")";
			}
		}

		var slots = map["slots"];
		for (var slotName in slots) {
			if (!slots.hasOwnProperty(slotName)) continue;
			var slotMap = slots[slotName];
			var slotIndex = skeletonData.findSlotIndex(slotName);

			for (var timelineName in slotMap) {
				if (!slotMap.hasOwnProperty(timelineName)) continue;
				var values = slotMap[timelineName];
				if (timelineName == "color") {
					var timeline = new spine.ColorTimeline(values.length);
					timeline.slotIndex = slotIndex;

					var frameIndex = 0;
					for (var i = 0, n = values.length; i < n; i++) {
						var valueMap = values[i];
						var color = valueMap["color"];
						var r = spine.SkeletonJson.toColor(color, 0);
						var g = spine.SkeletonJson.toColor(color, 1);
						var b = spine.SkeletonJson.toColor(color, 2);
						var a = spine.SkeletonJson.toColor(color, 3);
						timeline.setFrame(frameIndex, valueMap["time"], r, g, b, a);
						spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);
						frameIndex++;
					}
					timelines.push(timeline);
					duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);

				} else if (timelineName == "attachment") {
					var timeline = new spine.AttachmentTimeline(values.length);
					timeline.slotIndex = slotIndex;

					var frameIndex = 0;
					for (var i = 0, n = values.length; i < n; i++) {
						var valueMap = values[i];
						timeline.setFrame(frameIndex++, valueMap["time"], valueMap["name"]);
					}
					timelines.push(timeline);
					duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);

				} else
					throw "Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")";
			}
		}

		var events = map["events"];
		if (events) {
			var timeline = new spine.EventTimeline(events.length);
			var frameIndex = 0;
			for (var i = 0, n = events.length; i < n; i++) {
				var eventMap = events[i];
				var eventData = skeletonData.findEvent(eventMap["name"]);
				if (!eventData) throw "Event not found: " + eventMap["name"];
				var event = new spine.Event(eventData);
				event.intValue = eventMap.hasOwnProperty("int") ? eventMap["int"] : eventData.intValue;
				event.floatValue = eventMap.hasOwnProperty("float") ? eventMap["float"] : eventData.floatValue;
				event.stringValue = eventMap.hasOwnProperty("string") ? eventMap["string"] : eventData.stringValue;
				timeline.setFrame(frameIndex++, eventMap["time"], event);
			}
			timelines.push(timeline);
			duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
		}

		var drawOrderValues = map["draworder"];
		if (drawOrderValues) {
			var timeline = new spine.DrawOrderTimeline(drawOrderValues.length);
			var slotCount = skeletonData.slots.length;
			var frameIndex = 0;
			for (var i = 0, n = drawOrderValues.length; i < n; i++) {
				var drawOrderMap = drawOrderValues[i];
				var drawOrder = null;
				if (drawOrderMap["offsets"]) {
					drawOrder = [];
					drawOrder.length = slotCount;
					for (var ii = slotCount - 1; ii >= 0; ii--)
						drawOrder[ii] = -1;
					var offsets = drawOrderMap["offsets"];
					var unchanged = [];
					unchanged.length = slotCount - offsets.length;
					var originalIndex = 0, unchangedIndex = 0;
					for (var ii = 0, nn = offsets.length; ii < nn; ii++) {
						var offsetMap = offsets[ii];
						var slotIndex = skeletonData.findSlotIndex(offsetMap["slot"]);
						if (slotIndex == -1) throw "Slot not found: " + offsetMap["slot"];
						// Collect unchanged items.
						while (originalIndex != slotIndex)
							unchanged[unchangedIndex++] = originalIndex++;
						// Set changed items.
						drawOrder[originalIndex + offsetMap["offset"]] = originalIndex++;
					}
					// Collect remaining unchanged items.
					while (originalIndex < slotCount)
						unchanged[unchangedIndex++] = originalIndex++;
					// Fill in unchanged items.
					for (var ii = slotCount - 1; ii >= 0; ii--)
						if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];
				}
				timeline.setFrame(frameIndex++, drawOrderMap["time"], drawOrder);
			}
			timelines.push(timeline);
			duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
		}

		skeletonData.animations.push(new spine.Animation(name, timelines, duration));
	}
};
spine.SkeletonJson.readCurve = function (timeline, frameIndex, valueMap) {
	var curve = valueMap["curve"];
	if (!curve) return;
	if (curve == "stepped")
		timeline.curves.setStepped(frameIndex);
	else if (curve instanceof Array)
		timeline.curves.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);
};
spine.SkeletonJson.toColor = function (hexString, colorIndex) {
	if (hexString.length != 8) throw "Color hexidecimal length must be 8, recieved: " + hexString;
	return parseInt(hexString.substring(colorIndex * 2, (colorIndex * 2) + 2), 16) / 255;
};

spine.Atlas = function (atlasText, textureLoader) {
	this.textureLoader = textureLoader;
	this.pages = [];
	this.regions = [];

	var reader = new spine.AtlasReader(atlasText);
	var tuple = [];
	tuple.length = 4;
	var page = null;
	while (true) {
		var line = reader.readLine();
		if (line == null) break;
		line = reader.trim(line);
		if (line.length == 0)
			page = null;
		else if (!page) {
			page = new spine.AtlasPage();
			page.name = line;

			page.format = spine.Atlas.Format[reader.readValue()];

			reader.readTuple(tuple);
			page.minFilter = spine.Atlas.TextureFilter[tuple[0]];
			page.magFilter = spine.Atlas.TextureFilter[tuple[1]];

			var direction = reader.readValue();
			page.uWrap = spine.Atlas.TextureWrap.clampToEdge;
			page.vWrap = spine.Atlas.TextureWrap.clampToEdge;
			if (direction == "x")
				page.uWrap = spine.Atlas.TextureWrap.repeat;
			else if (direction == "y")
				page.vWrap = spine.Atlas.TextureWrap.repeat;
			else if (direction == "xy")
				page.uWrap = page.vWrap = spine.Atlas.TextureWrap.repeat;

			textureLoader.load(page, line);

			this.pages.push(page);

		} else {
			var region = new spine.AtlasRegion();
			region.name = line;
			region.page = page;

			region.rotate = reader.readValue() == "true";

			reader.readTuple(tuple);
			var x = parseInt(tuple[0]);
			var y = parseInt(tuple[1]);

			reader.readTuple(tuple);
			var width = parseInt(tuple[0]);
			var height = parseInt(tuple[1]);

			region.u = x / page.width;
			region.v = y / page.height;
			if (region.rotate) {
				region.u2 = (x + height) / page.width;
				region.v2 = (y + width) / page.height;
			} else {
				region.u2 = (x + width) / page.width;
				region.v2 = (y + height) / page.height;
			}
			region.x = x;
			region.y = y;
			region.width = Math.abs(width);
			region.height = Math.abs(height);

			if (reader.readTuple(tuple) == 4) { // split is optional
				region.splits = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];

				if (reader.readTuple(tuple) == 4) { // pad is optional, but only present with splits
					region.pads = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];

					reader.readTuple(tuple);
				}
			}

			region.originalWidth = parseInt(tuple[0]);
			region.originalHeight = parseInt(tuple[1]);

			reader.readTuple(tuple);
			region.offsetX = parseInt(tuple[0]);
			region.offsetY = parseInt(tuple[1]);

			region.index = parseInt(reader.readValue());

			this.regions.push(region);
		}
	}
};
spine.Atlas.prototype = {
	findRegion: function (name) {
		var regions = this.regions;
		for (var i = 0, n = regions.length; i < n; i++)
			if (regions[i].name == name) return regions[i];
		return null;
	},
	dispose: function () {
		var pages = this.pages;
		for (var i = 0, n = pages.length; i < n; i++)
			this.textureLoader.unload(pages[i].rendererObject);
	},
	updateUVs: function (page) {
		var regions = this.regions;
		for (var i = 0, n = regions.length; i < n; i++) {
			var region = regions[i];
			if (region.page != page) continue;
			region.u = region.x / page.width;
			region.v = region.y / page.height;
			if (region.rotate) {
				region.u2 = (region.x + region.height) / page.width;
				region.v2 = (region.y + region.width) / page.height;
			} else {
				region.u2 = (region.x + region.width) / page.width;
				region.v2 = (region.y + region.height) / page.height;
			}
		}
	}
};

spine.Atlas.Format = {
	alpha: 0,
	intensity: 1,
	luminanceAlpha: 2,
	rgb565: 3,
	rgba4444: 4,
	rgb888: 5,
	rgba8888: 6
};

spine.Atlas.TextureFilter = {
	nearest: 0,
	linear: 1,
	mipMap: 2,
	mipMapNearestNearest: 3,
	mipMapLinearNearest: 4,
	mipMapNearestLinear: 5,
	mipMapLinearLinear: 6
};

spine.Atlas.TextureWrap = {
	mirroredRepeat: 0,
	clampToEdge: 1,
	repeat: 2
};

spine.AtlasPage = function () {};
spine.AtlasPage.prototype = {
	name: null,
	format: null,
	minFilter: null,
	magFilter: null,
	uWrap: null,
	vWrap: null,
	rendererObject: null,
	width: 0,
	height: 0
};

spine.AtlasRegion = function () {};
spine.AtlasRegion.prototype = {
	page: null,
	name: null,
	x: 0, y: 0,
	width: 0, height: 0,
	u: 0, v: 0, u2: 0, v2: 0,
	offsetX: 0, offsetY: 0,
	originalWidth: 0, originalHeight: 0,
	index: 0,
	rotate: false,
	splits: null,
	pads: null
};

spine.AtlasReader = function (text) {
	this.lines = text.split(/\r\n|\r|\n/);
};
spine.AtlasReader.prototype = {
	index: 0,
	trim: function (value) {
		return value.replace(/^\s+|\s+$/g, "");
	},
	readLine: function () {
		if (this.index >= this.lines.length) return null;
		return this.lines[this.index++];
	},
	readValue: function () {
		var line = this.readLine();
		var colon = line.indexOf(":");
		if (colon == -1) throw "Invalid line: " + line;
		return this.trim(line.substring(colon + 1));
	},
	/** Returns the number of tuple values read (2 or 4). */
	readTuple: function (tuple) {
		var line = this.readLine();
		var colon = line.indexOf(":");
		if (colon == -1) throw "Invalid line: " + line;
		var i = 0, lastMatch= colon + 1;
		for (; i < 3; i++) {
			var comma = line.indexOf(",", lastMatch);
			if (comma == -1) {
				if (i == 0) throw "Invalid line: " + line;
				break;
			}
			tuple[i] = this.trim(line.substr(lastMatch, comma - lastMatch));
			lastMatch = comma + 1;
		}
		tuple[i] = this.trim(line.substring(lastMatch));
		return i + 1;
	}
};

spine.AtlasAttachmentLoader = function (atlas) {
	this.atlas = atlas;
};
spine.AtlasAttachmentLoader.prototype = {
	newAttachment: function (skin, type, name) {
		switch (type) {
		case spine.AttachmentType.boundingbox:
			return new spine.BoundingBoxAttachment(name);
		case spine.AttachmentType.region:
			var region = this.atlas.findRegion(name);
			if (!region) throw "Region not found in atlas: " + name + " (" + type + ")";
			var attachment = new spine.RegionAttachment(name);
			attachment.rendererObject = region;
			attachment.setUVs(region.u, region.v, region.u2, region.v2, region.rotate);
			attachment.regionOffsetX = region.offsetX;
			attachment.regionOffsetY = region.offsetY;
			attachment.regionWidth = region.width;
			attachment.regionHeight = region.height;
			attachment.regionOriginalWidth = region.originalWidth;
			attachment.regionOriginalHeight = region.originalHeight;
			return attachment;
		}
		throw "Unknown attachment type: " + type;
	}
};

spine.SkeletonBounds = function () {
	this.polygonPool = [];
	this.polygons = [];
	this.boundingBoxes = [];
};
spine.SkeletonBounds.prototype = {
	minX: 0, minY: 0, maxX: 0, maxY: 0,
	update: function (skeleton, updateAabb) {
		var slots = skeleton.slots;
		var slotCount = slots.length;
		var x = skeleton.x, y = skeleton.y;
		var boundingBoxes = this.boundingBoxes;
		var polygonPool = this.polygonPool;
		var polygons = this.polygons;

		boundingBoxes.length = 0;
		for (var i = 0, n = polygons.length; i < n; i++)
			polygonPool.push(polygons[i]);
		polygons.length = 0;

		for (var i = 0; i < slotCount; i++) {
			var slot = slots[i];
			var boundingBox = slot.attachment;
			if (boundingBox.type != spine.AttachmentType.boundingBox) continue;
			boundingBoxes.push(boundingBox);

			var poolCount = polygonPool.length;
			if (poolCount > 0) {
				polygon = polygonPool[poolCount - 1];
				polygonPool.splice(poolCount - 1, 1);
			} else
				polygon = [];
			polygons.push(polygon);

			polygon.length = boundingBox.vertices.length;
			boundingBox.computeWorldVertices(x, y, slot.bone, polygon);
		}

		if (updateAabb) this.aabbCompute();
	},
	aabbCompute: function () {
		var polygons = this.polygons;
		var minX = Number.MAX_VALUE, minY = Number.MAX_VALUE, maxX = Number.MIN_VALUE, maxY = Number.MIN_VALUE;
		for (var i = 0, n = polygons.length; i < n; i++) {
			var vertices = polygons[i];
			for (var ii = 0, nn = vertices.length; ii < nn; ii += 2) {
				var x = vertices[ii];
				var y = vertices[ii + 1];
				minX = Math.min(minX, x);
				minY = Math.min(minY, y);
				maxX = Math.max(maxX, x);
				maxY = Math.max(maxY, y);
			}
		}
		this.minX = minX;
		this.minY = minY;
		this.maxX = maxX;
		this.maxY = maxY;
	},
	/** Returns true if the axis aligned bounding box contains the point. */
	aabbContainsPoint: function (x, y) {
		return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;
	},
	/** Returns true if the axis aligned bounding box intersects the line segment. */
	aabbIntersectsSegment: function (x1, y1, x2, y2) {
		var minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;
		if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))
			return false;
		var m = (y2 - y1) / (x2 - x1);
		var y = m * (minX - x1) + y1;
		if (y > minY && y < maxY) return true;
		y = m * (maxX - x1) + y1;
		if (y > minY && y < maxY) return true;
		var x = (minY - y1) / m + x1;
		if (x > minX && x < maxX) return true;
		x = (maxY - y1) / m + x1;
		if (x > minX && x < maxX) return true;
		return false;
	},
	/** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */
	aabbIntersectsSkeleton: function (bounds) {
		return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;
	},
	/** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more
	 * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. */
	containsPoint: function (x, y) {
		var polygons = this.polygons;
		for (var i = 0, n = polygons.length; i < n; i++)
			if (this.polygonContainsPoint(polygons[i], x, y)) return this.boundingBoxes[i];
		return null;
	},
	/** Returns the first bounding box attachment that contains the line segment, or null. When doing many checks, it is usually
	 * more efficient to only call this method if {@link #aabbIntersectsSegment(float, float, float, float)} returns true. */
	intersectsSegment: function (x1, y1, x2, y2) {
		var polygons = this.polygons;
		for (var i = 0, n = polygons.length; i < n; i++)
			if (polygons[i].intersectsSegment(x1, y1, x2, y2)) return boundingBoxes[i];
		return null;
	},
	/** Returns true if the polygon contains the point. */
	polygonContainsPoint: function (polygon, x, y) {
		var nn = polygon.length;
		var prevIndex = nn - 2;
		var inside = false;
		for (var ii = 0; ii < nn; ii += 2) {
			var vertexY = polygon[ii + 1];
			var prevY = polygon[prevIndex + 1];
			if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {
				var vertexX = polygon[ii];
				if (vertexX + (y - vertexY) / (prevY - vertexY) * (polygon[prevIndex] - vertexX) < x) inside = !inside;
			}
			prevIndex = ii;
		}
		return inside;
	},
	/** Returns true if the polygon contains the line segment. */
	intersectsSegment: function (polygon, x1, y1, x2, y2) {
		var nn = polygon.length;
		var width12 = x1 - x2, height12 = y1 - y2;
		var det1 = x1 * y2 - y1 * x2;
		var x3 = polygon[nn - 2], y3 = polygon[nn - 1];
		for (var ii = 0; ii < nn; ii += 2) {
			var x4 = polygon[ii], y4 = polygon[ii + 1];
			var det2 = x3 * y4 - y3 * x4;
			var width34 = x3 - x4, height34 = y3 - y4;
			var det3 = width12 * height34 - height12 * width34;
			var x = (det1 * width34 - width12 * det2) / det3;
			if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {
				var y = (det1 * height34 - height12 * det2) / det3;
				if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;
			}
			x3 = x4;
			y3 = y4;
		}
		return false;
	},
	getPolygon: function (attachment) {
		var index = this.boundingBoxes.indexOf(attachment);
		return index == -1 ? null : this.polygons[index];
	},
	getWidth: function () {
		return this.maxX - this.minX;
	},
	getHeight: function () {
		return this.maxY - this.minY;
	}
};
/**
 * @description
 *
 * CG is the base class of the cangaja framework.
 * This file includes a requestAnimationFrame polyfill. It uses the simple javascript inheritance from John Resig.
 @example
 //Class example, how to start from scratch with simple inheritance
 CG.Class.extend("Entity",{
        init: function(){
            this.myprop = 'set from constructor'
        }
     });

 CG.Entity.extend("Point",{
        init: function(x, y){
            this._super()
            this.x = x
            this.y = y
        }
     });

 CG.Point.extend("Rectangle",{
        init: function(x, y, w, h){
            this._super(x, y)
            this.w = w
            this.h = h
        },
        move: function(){

        }
     });
 * @module CG
 * @main CG
 */
var CG = CG || {
    VERSION: 1,

    //canvas if needed, remember director mode slide!
    canvas: {},
    ctx: {},

    //constants
    Const_PI_180: Math.PI / 180,
    Const_180_PI: 180 / Math.PI,
    LEFT: 1,
    RIGHT: 2,
    UP: 3,
    DOWN: 4,

    //input related
    mousedown: false,
    mouse: {x: 0, y: 0},
    //touch start
    start: {x: 0, y: 0},
    //touch end
    end: {x: 0, y: 0}
};


// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

// requestAnimationFrame polyfill by Erik M??ller
// fixes from Paul Irish and Tino Zijdel

(function () {
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame']
            || window[vendors[x] + 'CancelRequestAnimationFrame'];
    }

    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function (callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function () {
                    callback(currTime + timeToCall);
                },
                timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };

    if (!window.cancelAnimationFrame)
        window.cancelAnimationFrame = function (id) {
            clearTimeout(id);
        };
}());


/* Simple JavaScript Inheritance
 * By John Resig http://ejohn.org/
 * MIT Licensed.
 *
 * Inspired by base2 and Prototype
 */
(function () {
    var initializing = false,
        fnTest = /xyz/.test(function () {
            var xyz;
        }) ? /\b_super\b/ : /.*/;
    /* The base Class implementation (does nothing) */
    CG.Class = function () {
    };

    // See if a object is a specific class
    CG.Class.prototype.isA = function (className) {
        return this.className === className;
    };

    /* Create a new Class that inherits from this class */
    CG.Class.extend = function (className, prop, classMethods) {
        /* No name, don't add onto Q */
        if (!typeof className === "string") {
            classMethods = prop;
            prop = className;
            className = null;
        }
        var _super = this.prototype,
            ThisClass = this;

        /* Instantiate a base class (but only create the instance, */
        /* don't run the init constructor) */
        initializing = true;
        var prototype = new ThisClass();
        initializing = false;

        function _superFactory(name, fn) {
            return function () {
                var tmp = this._super;

                /* Add a new ._super() method that is the same method */
                /* but on the super-class */
                this._super = _super[name];

                /* The method only need to be bound temporarily, so we */
                /* remove it when we're done executing */
                var ret = fn.apply(this, arguments);
                this._super = tmp;

                return ret;
            };
        }

        /* Copy the properties over onto the new prototype */
        for (var name in prop) {
            /* Check if we're overwriting an existing function */
            prototype[name] = typeof prop[name] === "function" &&
                typeof _super[name] === "function" &&
                fnTest.test(prop[name]) ?
                _superFactory(name, prop[name]) :
                prop[name];
        }

        /* The dummy class constructor */
        function Class() {
            /* All construction is actually done in the init method */
            if (!initializing && this.init) {
                this.init.apply(this, arguments);
            }
        }

        /* Populate our constructed prototype object */
        Class.prototype = prototype;

        /* Enforce the constructor to be what we expect */
        Class.prototype.constructor = Class;
        /* And make this class extendable */
        Class.extend = CG.Class.extend;

        /* If there are class-level Methods, add them to the class */
        if (classMethods) {
            CG._extend(Class, classMethods);
        }

        if (className) {
            /* Save the class onto Q */
            CG[className] = Class;

            /* Let the class know its name */
            Class.prototype.className = className;
            Class.className = className;
        }

        return Class;
    };
}())


/**
 * Created with JetBrains WebStorm.
 * User: Apple
 * Date: 23.07.13
 * Time: 22:43
 * To change this template use File | Settings | File Templates.
 */
var Clock = function (targetfps) {

    this.targetfps = targetfps || 60

    /** Member startTime will remain fixed at its integer
     millisecond value returned by Date.now(). Will always
     be equal to the time the clock was started */
    this.startTime = Date.now();

    /** Member ms is updated by tick() to a integer value reprsenting
     the number of milliseconds between the epoch (January 1, 1970)
     and the current date and time of the system. */
    this.ms = this.startTime;
    this.last = this.startTime;  /** millis at last call to tick() */
    this.time = 0;               /** ms in floating point seconds not millis */

    /** Member dt is updated by tick() to an integer value representing
     the number of milliseconds since the last call to tick(). */
    this.dt = 0;
    this.delta = 0; /** dt in floating point seconds not millis */

    /** Member fps is updated by tick() to a floating point value representing
     frames per second, updated and averaged approximately once per second */
    this.fps = 0.0;

    /** Member frameCount is updated to an integer value representing the
     total number of calls to tick() since the clock was created. */
    this.frameCount = 0;

    /** The frameCounter member is a flag you can turn off if you don't need to
     calculate the frameCount or do the average FPS calculation every second */
    this.frameCounter = true;

    /** Private globals needed to calculcate/average fps over eachs second */
    var timeToUpdate = 0;
    var framesToUpdate = 0;

    /************************************************************************************
     The tick() method updates ALL the Clock members, which should only
     be read from and never written to manually. It is recommended that
     tick() is called from a callback loop using requestAnimationFrame

     Learn more: http://paulirish.com/2011/requestanimationframe-for-smart-animating/
     *************************************************************************************/
    this.tick = function () {
        /** This is a new frame with it's very own unique number */

        if (this.frameCounter) this.frameCount++;

        /** Set the private currentTime variable */
        this.ms = Date.now();

        /** Update time delta and immediately set last time to
         be as accurate as possible in our timings. */
        this.dt = this.ms - this.last;
        this.last = this.ms;

        /** Calculate floating-point delta and increment time member */
//        this.delta = 0.001 * this.dt;
//        this.time += this.delta;
        this.delta = this.dt / (1000 / this.targetfps);
        this.time += 0.001 * this.dt;

        /** Calculate private temp variables for fps calculation */
        if (this.frameCounter) {
            timeToUpdate += this.dt;
            framesToUpdate++;
            if (timeToUpdate > 1000) {
                this.fps = Math.round((framesToUpdate * 1000) / timeToUpdate);
                framesToUpdate = 0;
                timeToUpdate = 0;
            }
        }
    }
}/**
 * string functions
 **/

function loadString(path) {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", path, false);
    xhr.send(null);
    if ((xhr.status == 200) || (xhr.status == 0)) return xhr.responseText;
    return "";
}

String.prototype.ltrim = function (clist) {
    if (clist) return this.replace(new RegExp('^[' + clist + ']+'), '')
    return this.replace(/^\s+/, '')
}
String.prototype.rtrim = function (clist) {
    if (clist) return this.replace(new RegExp('[' + clist + ']+$'), '')
    return this.replace(/\s+$/, '')
}
String.prototype.trim = function (clist) {
    if (clist) return this.ltrim(clist).rtrim(clist);
    return this.ltrim().rtrim();
}
String.prototype.startsWith = function (str) {
    return !this.indexOf(str);
}/**
 * @description
 *
 * A CanvasRenderer with WebGL and Canvas 2D fallback would be really nice ;o)
 * How to implement all the different classes....?
 *
 *
 * @class CG.CanvasRenderer
 * @extend CG.Class
 */


CG.Class.extend('CanvasRenderer', {
    /**
     * @method init
     * @constructor
     * @return {*}
     */
    init:function(canvas){

        //TODO the renderer recognizes the canvas features WebGL/Canvas

        //TODO the renderer creates the canvas element

        //TODO the renderer handles all drawings from all classes, urgh ;o)

        /*

         //sprite draw method

         draw:function () {
             this.updateDiff()

             Game.b_ctx.save()
             Game.b_ctx.globalAlpha = this.alpha
             Game.b_ctx.translate(this.position.x, this.position.y)
             if (this.atlasimage) {
                 Game.b_ctx.rotate((this.rotation - this.imagerotation) * CG.Const_PI_180)
                 Game.b_ctx.drawImage(this.image, this.xoffset, this.yoffset, this.cutwidth, this.cutheight, 0 - this.xhandle, 0 - this.yhandle, this.cutwidth * this.xscale, this.cutheight * this.yscale)
             } else {
                 Game.b_ctx.rotate(this.rotation * CG.Const_PI_180)
                 Game.b_ctx.drawImage(this.image, 0 - this.xhandle, 0 - this.yhandle, this.image.width * this.xscale, this.image.height * this.yscale)
             }
             Game.b_ctx.restore()
         },




        //animation draw method
         draw:function () {
             this.updateDiff()

             Game.b_ctx.save()
             Game.b_ctx.globalAlpha = this.alpha
             Game.b_ctx.translate(this.position.x, this.position.y)
             if (this.frames == 1) {
                 Game.b_ctx.drawImage(this.image, this.position.x, this.position.y, this.image.width * this.xscale, this.image.height * this.yscale)
             }
             else {
                 this.fx = this.currentframe * this.width

                 if ((this.fx / this.image.width) > 0) {
                 this.fx = this.fx % this.image.width
                 }
                 this.fy = Math.floor(this.width * this.currentframe / this.image.width) * this.height

                 Game.b_ctx.rotate(this.rotation * CG.Const_PI_180)
                 try {
                 Game.b_ctx.drawImage(this.image, this.fx, this.fy, this.width, this.height, 0 - this.xhandle, 0 - this.yhandle, this.width * this.xscale, this.height * this.yscale)
                 } catch (e) {

                 }
             }
             Game.b_ctx.restore()
         }



         //button draw method
         draw:function () {
             Game.b_ctx.save()
             Game.b_ctx.translate(this.position.x, this.position.y)
             if (this.atlasimage) {
                 var r = this.rotation
                 Game.b_ctx.rotate((r - this.imagerotation) * CG.Const_PI_180)
                 Game.b_ctx.drawImage(this.image, this.xoffset, this.yoffset, this.cutwidth, this.cutheight, 0 - (this.cutwidth / 2), 0 - (this.cutheight / 2), this.cutwidth * this.xscale, this.cutheight * this.yscale)
                 Game.b_ctx.rotate(this.imagerotation * CG.Const_PI_180)
             } else {
                 Game.b_ctx.rotate(r * CG.Const_PI_180)
                 Game.b_ctx.drawImage(this.image, 0 - (this.image.width * this.xscale / 2), 0 - (this.image.height * this.yscale / 2), this.image.width * this.xscale, this.image.height * this.yscale)
             }
             this.font.draw(this.text, 0 - (this.font.getTextWidth(this.text) / 2 >> 0), 0 - ((this.font.getFontSize() / 2) >> 0))
             Game.b_ctx.restore()
         }


        //particle draw method
         draw:function () {
             if (this.visible) {
                 Game.b_ctx.save()
                 Game.b_ctx.globalAlpha = this.alpha
                 Game.b_ctx.translate(this.position.x, this.position.y)
                 if (this.atlasimage) {
                     Game.b_ctx.rotate((this.rotation - this.imagerotation) * CG.Const_PI_180)
                     Game.b_ctx.drawImage(this.image, this.xoffset, this.yoffset, this.cutwidth, this.cutheight, 0 - (this.cutwidth / 2), 0 - (this.cutheight / 2), this.cutwidth * this.xscale, this.cutheight * this.yscale)
                     Game.b_ctx.rotate((this.rotation + this.imagerotation) * CG.Const_PI_180)
                 } else {
                     Game.b_ctx.rotate(this.rotation * CG.Const_PI_180)
                     Game.b_ctx.drawImage(this.image, 0 - (this.image.width * this.xscale / 2), 0 - (this.image.height * this.yscale / 2), this.image.width * this.xscale, this.image.height * this.yscale)
                 }
                 Game.b_ctx.restore()
             }
         }



         //map drawmap part orthogonal
         Game.b_ctx.save()
         Game.b_ctx.globalAlpha = this.layers[layer].opacity
         Game.b_ctx.translate(rx, ry)
         try {
            Game.b_ctx.drawImage(this.atlas, cx, cy, this.tilewidth, this.tileheight, this.sx, this.sy, this.tilewidth * this.xscale, this.tileheight * this.yscale)
         } catch (e) {
         }
         Game.b_ctx.restore()


         //map drawmap part isometric
         Game.b_ctx.save()
         Game.b_ctx.globalAlpha = this.layers[layer].opacity
         Game.b_ctx.translate(xpos, ypos)
         try {
            Game.b_ctx.drawImage(this.atlas, cx, cy, this.tilewidth, this.tileset.tileheight, 0, 0, this.tilewidth * this.xscale, this.tileset.tileheight * this.yscale)
         } catch (e) {

         }
         Game.b_ctx.restore()



        //font class part draw
         for (var i = 0, l = text.length; i < l; i++) {
             Game.b_ctx.drawImage(this.atlas, this.x[text.charCodeAt(i)], this.y[text.charCodeAt(i)], this.width[text.charCodeAt(i)], this.height[text.charCodeAt(i)], currx, curry + this.yoff[text.charCodeAt(i)], this.width[text.charCodeAt(i)], this.height[text.charCodeAt(i)])
             currx += this.xadv[text.charCodeAt(i)]
         }


         //bitmap class
         draw:function () {
             Game.b_ctx.drawImage(this.bitmap_canvas, this.x, this.y)
         },











         */
        return this
    }
})/**
 * @description
 *
 * CG.Delta not really used at the moment ;o)
 *
 * @class CG.Delta
 * @extends Class
 *
 */


CG.Class.extend('Delta', {
    /**
     * @method init
     * @constructor
     * @param fps {Number}
     */
    init: function (fps) {
        /**
         * @property targetfps
         * @type {Number}
         */
        this.targetfps = fps
        /**
         * @property currenttime
         * @type {Number}
         */
        this.currenttime = 0
        /**
         * @property lasttime
         * @type {Number}
         */
        this.lasttime = new Date().getTime()
        /**
         * @property elapsedtime
         * @type {Number}
         */
        this.elapsedtime = 0
        /**
         * @property frametime
         * @type {Number}
         */
        this.frametime = 0
        /**
         * @property delta
         * @type {Number}
         */
        this.delta = 0
        /**
         * @property fps
         * @type {Number}
         */
        this.fps = 0
    },

    update: function () {
        this.currenttime = new Date().getTime()
        var delta = (this.currenttime - this.lasttime) / 1000
        this.fps = 1 / delta
        this.lasttime = this.currenttime
    },
    getDelta: function () {
        return this.delta
    },
    getFPS: function () {
        return this.fps
    }
})


/**
 *  ¬© 2012 by Christian Sonntag <info@motions-media.de>
 *  simple experimental Canvas Game JavaScript Framework
 */


/**
 * @description
 *
 * CG.Entity the base class of Cangaja
 *
 * @class CG.Entity
 * @extends CG.Class
 */

CG.Class.extend('Entity', {
    /**
     * @constructor
     * @method init
     * @param name {string} the name of the Entity
     */
    init:function (name) {
        /**
         @property name {string}
         */
        this.name = name || ''
        /**
         @property visible {boolean}
         */
        this.visible = true
    },
    update:function () {
        throw {
            name:'Entity Error',
            message:'Subclass has no update method.'
        }
    },
    draw:function () {
        throw {
            name:'Entity Error',
            message:'Subclass has no draw method.'
        }
    },
    /**
     * @description initialize image for object. for now => sprite, particle, buffer, bitmap and button use it
     * @method setImage
     * @param {image} image image path, image or atlasimage
     */
    setImage:function (image) {
        this.atlasimage = false
        if (image) {
            if (image instanceof CG.AtlasImage) {
                //AtlasImage from MediaAsset
                this.image = Game.asset.getImageByName(image.atlasname)
                this.imagerotation = image.rotation //|| 0
                this.xoffset = image.xoffset
                this.yoffset = image.yoffset
                this.width = image.width
                this.height = image.height
                this.atlasimage = true
                if (this.imagerotation !== 0) {
                    this.cutwidth = image.height
                    this.cutheight = image.width
                } else {
                    this.cutwidth = image.width
                    this.cutheight = image.height
                }
            } else if (typeof image == 'string' && image != '') {
                //path to image
                this.image = new Image()
                this.image.src = image
                this.width = this.image.width
                this.height = this.image.height
            } else {
                //image from MediaAsset
                this.image = image
                this.width = this.image.width
                this.height = this.image.height
            }
        }
    }
})


/**
 * @description
 *
 * CG.Point
 *
 * @class CG.Point
 * @extends CG.Entity
 */
CG.Entity.extend('Point', {
    /**
     * @constructor
     * @method init
     * @param x {Number} the x value of the point
     * @param y {Number} the y value of the point
     */
    init:function (x, y) {
        /**
         @property x {Number}
         */
        this.x = x || 0
        /**
         @property y {Number}
         */
        this.y = y || 0
    }
})


/**
 * @description
 *
 * CG.Vector
 *
 * @class CG.Vector
 * @extends CG.Point
 */
CG.Point.extend('Vector', {
    /**
     * @constructor
     * @method init
     * @param x {Number} the x position
     * @param y {Number} the y position
     * @param z {Number} the z position
     */
    init:function (x, y, z) {
        this._super(this, x, y)
        /**
         @property z {Number}
         */
        this.z = z || 0
    }
})



/**
 * @description
 *
 * CG.Rectangle for click and mouseover handling, collision detection and AABB function
 *
 * @class CG.Rectangle
 * @extends CG.Entity
 *
 */
CG.Entity.extend('Rectangle', {
    /**
     * @constructor
     * @method init
     * @param position {CG.Point} position point
     * @param width {Number} width the width of rectangle
     * @param height {Number} height the height of rectangle
     * @return {*}
     */
    init:function (position, width, height) {
        /**
         @property position {CG.Point}
         */
        this.position = position || new CG.Point(0, 0)
        /**
         @property width {Number}
         */
        this.width = width || 0
        /**
         @property height {Number}
         */
        this.height = height || 0
        /**
         @property clickable {boolean}
         */
        this.clickable = false
        /**
         @property dragable {boolean}
         */
        this.dragable = false
        /**
         @property rotation {Number}
         */
        this.rotation = 0
        /**
         @property xscale {Number}
         */
        this.xscale = 1
        /**
         @property yscale {Number}
         */
        this.yscale = 1
        /**
         @property clicked {boolean}
         */
        this.clicked = false
        /**
         @property hover {boolean}
         */
        this.hover = false

        /**
         @property boundingradius {Number}
         */
        this.boundingradius = 0     //radius for circular collision bounds
        /**
         @property mapcollision {boolean}
         */
        this.mapcollision = false

        return this
    },
    /**
     * @description returns the bounds of rotated rectangle
     * @method AABB
     * @return {object} returns the calculated bounds
     */
    AABB:function () {
        //http://willperone.net/Code/coderr.php
        a = this.rotation * CG.Const_PI_180
        s = Math.sin(a);
        c = Math.cos(a);
        if (s < 0) s = -s;
        if (c < 0) c = -c;
        return {
            bw:this.height * this.xscale * s + this.width * this.yscale * c,
            bh:this.height * this.xscale * c + this.width * this.yscale * s
        }
    },
    /**
     * @description checks click inside of the rectangle, supports rotation
     * @method ifClicked
     * @return {true/false}
     */
    ifClicked:function () {
        if (CG.mousedown && this.clickable) {
            var dx = CG.mouse.x - this.position.x,
                dy = CG.mouse.y - this.position.y
            var h1 = Math.sqrt(dx * dx + dy * dy)
            var currA = Math.atan2(dy, dx)
            var newA = currA - (this.rotation * CG.Const_PI_180);
            var x2 = Math.cos(newA) * h1
            var y2 = Math.sin(newA) * h1
            if (x2 > -0.5 * (this.width * this.xscale) &&
                x2 < 0.5 * (this.width * this.xscale) &&
                y2 > -0.5 * (this.height * this.yscale) &&
                y2 < 0.5 * (this.height * this.yscale)) {
                this.clicked = true
                CG.mousedown = false
            }
        }
        return false
    },
    /**
     * @description checks if the mouse/pointer is over the rectangle
     * @method ifMouseOver
     */
    ifMouseOver:function () {
        var dx = CG.mouse.x - this.position.x,
            dy = CG.mouse.y - this.position.y
        var h1 = Math.sqrt(dx * dx + dy * dy)
        var currA = Math.atan2(dy, dx)
        var newA = currA - (this.rotation * CG.Const_PI_180)
        var x2 = Math.cos(newA) * h1
        var y2 = Math.sin(newA) * h1
        if (x2 > -0.5 * (this.width * this.xscale) &&
            x2 < 0.5 * (this.width * this.xscale) &&
            y2 > -0.5 * (this.height * this.yscale) &&
            y2 < 0.5 * (this.height * this.yscale)) {
            this.hover = true
        } else {
            this.hover = false
        }
    },
    /**
     * @description checks if there is a collision of the given objects to this object http://devmag.org.za/2009/04/13/basic-collision-detection-in-2d-part-1/
     * @method checkCollision
     * @param objects {array} a array of objects to check for collision => Sprites, Animations, MapAreas
     * @param callback {callback} what to do after collision?
     */
    checkCollision:function (objects, callback) {
        objects.forEach(function (obj, index) {
                if (obj.className == 'MapArea') {
                    if ((this.position.y + this.AABB().bh / 2) >= obj.bound.y &&
                        this.position.y - this.AABB().bh / 2 <= (obj.bound.y + obj.bound.height) &&
                        (this.position.x + this.AABB().bw / 2) >= obj.bound.x &&
                        this.position.x - this.AABB().bw / 2 <= (obj.bound.x + obj.bound.width )) {
                        if (obj.type === 'outer') {

                            w = 0.5 * (this.width + obj.bound.width)
                            h = 0.5 * (this.height + obj.bound.height)
                            dx = this.position.x - (obj.bound.width / 2 + obj.bound.x)
                            dy = this.position.y - (obj.bound.height / 2 + obj.bound.y)

                            if (Math.abs(dx) <= w && Math.abs(dy) <= h) {
                                /* collision! */
                                wy = w * dy;
                                hx = h * dx;

                                if (wy > hx) {
                                    if (wy > -hx) {
                                        direction = 'bottom'
                                        overlap = ((this.position.y - this.AABB().bh / 2) - (obj.bound.y + obj.bound.height)) >> 0
                                    } else {
                                        direction = 'CG.LEFT'
                                        overlap = ((this.position.x + this.AABB().bw / 2) - obj.bound.x) >> 0
                                    }
                                } else {
                                    if (wy > -hx) {
                                        direction = 'right'
                                        overlap = ((this.position.x - this.AABB().bw / 2) - (obj.bound.x + obj.bound.width)) >> 0
                                    } else {
                                        direction = 'top'
                                        overlap = ((this.position.y + this.AABB().bh / 2) - obj.bound.y) >> 0
                                    }
                                }
                            }

                            collision = {
                                overlap:overlap,
                                direction:direction
                            }
                            //callback arguments: this => the sprite, obj => the maparea if needed, collision => {collison direction, offset}
                            callback(this, obj, collision)
                        }
                    }
                }
                else if (this.boundingradius > 0 && obj.boundingradius > 0) {
                    //check boundingradius for circuar collision
                    distx = this.position.x - obj.position.x
                    disty = this.position.y - obj.position.y
                    dist = Math.sqrt((distx * distx) + (disty * disty))
                    if (dist <= (this.boundingradius / 2 * this.xscale + obj.boundingradius / 2 * obj.yscale)) {
                        collision = false //dummy
                        callback(this, obj, collision)
                    }
                }
                else {
                    //if boundingradius is 0, fallback to bounding collision
                    if ((this.position.y + this.AABB().bh / 2) >= obj.position.y - obj.AABB().bh / 2 &&
                        this.position.y - this.AABB().bh / 2 <= (obj.position.y + obj.AABB().bh / 2) &&
                        (this.position.x + this.AABB().bw / 2) >= obj.position.x - obj.AABB().bw / 2 &&
                        this.position.x - this.AABB().bw / 2 <= (obj.position.x + obj.AABB().bw / 2)) {

                        w = 0.5 * (this.width + obj.width)
                        h = 0.5 * (this.height + obj.height)
                        dx = this.position.x - obj.position.x
                        dy = this.position.y - obj.position.y

                        if (Math.abs(dx) <= w && Math.abs(dy) <= h) {
                            /* collision! */
                            wy = w * dy;
                            hx = h * dx;

                            if (wy > hx) {
                                if (wy > -hx) {
                                    direction = 'bottom'
                                    overlap = ((this.position.y - this.AABB().bh / 2) - (obj.position.y - obj.AABB().bh / 2)) >> 0
                                } else {
                                    direction = 'CG.LEFT'
                                    overlap = ((this.position.x + this.AABB().bw / 2) - (obj.position.x + obj.AABB().bw / 2)) >> 0
                                }
                            } else {
                                if (wy > -hx) {
                                    direction = 'right'
                                    overlap = ((this.position.x - this.AABB().bw / 2) - (obj.position.x - obj.AABB().bw / 2)) >> 0
                                } else {
                                    direction = 'top'
                                    overlap = ((this.position.y + this.AABB().bh / 2) - (obj.position.y + obj.AABB().bh / 2)) >> 0
                                }
                            }
                        }

                        collision = {
                            overlap:overlap,
                            direction:direction
                        }

                        callback(this, obj, collision)
                    }
                }
            },
            this
        )
        return this
    }

})


/**
 * @description
 *
 * CG.Bound is used at different places in the Cangaja FW.
 *
 * @class CG.Bound
 * @extends CG.Entity
 *
 */
CG.Entity.extend('Bound', {
    /**
     * @constructor
     * @method init
     * @param x {number} x the x position
     * @param y {number} y the y position
     * @param width {number} width the width of bound
     * @param height {number} height the height of bound
     * @return {*}
     */
    init:function (x, y, width, height) {
        this._super()
        /**
         * @property x
         * @type {Number}
         */
        this.x = x
        /**
         * @property y
         * @type {Number}
         */
        this.y = y
        /**
         * @property width
         * @type {Number}
         */
        this.width = width
        /**
         * @property height
         * @type {Number}
         */
        this.height = height
        return this
    },

    /**
     * @method setName
     * @param {string} name of the bounding box
     * @return {*}
     */
    setName:function (name) {
        this.name = name
        return this
    }
})


/**
 * @description
 *
 * CG.Buffer for separate canvas rendering/buffering
 *
 * @class CG.Buffer
 * @extends CG.Entity
 *
 */
CG.Entity.extend('Buffer', {
    /**
     * @constructor
     * @method init
     * @param width {Number} width of the buffer
     * @param height {Number} height of the buffer
     * @param buffername {string} buffername
     * @return {*}
     */
    init:function (width, height, buffername) {
        this._super(buffername)
        /**
         * @property b_canvas
         * @type {HTMLElement}
         */
        this.b_canvas = document.createElement('canvas')
//    if(typeof(ejecta) !== 'undefined'){
//        this.b_canvas.width = w
//        this.b_canvas.height = h
//    }else{

        /**
         * @property b_canvas.width
         * @type {*}
         */
        this.b_canvas.width = width
        /**
         * @property b_canvas.height
         * @type {*}
         */
        this.b_canvas.height = height
//    }

        /**
         * @property b_ctx
         * @type {CanvasRenderingContext2D}
         */
        this.b_ctx = this.b_canvas.getContext('2d')
        return this
    }
})


/**
 * @description
 *
 * CG.Sprite
 *
 * @class CG.Sprite
 * @extends CG.Rectangle
 */
CG.Rectangle.extend('Sprite', {
    /**
     * @method init
     * @constructor
     * @param image {image}  imgpath, image object or atlasimage object to use
     * @param position {CG.Point}  position object
     * @return {*}
     */
    init:function (image, position) {
        this._super(position, 0, 0)

        /**
         @property atlasimage {boolean}
         */
        this.atlasimage = false
        this.setImage(image)

        /**
         @property bound {CG.Bound}
         */
        this.bound = Game.bound     //global bounds of game
        /**
         @property diffpoint {CG.Point}
         */
        this.diffpoint = new CG.Point(this.bound.x, this.bound.y)  //store diffpoint if bound is moving

        /**
         @property xspeed {Number}
         */
        this.xspeed = 0 //xspeed of the sprite
        /**
         @property xscale {Number}
         */
        this.xscale = 1
        /**
         @property xhandle {Number}
         */
        this.xhandle = 0
        /**
         @property yspeed {Number}
         */
        this.yspeed = 0
        /**
         @property yscale {Number}
         */
        this.yscale = 1
        /**
         @property yhandle {Number}
         */
        this.yhandle = 0
        /**
         @property boundsMode {false/string}
         */
        this.boundsMode = false // false, bounce or slide
        /**
         @property rotation {integer/float}
         */
        this.rotation = 0
        /**
         @property rotationspeed {integer/float}
         */
        this.rotationspeed = 0
        /**
         @property alpha {float}
         */
        this.alpha = 1
        /**
         @property clicked {boolean}
         */
        this.clicked = false

        /**
         @property followobject {boolean/object}
         */
        this.followobject = false   //object to follow
        /**
         @property followspeed {boolean/integer}
         */
        this.followspeed = false    //followspeed for follower in pixel, has prio over followsteps
        /**
         @property followsteps {boolean/integer}
         */
        this.followsteps = false    //followsteps between follower and target

        /**
         @property attachedobject {boolean}
         */
        this.attachedobject = false //attached object
        /**
         @property offsetx {Number}
         */
        this.offsetx = 0            //offset x for attached object
        /**
         @property offsety {Number}
         */
        this.offsety = 0            //offset y for attached object
        return this
    },
    update:function () {
        this.ifClicked()
        this.ifMouseOver()
        this.ifAttached()

        if (this.followobject) {
            this.follow()
        }

        this.position.x += this.xspeed
        this.position.y += this.yspeed
        this.rotation += this.rotationspeed
        this.xhandle = (this.width * this.xscale / 2)
        this.yhandle = (this.height * this.yscale / 2)

        if (this.boundsMode) {
            this.checkBound()
        }
    },
    draw:function () {
        this.updateDiff()

        Game.b_ctx.save()
        Game.b_ctx.globalAlpha = this.alpha
        Game.b_ctx.translate(this.position.x, this.position.y)
        if (this.atlasimage) {
            Game.b_ctx.rotate((this.rotation - this.imagerotation) * CG.Const_PI_180)
            Game.b_ctx.drawImage(this.image, this.xoffset, this.yoffset, this.cutwidth, this.cutheight, 0 - this.xhandle, 0 - this.yhandle, this.cutwidth * this.xscale, this.cutheight * this.yscale)
        } else {
            Game.b_ctx.rotate(this.rotation * CG.Const_PI_180)
            Game.b_ctx.drawImage(this.image, 0 - this.xhandle, 0 - this.yhandle, this.image.width * this.xscale, this.image.height * this.yscale)
        }
        Game.b_ctx.restore()
    },

    /**
     * @description Checks the bound if a boundMode (bounce or slide) is set
     * @method checkBound
     */
    checkBound:function () {
        switch (this.boundsMode) {
            case 'bounce':
                if (this.position.x > ( this.bound.width - this.xhandle + this.bound.x )) {
                    this.position.x = this.bound.width - this.xhandle + this.bound.x
                    this.xspeed = this.xspeed * -1
                }
                else if (this.position.x < this.bound.x + this.xhandle) {
                    this.position.x = this.bound.x + this.xhandle
                    this.xspeed = this.xspeed * -1
                }
                if (this.position.y > ( this.bound.height - this.yhandle + this.bound.y )) {
                    this.position.y = this.bound.height - this.yhandle + this.bound.y
                    this.yspeed = this.yspeed * -1
                }
                else if (this.position.y < this.bound.y + this.yhandle) {
                    this.position.y = this.bound.y + this.yhandle
                    this.yspeed = this.yspeed * -1
                }
                break
            case 'slide':
                if (this.position.x > ( this.bound.width + this.xhandle + this.bound.x )) {
                    this.position.x = ( this.bound.x - this.xhandle )
                }
                else if (this.position.x < this.bound.x - this.xhandle) {
                    this.position.x = this.bound.x + this.bound.width + this.xhandle
                }
                if (this.position.y > (this.bound.height + this.yhandle + this.bound.y)) {
                    this.position.y = (this.bound.y - this.yhandle)
                }
                else if (this.position.y < this.bound.y - this.yhandle) {
                    this.position.y = this.bound.height + this.yhandle + this.bound.y
                }
                break
            default:
                break
        }
    },

    /**
     * @description calculate offset if bound is moving
     * @method updateDiff
     */
    updateDiff:function () {
        if (this.diffpoint.x !== this.bound.x) {
            this.position.x += this.bound.x - this.diffpoint.x
        }
        if (this.diffpoint.y !== this.bound.y) {
            this.position.y += this.bound.y - this.diffpoint.y
        }
        this.diffpoint.x = this.bound.x
        this.diffpoint.y = this.bound.y
    },
    /**
     * @description is there an attached element, this sprite will follow it depending on followspeed or followsteps it follows different
     * @method follow
     */
    follow:function () {
        if (this.followspeed) {
            //constant follow speed between objects
            angl = Math.atan2(this.followobject.position.x - this.position.x, this.followobject.position.y - this.position.y) * CG.Const_180_PI
            xs = this.followspeed * Math.sin(angl * CG.Const_PI_180)
            ys = this.followspeed * Math.cos(angl * CG.Const_PI_180)

            this.xspeed = xs
            this.yspeed = ys
            this.rotation = angl * -1

        } else if (this.followsteps) {
            //constant steps between objetcs
            angl = Math.atan2(this.followobject.position.x - this.position.x, this.followobject.position.y - this.position.y) * CG.Const_180_PI
            this.rotation = angl * -1
            if (this.followobject.position.x != this.position.x) {
                distx = this.followobject.position.x - this.position.x
                this.xspeed = distx / this.followsteps //>> 0
            } else {
                this.xspeed = 0
            }
            if (this.followobject.position.y != this.position.y) {
                disty = this.followobject.position.y - this.position.y
                this.yspeed = disty / this.followsteps //>> 0
            } else {
                this.yspeed = 0
            }
        }
    },

    /**
     * @description set the bound of the sprite
     * @method setBound
     * @param bound {CG.Bound} the bound
     */
    setBound:function (bound) {
        this.bound = bound
        return this
    },


    /**
     * @description if there is a attached object get its position
     * @method ifAttached
     */
    ifAttached:function () {
        if (this.attachedobject != false) {
            this.attachedobject.position._x = this.attachedobject.position.x = (this.position.x + this.offsetx)
            this.attachedobject.position._y = this.attachedobject.position.y = (this.position.y + this.offsety)
        }
    },

    /**
     * @description attach a reference of the given object to this object
     * @method attachObject
     */
    attachObject:function (obj) {
        this.attachedobject = obj
        return this
    },

    /**
     * @description removes the attached object reference
     * @method removeAttachedObject
     */
    removeAttachedObject:function () {
        this.attachedobject = null
        return this
    },

    /**
     * @description set the x offset of the attached object to this object
     * @method setAttachedOffsetX
     */
    setAttachedOffsetX:function (offsetx) {
        this.offsetx = offsetx
        return this
    },

    /**
     * @description set the y offset of the attached object to this object
     * @method setAttachedOffsetY
     */
    setAttachedOffsetY:function (offsety) {
        this.offsety = offsety
        return this
    }
})



/**
 * @description
 *
 * CG.AtlasImage class. It is needed when using TexturePacker atlas files.
 *
 * @class CG.AtlasImage
 * @extends Class
 */
CG.Class.extend('AtlasImage', {
    /**
     * @method init
     * @constructor
     * @param image {image} imgpath, image object or atlasimage object to use
     * @param xoffset {Number} xoffset of image in atlas file
     * @param yoffset {Number} yoffset of image in atlas file
     * @param width {Number} width of image in atlas file
     * @param height {Number} height of image in atlas file
     */
    init:function (image, xoffset, yoffset, width, height) {
        /**
         * @property source
         * @type {String}
         */
        this.source = ''
        /**
         * @property atlasimage
         * @type {String}
         */
        this.atlasimage = ''
        /**
         * @property atlasname
         * @type {String}
         */
        this.atlasname = ''
        /**
         * @property image
         * @type {*}
         */
        this.image = image || ''    //imagepath
        /**
         * @property name
         * @type {String}
         */
        this.name = image.split(/(\\|\/)/g).pop().split('.')[0] //image name only for name
        /**
         * @property xoffset
         * @type {Number}
         */
        this.xoffset = xoffset || 0
        /**
         * @property yoffset
         * @type {*}
         */
        this.yoffset = yoffset || 0
        /**
         * @property width
         * @type {Number}
         */
        this.width = width || 0
        /**
         * @property height
         * @type {Number}
         */
        this.height = height || 0
        /**
         * @property rotation
         * @type {Number}
         */
        this.rotation = 0
    }
})/**
 *  @description
 *
 *  CG.AtlasTexturePacker class supports loading xml and json files from . . . TexturePacker ;o)
 *  No trimming at the moment, keep TexturePacker settings simple! TexturePacker parses the xml/json and generates new CG.atlasimage objects in the MediaAsset manager.
 *  These atlasimages are only handled within Sprite, Particle and Button class.
 *
 *  @class CG.AtlasTexturePacker
 *  @extends Class
 */
CG.Class.extend('AtlasTexturePacker', {
    /**
     * @constructor
     * @method init
     * @return {*}
     */
    init:function () {
        if (typeof(ejecta) == 'undefined') {
            this.xml = ''
            this.xmlDoc = ''
            this.parser = new DOMParser() || {}
        }
        /**
         * @property imagename
         * @type {String}
         */
        this.imagename = ''
        /**
         * @property width
         * @type {Number}
         */
        this.width = 0
        /**
         * @property height
         * @type {Number}
         */
        this.height = 0
        /**
         * @property atlasimages
         * @type {Array}
         */
        this.atlasimages = []
        return this
    },
    /**
     * @description load a xml file from TexturePacker
     * @method loadXml
     * @param {string/object} xmlfile path or mediaasset object with data of TexturePacker xml
     * @return {*}
     */
    loadXml:function (xmlfile) {
        //from asset
        if (typeof xmlfile == 'string') {
            this.xml = loadString(xmlfile)
        } else {
            this.xml = xmlfile.data
        }

        this.xmlDoc = this.parser.parseFromString(this.xml, 'text/xml')

        this.imagename = this.xmlDoc.getElementsByTagName('TextureAtlas')[0].getAttribute('imagePath')
        this.width = parseInt(this.xmlDoc.getElementsByTagName('TextureAtlas')[0].getAttribute('width'))
        this.height = parseInt(this.xmlDoc.getElementsByTagName('TextureAtlas')[0].getAttribute('height'))

        var sprites = this.xmlDoc.getElementsByTagName('sprite')
        for (var i = 0, l = sprites.length; i < l; i++) {
            atlasimage = new CG.atlasimage(
                sprites[i].getAttribute('n'),
                parseInt(sprites[i].getAttribute('x')),
                parseInt(sprites[i].getAttribute('y')),
                parseInt(sprites[i].getAttribute('w')),
                parseInt(sprites[i].getAttribute('h'))
            )
            if (sprites[i].getAttribute('r') == 'y') {
                atlasimage.rotation = 90
            }
            atlasimage.atlasimage = this.imagename
            atlasimage.source = 'xml'
            atlasimage.atlasname = this.imagename.split(/(\\|\/)/g).pop().split('.')[0] //image name only for name

            this.atlasimages.push(atlasimage)
        }
        return this
    },

    /**
     * @description load a json file from TexturePacker
     * @method loadJson
     * @param {string/object} jsonfile path or mediaasset object with data of TexturePacker json
     * @return {*}
     */
    loadJson:function (jsonfile) {
        //from asset
        if (typeof jsonfile == 'string') {
            this.json = JSON.parse(loadString(jsonfile))
        } else {
            this.json = jsonfile.data
        }
        //meta info from json file
        this.imagename = this.json.meta.image
        this.width = this.json.meta.size.w
        this.height = this.json.meta.size.h

        //loop thru all images
        for (var i = 0, l = this.json.frames.length; i < l; i++) {
            var image = this.json.frames[i]
            var atlasimage = new CG.AtlasImage(
                image.filename,
                image.frame.x,
                image.frame.y,
                image.frame.w,
                image.frame.h
            )
            if (image.rotated === true) {
                atlasimage.rotation = 90
                //            atlasimage.width = this.json.frames[i].frame.w,
                //            atlasimage.height = this.json.frames[i].frame.h
            }
            atlasimage.atlasimage = this.imagename
            atlasimage.source = 'json'
            atlasimage.atlasname = this.imagename.split(/(\\|\/)/g).pop().split('.')[0] //image name only for name

            this.atlasimages.push(atlasimage)
        }
        return this
    },

    /**
     * @description get all TexturePacker images (Use array.push.apply(array, anotherarray) to append to Game.asset)
     * @method getatlasimages
     * @return {array} returns all atlasimages of TexturePacker file to use with Game.asset
     */
    getAtlasImages:function () {
        return this.atlasimages
    }
})


/**
 * @description
 *
 * CG.Animation extends CG.Sprite and add support for animations ;o) It needs atlas files with fixed framesizes and with following animation frames.
 * For example you can use Timeline FX generated graphics.
 *
 * @class CG.Animation
 * @extends CG.Sprite
 */
CG.Sprite.extend('Animation', {
    /**
     * @constructor
     * @method init
     * @param image {string, image} image imagepath or image object
     * @param position {point} position object
     * @param startframe {number} startframe of atlas image
     * @param endframe {number} endframe endframe of atlas image
     * @param framewidth {number} framewidth width of frame to cut
     * @param frameheight {number} frameheight height of frame to cut
     * @return {*}
     */
    init:function (image, position, startframe, endframe, framewidth, frameheight) {
        this._super(image, position)

        //from asset?
        if (typeof image == 'string') {
            this.image = new Image()
            this.image.src = image
        } else {
            this.image = image
        }

        /**
         @property loop {boolean}
         */
        this.loop = true
        /**
         @property status {Number}
         */
        this.status = 0
        /**
         @property currentframe {Number}
         */
        this.currentframe = 0
        /**
         @property frames {Number}
         */
        this.frames = 0
        /**
         @property startframe {Number}
         */
        this.startframe = startframe - 1
        /**
         @property endframe {Number}
         */
        this.endframe = endframe - 1
        /**
         @property width {Number}
         */
        this.width = framewidth
        /**
         @property height {Number}
         */
        this.height = frameheight

        if (this.startframe === undefined && this.endframe === undefined) {
            this.frames = 1
            this.startframe = 0
            this.endframe = 0
        } else {
            this.currentframe = this.startframe - 1
            this.frames = this.endframe - this.startframe + 1
        }

        /**
         @property fx {Number}
         */
        this.fx = 0
        /**
         @property fy {Number}
         */
        this.fy = 0

        /**
         @property delay {Number}
         */
        this.delay = 0
        /**
         @property tempdelay {Number}
         */
        this.tempdelay = 0

        return this
    },
    update:function () {
        //animation specific stuff
        if (this.status == 0) {
            this.tempdelay += 1
            if (this.tempdelay >= this.delay) {
                this.tempdelay = 0
                if (this.frames > 1) {
                    this.currentframe += 1
                    if ((this.currentframe - this.startframe) >= this.frames) {
                        if (this.loop === false) {
                            this.status = 1 //time to say good by, elements would be deleted at the moment
                        } else {
                            this.currentframe = this.startframe
                        }
                    }
                }
            }
        }
        //update all other stuff in the parent class
        this._super()
    },
    draw:function () {
        this.updateDiff()

        Game.b_ctx.save()
        Game.b_ctx.globalAlpha = this.alpha
        Game.b_ctx.translate(this.position.x, this.position.y)
        if (this.frames == 1) {
            Game.b_ctx.drawImage(this.image, this.position.x, this.position.y, this.image.width * this.xscale, this.image.height * this.yscale)
        }
        else {
            this.fx = this.currentframe * this.width

            if ((this.fx / this.image.width) > 0) {
                this.fx = this.fx % this.image.width
            }
            this.fy = Math.floor(this.width * this.currentframe / this.image.width) * this.height

            Game.b_ctx.rotate(this.rotation * CG.Const_PI_180)
            try {
                Game.b_ctx.drawImage(this.image, this.fx, this.fy, this.width, this.height, 0 - this.xhandle, 0 - this.yhandle, this.width * this.xscale, this.height * this.yscale)
            } catch (e) {

            }
        }
        Game.b_ctx.restore()
    }
})

/**
 * @description
 *
 * CG.Bitmap is a simple bitmap class with basic features for bitmap manipulation at the moment.
 *
 * @class CG.Bitmap
 * @extends CG.Entity
 *
 */

//@TODO add margin squares function for contour finding => also for polygon path? (http://www.emanueleferonato.com/2013/03/01/using-marching-squares-algorithm-to-trace-the-contour-of-an-image/)
//@TODO add surface normal function (http://gamedev.tutsplus.com/tutorials/implementation/coding-destructible-pixel-terrain/, http://en.wikipedia.org/wiki/Surface_normal)
//@TODO add a raycast function ?

CG.Entity.extend('Bitmap', {
    /**
     * @method init
     * @constructor
     * @param width {Number} width the width for the buffer
     * @param height {Number} height the height for the buffer
     * @return {*}
     */
    init:function (width, height) {
        this._super(this)
        this.x = 0
        this.y = 0
        this.bitmap_canvas = document.createElement('canvas')
        this.bitmap_canvas.width = width
        this.bitmap_canvas.height = height
        this.bitmap_ctx = this.bitmap_canvas.getContext('2d')
        return this
    },
    /**
     * @description
     *
     * Loads an image and draws it to the buffer
     *
     * @method loadImage
     *
     * @param {string, image, atlasimage} imgpath, image object or atlasimage object to use
     */
    loadImage:function (image) {
        this.setImage(image)
        this.drawImageToBuffer()
        return this
    },


    update:function () {
    },

    draw:function () {
        Game.b_ctx.drawImage(this.bitmap_canvas, this.x, this.y)
    },


    /**
     * @method clearBuffer
     */
    clearBuffer:function () {
        this.bitmap_ctx.clearRect(0, 0, this.bitmap_canvas.width, this.bitmap_canvas.height)
        return this
    },

    /**
     * @method drawImageToBuffer
     */
    drawImageToBuffer:function () {
        this.bitmap_ctx.drawImage(this.image, 0, 0)
        return this
    },


    /**
     * @method clearRect
     *
     * @param {Number} x the x position for clearRect
     * @param {Number} y the y position for clearRect
     * @param {Number} width the width for clearRect
     * @param {Number} height the height for clearRect
     */
    clearRect:function (x, y, width, height) {
        this.bitmap_ctx.save()
        this.bitmap_ctx.globalCompositeOperation = 'destination-out'
        this.bitmap_ctx.clearRect(x, y, width, height)
        this.bitmap_ctx.restore()
    },

    /**
     * @method clearCircle
     *
     * @param {Number} x the x position for clearCircle
     * @param {Number} y the y position for clearCircle
     * @param {Number} radius the radius for clearCircle
     */
    clearCircle:function (x, y, radius) {
        this.bitmap_ctx.save()
        this.bitmap_ctx.globalCompositeOperation = 'destination-out'
        this.bitmap_ctx.beginPath()
        this.bitmap_ctx.arc(x, y, radius, 0, 2 * Math.PI, false)
        this.bitmap_ctx.closePath()
        this.bitmap_ctx.fill()
        this.bitmap_ctx.restore()
    },

    /**
     * @method getPixel
     *
     * @param {Number} x the x position for getPixel
     * @param {Number} y the y position for getPixel
     * @returns {imagedata} data from canvas
     */
    getPixel:function (x, y) {
        return this.bitmap_ctx.getImageData(x, y, 1, 1)
    },

    /**
     * @method getPixels
     *
     * @param {Number} x the x position for getPixels
     * @param {Number} y the y position for getPixels
     * @param {Number} width for getPixels
     * @param {Number} height for getPixels
     * @returns {imagedata} data from canvas
     */
    getPixels:function (x, y, width, height) {
        return this.bitmap_ctx.getImageData(x, y, width, height)
    }
})


/**
 * @description
 *
 * CG.Button represents a simple button class that can handle click, mouseover and callback functionality.
 *
 * @class CG.Button
 * @extends CG.Sprite
 *
 */
CG.Sprite.extend('Button', {
    /**
     * @method init
     * @constructor
     * @param image {image} image image path, image or atlasimage
     * @param position {CG.Point} position point
     * @param text {string} the button text
     * @param font {CG.Font} a CG.Font object for text rendering
     * @param clickedCallback {callback} callback function for click handling
     * @return {*}
     */
    init:function (image, position, text, font, clickedCallback) {
        this._super(image, position)

        /**
         @property font {CG.Font}
         */
        this.font = font
        /**
         @property clickedCallback {callback}
         */
        this.clickedCallback = clickedCallback
        /**
         @property clicked {boolean}
         */
        this.clicked = false
        /**
         @property clickable {boolean}
         */
        this.clickable = true

        /**
         @property text {string}
         */
        this.text = text
        return this
    },
    update:function () {
        this.ifClicked()
        this.ifMouseOver()
        this.ifAttached()

        if (this.clicked) {
            if (this.clickedCallback) {
                this.clicked = false
                this.clickedCallback(this)
            }
        }
    },
    draw:function () {
        Game.b_ctx.save()
        Game.b_ctx.translate(this.position.x, this.position.y)
        if (this.atlasimage) {
            var r = this.rotation
            Game.b_ctx.rotate((r - this.imagerotation) * CG.Const_PI_180)
            Game.b_ctx.drawImage(this.image, this.xoffset, this.yoffset, this.cutwidth, this.cutheight, 0 - (this.cutwidth / 2), 0 - (this.cutheight / 2), this.cutwidth * this.xscale, this.cutheight * this.yscale)
            Game.b_ctx.rotate(this.imagerotation * CG.Const_PI_180)
        } else {
            Game.b_ctx.rotate(r * CG.Const_PI_180)
            Game.b_ctx.drawImage(this.image, 0 - (this.image.width * this.xscale / 2), 0 - (this.image.height * this.yscale / 2), this.image.width * this.xscale, this.image.height * this.yscale)
        }
        this.font.drawText(this.text, 0 - (this.font.getTextWidth(this.text) / 2 >> 0), 0 - ((this.font.getFontSize() / 2) >> 0))
        Game.b_ctx.restore()
    }
})


/**
 * @description
 *
 * CG.Menu
 *
 * @class CG.Menu
 * @extends CG.Entity
 *
 */
CG.Entity.extend('Menu', {
    /**
     * @method init
     * @constructor
     * @param x {Number} x the x position
     * @param y {Number} y the y position
     * @param margin {Number} margin the margin between the menu buttons
     * @return {*}
     */
    init:function (x, y, margin) {
        /**
         * @property x
         * @type {Number}
         */
        this.x = x
        /**
         * @property y
         * @type {Number}
         */
        this.y = y
        /**
         * @proerty margin
         * @type {Number}
         */
        this.margin = margin
        /**
         * @property step
         * @type {*}
         */
        this.step = this.y
        /**
         * @property buttons
         * @type {Array}
         */
        this.buttons = []
        return this
    },
    /**
     * @method addButton
     *
     * @param {button} button
     */
    addButton:function (button) {
        this.buttons.push(button)
    },

    update:function () {
        this.buttons.forEach(function (button) {
            button.update()
        }, this)
    },

    draw:function () {
        this.buttons.forEach(function (button) {
            button.position.x = this.x
            button.position.y = this.step
            button.draw()
            this.step += button.height
            this.step += this.margin
        }, this)
        this.step = this.y
    }
})


/**
 * @description
 *
 * CG.MediaAsset preloader.
 *
 * @class CG.MediaAsset
 * @extends Class
 *
 */

CG.Class.extend('MediaAsset', {
    /**
     * @method init
     * @constructor
     * @param image {string} image path to background image of preloader
     * @param ctx {canvas context} canvas context for drawing
     */
    init:function (image, ctx) {
        if (image != '') {
            this.image = new Image()
            this.image.src = image
        }

        this.ctx = ctx

        this.ready = false
        this.progress = 0

        this.images = []
        this.currimage = 0

        this.sounds = []
        this.currsound = 0

        this.xmls = []
        this.currxml = 0

        this.jsons = []
        this.currjson = 0

        this.fonts = []
        this.currfont = 0

        this.assetcount = 0
        this.assetcurrent = 0

        //progress
        this.width = 300
        this.height = 20
        this.radius = 10

        this.linewidth = 8
        this.bordercolor = 'white'
        this.progresscolor = 'red'
        this.shadowcolor = '#222'
        this.shadowblur = 6
        this.shadowoffsetx = 2
        this.shadowoffsety = 2

//return this
    },
    /**
     * @method addImage
     * @param path
     * @param name
     * @return {*}
     */
    addImage:function (path, name) {
        this.assetcount += 1
        this.images.push({
            name:name || '', //optional
            path:path,
            img:new Image()
        })
        return this
    },
    /**
     * @method addFont
     * @param path
     * @param name
     * @return {*}
     */
    addFont:function (path, name) {
        this.assetcount += 1
        this.fonts.push({
            name:name || '', //optional
            path:path,
            data:''
        })
        return this
    },
    /**
     * @method addXml
     * @param path
     * @param name
     * @return {*}
     */
    addXml:function (path, name) {
        this.assetcount += 1
        this.xmls.push({
            name:name || '', //optional
            path:path,
            data:''
        })
        return this
    },
    /**
     * @method addJson
     * @param path
     * @param name
     * @return {*}
     */
    addJson:function (path, name) {
        this.assetcount += 1
        this.jsons.push({
            name:name || '', //optional
            path:path,
            data:''
        })
        return this
    },
    /**
     * @method getImageByName
     * @param name
     * @return {*}
     */
    getImageByName:function (name) {
        for (var i = 0, l = this.images.length; i < l; i++) {
            if (this.images[i].name == name) {
                if (this.images[i] instanceof CG.AtlasImage) {
                    return this.images[i]
                } else {
                    return this.images[i].img
                }
            }
        }
        throw new CG.MediaAssetException('No image with this name in asset.')
    },
    /**
     * @method getImagesByName
     * @param name
     * @return {*}
     */
    getImagesByName:function (name) {
        names = []
        for (var i = 0, l = this.images.length; i < l; i++) {
            if (this.images[i].name == name) {
                if (this.images[i] instanceof CG.AtlasImage) {
                    names.push(this.images[i])
                } else {
                    names.push(this.images[i].img)
                }
            }
        }
        if (names.length === 0) {
            throw new CG.MediaAssetException('No image with this name in asset.')
        }
        return names
    },
    /**
     * @method getFontByName
     * @param name
     * @return {*}
     */
    getFontByName:function (name) {
        for (var i = 0, l = this.fonts.length; i < l; i++) {
            if (this.fonts[i].name == name) {
                return this.fonts[i]
            }
        }
        throw new CG.MediaAssetException('No font with this name in asset.')
    },
    /**
     * @method getXmlByName
     * @param name
     * @return {*}
     */
    getXmlByName:function (name) {
        for (var i = 0, l = this.xmls.length; i < l; i++) {
            if (this.xmls[i].name == name) {
                return this.xmls[i]
            }
        }
        throw new CG.MediaAssetException('No XML with this name in asset.')
    },
    /**
     * @method getJsonByName
     * @param name
     * @return {*}
     */
    getJsonByName:function (name) {
        for (var i = 0, l = this.jsons.length; i < l; i++) {
            if (this.jsons[i].name == name) {
                return this.jsons[i]
            }
        }
        throw new CG.MediaAssetException('No JSON with this name in asset.')
    },
    /**
     * @method startPreLoad
     */
    startPreLoad:function () {

        this.progress = 100 / this.assetcount * this.assetcurrent
        this.progressScreen()

        if (this.currimage < this.images.length) {
            //BUG last image is not preloading
            this.images[this.currimage].img.onload = function () {
                console.log('loaded image (' + Math.floor(100 / (this.images.length - 1) * this.currimage) + ' %): ' + this.images[this.currimage].name)
                this.currimage += 1
                this.assetcurrent += 1
                this.startPreLoad()
            }.bind(this)
            this.images[this.currimage].img.src = this.images[this.currimage].path
        } else if (this.currfont < this.fonts.length) {
            //        if(typeof(ejecta) !== 'undefined'){
            //            this.fonts[this.currfont].data = ejecta.loadText(this.fonts[this.currfont].path)
            //        } else {
            this.fonts[this.currfont].data = loadString(this.fonts[this.currfont].path)
            //        }
            this.currfont += 1
            this.assetcurrent += 1
            this.startPreLoad()
        } else if (this.currxml < this.xmls.length) {
            this.xmls[this.currxml].data = loadString(this.xmls[this.currxml].path)
            this.currxml += 1
            this.assetcurrent += 1
            this.startPreLoad()
        } else if (this.currjson < this.jsons.length) {
            //        if(typeof(ejecta) !== 'undefined'){
            //            this.jsons[this.currjson].data = ejecta.loadJSON(this.jsons[this.currjson].path)
            //        } else {
            this.jsons[this.currjson].data = JSON.parse(loadString(this.jsons[this.currjson].path))
            //        }
            this.currjson += 1
            this.assetcurrent += 1
            this.startPreLoad()
        } else if (this.currimage == this.images.length &&
            this.assetcount == this.assetcurrent) {
            this.ready = true
            Game.create()
        }
    },
    /**
     * @method progressScreen
     * @description render a progress screen to the canvas
     */
    progressScreen:function () {
        var x = (Game.bound.width - this.width) / 2
        var y = (Game.bound.height - this.height) / 2
        if (this.image) {
            this.ctx.drawImage(this.image, 0, 0, this.image.width, this.image.height)
        } else {
            this.ctx.clearRect(0, 0, Game.bound.width, Game.bound.height)
        }
        this.ctx.save()

        this.ctx.fillStyle = this.progresscolor;
        this.ctx.fillRect((Game.bound.width - this.width) / 2, (Game.bound.height - this.height) / 2, this.width / 100 * this.progress, this.height);

        this.ctx.strokeStyle = this.bordercolor
        this.ctx.shadowColor = this.shadowcolor
        this.ctx.shadowBlur = this.shadowblur
        this.ctx.shadowOffsetX = this.shadowoffsetx
        this.ctx.shadowOffsetY = this.shadowoffsety
        this.ctx.beginPath();
        this.ctx.moveTo(x + this.radius, y);
        this.ctx.lineTo(x + this.width - (1 * this.radius), y)
        this.ctx.arcTo(x + this.width, y, x + this.width, y + this.radius, this.radius)
        this.ctx.arcTo(x + this.width, this.radius * 2 + y, x + this.width - (1 * this.radius), this.radius * 2 + y, this.radius)
        this.ctx.lineTo(x + this.radius, 2 * this.radius + y)
        this.ctx.arcTo(x, 2 * this.radius + y, x, y, this.radius)
        this.ctx.arcTo(x, y, 2 * this.radius + x, y, this.radius)
        this.ctx.lineWidth = this.linewidth
        this.ctx.stroke()
        this.ctx.restore()
    }
})

function MediaAssetException(message) {
    this.message = message
}



/**
 * @description
 *
 * CG.Font supports loading and drawing font files (EZ GUI Text format) from Glyph Designer,
 * (Hiero works also but need some modifications of the exported files)
 @example
 //create font object
 small = new CG.Font().loadFont(Game.asset.getFontByName('small'))

 //draw text to canvas
 small.drawText('Foo bar!', xpos, ypos)
 *
 * @class CG.Font
 * @extends CG.Entity
 */
CG.Entity.extend('Font', {
    /**
     * @method init
     * @constructor
     * @return {*}
     */
    init: function () {
        /**
         @property atlas {Image}
         */
        this.atlas = new Image()
        /**
         @property initText {string}
         */
        this.fontFile = ''
        /**
         @property chars {Array}
         */
        this.chars = new Array(256)
        /**
         @property x {Array}
         */
        this.x = new Array(256)
        /**
         @property y {Array}
         */
        this.y = new Array(256)
        /**
         @property width {Array}
         */
        this.width = new Array(256)
        /**
         @property height {Array}
         */
        this.height = new Array(256)
        /**
         @property xoff {Array}
         */
        this.xoff = new Array(256)
        /**
         @property yoff {Array}
         */
        this.yoff = new Array(256)
        /**
         @property xadv {Array}
         */
        this.xadv = new Array(256)
        /**
         @property lineHeight {Number}
         */
        this.lineHeight = 0
        /**
         @property face {string}
         */
        this.face = ''
        /**
         @property size {Number}
         */
        this.size = 0
        /**
         @property bold {Number}
         */
        this.bold = 0
        /**
         @property italic {Number}
         */
        this.italic = 0

        /**
         @property base {Number}
         */
        this.base = 0
        /**
         @property scaleW {Number}
         */
        this.scaleW = 0
        /**
         @property scaleH {Number}
         */
        this.scaleH = 0
        return this
    },
    /**
     * @method update
     */
    update: function () {
        throw {
            name: 'Font Error',
            message: 'TODO, not defined yet.'
        }
    },
    /**
     * @method draw
     */
    draw: function () {
        throw {
            name: 'Font Error',
            message: 'TODO, not defined yet.'
        }
    },
    /**
     * @description draw the given text to the canvas
     * @method draw
     * @param text {string} the text to draw
     * @param xpos {Number} the x position
     * @param ypos {Number} the y position
     */
    drawText: function (text, xpos, ypos) {
        var currx = xpos
        var curry = ypos

        for (var i = 0, l = text.length; i < l; i++) {
            var charCode = text.charCodeAt(i)
            try {
                Game.b_ctx.drawImage(
                    this.atlas,
                    this.x[charCode],
                    this.y[charCode],
                    this.width[charCode],
                    this.height[charCode],
                    currx,
                    curry + this.yoff[charCode],
                    this.width[charCode],
                    this.height[charCode]
                )
            } catch (e) {
                //console.log("drawText error: " + e)
            }
            currx += this.xadv[charCode]
        }
    },

    /**
     * @description get the line height of the current font
     * @method getLineHeight
     * @return lineheight {Number}
     */
    getLineHeight: function () {
        return this.lineHeight
    },

    /**
     * @description get the font size of the current font
     * @method getFontSize
     * @return size {Number} font size
     */
    getFontSize: function () {
        return this.size
    },

    /**
     * @description get the width of the given text
     * @method getTextWidth
     * @param text {string} the string to calculate the width
     * @return textwidth {Number}
     */
    getTextWidth: function (text) {
        var textwidth = 0
        var c = 0
        for (var i = 0, l = text.length; i < l; i++) {
            textwidth += this.xadv[text.charCodeAt(i)]
        }
        return textwidth
    },

    /**
     * @description loadFont - load and parse the given fontfile
     * @method loadFont
     * @param {string/object} fontfile path or mediaasset object with data
     */
    loadFont: function (fontfile) {
        idnum = 0
        if (typeof fontfile == 'string') {
            this.fontFile = loadString(fontfile)
        } else {
            this.fontFile = fontfile.data
        }

        var lines = this.fontFile.split('\n')
        for (l in lines) {
            line = lines[l].trim()

            if (line.startsWith('info') || line == '') {
                var infodata = line.split(' ')
                for (i in infodata) {
                    var info = infodata[i]
                    if (info.startsWith('face=')) {
                        var face = info.split("=")
                        this.face = face[1].split('"').join('')
                    }
                    if (info.startsWith('size=')) {
                        var size = info.split("=")
                        this.size = parseInt(size[1])
                    }
                    if (info.startsWith('bold=')) {
                        var bold = info.split("=")
                        this.bold = parseInt(bold[1])
                    }
                    if (info.startsWith('italic=')) {
                        var italic = info.split("=")
                        this.italic = parseInt(italic[1])
                    }
                }
            }
            if (line.startsWith('padding')) {
                continue
            }
            if (line.startsWith('common')) {
                var commondata = line.split(' ')
                for (c in commondata) {
                    var common = commondata[c]
                    if (common.startsWith('lineHeight=')) {
                        var lnh = common.split("=")
                        this.lineHeight = parseInt(lnh[1])
                    }
                    if (common.startsWith('base=')) {
                        var base = common.split("=")
                        this.base = parseInt(base[1])
                    }
                    if (common.startsWith('scaleW=')) {
                        var scaleW = common.split("=")
                        this.scaleW = parseInt(scaleW[1])
                    }
                    if (common.startsWith('scaleH=')) {
                        var scaleH = common.split("=")
                        this.scaleH = parseInt(scaleH[1])
                    }
                }
            }
            if (line.startsWith('page')) {
                var pagedata = line.split(' ')
                for (p in pagedata) {
                    data = pagedata[p]
                    if (data.startsWith('file=')) {
                        var fn = data.split('=')
                        this.atlas.src = 'media/font/' + fn[1].split('"').join('')
                    }

                }
            }
            if (line.startsWith('chars')) {
                continue
            }
            if (line.startsWith('char')) {
                var linedata = line.split(' ')
                for (l in linedata) {
                    ld = linedata[l]
                    if (ld.startsWith('id=')) {
                        var idc = ld.split('=')
                        idnum = parseInt(idc[1])
                    }
                    if (ld.startsWith('x=')) {
                        var xc = ld.split('=')
                        this.x[idnum] = parseInt(xc[1])
                    }
                    if (ld.startsWith('y=')) {
                        var yc = ld.split('=')
                        this.y[idnum] = parseInt(yc[1])
                    }
                    if (ld.startsWith('width=')) {
                        var wc = ld.split('=')
                        this.width[idnum] = parseInt(wc[1])
                    }
                    if (ld.startsWith('height=')) {
                        var hc = ld.split('=')
                        this.height[idnum] = parseInt(hc[1])
                    }
                    if (ld.startsWith('xoffset=')) {
                        var xoc = ld.split('=')
                        this.xoff[idnum] = parseInt(xoc[1])
                    }
                    if (ld.startsWith('yoffset=')) {
                        var yoc = ld.split('=')
                        this.yoff[idnum] = parseInt(yoc[1])
                    }
                    if (ld.startsWith('xadvance=')) {
                        var advc = ld.split('=')
                        this.xadv[idnum] = parseInt(advc[1])
                    }
                }
            }
        }
        return this
    }
})


/**
 * @description
 *
 * Future plans:
 * CG.Text => support for different text drawing modes like textblock, text alignment, text ticker or scroller.
 *
 * @class CG.Text
 * @extends CG.Entity
 */
CG.Entity.extend('Text', {
    /**
     * @method init
     * @param font the font object (CG.Font) to use
     * @constructor
     * @return {*}
     */

    init: function (font) {

        /**
         @property font {CG.Font}
         */
        this.font = font

        /**
         * @property text {string}
         */
        this.text = ''

        /**
         * @property textcurrent {string}
         */
        this.textcurrent = ''

        /**
         * @property x {number} the x position
         */
        this.x = 0

        /**
         * @property y {number} the y position
         */
        this.y = 0

        /**
         * @property width {number} width of textbox
         */
        this.width = 0

        /**
         * @property height {number} height of textbox
         */
        this.height = 0

        /**
         * @property textAlign {string} alignment of text
         */
        this.textAlign = 'left' //left, right, centered

        return this
    },
    initAsTextblock: function (font) {

        return this
    },
    initAsScroller: function () {

    },
    initAsTicker: function () {

    },
    /**
     * @method setText
     * @param text
     * @returns {*}
     */
    setText: function (text) {
        this.text = text
        return this
    },
    /**
     * @method update
     */
    update: function () {

    },
    /**
     * @method draw
     */
    draw: function () {

    }
})/**
 * @description
 *
 * CG.Director the top instance for CG.Screens, CG.Layers, CG.Sprites and so on in the control hierarchy.
 * Its main purpose is to collect CG.Screens under its hood and support some basic screen fading features.
 @example
 //create top level CG.Director object
 var director = new CG.Director()

 //create a CG.Screen
 var mainscreen = new CG.Screen('mainscreen')

 //create a CG.Layer
 var mainlayer = new CG.Layer('mainlayer')

 //create a demo CG.Sprite
 var demosprite = new CG.Sprite(Game.asset.getImageByName('spritegfx'), new CG.Point(400, 240))

 //add/attach the demo sprite to the layer
 mainlayer.addElement(back)

 //add/attach mainscreen and mainlayer to the director
 director.addScreen(mainscreen.addLayer(mainlayer))

 * @class CG.Director
 * @extends Class
 */
CG.Class.extend('Director', {
    /**
     * @method init
     * @constructor
     * @return {*}
     */
    init: function () {
        /**
         * @property screens
         * @type {Array}
         */
        this.screens = []
        /**
         * @property activescreen
         * @type {Number}
         */
        this.activescreen = 0
        /**
         * @description nextscreen
         * @type {Number}
         */
        this.nextscreen = 0
        /**
         * @property duration
         * @type {Number}
         */
        this.duration = 20
        /**
         * @property stepx
         * @type {number}
         */
        this.stepx = 40
        /**
         * @property stepy
         * @type {number}
         */
        this.stepy = 30
        /**
         * @description alpha
         * @type {Number}
         */
        this.alpha = 0
        /**
         * @description mode
         * @type {String}
         */
        this.mode = 'fade'      //fade or scale
        /**
         * @description direction
         * @type {String}
         */
        this.direction = CG.RIGHT      //CG.LEFT, CG.RIGHT, CG.UP, CG.DOWN
        /**
         * @property color
         * @type {String}
         */
        this.color = 'rgb(0,0,0)'
        return this
    },
    update: function () {
        //handle screen fading
        switch (this.mode) {
            case 'scale':
                if (this.nextscreen != this.activescreen) {
                    this.screens[this.activescreen].xscale -= 0.4 / this.duration
                    this.screens[this.activescreen].yscale -= 0.4 / this.duration
                } else if (this.nextscreen == this.activescreen) {
                    this.screens[this.activescreen].xscale += 0.4 / this.duration
                    this.screens[this.activescreen].yscale += 0.4 / this.duration
                }

                if (this.screens[this.activescreen].xscale >= 1) {
                    this.screens[this.activescreen].xscale = this.screens[this.activescreen].yscale = 1
                    this.screens[this.nextscreen].xscale = this.screens[this.nextscreen].yscale = 1
                }

                if (this.screens[this.activescreen].xscale <= 0) {
                    this.screens[this.activescreen].xscale = this.screens[this.activescreen].yscale = 1
                    this.screens[this.nextscreen].xscale = this.screens[this.nextscreen].yscale = 0
                    this.activescreen = this.nextscreen
                }
                //this.screens[this.nextscreen].update()
                break

            case 'fade':
                // the fade is bound to the alpha value in the draw method
                if (this.nextscreen != this.activescreen && this.alpha < 1) {
                    this.alpha += 1 / this.duration
                } else if (this.nextscreen == this.activescreen && this.alpha != 0) {
                    this.alpha -= 1 / this.duration
                }
                if (this.alpha >= 1) {
                    this.activescreen = this.nextscreen
                    this.alpha = 1
                }
                if (this.alpha < 0) {
                    this.alpha = 0
                }
                break

            case 'slide':
                if (this.nextscreen != this.activescreen) {
                    switch (this.direction) {
                        case CG.UP:
                            this.screens[this.activescreen].position.y -= this.stepy
                            this.screens[this.nextscreen].position.y -= this.stepy
                            if (this.screens[this.nextscreen].position.y < 0) {
                                this.resetScreens()
                                this.activescreen = this.nextscreen
                            }
                            break
                        case CG.DOWN:
                            this.screens[this.activescreen].position.y += this.stepy
                            this.screens[this.nextscreen].position.y += this.stepy
                            if (this.screens[this.nextscreen].position.y > 0) {
                                this.resetScreens()
                                this.activescreen = this.nextscreen
                            }
                            break
                        case CG.LEFT:
                            this.screens[this.activescreen].position.x -= this.stepx
                            this.screens[this.nextscreen].position.x -= this.stepx
                            if (this.screens[this.nextscreen].position.x < 0) {
                                this.resetScreens()
                                this.activescreen = this.nextscreen
                            }
                            break
                        case CG.RIGHT:
                            this.screens[this.activescreen].position.x += this.stepx
                            this.screens[this.nextscreen].position.x += this.stepx
                            if (this.screens[this.nextscreen].position.x > 0) {
                                this.resetScreens()
                                this.activescreen = this.nextscreen
                            }
                            break
                    }
                    //this.screens[this.nextscreen].update()
                }
                break
        }
        this.screens[this.activescreen].update()
    },
    draw: function () {
        //draw active screen
        this.screens[this.activescreen].draw()

        //draw nextscreen for slide mode
        if (this.screens[this.nextscreen].position.x != 0 || this.screens[this.nextscreen].position.y != 0) {
            this.screens[this.nextscreen].draw()
        }

        //draw fading layer => why not use the screens itself with alpha without additional rect?
        if (this.alpha > 0) {
            Game.b_ctx.save()
            Game.b_ctx.globalAlpha = this.alpha
            Game.b_ctx.fillStyle = this.color
            Game.b_ctx.fillRect(0, 0, Game.bound.width, Game.bound.height)
            Game.b_ctx.restore()
        }
    },
    /**
     * @method nextScreen
     @example
     //tell the director class to fade to next screen with scale mode
     Game.director.nextScreen('gamescreen', 'scale', 10);

     //tell the director class to fade to next screen
     Game.director.nextScreen('settingsscreen', 'fade', 10);
     *
     * @param {string} screenname to define nextscreen for fading
     * @param {string} mode mode for transition
     * @param {Number} duration the duration for fading
     */
    nextScreen: function (screenname, mode, duration) {
        var nextscreen = this.getIndexOfScreen(screenname)

        if (nextscreen != this.activescreen) {
            this.resetScreens()
            this.mode = mode
            this.duration = duration
            this.stepx = Game.canvas.width / this.duration >> 0
            this.stepy = Game.canvas.height / this.duration >> 0
            this.nextscreen = nextscreen

            if (this.mode === 'scale') {
                this.alpha = 0
            } else if (this.mode === 'fade') {
                // hmm ;o) ?
            } else if (this.mode === 'slide') {
                switch (this.direction) {
                    case CG.UP:
                        this.screens[this.nextscreen].position.y += CG.canvas.height
                        break
                    case CG.DOWN:
                        this.screens[this.nextscreen].position.y -= CG.canvas.height
                        break
                    case CG.LEFT:
                        this.screens[this.nextscreen].position.x += CG.canvas.width
                        break
                    case CG.RIGHT:
                    default:
                        this.screens[this.nextscreen].position.x -= CG.canvas.width
                        break
                }
            }
        }
        return this
    },
    resetScreens: function () {
        this.screens[this.activescreen].position = new CG.Point(0, 0)
        this.screens[this.nextscreen].position = new CG.Point(0, 0)
        return this
    },
    /**
     * @method addScreen
     *
     * @param {CG.Screen} screen to add to the screen list
     */
    addScreen: function (screen) {
        this.screens.push(screen)
        return this
    },
    /**
     * @method getScreenByName
     *
     * @param {string} screenname to find screen by name
     * @return {false/CG.Screen} returns false or the screen object
     */
    getScreenByName: function (screenname) {
        for (var i = 0, l = this.screens.length; i < l; i++) {
            if (this.screens[i].name == screenname) {
                return this.screens[i]
            }
        }
        return false
    },

    /**
     * @method getIndexOfScreen
     *
     * @param {string} screenname to find index of screen in screen array
     * @return {false/Number} return false or index number of the screen
     */
    getIndexOfScreen: function (screenname) {
        for (var i = 0, l = this.screens.length; i < l; i++) {
            if (this.screens[i].name == screenname) {
                return i
            }
        }
        return false
    },

    /**
     * @method getActiveScreenName
     *
     * @return {string} the name of the active screen
     */
    getActiveScreenName: function () {
        return this.screens[this.activescreen].name
    },
    setDirection: function (direction) {
        this.direction = direction
        return this
    }
})/**
 * @description
 *
 * CG.Screen is a child of CG.Director and a container to collect/group CG.Layers and/or CG.B2DWorld
 *
 * @class CG.Screen
 * @extends CG.Entity
 *
 * @param {string} screenname the name of the screen
 */
CG.Entity.extend('Screen', {
    /**
     * @constructor
     * @method init
     * @param screenname
     * @return {*}
     */
    init: function (screenname) {
        this._super(screenname)
        /**
         @property position {CG.Point}
         */
        this.position = new CG.Point(0, 0)
        /**
         * @property xscale
         * @type {Number}
         */
        this.xscale = 1
        /**
         * @property yscale
         * @type {Number}
         */
        this.yscale = 1
        /**
         * @property layers
         * @type {Array}
         */
        this.layers = []
        return this
    },
    create: function () {

    },
    update: function () {
        for (var i = 0, l = this.layers.length; i < l; i++) {
            this.layers[i].update()
        }
    },
    draw: function () {
        Game.b_ctx.save()
        if (this.xscale !== 1 || this.yscale !== 1) {
            Game.b_ctx.translate((Game.width - (Game.width * this.xscale)) / 2, (Game.height - (Game.height * this.yscale)) / 2)
            Game.b_ctx.scale(this.xscale, this.yscale)
        } else {
            Game.b_ctx.translate(this.position.x, this.position.y)
        }
        for (var i = 0, l = this.layers.length; i < l; i++) {
            this.layers[i].draw()
        }


        Game.b_ctx.restore()

    },

    /**
     * @description add a CG.Layer object to the layer array
     * @method addLayer
     * @param {layer} layer to add
     */
    addLayer: function (layer) {
        this.layers.push(layer)
        return this
    },

    /**
     * @description find CG.Layer by name
     * @method getLayerByName
     * @param {string} layername find layer by name
     * @return {false/layer}
     */
    getLayerByName: function (layername) {
        for (var i = 0, l = this.layers.length; i < l; i++) {
            if (this.layers[i].name == layername) {
                return this.layers[i]
            }
        }
        return false
    }
})


/**
 * @description
 *
 * CG.Layer is a child of CG.Screen and a container to collect/group sprites, buttons, menus, emitters and animations
 *
 * @class CG.Layer
 * @extends CG.Entity
 */
CG.Entity.extend('Layer', {
    /**
     * @constructor
     * @method init
     * @param layername {string} the name of the layer
     * @return {*}
     */
    init:function (layername) {
        this._super(layername)

        var self = this
        this.elements = []
        this.elementsToDelete = []
        return this
    },
    update:function () {
        if (this.visible == true) {
//            this.elements.forEach(function (element, index) {
//                element.update()
//                if (element.status == 1) {
//                    this.elementsToDelete.push(index)
//                }
//            }, this)

            for(var i = 0, l = this.elements.length; i < l; i++){
                this.elements[i].update()
                if(this.elements[i].status == 1){
                    this.elementsToDelete.push(this.elements[i])
                }
            }

            if (this.elementsToDelete.length > 0) {
                this._deleteElements()
            }
        }
    },
    draw:function () {
        if (this.visible == true) {

            //TODO ? place for CanvasRenderer ?

//            this.elements.forEach(function (element) {
//                element.draw()
//            }, this)


            for(var i = 0, l = this.elements.length; i < l; i++){
                this.elements[i].draw()
            }


        }
    },
    _deleteElements:function () {
        this.elementsToDelete.reverse()
        this.elementsToDelete.forEach(this._deleteElement, this)
        this.elementsToDelete = []
    },
    _deleteElement:function (elementToDelete) {
        this.elements.splice(elementToDelete, 1)
    },

    /**
     * @description Add new element to the layer. This could be a CG.Sprite, CG.Animation, CG.Button and so on. Every thing that has a update and draw method ;o)
     * @method addElement
     * @param {obj} element to add to elements array
     */
    addElement:function (element) {
        this.elements.push(element)
        return this
    },

    /**
     * @description Find element by name (the first one)
     * @method getElementByName
     * @param {string} elementname name of element to find in element array
     * @return {false/object} returns false or the searched object
     */
    getElementByName:function (elementname) {
        for (var i = 0, l = this.elements.length; i < l; i++) {
            if (this.elements[i].name == elementname) {
                return this.elements[i]
            }
        }
        return false
    },

    /**
     * @description Find elements by name (if they have the same name ;o)
     * @method getElementsByName
     * @param {string} elementname name of element to find in element array
     * @return {array} returns a array of objects
     */
    getElementsByName:function (elementname) {
        elements = []
        for (var i = 0, l = this.elements.length; i < l; i++) {
            if (this.elements[i].name == elementname) {
                elements.push(this.elements[i])
            }
        }
        return elements
    }
})



/**
 * @description
 *
 * CG.MapTileLayer
 *
 * @class CG.MapTileLayer
 * @extends Class
 */
CG.Class.extend('MapTileLayer', {
    /**
     * @constructor
     * @method init
     * @return {*}
     */
    init:function () {
        /**
         * @property width
         * @type {Number}
         */
        this.width = 0
        /**
         * @property height
         * @type {Number}
         */
        this.height = 0
        /**
         * @property visible
         * @type {Boolean}
         */
        this.visible = true
        /**
         * @property opacity
         * @type {Number}
         */
        this.opacity = 1
        /**
         * @property tiles
         * @type {Array}
         */
        this.tiles = []
        return this
    }
})


/**
 * @description
 *
 * CG.MapTileProperties
 *
 * @class CG.MapTileProperties
 * @extends Class
 */
CG.Class.extend('MapTileProperties', {
    /**
     * @method init
     * @constructor
     * @return {*}
     */
    init:function () {
        /**
         * @property animated
         * @type {Boolean}
         */
        this.animated = false
        /**
         * @property animDelay
         * @type {Number}
         */
        this.animDelay = 0
        /**
         * @property animDirection
         * @type {Number}
         */
        this.animDirection = 0 // >0 = forward, <0 = backward, 0 = paused
        /**
         * @property animNext
         * @type {Number}
         */
        this.animNext = 0
        /**
         * @property delayTimer
         * @type {Number}
         */
        this.delayTimer = 0
        return this
    }
})


/**
 * @description
 *
 * CG.MapPoint. Support now for name, gid and x/y-position values. No tilemap properties at the moment.
 *
 * @class CG.MapPoint
 * @extends CG.Class
 *
 */
CG.Class.extend('MapPoint', {
    /**
     * @method init
     * @constructor
     * @param position {point} position point
     * @param mapoffset {point} mapoffset reference to the current map position
     * @param name {string} name of the tile
     * @param gid {Number} gid number of tilemap editor
     * @return {*}
     */
    init:function (position, mapoffset, name, gid) {
        /**
         * @property initposition
         * @type {CG.Point}
         */
        this.initposition = position || new CG.Point(0, 0)
        /**
         * @property mapoffset
         * @type {CG.Point}
         */
        this.mapoffset = mapoffset || new CG.Point(0, 0)
        /**
         * @description gid
         * @type {Number}
         */
        this.gid = gid
        /**
         * @property name
         * @type {*}
         */
        this.name = name
        /**
         * @property position
         * @type {CG.Point}
         */
        this.position = new CG.Point(position.x, position.y) //for reference use
        return this
    },

    update:function () {
        this.position.x = this.initposition.x - this.mapoffset.x
        this.position.y = this.initposition.y - this.mapoffset.y
    }
})


/**
 * @description
 *
 * CG.MapArea. Support now for name and the bound values.
 *
 * @class CG.MapArea
 * @extends CG.Class
 */
CG.Class.extend('MapArea', {
    /**
     * @constructor
     * @method init
     * @param bound {CG.Bound} bound of area
     * @param mapoffset {CG.Point} mapoffset reference to the current map position
     * @param name {string} name of the group
     * @param type {false/string} type (a property) of area for collision detection or what ever ;o)
     * @return {*}
     */
    init:function (bound, mapoffset, name, type) {
        /**
         * @property initbound
         * @type {CG.Bound}
         */
        this.initbound = bound || new CG.Bound(0, 0, 0, 0)
        /**
         * @property mapoffset
         * @type {CG.Point}
         */
        this.mapoffset = mapoffset || new CG.Point(0, 0)
        /**
         * @property name
         * @type {String}
         */
        this.name = name
        /**
         * @property type
         * @type {String}
         */
        this.type = type || false       //false, inner or outer

        /**
         * @property bound
         * @type {CG.Bound}
         */
        this.bound = new CG.Bound(bound.x, bound.y, bound.width, bound.height)
        return this
    },

    update:function () {
        this.bound.x = this.initbound.x - this.mapoffset.x
        this.bound.y = this.initbound.y - this.mapoffset.y
    }
})


/**
 * @description
 *
 * CG.Map supports loading and rendering maps from the editor Tiled.
 * XML and JSON file types are supported.
 * XML => supported tiled encodings are csv and xml (see settings!). base64, base64(gzip) and base64(zlib) are not supported!
 *
 * Supported types of the object layer are:
 * - object/group (rectangle?)
 * - tile element, reference point is bottom/CG.LEFT
 *
 * These object layer types are used to generate Point and Bound objects and can be used to position sprites, what ever in the map.
 *
 * @class CG.Map
 * @extends CG.Entity
 *
 * TODO spacing and margin ?
 * TODO own buffer for drawing => split screen possible?
 * TODO update & draw method 50%
 *
 */
CG.Entity.extend('Map', {
    /**
     * @method init
     * @constructor
     * @param width {Number} width of the map
     * @param height {Number} height of the map
     * @param mapname {string} mapname
     * @return {*}
     */
    init:function (width, height, mapname) {
        this._super(mapname)

        /**
         * @property elements
         * @type {Array}
         */
        this.elements = [] //how handle elements in maps? experimental collision detection at the moment with only one
        //point and areas from tilemap editor
        //using as references for external objects in layers?
        //how to handle the relative position to the position of the map?

        /**
         * @property points
         * @type {Array}
         */
        this.points = [] // position points (tiles) of tilemap editor => position point and type?
        /**
         * @property areas
         * @type {Array}
         */
        this.areas = [] // group objects e.g. area for objects of tilemap editor => bound and type?
        /**
         * @property position
         * @type {CG.Point}
         */
        this.position = new CG.Point(0, 0) // needed as relative point for points and areas
        /**
         * @property changemap
         * @type {String}
         */
        this.changemap = ''
        /**
         * @description
         *
         * If set to true the map is being updated with method updateAnimation.
         * See also method description of updateAnimation!
         *
         * @property animated
         * @type {Boolean}
         */
        this.animated = false //performance eater if true ;o(
        /**
         * @property animDelayFactor
         * @type {Number}
         */
        this.animDelayFactor = 20
        /**
         * @property atlas
         * @type {Image}
         */
        this.atlas = new Image()
        /**
         * @property atlaswidth
         * @type {Number}
         */
        this.atlaswidth = 0
        /**
         * @property atlasheight
         * @type {Number}
         */
        this.atlasheight = 0
        /**
         * @property atlastranscol
         * @type {String}
         */
        this.atlastranscol = '' //
        //ejecta has no DOMParser!
        if (typeof(ejecta) == 'undefined') {
            /**
             * @property xml
             * @type {String}
             */
            this.xml = ''
            /**
             * @property parser
             * @type {DOMParser}
             */
            this.parser = new DOMParser()
            /**
             * @property xmlDoc
             * @type {String}
             */
            this.xmlDoc = ''
        }
        /**
         * @property json
         * @type {Object}
         */
        this.json = {}
        /**
         * @description
         *
         * The tiled layer are parsed into separate layers
         *
         * @property layers
         * @type {Array}
         */
        this.layers = [] //can contain maptilelayer or objectlayer
        /**
         * @description
         *
         * Defines the layer to draw:
         * all - for all layers
         * name - the name of layer to draw
         * index - array index of layer
         *
         * @property renderlayer
         * @type {String}
         */
        this.renderlayer = 'all' //render layer: all for all layers, name of layer or array index for example 0 ;o)
        /**
         * @property tileproperties
         * @type {Array}
         */
        this.tileproperties = [] //properties of the tiles
        /**
         * @property orientation
         * @type {String}
         */
        this.orientation = ''
        /**
         * @property width
         * @type {Number}
         */
        this.width = 0
        /**
         * @property height
         * @type {Number}
         */
        this.height = 0
        /**
         * @property tilewidth
         * @type {Number}
         */
        this.tilewidth = 0
        /**
         * @property tileheight
         * @type {Number}
         */
        this.tileheight = 0
        /**
         * @property tileset
         * @type {Object}
         */
        this.tileset = {
            tilewidth:0,
            tileheight:0,
            offsetx:0,
            offsety:0,
            spacing:0,
            margin:0
        }
        /**
         * @property xspeed
         * @type {Number}
         */
        this.xspeed = 0
        /**
         * @property yspeed
         * @type {Number}
         */
        this.yspeed = 0
        /**
         * @property xscale
         * @type {Number}
         */
        this.xscale = 1
        /**
         * @property yscale
         * @type {Number}
         */
        this.yscale = 1
        /**
         * @property alpha
         * @type {Number}
         */
        this.alpha = 1
        /**
         * @property wrapX
         * @deprecated
         * @type {Boolean}
         */
        this.wrapX = false //stuff from diddy?
        /**
         * @property wrapY
         * @deprecated
         * @type {Boolean}
         */
        this.wrapY = false //stuff from diddy?
        /**
         * @property layertocheck
         * @type {Number}
         */
        this.layertocheck = 0 //as default use layer 0 for collision detection
        return this
    },
    /**
     * @description
     *
     * Load and parse an xml tilemap file. It can handle the tiled XML and CSV format.
     * All other formats are not supported!
     *
     * @method loadMapXml
     * @param xmlfile {string/object} xmlfile path or mediaasset object with data of tiled map xml
     */
    loadMapXml:function (xmlfile) {
        this.changemap = ''
        this.animated = false
        this.layers = []

        //from asset
        if (typeof xmlfile == 'string') {
            this.xml = loadString(xmlfile)
        } else {
            this.xml = xmlfile.data
        }
        this.removeJsonData()

        this.xmlDoc = this.parser.parseFromString(this.xml, 'text/xml')

        //get map
        var tilemap = map.xmlDoc.getElementsByTagName('map')[0]
        this.orientation = tilemap.getAttribute('orientation')
        this.width = parseInt(tilemap.getAttribute('width'))
        this.height = parseInt(tilemap.getAttribute('height'))
        this.tilewidth = parseInt(tilemap.getAttribute('tilewidth'))
        this.tileheight = parseInt(tilemap.getAttribute('tileheight'))

        var childcount = tilemap.childElementCount

        //tilemap.firstElementChild.nextElementSibling.nextElementSibling
        var element = tilemap.firstElementChild
        for (i = 0; i < childcount; i++) {
            console.log('>' + element.nodeName)
            switch (element.nodeName) {
                case 'tileset':
                    //read tileset settings
                    //only one tileset for the moment
                    this.tileset.tilewidth = parseInt(element.getAttribute('tilewidth'))
                    this.tileset.tileheight = parseInt(element.getAttribute('tileheight'))
                    if (element.getAttribute('spacing')) {
                        this.tileset.spacing = parseInt(element.getAttribute('spacing'))
                    }
                    if (element.getAttribute('margin')) {
                        this.tileset.margin = parseInt(element.getAttribute('margin'))
                    }
                    if (element.getElementsByTagName('tileoffset')[0]) {
                        this.tileset.offsetx = parseInt(element.getElementsByTagName('tileoffset')[0].getAttribute('x'))
                        this.tileset.offsety = parseInt(element.getElementsByTagName('tileoffset')[0].getAttribute('y'))
                    }
                    var image = element.getElementsByTagName('image')[0]
                    this.atlas.src = 'media/map/' + image.getAttribute('source')

                    this.atlaswidth = parseInt(image.getAttribute('width'))
                    this.atlasheight = parseInt(image.getAttribute('height'))
                    this.atlastranscol = image.getAttribute('trans')

                    break
                case 'layer':
                    //get tilemap data of layer
                    var tl = new CG.MapTileLayer()
                    data = element.getElementsByTagName('data')[0]

                    if (data.getAttribute('encoding') == 'csv') {
                        tl.tiles = data.textContent.replace(/(\r\n|\n|\r)/gm, '').split(',')
                        console.log('map encoding csv [layer ' + i + ']')
                    } else if (data.getAttribute('encoding') == 'base64' && data.getAttribute('compression') == 'gzip') {
                        throw 'base64 gzip compressed map format not supported at the moment'
                    } else if (data.getAttribute('encoding') == 'base64' && data.getAttribute('compression') == 'zlib') {
                        throw 'base64 zlib compressed map format not supported at the moment'
                    } else if (data.getAttribute('encoding') == 'base64') {
                        throw 'base64 map format not supported at the moment'
                    } else {
                        console.log('map encoding xml [layer ' + i + ']')
                        var tiles = element.getElementsByTagName('tile')
                        for (x in tiles) {
                            if (x < tiles.length) {
                                tl.tiles[x] = parseInt(tiles[x].getAttribute('gid'))
                            }
                        }
                    }

                    tl.name = element.getAttribute('name')
                    tl.width = parseInt(element.getAttribute('width'))
                    tl.height = parseInt(element.getAttribute('height'))
                    if (element.getAttribute('opacity')) {
                        tl.opacity = parseFloat(element.getAttribute('opacity'))
                    }
                    if (element.getAttribute('visible') === '0') {
                        tl.visible = false
                    }
                    this.layers.push(tl)
                    break
                case 'objectgroup':
                    //get tilemap data of grouplayer
                    console.log('grouplayer found')
                    var objects = element.getElementsByTagName('object')
                    for (o in objects) {
                        if (o < objects.length) {
                            var obj = objects[o]
                            var name = obj.getAttribute('name')
                            if (obj.getAttribute('gid')) {
                                //tile as object/point
                                this.points.push(
                                    new CG.MapPoint(
                                        new CG.Point(
                                            parseInt(obj.getAttribute('x')), parseInt(obj.getAttribute('y'))), this.position, obj.getAttribute('name'), parseInt(obj.getAttribute('gid'))))
                                console.log('tile as oject found: ' + name)
                                console.log(obj)
                            } else if (obj.getAttribute('width')) {
                                type = false
                                properties = obj.getElementsByTagName('property')
                                console.log(properties.length)
                                for (var p = 0, l = properties.length; p < l; p++) {
                                    if (properties[p].getAttribute('name') == 'type') {
                                        type = properties[p].getAttribute('value')
                                    }
                                }

                                //object group
                                this.areas.push(
                                    new CG.MapArea(
                                        new CG.Bound(
                                            parseInt(obj.getAttribute('x')), parseInt(obj.getAttribute('y')), parseInt(obj.getAttribute('width')), parseInt(obj.getAttribute('height'))), this.position, obj.getAttribute('name'), type))
                                console.log('group object found: ' + name)
                                console.log(obj)
                            } else if (obj.getElementsByTagName('polygon').length > 0) {
                                console.log('polygon found: ' + name)
                            } else if (obj.getElementsByTagName('polyline').length > 0) {
                                console.log('polyline found: ' + name)
                            }
                        }
                    }
                    break

            }
            element = element.nextElementSibling
        }


        //get tile properties
        this.tileproperties = Array(parseInt((this.atlaswidth / this.tilewidth)) * parseInt((this.atlasheight / this.tileheight)))
        var tiles = map.xmlDoc.getElementsByTagName('tileset')[0].getElementsByTagName('tile')
        var time = new Date().getTime()
        for (i in tiles) {
            var tprop = new CG.MapTileProperties()
            var tile = tiles[i]

            if (i < this.tileproperties.length) {
                var id = tile.getAttribute('id')
                var properties = tile.getElementsByTagName('properties')[0].getElementsByTagName('property')
                for (p in properties) {
                    if (p < properties.length) {
                        var tp = properties[p]
                        var elem = tp.getAttribute('name')
                        var value = tp.getAttribute('value')
                        if (elem == 'name') {
                            tprop.name = value
                        } else if (elem == 'anim_delay') {
                            tprop.animDelay = parseInt(value)
                            tprop.delayTimer = time
                            this.animated = true
                        } else if (elem == 'anim_direction') {
                            tprop.animDirection = parseInt(value)
                        } else if (elem == 'anim_next') {
                            tprop.animNext = parseInt(value)
                            tprop.animated = true
                        }
                    }
                }
                this.tileproperties[id] = tprop
            }
        }
        return this
    },

    /**
     * @description
     *
     * Load and parse an tilemap json file. Use the tiled json export.
     * Hopefully the json format has the same functionality as the xml loader ;o)
     *
     * @method loadMapJson
     * @param jsonfile {string/object} jsonfile path or mediaasset object with data of tiled map xml
     */
    loadMapJson:function (jsonfile) {
        this.changemap = ''
        this.animated = false
        this.layers = []

        //from asset
        if (typeof jsonfile == 'string') {
            this.json = JSON.parse(loadString(jsonfile))
        } else {
            this.json = jsonfile.data
        }

        this.removeXmlData()

        //get map
        this.orientation = this.json.orientation
        this.width = this.json.width
        this.height = this.json.height
        this.tilewidth = this.json.tilewidth
        this.tileheight = this.json.tileheight

        //tilesets
        for (i = 0, l = this.json.layers.length; i < l; i++) {
            switch (this.json.layers[i].type) {
                case 'tilelayer':
                    //get tilemap data of layer
                    var tl = new CG.MapTileLayer()
                    tl.tiles = this.json.layers[i].data
                    tl.name = this.json.layers[i].name
                    tl.width = this.json.layers[i].width
                    tl.height = this.json.layers[i].height
                    tl.opacity = this.json.layers[i].opacity
                    tl.visible = this.json.layers[i].visible
                    this.layers.push(tl)
                    break
                case 'objectgroup':
                    //get tilemap data of grouplayer
                    console.log('grouplayer found')
                    var objects = this.json.layers[i].objects
                    for (o in objects) {
                        if (o < objects.length) {
                            var obj = objects[o]
                            var name = obj.name
                            if (obj.gid) {
                                //tile as object/point
                                this.points.push(
                                    new CG.MapPoint(
                                        new CG.Point(
                                            parseInt(obj.x), parseInt(obj.y)), this.position, obj.name, parseInt(obj.gid)))

                                console.log('tile as oject found: ' + name)
                                console.log(obj)
                            } else if (obj.width) {
                                //object group
                                this.areas.push(
                                    new CG.MapArea(
                                        new CG.Bound(
                                            parseInt(obj.x), parseInt(obj.y), parseInt(obj.width), parseInt(obj.height)), this.position, obj.name, obj.properties.type))

                                console.log('group object found: ' + name)
                                console.log(obj)
                            } else if (obj.polygon) {
                                console.log('polygon found: ' + name)
                            } else if (obj.polyline) {
                                console.log('polyline found: ' + name)
                            }
                        }
                    }
                    break

            }
        }


        //get tile properties
        this.atlas.src = 'media/map/' + this.json.tilesets[0].image

        this.atlaswidth = this.json.tilesets[0].imagewidth
        this.atlasheight = this.json.tilesets[0].imageheight
        this.atlastranscol = this.json.tilesets[0].transparentcolor

        this.tileproperties = Array(parseInt((this.atlaswidth / this.tilewidth)) * parseInt((this.atlasheight / this.tileheight)))
        var tiles = this.json.tilesets[0].tileproperties

        var time = new Date().getTime()

        for (id in tiles) {
            var tprop = new CG.MapTileProperties()
            var tile = tiles[id]
            tprop.name = tile.name
            tprop.animDelay = parseInt(tile.anim_delay)
            tprop.delayTimer = (tprop.animDelay > 0) ? time : 0
            tprop.animated = (tprop.animDelay > 0) ? true : false
            tprop.animNext = parseInt(tile.anim_next)
            if (tprop.animDelay > 0) {
                this.animated = true
            }
            tprop.animDirection = parseInt(tile.anim_direction)
            this.tileproperties[id] = tprop

        }
        return this
    },


    /**
     * @description
     *
     * This is the main method for map drawing. Orthogonal maps works very well. Isometric maps are not well implemented yet.
     *
     * @method drawMap
     *
     * @param sx {Number} sx top left coord for canvas drawing
     * @param sy {Number} sy top left coord for canvas drawing
     * @param bx {Number} bx top left x coord of bound in tilemap
     * @param by {Number} by top left y coord of bound in tilemap
     * @param bw {Number} bw width of bound in tilemap
     * @param bh {Number} bh height of bound in tilemap
     * @param callback {callback} callback for collision handling - callback(obj,maptileproperties)
     */
    drawMap:function (sx, sy, bx, by, bw, bh, callback) {
        this.position.x = bx
        this.position.y = by

        this.bx = bx || this.bx || 0
        this.by = by || this.by || 0
        this.bw = bw || Game.bound.width
        this.bh = bh || Game.bound.height
        this.sx = sx || this.sx || 0
        this.sy = sy || this.sy || 0
        this.callback = callback || false

        //update all points an areas
        this.updatePointsAndAreas()

        if (this.changemap != '') {
            this.loadMap(this.changemap)
        }
        if (this.visible) {
            this.updateAnimation()
            if (this.layers.length > 0) {
                for (var layer = 0, l = this.layers.length; layer < l; layer++) {
                    var tl = this.layers[layer]
                    //render control, render by name, layer number or 'all''
                    if (this.renderlayer == tl.name || this.renderlayer == layer || this.renderlayer == 'all') {
                        // MAP ORTHOGONAL
                        if (this.orientation == 'orthogonal' && tl.visible == true) {
                            modx = (this.bx * this.xscale) % this.tilewidth
                            mody = (this.by * this.yscale) % this.tileheight
                            y = this.by
                            my = Math.floor(parseFloat(this.by) / parseFloat(this.tileheight)) >> 0

                            var tmpy = (this.by + this.bh + this.tileheight)
                            while (y < tmpy) {
                                x = this.bx //- this.tilewidth
                                mx = Math.floor(parseFloat(this.bx) / parseFloat(this.tilewidth)) >> 0

                                var tmpx = (this.bx + this.bw + this.tilewidth)
                                while (x < tmpx) {
                                    if ((this.wrapX || (mx >= 0 && mx < this.width)) && (this.wrapY || (my >= 0 && my < this.height))) {
                                        mx2 = mx
                                        my2 = my

                                        while (mx2 < 0) {
                                            mx2 += this.width
                                        }

                                        while (mx2 >= this.width) {
                                            mx2 -= this.width
                                        }

                                        while (my2 < 0) {
                                            my2 += this.height
                                        }

                                        while (my2 >= this.height) {
                                            my2 -= this.height
                                        }

                                        gid = tl.tiles[mx2 + my2 * tl.width] - 1

                                        if (gid >= 0) {
                                            if (modx < 0) {
                                                modx += this.tilewidth
                                            }
                                            if (mody < 0) {
                                                mody += this.tileheight
                                            }
                                            rx = x - modx - this.bx
                                            ry = y - mody - this.by


                                            //time for collision detection?
                                            //limit to specific tilemap layer?
                                            //collision depending on bounds and direction (xspeed/yspeed)?
                                            //include some layer functionality here and render some sprites between map layers?
                                            if (this.elements.length > 0 && this.layertocheck == l) {
                                                for (var o = 0, l = this.elements.length; o < l; o++) {
                                                    if (this.checkMapCollision(this.elements[0], rx, ry)) {
                                                        this.callback(this.elements[o], this.tileproperties[gid])
                                                    }
                                                }
                                            }


                                            //margin/spacing?
                                            cx = (gid % (this.atlaswidth / this.tilewidth)) * this.tilewidth
                                            cy = Math.floor(this.tilewidth * gid / this.atlaswidth) * this.tileheight

                                            Game.b_ctx.save()
                                            Game.b_ctx.globalAlpha = this.layers[layer].opacity
                                            Game.b_ctx.translate(rx, ry)
                                            try {
                                                Game.b_ctx.drawImage(this.atlas, cx, cy, this.tilewidth, this.tileheight, this.sx, this.sy, this.tilewidth * this.xscale, this.tileheight * this.yscale)
                                            } catch (e) {
                                            }
                                            Game.b_ctx.restore()
                                        }
                                    }
                                    x = x + this.tilewidth
                                    mx += 1
                                }
                                y = y + this.tileheight
                                my += 1
                            }
                        }
                        // MAP ISOMETRIC
                        else if (this.orientation == 'isometric') {
                            var t = tl.width + tl.height
                            for (var y = 0; y < t; y++) {
                                var ry = y
                                var rx = 0
                                while (ry >= tl.height) {
                                    ry -= 1
                                    rx += 1
                                }


                                while (ry >= 0 && rx < tl.width) {
                                    var gid = tl.tiles[rx + ry * tl.width]
                                    var xpos = (rx - ry - 1) * this.tilewidth / 2 - bx
                                    var ypos = (rx + ry + 1) * this.tileheight / 2 - by
                                    if (xpos > -this.tileset.tilewidth && xpos < bw && ypos > -this.tileset.tileheight && ypos < bh) {
                                        if (gid > 0) {
                                            cx = ((gid - 1) % (this.atlaswidth / this.tilewidth)) * this.tilewidth
                                            cy = Math.floor(this.tilewidth * (gid - 1) / this.atlaswidth) * this.tileset.tileheight
                                            Game.b_ctx.save()
                                            Game.b_ctx.globalAlpha = this.layers[layer].opacity
                                            Game.b_ctx.translate(xpos, ypos)
                                            try {
                                                Game.b_ctx.drawImage(this.atlas, cx, cy, this.tilewidth, this.tileset.tileheight, 0, 0, this.tilewidth * this.xscale, this.tileset.tileheight * this.yscale)
                                            } catch (e) {

                                            }
                                            Game.b_ctx.restore()
                                        }
                                    }
                                    ry -= 1
                                    rx += 1
                                }
                            }
                        }
                    }
                    //                else {
                    //                    throw 'unknown orientation: ' + this.orientation
                    //                }
                }
            }
        }
    },

    /**
     * @description
     *
     * Update all areas and points elements.
     *
     * @method updatePointsAndAreas
     */
    updatePointsAndAreas:function () {
        this.points.forEach(function (point, index) {
            point.update()
        }, this)
        this.areas.forEach(function (area, index) {
            area.update()
        }, this)
    },


    /**
     * @description
     *
     * Get all point(s) with the given name in the points
     *
     * @method getPointsByName
     *
     * @param name {string} name of the points to return
     * @return {false/array} returns false or an array with point(s)
     */
    getPointsByName:function (name) {
        points = []
        for (var i = 0, l = this.points.length; i < l; i++) {
            if (this.points[i].name === name) {
                points.push(this.points[i])
            }
        }
        if (points.length > 0) {
            return points
        }
        return false
    },

    /**
     * @description
     *
     * Get all areas with the given name
     *
     * @method getAreasByName
     *
     * @param name {string} name of the area(s) to return
     * @return {false/array} returns false or an array with area(s)
     */
    getAreasByName:function (name) {
        areas = []
        for (var i = 0, l = this.areas.length; i < l; i++) {
            if (this.areas[i].name === name) {
                areas.push(this.areas[i])
            }
        }
        if (areas.length > 0) {
            return areas
        }
        return false
    },


    /**
     * @description
     *
     * Defines layer drawing, See property options
     *
     * @method setLayerToRender
     *
     * @param mixed {mixed} mixed define the map layer(s) to render 'all' (string) for all layers, array index (integer) for layer to render or 'name' (string) of layer to render'
     */
    setLayerToRender:function (mixed) {
        this.renderlayer = mixed
        return this
    },

    /**
     * @description
     *
     * The update method is not complete yet and only experimental.
     * At the final stage the methods updateAnimation and updatePointsAndAreas have to be called from here!
     * Then also a map class can be added to a layer as an element for auto update/draw from Game.director!
     *
     * @method update
     */
    update:function () {
        //TODO automatic movement of map or other stuff?
        this.bx += this.xspeed
        this.by += this.yspeed
        if (this.getBounds().width - Game.bound.width < this.bx) {
            this.xspeed = this.xspeed * -1
        }
        if (this.bx < 0) {
            this.xspeed = this.xspeed * -1
        }
        if (this.getBounds().height - Game.bound.height < this.by) {
            this.yspeed = this.yspeed * -1
        }
        if (this.by < 0) {
            this.yspeed = this.yspeed * -1
        }
        return this
    },

    /**
     * yust calls drawMap ;o)
     */
    draw:function () {
        this.drawMap(this.bx, this.by, this.bw, this.bh, this.sx, this.sy, this.callback)
        return this
    },

    /**
     * @description
     *
     * Get the bounds of the map
     *
     * @method getBounds
     */
    getBounds:function () {
        return {
            width:this.width * this.tilewidth,
            height:this.height * this.tileheight
        }
    },

    /**
     * @description
     *
     * Updates all tilemap properties of the map.
     *
     * Supported custom tiled map properties for now are (see also tilemap examples):
     * anim_delay       => time to used to display an switch to next tile
     * anim_direction   => direction for next tile 1 = jump forward, -1 = jump back
     * anim_next        => defines the offset
     *
     * With this tile properties it is possible to define tilemap animations.
     * These must be defined in the tilemap property window with key/value pairs
     *
     * @method updateAnimation
     */
    updateAnimation:function () {
        // update if map is visible
        if (this.visible && this.animated) {
            if (this.layers.length > 0) {
                for (var layer = 0, l = this.layers.length; layer < l; layer++) {
                    var newtime = new Date().getTime()
                    for (t = 0; t < this.layers[layer].tiles.length; t++) {
                        var tile = this.layers[layer].tiles[t]
                        if (tile > 0) {
                            try {
                                var tprop = this.tileproperties[tile - 1]
                                if (tprop.animated && tprop.animDirection != 0) {
                                    if (newtime > (tprop.delayTimer + (tprop.animDelay / this.animDelayFactor))) {
                                        switch (tprop.animDirection) {
                                            case 1:
                                                this.layers[layer].tiles[t] += tprop.animNext
                                                this.tileproperties[tile - 1 + tprop.animNext].delayTimer = newtime
                                                break
                                            case -1:
                                                this.layers[layer].tiles[t] -= tprop.animNext
                                                this.tileproperties[tile - 1 - tprop.animNext].delayTimer = newtime
                                                break
                                            default:
                                                break
                                        }
                                    }
                                }
                            } catch (e) {

                            }
                        }
                    }
                }
            }
        }
    },

    /**
     * @description
     *
     * Adds a object to the element array, used at the moment for collision detection to tilemap.
     *
     * @method addElement
     *
     * @param {obj} element to to add to elements array
     */
    addElement:function (element) {
        this.elements.push(element)
        return this
    },

    /**
     * @description
     * Checks if the attached element collides with an tile of the tilemap
     *
     * @method checkMapCollision
     *
     * @param {obj} element to check for
     * @param {Number} rx current rx of rendermap method
     * @param {Number} ry current ry of rendermap method
     *
     * @return {boolean} returns true or false
     */
    checkMapCollision:function (element, rx, ry) {
        //TODO return detailed collision object or offsets instead of true?
        if (element.boundingradius > 0) {
            //circular collision
            xr = element.boundingradius / 2 * element.xscale
            yr = element.boundingradius / 2 * element.yscale
            if (element.position.x + xr >= rx && element.position.x - xr <= rx + this.tilewidth && element.position.y + yr >= ry && element.position.y - yr <= ry + this.tileheight) {
                return true
            }
        } else {
            //bounding collision
            xw = element.width / 2 * element.xscale
            yh = element.height / 2 * element.yscale
            if (element.position.x + xw >= rx && element.position.x - xw <= rx + this.tilewidth && element.position.y + yh >= ry && element.position.y - yh <= ry + this.tileheight) {
                return true
            }
        }
        return false
    },

    /**
     * @description
     *
     * Checks if a external object(s) collides with the areas of the tiled map.
     * This can be elements from an layer or the map itself.
     *
     * @param {Array} objarray to check for a areas collision
     * @param {Callback} callback what should happen
     */
    checkElementsToAreasCollision:function (objarray, callback) {
        for (var o = 0, ol = objarray.length; o < ol; o++) {

            obj = objarray[o].checkCollision(this.areas, callback)
        }
        return this
    },

    /**
     * @description removes the json data of the map object
     * @method removeJsonData
     */
    removeJsonData:function () {
        this.json = {}
        return this
    },
    /**
     * @description removes the xml data of the map object
     * @method removeXmlData
     */
    removeXmlData:function () {
        this.xml = ''
        //this.parser = new DOMParser()
        this.xmlDoc = ''
        return this
    }
})


/**
 * @description
 *
 * CG.Sequence container to collect/group CG.Translation objects
 *
 * @class CG.Sequence
 * @extends Entity
 */
CG.Entity.extend('Sequence', {
    /**
     * @constructor
     * @method init
     * @param sequencename
     * @return {*}
     */
    init: function (sequencename) {
        this._super(sequencename)
        /**
         * @property current
         * @type {Number}
         */
        this.current = 0
        /**
         * @property loop
         * @type {Boolean}
         */
        this.loop = false
        /**
         * @property translations
         * @type {Array}
         */
        this.translations = []
        return this
    },
    /**
     * @description add a translation object to the sequence array
     * @method addTranslation
     * @param translationobj {translation} the translation object to add
     * @return {*}
     */
    addTranslation: function (translationobj) {
        this.translations.push(translationobj)
        return this
    },
    update: function (callback) {
        if (this.current < this.translations.length) {
            if (this.translations[this.current].finished === false) {
                this.translations[this.current].update()
            } else {
                this.current += 1
            }
        } else {
            if (this.loop) {
                this.reset()
            } else {
                //callback?
            }
        }
    },
    draw: function () {

    },
    reset: function () {
        for (var i = 0, l = this.translations.length; i < l; i++) {
            this.translations[i].reset()
        }
        this.current = 0
        return this
    }
})


/**
 * @description
 *
 * CG.Translate moving a object
 *
 * @class CG.Translate
 * @extends CG.Entity
 */
CG.Entity.extend('Translate', {
    /**
     * @init
     * @constructor
     * @return {*}
     */
    init:function () {
        this._super()
        /**
         * @property type
         * @type {String}
         */
        this.type = ''
        /**
         * @property tx
         * @type {Number}
         */
        this.tx = 0 //translated x value for the object
        /**
         * @property ty
         * @type {Number}
         */
        this.ty = 0 //translated y value for the object
        /**
         * @properzty x1
         * @type {Number}
         */
        this.x1 = 0
        /**
         * @property y1
         * @type {Number}
         */
        this.y1 = 0
        /**
         * @property x2
         * @type {Number}
         */
        this.x2 = 0
        /**
         * @property y2
         * @type {Number}
         */
        this.y2 = 0
        /**
         * @property bx
         * @type {Number}
         */
        this.bx = 0 //b√©zier x
        /**
         * @property by
         * @type {Number}
         */
        this.by = 0 //b√©zier y
        /**
         * @property theobj
         * @type {Object}
         */
        this.theobj = {}
        /**
         * @property r1
         * @type {Number}
         */
        this.r1 = 0
        /**
         * @property r2
         * @type {Number}
         */
        this.r2 = 0
        /**
         * @property startangle
         * @type {Number}
         */
        this.startangle = 0
        /**
         * @property angle
         * @type {Number}
         */
        this.angle = 0
        /**
         * @property speed
         * @type {Number}
         */
        this.speed = 0
        /**
         * @property steps
         * @type {Number}
         */
        this.steps = 0
        /**
         * @property step
         * @type {Number}
         */
        this.step = 0
        /**
         * @property positions
         * @type {Array}
         */
        this.positions = []
        /**
         * @property finished
         * @type {Boolean}
         */
        this.finished = false
        return this
    },
    /**
     * @method initTween
     *
     * @param obj {Object} object to move
     * @param steps {Number} steps of tween
     * @param startpoint {point} startpoint of tween
     * @param endpoint {point} endpoint of tween
     * @return {this}
     */
    initTween:function (obj, steps, startpoint, endpoint) {
        this.type = 'tween'
        this.theobj = obj
        this.steps = steps
        this.x1 = startpoint.x
        this.y1 = startpoint.y
        this.x2 = endpoint.x
        this.y2 = endpoint.y

        var xstep = (this.x2 - this.x1) / this.steps
        var ystep = (this.y2 - this.y1) / this.steps
        var tx = this.x1 >> 0   //replace parseInt
        var ty = this.y1 >> 0   //replace parseInt
        //precalc positions and push to array
        for (var i = 0; i <= this.steps; i++) {
            this.positions.push(new CG.Point(tx, ty))
            tx += xstep
            ty += ystep
        }
        return this
    },

    /**
     * @method initOval
     * @param obj {Object} obj object to move
     * @param centerpoint {point} centerpoint
     * @param radius1 {Number} radius1
     * @param radius2 {Number} radius2
     * @param startangle {Number} startangle
     * @param rotation {Number} rotation
     * @return {this}
     */
    initOval:function (obj, centerpoint, radius1, radius2, startangle, rotation) {
        this.type = 'oval'
        this.theobj = obj
        this.x1 = centerpoint.x
        this.y1 = centerpoint.y
        this.r1 = radius1
        this.r2 = radius2
        this.startangle = startangle
        this.speed = rotation

        return this
    },

    /**
     * @description initBezier
     * http://13thparallel.com/archive/bezier-curves/
     *
     * @method initBezier
     *
     * @param obj {Object} obj object to move
     * @param steps {Number} steps of b√©zier curve
     * @param startpoint {CG.Point} startpoint startpoint of b√©zier
     * @param endpoint {CG.Point} endpoint endpoint of b√©zier
     * @param control1 {CG.Point} control1 point for b√©zier calculation (optional)
     * @param control2 {CG.Point} control2 point for b√©zier calculation (optional)
     * @return {this}
     */
    initBezier:function (obj, steps, startpoint, endpoint, control1, control2) {
        this.type = 'bezier'
        this.theobj = obj  //first argument is always the object to handle
        this.steps = steps
        this.start = endpoint
        this.end = startpoint

        if (this.control2 == 'undefined' && this.control1 == 'undefined') {
            this.control2 = new CG.Point(this.start.x + 3 * (this.end.x - this.start.x) / 4, this.start.y + 3 * (this.end.y - this.start.y) / 4);
        } else {
            this.control2 = control2 || control1
        }
        this.control1 = control1 || new CG.Point(this.start.x + (this.end.x - this.start.x) / 4, this.start.y + (this.end.y - this.start.y) / 4)

        b1 = function (t) {
            return (t * t * t)
        }
        b2 = function (t) {
            return (3 * t * t * (1 - t))
        }
        b3 = function (t) {
            return (3 * t * (1 - t) * (1 - t))
        }
        b4 = function (t) {
            return ((1 - t) * (1 - t) * (1 - t))
        }

        for (var i = 0; i <= this.steps; i++) {
            percent = (1 / this.steps) * i;
            var pos = new CG.Point();
            pos.x = this.start.x * b1(percent) + this.control1.x * b2(percent) + this.control2.x * b3(percent) + this.end.x * b4(percent)
            pos.y = this.start.y * b1(percent) + this.control1.y * b2(percent) + this.control2.y * b3(percent) + this.end.y * b4(percent)
            this.positions.push(pos)
        }

        return this
    },
    draw:function () {
    },
    update:function () {
        var obj = this.theobj
        switch (this.type) {
            case 'bezier':
            case 'tween':
                if (this.step < this.steps) {
                    obj.position.x = obj.position._x = this.positions[this.step].x
                    obj.position.y = obj.position._y = this.positions[this.step].y
                    this.step += 1
                } else {
                    this.finished = true
                }
                break
            case 'oval':
                var rad = this.startangle * CG.Const_PI_180
                this.tx = this.x1 - (this.r1 * Math.cos(rad))
                this.ty = this.y1 - (this.r2 * Math.sin(rad))
                this.startangle += this.speed

                if (this.startangle > 360) {
                    this.startangle = 0 + (this.startangle - 360)
                }

                obj.position.x = obj.position._x = this.tx >> 0  //replace parseInt
                obj.position.y = obj.position._y = this.ty >> 0  //replace parseInt
                break
            default:
                break
        }
    },
    draw:function () {

    },
    reset:function () {
        this.step = 0
        this.finished = false
    }

})

/*
 function drawBezier() {
 var C1 = new coord(objDragger[0].x(), objDragger[0].y());
 var C2 = new coord(objDragger[1].x(), objDragger[1].y());
 var C3 = new coord(objDragger[2].x(), objDragger[2].y());
 var C4 = new coord(objDragger[3].x(), objDragger[3].y());

 for(var i=0; i<numPixels; i++) {
 percent = (1/numPixels) * i;
 var pos = getBezier(percent, C1, C2, C3, C4);
 objPixels[i].moveTo(pos.x, pos.y);
 }
 }


 //====================================================================================
 // getBezier() - calculates a given position along a Bezier curve specified by 2,3 or
 //               4 control points.
 //====================================================================================

 //Bezier functions:
 B1 = function(t) { return (t*t*t); }
 B2 = function(t) { return (3*t*t*(1-t)); }
 B3 = function(t) { return (3*t*(1-t)*(1-t)); }
 B4 = function(t) { return ((1-t)*(1-t)*(1-t)); }

 //coordinate constructor
 coord = function (x,y) { if(!x) var x=0; if(!y) var y=0; return {x: x, y: y}; }

 //Finds the coordinates of a point at a certain stage through a bezier curve
 function getBezier(percent,startPos,endPos,control1,control2) {
 //if there aren't any extra control points plot a straight line, if there is only 1
 //make 2nd point same as 1st

 if(!control2 && !control1) var control2 = new coord(startPos.x + 3*(endPos.x-startPos.x)/4, startPos.y + 3*(endPos.y-startPos.y)/4);
 if(!control2) var control2 = control1;
 if(!control1) var control1 = new coord(startPos.x + (endPos.x-startPos.x)/4, startPos.y + (endPos.y-startPos.y)/4);

 var pos = new coord();
 pos.x = startPos.x * B1(percent) + control1.x * B2(percent) + control2.x * B3(percent) + endPos.x * B4(percent);
 pos.y = startPos.y * B1(percent) + control1.y * B2(percent) + control2.y * B3(percent) + endPos.y * B4(percent);

 return pos;
 }
 */


/**
 * @description
 *
 * CG.Morph to manipulate objects in size and so on
 *
 * @class CG.Morph
 * @extends CG.Entity
 *
 */
CG.Entity.extend('Morph', {
    /**
     * @method init
     * @constructor
     * @param mode {string} mode type of the morph object
     * @param min {Number} min min value
     * @param max {Number} max max value
     * @param speed {Number} speed speed value
     */
    init:function (mode, min, max, speed) {
        this.mode = mode
        this.min = min
        this.max = max
        this.speed = speed
        this.angle = 0
        this.rad = this.max - this.min
        this.val = 0
    },
    update:function () {
        switch (this.mode) {
            case 'sinus':
                var rad = this.angle * CG.Const_PI_180
                this.val = this.rad * Math.sin(rad)
                if (this.val < 0) {
                    this.val = this.val * -1
                }
                this.angle += this.speed

                if (this.angle > 360) {
                    this.angle = 0 + (this.angle - 360)
                }
                break
        }
        return this
    },
    draw:function () {

    },
    /**
     * @method getVal
     *
     * @return {float}
     */
    getVal:function () {
        return this.val
    }
})



/**
 * @description
 *
 * CG.Particle
 *
 * @class CG.Particle
 * @extends CG.Sprite
 *
 */

CG.Sprite.extend('Particle', {
    /**
     * @constructor
     * @method init
     * @param image {mixed} image imgpath, image object or atlasimage object to use for the particle
     */
    init:function (image) {
        this._super(image, new CG.Point(0, 0))
        /**
         * @property lifetime
         * @type {Number}
         */
        this.lifetime = 100
        /**
         * @property currtime
         * @type {Number}
         */
        this.currtime = this.lifetime
        /**
         * @property aging
         * @type {Number}
         */
        this.aging = 1
        /**
         * @property fadeout
         * @type {Boolean}
         */
        this.fadeout = false
        /**
         * @property alpha
         * @type {Number}
         */
        this.alpha = 1
        /**
         * @property gravity
         * @type {Number}
         */
        this.gravity = 0
    },
    update:function () {
        if (this.visible) {
            if (this.fadeout) {
                this.alpha = this.currtime / this.lifetime
                if (this.alpha <= 0) {
                    this.visible = false
                }
            }
            this.currtime -= this.aging
            if (this.currtime < 0) {
                this.visible = false
            }

            this.position.x += this.xspeed
            this.position.y += this.yspeed
            this.yspeed += this.gravity
            this.rotation += this.rotationspeed
        }
    },
    draw:function () {
        if (this.visible) {
            Game.b_ctx.save()
            Game.b_ctx.globalAlpha = this.alpha
            Game.b_ctx.translate(this.position.x, this.position.y)
            if (this.atlasimage) {
                Game.b_ctx.rotate((this.rotation - this.imagerotation) * CG.Const_PI_180)
                Game.b_ctx.drawImage(this.image, this.xoffset, this.yoffset, this.cutwidth, this.cutheight, 0 - (this.cutwidth / 2), 0 - (this.cutheight / 2), this.cutwidth * this.xscale, this.cutheight * this.yscale)
                Game.b_ctx.rotate((this.rotation + this.imagerotation) * CG.Const_PI_180)
            } else {
                Game.b_ctx.rotate(this.rotation * CG.Const_PI_180)
                Game.b_ctx.drawImage(this.image, 0 - (this.image.width * this.xscale / 2), 0 - (this.image.height * this.yscale / 2), this.image.width * this.xscale, this.image.height * this.yscale)
            }
            Game.b_ctx.restore()
        }
    }
})


/**
 * @description
 *
 * CG.Emitter that handles . . . particles.
 *
 * @class CG.Emitter
 * @extends CG.Entity
 *
 * @param {point} position of emitter
 */
CG.Entity.extend('Emitter', {
    /**
     * @method init
     * @constructor
     * @param position {CG.Point}
     * @return {*}
     */
    init:function (position) {
        this._super()
        /**
         * @property particle
         * @type {Array}
         */
        this.particles = []     //Particle pool delegated by emitter
        /**
         * @property maxparticles
         * @type {Number}
         */
        this.maxparticles = 50
        /**
         * @property creationtime
         * @type {Number}
         */
        this.creationtime = 100 //time when next particle would be generated/reanimated
        /**
         * @property currenttime
         * @type {Number}
         */
        this.currenttime = 0    //current counter
        /**
         * @property creationspeed
         * @type {Number}
         */
        this.creationspeed = 50 //increase for currenttime
        /**
         * @property gravity
         * @type {Number}
         */
        this.gravity = 0.05
        /**
         * @property image
         * @type {null}
         */
        this.image = null       //Image of the particle
        /**
         * @property type
         * @type {String}
         */
        this.type = ''          //point, corona, plate
        /**
         * @property position
         * @type {CG.Point}
         */
        this.position = position || new CG.Point(0, 0)
        this.position._x = this.position.x
        this.position._y = this.position.y
        /**
         * @property rotation
         * @type {Number}
         */
        this.rotation = 0       //rotation of plate emitter
        /**
         * @property width
         * @type {Number}
         */
        this.width = 200        //width of line and rectangle emitter
        /**
         * @property height
         * @type {Number}
         */
        this.height = 200       //width of rectangle emitter
        /**
         * @property radius
         * @type {Number}
         */
        this.radius = 0         //radius for corona emitter
        /**
         * @property pspeed
         * @type {Number}
         */
        this.pspeed = 10        //particle speed
        /**
         * @property protation
         * @type {Number}
         */
        this.protation = 0
        /**
         * @property pdirection
         * @type {Number}
         */
        this.pdirection = 0     //particle direction UP, DOWN, CG.LEFT, RIGHT
        /**
         * @property plifetime
         * @type {Number}
         */
        this.plifetime = 100    //particle lifetime
        /**
         * @property paging
         * @type {Number}
         */
        this.paging = 1         //particle aging
        /**
         * @property pfadeout
         * @type {Boolean}
         */
        this.pfadeout = false   //particle fadeout
        return this
    },
    /*
     * Objective-C style initialisation of all emitter types
     */

    /**
     * @description initAsPoint
     *
     * @param {mixed} image path, image or atlasimage to use for the particle
     */

    initAsPoint:function (image) {
        this.image = image
        this.type = 'point'
        return this
    },


    /**
     * @method initAsExplosion
     *
     * @param {mixed} image path, image or atlasimage to use for the particle
     * @param {Number} min value for particle speed
     * @param {Number} max value for particle speed
     */
    initAsExplosion:function (image, min, max) {
        this.image = image
        this.type = 'explosion'
        this.min = min
        this.max = max
        return this
    },

    /**
     * @method initAsCorona
     *
     * @param {mixed} image path, image or atlasimage to use for the particle
     * @param {Number} radius of the corona emitter
     */
    initAsCorona:function (image, radius) {
        this.image = image
        this.type = 'corona'
        this.radius = radius || 0
        return this
    },

    /**
     * @method initAsLine
     *
     * @param {mixed} image path, image or atlasimage to use for the particle
     * @param {Number} width of the plate emitter
     * @param {Number} direction (defined constants) of the plate emitter
     */
    initAsLine:function (image, width, direction) {
        this.image = image
        this.width = width || 200
        this.pdirection = direction || CG.UP
        this.type = 'line'
        return this
    },

    /**
     * @method initAsRectangle
     *
     * @param {mixed} image path, image or atlasimage to use for the particle
     * @param {Number} width of the plate emitter
     * @param {Number} height (defined constants) of the plate emitter
     */
    initAsRectangle:function (image, width, height) {
        this.image = image
        this.width = width || 200
        this.height = height || 200
        this.type = 'rectangle'
        return this
    },
    /**
     * @method createParticle
     * @return {*}
     */
    createParticle:function () {
        particle = new CG.Particle(this.image)
        return particle
    },

    /**
     * @method initParticle
     *
     * @param {particle} particle particle object
     */
    initParticle:function (particle) {
        if (this.pfadeout) {
            particle.fadeout = true
        }
        particle.gravity = this.gravity     //set particle gravity to emitter gravity
        particle.alpha = 1                  //set alpha back to 1
        particle.visible = true             //make particle visible again
        particle.lifetime = this.plifetime  //reset lifetime
        particle.currtime = this.plifetime
        particle.rotationspeed = this.protation
        switch (this.type) {
            case 'corona':
                var rad = this.getRandom(0, 359) * CG.Const_PI_180

                particle.position.x = this.getX() - (this.radius * Math.cos(rad))
                particle.position.y = this.getY() - (this.radius * Math.sin(rad))

                angl = Math.atan2(particle.position.x - this.getX(), particle.position.y - this.getY()) * CG.Const_180_PI

                particle.xspeed = this.pspeed * Math.sin(angl * CG.Const_PI_180)
                particle.yspeed = this.pspeed * Math.cos(angl * CG.Const_PI_180)

                break
            case 'rectangle':
                //random value in rectangle
                rndx = this.getRandom(this.width / 2 * -1, this.width / 2)
                rndy = this.getRandom(this.height / 2 * -1, this.height / 2)

                particle.position.x = this.position._x - rndx
                particle.position.y = this.position._y - rndy
                particle.xspeed = 0
                particle.yspeed = 0

                break
            case 'line':
                //random value on plate line
                rnd = this.getRandom(this.width / 2 * -1, this.width / 2)

                //handle directions of line emitter
                switch (this.pdirection) {
                    default:
                    case CG.UP:
                        particle.xspeed = 0
                        particle.yspeed = this.pspeed * -1
                        particle.position.x = rnd + this.getX()
                        particle.position.y = this.position._y
                        break
                    case CG.DOWN:
                        particle.xspeed = 0
                        particle.yspeed = this.pspeed
                        particle.position.x = rnd + this.getX()
                        particle.position.y = this.position._y
                        break
                    case CG.LEFT:
                        particle.xspeed = this.pspeed * -1
                        particle.yspeed = 0
                        particle.position.x = this.position._x
                        particle.position.y = rnd + this.getY()
                        break
                    case CG.RIGHT:
                        particle.xspeed = this.pspeed
                        particle.yspeed = 0
                        particle.position.x = this.position._x
                        particle.position.y = rnd + this.getY()
                        break
                }
                break
            case 'explosion':
                particle.position.x = this.position._x
                particle.position.y = this.position._y

                particle.xspeed = this.getRandom(this.min, this.max)
                particle.yspeed = this.getRandom(this.min, this.max)
                break
            case 'point':
            default:
                particle.xspeed = 0
                particle.yspeed = 0
                particle.position.x = this.position._x
                particle.position.y = this.position._y
                break
        }
        return particle
    },

    update:function () {
        if (this.visible) {
            this.currenttime += this.creationspeed
            //particle lifetime
            if (this.currenttime >= this.creationtime) {
                this.currenttime = 0
                if (this.particles.length < this.maxparticles) {
                    this.particles.push(this.initParticle(this.createParticle()))
                }
                else {
                    particle = this.searchInvisibleParticle()   //search inactive particle in 'pool''
                    this.initParticle(particle)
                    this.particles.sort(function (obj1, obj2) {
                            return obj1.currtime - obj2.currtime
                        }
                    )
                }
            }


            for (var i = 0, l = this.particles.length; i < l; i++) {
                this.particles[i].update()
            }
            return this
        }
    },
    draw:function () {
        if (this.visible) {
            for (var i = 0, l = this.particles.length; i < l; i++) {
                this.particles[i].draw()
            }
            return this
        }
    },
    /**
     * @description Each emitter has its own particle pool to prevent object deletion/creation. This method searches an inactive/invisible particle
     * @method searchInvisibleParticle
     */
    searchInvisibleParticle:function () {
        for (var i = 0, l = this.particles.length; i < l; i++) {
            if (this.particles[i].visible == false) {
                return this.particles[i]
            }
        }
        return this
    },

    /**
     * @method setEmitterPosition
     *
     * @param {CG.Point} position of the emitter
     */
    setEmitterPosition:function (position) {
        this.position = position
        return this
    },

    /**
     * @method  setName
     *
     * @param {string} name of the object for search with layerobject.getElementByName(name)
     */
    setName:function (name) {
        this.name = name
        return this
    },

    /**
     * @method setCreationTime
     *
     * @param {Number} creationtime
     */
    setCreationTime:function (creationtime) {
        this.creationtime = creationtime
        return this
    },
    /**
     * @method setMaxParticles
     *
     * @param {Number} maxparticle
     */
    setMaxParticles:function (maxparticle) {
        this.maxparticles = maxparticle
        return this
    },
    /**
     * @method setGravity
     *
     * @param {float} gravity for all emitter controlled particles
     */
    setGravity:function (gravity) {
        this.gravity = gravity
        return this
    },

    /**
     * @method setParticleSpeed
     *
     * @param {Number} speed set the speed of the particles
     */
    setParticleSpeed:function (speed) {
        this.pspeed = speed
        return this
    },

    /**
     * @method setProtation
     *
     * @param {mixed} rotation set the rotation of the particles
     */
    setProtation:function (rotation) {
        this.protation = rotation
        return this
    },

    /**
     * @method setPLifetime
     *
     * @param {Number} plifetime set the lifetime of the particles
     */
    setPLifetime:function (plifetime) {
        this.plifetime = plifetime
        return this
    },

    /**
     * @method activateFadeout
     * @description Activate fadeout of the particles depending on lifetime
     */
    activateFadeout:function () {
        this.pfadeout = true
        return this
    },

    /**
     * @method deactivateFadeout
     * @description Deactivate fadeout of the particles depending on lifetime
     */
    deactivateFadeout:function () {
        this.pfadeout = false
        return this
    },

    /**
     * @method getRandom
     *
     * @param {mixed} min value for random number
     * @param {mixed} max value for random number
     */
    getRandom:function (min, max) {
        return Math.random() * (max - min + 1) + min >> 0
    },

    /**
     * @method getX
     */
    getX:function () {
        return this.position._x
    },

    /**
     * @method getY
     */
    getY:function () {
        return this.position._y
    }
})


var COMPILED = !0, goog = goog || {};
goog.global = this;
goog.DEBUG = !1;
goog.LOCALE = "en";
goog.TRUSTED_SITE = !0;
goog.provide = function(a) {
    if (!COMPILED) {
        if (goog.isProvided_(a))
            throw Error('Namespace "' + a + '" already declared.');
        delete goog.implicitNamespaces_[a];
        for (var b = a; (b = b.substring(0, b.lastIndexOf("."))) && !goog.getObjectByName(b); )
            goog.implicitNamespaces_[b] = !0
    }
    goog.exportPath_(a)
};
goog.setTestOnly = function(a) {
    if (COMPILED && !goog.DEBUG)
        throw a = a || "", Error("Importing test-only code into non-debug environment" + a ? ": " + a : ".");
};
COMPILED || (goog.isProvided_ = function(a) {
    return!goog.implicitNamespaces_[a] && !!goog.getObjectByName(a)
}, goog.implicitNamespaces_ = {});
goog.exportPath_ = function(a, b, c) {
    a = a.split(".");
    c = c || goog.global;
    a[0]in c || !c.execScript || c.execScript("var " + a[0]);
    for (var e; a.length && (e = a.shift()); )
        !a.length && goog.isDef(b) ? c[e] = b : c = c[e] ? c[e] : c[e] = {}
};
goog.getObjectByName = function(a, b) {
    for (var c = a.split("."), e = b || goog.global, d; d = c.shift(); )
        if (goog.isDefAndNotNull(e[d]))
            e = e[d];
        else
            return null;
    return e
};
goog.globalize = function(a, b) {
    var c = b || goog.global, e;
    for (e in a)
        c[e] = a[e]
};
goog.addDependency = function(a, b, c) {
    if (!COMPILED) {
        var e;
        a = a.replace(/\\/g, "/");
        for (var d = goog.dependencies_, f = 0; e = b[f]; f++)
            d.nameToPath[e] = a, a in d.pathToNames || (d.pathToNames[a] = {}), d.pathToNames[a][e] = !0;
        for (e = 0; b = c[e]; e++)
            a in d.requires || (d.requires[a] = {}), d.requires[a][b] = !0
    }
};
goog.ENABLE_DEBUG_LOADER = !0;
goog.require = function(a) {
    if (!COMPILED && !goog.isProvided_(a)) {
        if (goog.ENABLE_DEBUG_LOADER) {
            var b = goog.getPathFromDeps_(a);
            if (b) {
                goog.included_[b] = !0;
                goog.writeScripts_();
                return
            }
        }
        a = "goog.require could not find: " + a;
        goog.global.console && goog.global.console.error(a);
        throw Error(a);
    }
};
goog.basePath = "";
goog.nullFunction = function() {
};
goog.identityFunction = function(a, b) {
    return a
};
goog.abstractMethod = function() {
    throw Error("unimplemented abstract method");
};
goog.addSingletonGetter = function(a) {
    a.getInstance = function() {
        if (a.instance_)
            return a.instance_;
        goog.DEBUG && (goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = a);
        return a.instance_ = new a
    }
};
goog.instantiatedSingletons_ = [];
!COMPILED && goog.ENABLE_DEBUG_LOADER && (goog.included_ = {}, goog.dependencies_ = {pathToNames: {}, nameToPath: {}, requires: {}, visited: {}, written: {}}, goog.inHtmlDocument_ = function() {
    var a = goog.global.document;
    return"undefined" != typeof a && "write"in a
}, goog.findBasePath_ = function() {
    if (goog.global.CLOSURE_BASE_PATH)
        goog.basePath = goog.global.CLOSURE_BASE_PATH;
    else if (goog.inHtmlDocument_())
        for (var a = goog.global.document.getElementsByTagName("script"), b = a.length - 1; 0 <= b; --b) {
            var c = a[b].src, e = c.lastIndexOf("?"), e =
                    -1 == e ? c.length : e;
            if ("base.js" == c.substr(e - 7, 7)) {
                goog.basePath = c.substr(0, e - 7);
                break
            }
        }
}, goog.importScript_ = function(a) {
    var b = goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_;
    !goog.dependencies_.written[a] && b(a) && (goog.dependencies_.written[a] = !0)
}, goog.writeScriptTag_ = function(a) {
    if (goog.inHtmlDocument_()) {
        var b = goog.global.document;
        if ("complete" == b.readyState) {
            if (/\bdeps.js$/.test(a))
                return!1;
            throw Error('Cannot write "' + a + '" after document load');
        }
        b.write('<script type="text/javascript" src="' +
                a + '">\x3c/script>');
        return!0
    }
    return!1
}, goog.writeScripts_ = function() {
    function a(d) {
        if (!(d in e.written)) {
            if (!(d in e.visited) && (e.visited[d] = !0, d in e.requires))
                for (var g in e.requires[d])
                    if (!goog.isProvided_(g))
                        if (g in e.nameToPath)
                            a(e.nameToPath[g]);
                        else
                            throw Error("Undefined nameToPath for " + g);
            d in c || (c[d] = !0, b.push(d))
        }
    }
    var b = [], c = {}, e = goog.dependencies_, d;
    for (d in goog.included_)
        e.written[d] || a(d);
    for (d = 0; d < b.length; d++)
        if (b[d])
            goog.importScript_(goog.basePath + b[d]);
        else
            throw Error("Undefined script input");
}, goog.getPathFromDeps_ = function(a) {
    return a in goog.dependencies_.nameToPath ? goog.dependencies_.nameToPath[a] : null
}, goog.findBasePath_(), goog.global.CLOSURE_NO_DEPS || goog.importScript_(goog.basePath + "deps.js"));
goog.typeOf = function(a) {
    var b = typeof a;
    if ("object" == b)
        if (a) {
            if (a instanceof Array)
                return"array";
            if (a instanceof Object)
                return b;
            var c = Object.prototype.toString.call(a);
            if ("[object Window]" == c)
                return"object";
            if ("[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("splice"))
                return"array";
            if ("[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("call"))
                return"function"
        } else
            return"null";
    else if ("function" == b && "undefined" == typeof a.call)
        return"object";
    return b
};
goog.isDef = function(a) {
    return void 0 !== a
};
goog.isNull = function(a) {
    return null === a
};
goog.isDefAndNotNull = function(a) {
    return null != a
};
goog.isArray = function(a) {
    return"array" == goog.typeOf(a)
};
goog.isArrayLike = function(a) {
    var b = goog.typeOf(a);
    return"array" == b || "object" == b && "number" == typeof a.length
};
goog.isDateLike = function(a) {
    return goog.isObject(a) && "function" == typeof a.getFullYear
};
goog.isString = function(a) {
    return"string" == typeof a
};
goog.isBoolean = function(a) {
    return"boolean" == typeof a
};
goog.isNumber = function(a) {
    return"number" == typeof a
};
goog.isFunction = function(a) {
    return"function" == goog.typeOf(a)
};
goog.isObject = function(a) {
    var b = typeof a;
    return"object" == b && null != a || "function" == b
};
goog.getUid = function(a) {
    return a[goog.UID_PROPERTY_] || (a[goog.UID_PROPERTY_] = ++goog.uidCounter_)
};
goog.removeUid = function(a) {
    "removeAttribute"in a && a.removeAttribute(goog.UID_PROPERTY_);
    try {
        delete a[goog.UID_PROPERTY_]
    } catch (b) {
    }
};
goog.UID_PROPERTY_ = "closure_uid_" + (1E9 * Math.random() >>> 0);
goog.uidCounter_ = 0;
goog.getHashCode = goog.getUid;
goog.removeHashCode = goog.removeUid;
goog.cloneObject = function(a) {
    var b = goog.typeOf(a);
    if ("object" == b || "array" == b) {
        if (a.clone)
            return a.clone();
        var b = "array" == b ? [] : {}, c;
        for (c in a)
            b[c] = goog.cloneObject(a[c]);
        return b
    }
    return a
};
goog.bindNative_ = function(a, b, c) {
    return a.call.apply(a.bind, arguments)
};
goog.bindJs_ = function(a, b, c) {
    if (!a)
        throw Error();
    if (2 < arguments.length) {
        var e = Array.prototype.slice.call(arguments, 2);
        return function() {
            var c = Array.prototype.slice.call(arguments);
            Array.prototype.unshift.apply(c, e);
            return a.apply(b, c)
        }
    }
    return function() {
        return a.apply(b, arguments)
    }
};
goog.bind = function(a, b, c) {
    Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? goog.bind = goog.bindNative_ : goog.bind = goog.bindJs_;
    return goog.bind.apply(null, arguments)
};
goog.partial = function(a, b) {
    var c = Array.prototype.slice.call(arguments, 1);
    return function() {
        var b = Array.prototype.slice.call(arguments);
        b.unshift.apply(b, c);
        return a.apply(this, b)
    }
};
goog.mixin = function(a, b) {
    for (var c in b)
        a[c] = b[c]
};
goog.now = goog.TRUSTED_SITE && Date.now || function() {
    return+new Date
};
goog.globalEval = function(a) {
    if (goog.global.execScript)
        goog.global.execScript(a, "JavaScript");
    else if (goog.global.eval)
        if (null == goog.evalWorksForGlobals_ && (goog.global.eval("var _et_ = 1;"), "undefined" != typeof goog.global._et_ ? (delete goog.global._et_, goog.evalWorksForGlobals_ = !0) : goog.evalWorksForGlobals_ = !1), goog.evalWorksForGlobals_)
            goog.global.eval(a);
        else {
            var b = goog.global.document, c = b.createElement("script");
            c.type = "text/javascript";
            c.defer = !1;
            c.appendChild(b.createTextNode(a));
            b.body.appendChild(c);
            b.body.removeChild(c)
        }
    else
        throw Error("goog.globalEval not available");
};
goog.evalWorksForGlobals_ = null;
goog.getCssName = function(a, b) {
    var c = function(a) {
        return goog.cssNameMapping_[a] || a
    }, e = function(a) {
        a = a.split("-");
        for (var b = [], e = 0; e < a.length; e++)
            b.push(c(a[e]));
        return b.join("-")
    }, e = goog.cssNameMapping_ ? "BY_WHOLE" == goog.cssNameMappingStyle_ ? c : e : function(a) {
        return a
    };
    return b ? a + "-" + e(b) : e(a)
};
goog.setCssNameMapping = function(a, b) {
    goog.cssNameMapping_ = a;
    goog.cssNameMappingStyle_ = b
};
!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING && (goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING);
goog.getMsg = function(a, b) {
    var c = b || {}, e;
    for (e in c) {
        var d = ("" + c[e]).replace(/\$/g, "$$$$");
        a = a.replace(RegExp("\\{\\$" + e + "\\}", "gi"), d)
    }
    return a
};
goog.getMsgWithFallback = function(a, b) {
    return a
};
goog.exportSymbol = function(a, b, c) {
    goog.exportPath_(a, b, c)
};
goog.exportProperty = function(a, b, c) {
    a[b] = c
};
goog.inherits = function(a, b) {
    function c() {
    }
    c.prototype = b.prototype;
    a.superClass_ = b.prototype;
    a.prototype = new c;
    a.prototype.constructor = a
};
goog.base = function(a, b, c) {
    var e = arguments.callee.caller;
    if (e.superClass_)
        return e.superClass_.constructor.apply(a, Array.prototype.slice.call(arguments, 1));
    for (var d = Array.prototype.slice.call(arguments, 2), f = !1, g = a.constructor; g; g = g.superClass_ && g.superClass_.constructor)
        if (g.prototype[b] === e)
            f = !0;
        else if (f)
            return g.prototype[b].apply(a, d);
    if (a[b] === e)
        return a.constructor.prototype[b].apply(a, d);
    throw Error("goog.base called from a method of one name to a method of a different name");
};
goog.scope = function(a) {
    a.call(goog.global)
};
goog.debug = {};
goog.debug.Error = function(a) {
    Error.captureStackTrace ? Error.captureStackTrace(this, goog.debug.Error) : this.stack = Error().stack || "";
    a && (this.message = String(a))
};
goog.inherits(goog.debug.Error, Error);
goog.debug.Error.prototype.name = "CustomError";
goog.string = {};
goog.string.Unicode = {NBSP: "\u00a0"};
goog.string.startsWith = function(a, b) {
    return 0 == a.lastIndexOf(b, 0)
};
goog.string.endsWith = function(a, b) {
    var c = a.length - b.length;
    return 0 <= c && a.indexOf(b, c) == c
};
goog.string.caseInsensitiveStartsWith = function(a, b) {
    return 0 == goog.string.caseInsensitiveCompare(b, a.substr(0, b.length))
};
goog.string.caseInsensitiveEndsWith = function(a, b) {
    return 0 == goog.string.caseInsensitiveCompare(b, a.substr(a.length - b.length, b.length))
};
goog.string.subs = function(a, b) {
    for (var c = 1; c < arguments.length; c++) {
        var e = String(arguments[c]).replace(/\$/g, "$$$$");
        a = a.replace(/\%s/, e)
    }
    return a
};
goog.string.collapseWhitespace = function(a) {
    return a.replace(/[\s\xa0]+/g, " ").replace(/^\s+|\s+$/g, "")
};
goog.string.isEmpty = function(a) {
    return/^[\s\xa0]*$/.test(a)
};
goog.string.isEmptySafe = function(a) {
    return goog.string.isEmpty(goog.string.makeSafe(a))
};
goog.string.isBreakingWhitespace = function(a) {
    return!/[^\t\n\r ]/.test(a)
};
goog.string.isAlpha = function(a) {
    return!/[^a-zA-Z]/.test(a)
};
goog.string.isNumeric = function(a) {
    return!/[^0-9]/.test(a)
};
goog.string.isAlphaNumeric = function(a) {
    return!/[^a-zA-Z0-9]/.test(a)
};
goog.string.isSpace = function(a) {
    return" " == a
};
goog.string.isUnicodeChar = function(a) {
    return 1 == a.length && " " <= a && "~" >= a || "\u0080" <= a && "\ufffd" >= a
};
goog.string.stripNewlines = function(a) {
    return a.replace(/(\r\n|\r|\n)+/g, " ")
};
goog.string.canonicalizeNewlines = function(a) {
    return a.replace(/(\r\n|\r|\n)/g, "\n")
};
goog.string.normalizeWhitespace = function(a) {
    return a.replace(/\xa0|\s/g, " ")
};
goog.string.normalizeSpaces = function(a) {
    return a.replace(/\xa0|[ \t]+/g, " ")
};
goog.string.collapseBreakingSpaces = function(a) {
    return a.replace(/[\t\r\n ]+/g, " ").replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, "")
};
goog.string.trim = function(a) {
    return a.replace(/^[\s\xa0]+|[\s\xa0]+$/g, "")
};
goog.string.trimLeft = function(a) {
    return a.replace(/^[\s\xa0]+/, "")
};
goog.string.trimRight = function(a) {
    return a.replace(/[\s\xa0]+$/, "")
};
goog.string.caseInsensitiveCompare = function(a, b) {
    var c = String(a).toLowerCase(), e = String(b).toLowerCase();
    return c < e ? -1 : c == e ? 0 : 1
};
goog.string.numerateCompareRegExp_ = /(\.\d+)|(\d+)|(\D+)/g;
goog.string.numerateCompare = function(a, b) {
    if (a == b)
        return 0;
    if (!a)
        return-1;
    if (!b)
        return 1;
    for (var c = a.toLowerCase().match(goog.string.numerateCompareRegExp_), e = b.toLowerCase().match(goog.string.numerateCompareRegExp_), d = Math.min(c.length, e.length), f = 0; f < d; f++) {
        var g = c[f], h = e[f];
        if (g != h)
            return c = parseInt(g, 10), !isNaN(c) && (e = parseInt(h, 10), !isNaN(e) && c - e) ? c - e : g < h ? -1 : 1
    }
    return c.length != e.length ? c.length - e.length : a < b ? -1 : 1
};
goog.string.urlEncode = function(a) {
    return encodeURIComponent(String(a))
};
goog.string.urlDecode = function(a) {
    return decodeURIComponent(a.replace(/\+/g, " "))
};
goog.string.newLineToBr = function(a, b) {
    return a.replace(/(\r\n|\r|\n)/g, b ? "<br />" : "<br>")
};
goog.string.htmlEscape = function(a, b) {
    if (b)
        return a.replace(goog.string.amperRe_, "&amp;").replace(goog.string.ltRe_, "&lt;").replace(goog.string.gtRe_, "&gt;").replace(goog.string.quotRe_, "&quot;");
    if (!goog.string.allRe_.test(a))
        return a;
    -1 != a.indexOf("&") && (a = a.replace(goog.string.amperRe_, "&amp;"));
    -1 != a.indexOf("<") && (a = a.replace(goog.string.ltRe_, "&lt;"));
    -1 != a.indexOf(">") && (a = a.replace(goog.string.gtRe_, "&gt;"));
    -1 != a.indexOf('"') && (a = a.replace(goog.string.quotRe_, "&quot;"));
    return a
};
goog.string.amperRe_ = /&/g;
goog.string.ltRe_ = /</g;
goog.string.gtRe_ = />/g;
goog.string.quotRe_ = /\"/g;
goog.string.allRe_ = /[&<>\"]/;
goog.string.unescapeEntities = function(a) {
    return goog.string.contains(a, "&") ? "document"in goog.global ? goog.string.unescapeEntitiesUsingDom_(a) : goog.string.unescapePureXmlEntities_(a) : a
};
goog.string.unescapeEntitiesUsingDom_ = function(a) {
    var b = {"&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"'}, c = document.createElement("div");
    return a.replace(goog.string.HTML_ENTITY_PATTERN_, function(a, d) {
        var f = b[a];
        if (f)
            return f;
        if ("#" == d.charAt(0)) {
            var g = Number("0" + d.substr(1));
            isNaN(g) || (f = String.fromCharCode(g))
        }
        f || (c.innerHTML = a + " ", f = c.firstChild.nodeValue.slice(0, -1));
        return b[a] = f
    })
};
goog.string.unescapePureXmlEntities_ = function(a) {
    return a.replace(/&([^;]+);/g, function(a, c) {
        switch (c) {
            case "amp":
                return"&";
            case "lt":
                return"<";
            case "gt":
                return">";
            case "quot":
                return'"';
            default:
                if ("#" == c.charAt(0)) {
                    var e = Number("0" + c.substr(1));
                    if (!isNaN(e))
                        return String.fromCharCode(e)
                }
                return a
            }
    })
};
goog.string.HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g;
goog.string.whitespaceEscape = function(a, b) {
    return goog.string.newLineToBr(a.replace(/  /g, " &#160;"), b)
};
goog.string.stripQuotes = function(a, b) {
    for (var c = b.length, e = 0; e < c; e++) {
        var d = 1 == c ? b : b.charAt(e);
        if (a.charAt(0) == d && a.charAt(a.length - 1) == d)
            return a.substring(1, a.length - 1)
    }
    return a
};
goog.string.truncate = function(a, b, c) {
    c && (a = goog.string.unescapeEntities(a));
    a.length > b && (a = a.substring(0, b - 3) + "...");
    c && (a = goog.string.htmlEscape(a));
    return a
};
goog.string.truncateMiddle = function(a, b, c, e) {
    c && (a = goog.string.unescapeEntities(a));
    if (e && a.length > b) {
        e > b && (e = b);
        var d = a.length - e;
        a = a.substring(0, b - e) + "..." + a.substring(d)
    } else
        a.length > b && (e = Math.floor(b / 2), d = a.length - e, a = a.substring(0, e + b % 2) + "..." + a.substring(d));
    c && (a = goog.string.htmlEscape(a));
    return a
};
goog.string.specialEscapeChars_ = {"\x00": "\\0", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "\t": "\\t", "\x0B": "\\x0B", '"': '\\"', "\\": "\\\\"};
goog.string.jsEscapeCache_ = {"'": "\\'"};
goog.string.quote = function(a) {
    a = String(a);
    if (a.quote)
        return a.quote();
    for (var b = ['"'], c = 0; c < a.length; c++) {
        var e = a.charAt(c), d = e.charCodeAt(0);
        b[c + 1] = goog.string.specialEscapeChars_[e] || (31 < d && 127 > d ? e : goog.string.escapeChar(e))
    }
    b.push('"');
    return b.join("")
};
goog.string.escapeString = function(a) {
    for (var b = [], c = 0; c < a.length; c++)
        b[c] = goog.string.escapeChar(a.charAt(c));
    return b.join("")
};
goog.string.escapeChar = function(a) {
    if (a in goog.string.jsEscapeCache_)
        return goog.string.jsEscapeCache_[a];
    if (a in goog.string.specialEscapeChars_)
        return goog.string.jsEscapeCache_[a] = goog.string.specialEscapeChars_[a];
    var b = a, c = a.charCodeAt(0);
    if (31 < c && 127 > c)
        b = a;
    else {
        if (256 > c) {
            if (b = "\\x", 16 > c || 256 < c)
                b += "0"
        } else
            b = "\\u", 4096 > c && (b += "0");
        b += c.toString(16).toUpperCase()
    }
    return goog.string.jsEscapeCache_[a] = b
};
goog.string.toMap = function(a) {
    for (var b = {}, c = 0; c < a.length; c++)
        b[a.charAt(c)] = !0;
    return b
};
goog.string.contains = function(a, b) {
    return-1 != a.indexOf(b)
};
goog.string.countOf = function(a, b) {
    return a && b ? a.split(b).length - 1 : 0
};
goog.string.removeAt = function(a, b, c) {
    var e = a;
    0 <= b && (b < a.length && 0 < c) && (e = a.substr(0, b) + a.substr(b + c, a.length - b - c));
    return e
};
goog.string.remove = function(a, b) {
    var c = RegExp(goog.string.regExpEscape(b), "");
    return a.replace(c, "")
};
goog.string.removeAll = function(a, b) {
    var c = RegExp(goog.string.regExpEscape(b), "g");
    return a.replace(c, "")
};
goog.string.regExpEscape = function(a) {
    return String(a).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08")
};
goog.string.repeat = function(a, b) {
    return Array(b + 1).join(a)
};
goog.string.padNumber = function(a, b, c) {
    a = goog.isDef(c) ? a.toFixed(c) : String(a);
    c = a.indexOf(".");
    -1 == c && (c = a.length);
    return goog.string.repeat("0", Math.max(0, b - c)) + a
};
goog.string.makeSafe = function(a) {
    return null == a ? "" : String(a)
};
goog.string.buildString = function(a) {
    return Array.prototype.join.call(arguments, "")
};
goog.string.getRandomString = function() {
    return Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ goog.now()).toString(36)
};
goog.string.compareVersions = function(a, b) {
    for (var c = 0, e = goog.string.trim(String(a)).split("."), d = goog.string.trim(String(b)).split("."), f = Math.max(e.length, d.length), g = 0; 0 == c && g < f; g++) {
        var h = e[g] || "", l = d[g] || "", k = RegExp("(\\d*)(\\D*)", "g"), m = RegExp("(\\d*)(\\D*)", "g");
        do {
            var n = k.exec(h) || ["", "", ""], p = m.exec(l) || ["", "", ""];
            if (0 == n[0].length && 0 == p[0].length)
                break;
            var c = 0 == n[1].length ? 0 : parseInt(n[1], 10), q = 0 == p[1].length ? 0 : parseInt(p[1], 10), c = goog.string.compareElements_(c, q) || goog.string.compareElements_(0 ==
                    n[2].length, 0 == p[2].length) || goog.string.compareElements_(n[2], p[2])
        } while (0 == c)
    }
    return c
};
goog.string.compareElements_ = function(a, b) {
    return a < b ? -1 : a > b ? 1 : 0
};
goog.string.HASHCODE_MAX_ = 4294967296;
goog.string.hashCode = function(a) {
    for (var b = 0, c = 0; c < a.length; ++c)
        b = 31 * b + a.charCodeAt(c), b %= goog.string.HASHCODE_MAX_;
    return b
};
goog.string.uniqueStringCounter_ = 2147483648 * Math.random() | 0;
goog.string.createUniqueString = function() {
    return"goog_" + goog.string.uniqueStringCounter_++
};
goog.string.toNumber = function(a) {
    var b = Number(a);
    return 0 == b && goog.string.isEmpty(a) ? NaN : b
};
goog.string.toCamelCase = function(a) {
    return String(a).replace(/\-([a-z])/g, function(a, c) {
        return c.toUpperCase()
    })
};
goog.string.toSelectorCase = function(a) {
    return String(a).replace(/([A-Z])/g, "-$1").toLowerCase()
};
goog.string.toTitleCase = function(a, b) {
    var c = goog.isString(b) ? goog.string.regExpEscape(b) : "\\s";
    return a.replace(RegExp("(^" + (c ? "|[" + c + "]+" : "") + ")([a-z])", "g"), function(a, b, c) {
        return b + c.toUpperCase()
    })
};
goog.string.parseInt = function(a) {
    isFinite(a) && (a = String(a));
    return goog.isString(a) ? /^\s*-?0x/i.test(a) ? parseInt(a, 16) : parseInt(a, 10) : NaN
};
goog.asserts = {};
goog.asserts.ENABLE_ASSERTS = goog.DEBUG;
goog.asserts.AssertionError = function(a, b) {
    b.unshift(a);
    goog.debug.Error.call(this, goog.string.subs.apply(null, b));
    b.shift();
    this.messagePattern = a
};
goog.inherits(goog.asserts.AssertionError, goog.debug.Error);
goog.asserts.AssertionError.prototype.name = "AssertionError";
goog.asserts.doAssertFailure_ = function(a, b, c, e) {
    var d = "Assertion failed";
    if (c)
        var d = d + (": " + c), f = e;
    else
        a && (d += ": " + a, f = b);
    throw new goog.asserts.AssertionError("" + d, f || []);
};
goog.asserts.assert = function(a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !a && goog.asserts.doAssertFailure_("", null, b, Array.prototype.slice.call(arguments, 2));
    return a
};
goog.asserts.fail = function(a, b) {
    if (goog.asserts.ENABLE_ASSERTS)
        throw new goog.asserts.AssertionError("Failure" + (a ? ": " + a : ""), Array.prototype.slice.call(arguments, 1));
};
goog.asserts.assertNumber = function(a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isNumber(a) && goog.asserts.doAssertFailure_("Expected number but got %s: %s.", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));
    return a
};
goog.asserts.assertString = function(a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isString(a) && goog.asserts.doAssertFailure_("Expected string but got %s: %s.", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));
    return a
};
goog.asserts.assertFunction = function(a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isFunction(a) && goog.asserts.doAssertFailure_("Expected function but got %s: %s.", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));
    return a
};
goog.asserts.assertObject = function(a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isObject(a) && goog.asserts.doAssertFailure_("Expected object but got %s: %s.", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));
    return a
};
goog.asserts.assertArray = function(a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isArray(a) && goog.asserts.doAssertFailure_("Expected array but got %s: %s.", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));
    return a
};
goog.asserts.assertBoolean = function(a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isBoolean(a) && goog.asserts.doAssertFailure_("Expected boolean but got %s: %s.", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));
    return a
};
goog.asserts.assertInstanceof = function(a, b, c, e) {
    !goog.asserts.ENABLE_ASSERTS || a instanceof b || goog.asserts.doAssertFailure_("instanceof check failed.", null, c, Array.prototype.slice.call(arguments, 3));
    return a
};
goog.string.format = function(a, b) {
    var c = Array.prototype.slice.call(arguments), e = c.shift();
    if ("undefined" == typeof e)
        throw Error("[goog.string.format] Template required");
    return e.replace(/%([0\-\ \+]*)(\d+)?(\.(\d+))?([%sfdiu])/g, function(a, b, e, h, l, k, m, n) {
        if ("%" == k)
            return"%";
        var p = c.shift();
        if ("undefined" == typeof p)
            throw Error("[goog.string.format] Not enough arguments");
        arguments[0] = p;
        return goog.string.format.demuxes_[k].apply(null, arguments)
    })
};
goog.string.format.demuxes_ = {};
goog.string.format.demuxes_.s = function(a, b, c, e, d, f, g, h) {
    return isNaN(c) || "" == c || a.length >= c ? a : a = -1 < b.indexOf("-", 0) ? a + goog.string.repeat(" ", c - a.length) : goog.string.repeat(" ", c - a.length) + a
};
goog.string.format.demuxes_.f = function(a, b, c, e, d, f, g, h) {
    e = a.toString();
    isNaN(d) || "" == d || (e = a.toFixed(d));
    f = 0 > a ? "-" : 0 <= b.indexOf("+") ? "+" : 0 <= b.indexOf(" ") ? " " : "";
    0 <= a && (e = f + e);
    if (isNaN(c) || e.length >= c)
        return e;
    e = isNaN(d) ? Math.abs(a).toString() : Math.abs(a).toFixed(d);
    a = c - e.length - f.length;
    0 <= b.indexOf("-", 0) ? e = f + e + goog.string.repeat(" ", a) : (b = 0 <= b.indexOf("0", 0) ? "0" : " ", e = f + goog.string.repeat(b, a) + e);
    return e
};
goog.string.format.demuxes_.d = function(a, b, c, e, d, f, g, h) {
    return goog.string.format.demuxes_.f(parseInt(a, 10), b, c, e, 0, f, g, h)
};
goog.string.format.demuxes_.i = goog.string.format.demuxes_.d;
goog.string.format.demuxes_.u = goog.string.format.demuxes_.d;
var box2d = {b2Settings: {}};
Object.defineProperty || (Object.defineProperty = function(a, b, c) {
    Object.__defineGetter__ && ("get"in c ? a.__defineGetter__(b, c.get) : "value"in c && a.__defineGetter__(b, c.value));
    Object.__defineSetter__ && ("set"in c ? a.__defineSetter__(b, c.set) : "value"in c && a.__defineSetter__(b, c.value))
});
box2d.DEBUG = !1;
goog.exportSymbol("box2d.DEBUG", box2d.DEBUG);
box2d.ENABLE_ASSERTS = box2d.DEBUG;
goog.exportSymbol("box2d.ENABLE_ASSERTS", box2d.ENABLE_ASSERTS);
box2d.b2Assert = function(a, b, c) {
    if (box2d.DEBUG && !a)
        debugger
};
goog.exportSymbol("box2d.b2Assert", box2d.b2Assert);
box2d.b2_maxFloat = 1E37;
goog.exportSymbol("box2d.b2_maxFloat", box2d.b2_maxFloat);
box2d.b2_epsilon = 1E-5;
goog.exportSymbol("box2d.b2_epsilon", box2d.b2_epsilon);
box2d.b2_epsilon_sq = box2d.b2_epsilon * box2d.b2_epsilon;
goog.exportSymbol("box2d.b2_epsilon_sq", box2d.b2_epsilon_sq);
box2d.b2_pi = Math.PI;
goog.exportSymbol("box2d.b2_pi", box2d.b2_pi);
box2d.b2_maxManifoldPoints = 2;
goog.exportSymbol("box2d.b2_maxManifoldPoints", box2d.b2_maxManifoldPoints);
box2d.b2_maxPolygonVertices = 8;
goog.exportSymbol("box2d.b2_maxPolygonVertices", box2d.b2_maxPolygonVertices);
box2d.b2_aabbExtension = 0.1;
goog.exportSymbol("box2d.b2_aabbExtension", box2d.b2_aabbExtension);
box2d.b2_aabbMultiplier = 2;
goog.exportSymbol("box2d.b2_aabbMultiplier", box2d.b2_aabbMultiplier);
box2d.b2_linearSlop = 0.008;
goog.exportSymbol("box2d.b2_linearSlop", box2d.b2_linearSlop);
box2d.b2_angularSlop = 2 / 180 * box2d.b2_pi;
goog.exportSymbol("box2d.b2_angularSlop", box2d.b2_angularSlop);
box2d.b2_polygonRadius = 2 * box2d.b2_linearSlop;
goog.exportSymbol("box2d.b2_polygonRadius", box2d.b2_polygonRadius);
box2d.b2_maxSubSteps = 8;
goog.exportSymbol("box2d.b2_maxSubSteps", box2d.b2_maxSubSteps);
box2d.b2_maxTOIContacts = 32;
goog.exportSymbol("box2d.b2_maxTOIContacts", box2d.b2_maxTOIContacts);
box2d.b2_velocityThreshold = 1;
goog.exportSymbol("box2d.b2_velocityThreshold", box2d.b2_velocityThreshold);
box2d.b2_maxLinearCorrection = 0.2;
goog.exportSymbol("box2d.b2_maxLinearCorrection", box2d.b2_maxLinearCorrection);
box2d.b2_maxAngularCorrection = 8 / 180 * box2d.b2_pi;
goog.exportSymbol("box2d.b2_maxAngularCorrection", box2d.b2_maxAngularCorrection);
box2d.b2_maxTranslation = 2;
goog.exportSymbol("box2d.b2_maxTranslation", box2d.b2_maxTranslation);
box2d.b2_maxTranslationSquared = box2d.b2_maxTranslation * box2d.b2_maxTranslation;
goog.exportSymbol("box2d.b2_maxTranslationSquared", box2d.b2_maxTranslationSquared);
box2d.b2_maxRotation = 0.5 * box2d.b2_pi;
goog.exportSymbol("box2d.b2_maxRotation", box2d.b2_maxRotation);
box2d.b2_maxRotationSquared = box2d.b2_maxRotation * box2d.b2_maxRotation;
goog.exportSymbol("box2d.b2_maxRotationSquared", box2d.b2_maxRotationSquared);
box2d.b2_baumgarte = 0.2;
goog.exportSymbol("box2d.b2_baumgarte", box2d.b2_baumgarte);
box2d.b2_toiBaumgarte = 0.75;
goog.exportSymbol("box2d.b2_toiBaumgarte", box2d.b2_toiBaumgarte);
box2d.b2_timeToSleep = 0.5;
goog.exportSymbol("box2d.b2_timeToSleep", box2d.b2_timeToSleep);
box2d.b2_linearSleepTolerance = 0.01;
goog.exportSymbol("box2d.b2_linearSleepTolerance", box2d.b2_linearSleepTolerance);
box2d.b2_angularSleepTolerance = 2 / 180 * box2d.b2_pi;
goog.exportSymbol("box2d.b2_angularSleepTolerance", box2d.b2_angularSleepTolerance);
box2d.b2Alloc = function(a) {
    return null
};
goog.exportSymbol("box2d.b2Alloc", box2d.b2Alloc);
box2d.b2Free = function(a) {
};
goog.exportSymbol("box2d.b2Free", box2d.b2Free);
box2d.b2Log = function(a, b) {
    var c = Array.prototype.slice.call(arguments), c = goog.string.format.apply(null, c.slice(0));
    goog.global.console.log(c)
};
goog.exportSymbol("box2d.b2Log", box2d.b2Log);
box2d.b2Version = function(a, b, c) {
    this.major = a || 0;
    this.minor = b || 0;
    this.revision = c || 0
};
goog.exportSymbol("box2d.b2Version", box2d.b2Version);
box2d.b2Version.prototype.major = 0;
goog.exportProperty(box2d.b2Version.prototype, "major", box2d.b2Version.prototype.major);
box2d.b2Version.prototype.minor = 0;
goog.exportProperty(box2d.b2Version.prototype, "minor", box2d.b2Version.prototype.minor);
box2d.b2Version.prototype.revision = 0;
goog.exportProperty(box2d.b2Version.prototype, "revision", box2d.b2Version.prototype.revision);
box2d.b2Version.prototype.toString = function() {
    return this.major + "." + this.minor + "." + this.revision
};
goog.exportProperty(box2d.b2Version.prototype, "toString", box2d.b2Version.prototype.toString);
box2d.b2_version = new box2d.b2Version(2, 3, 0);
goog.exportSymbol("box2d.b2_version", box2d.b2_version);
box2d.b2_changelist = 254;
goog.exportSymbol("box2d.b2_changelist", box2d.b2_changelist);
box2d.b2ParseInt = function(a) {
    return parseInt(a, 10)
};
goog.exportSymbol("box2d.b2ParseInt", box2d.b2ParseInt);
box2d.b2ParseUInt = function(a) {
    return box2d.b2Abs(parseInt(a, 10))
};
goog.exportSymbol("box2d.b2ParseUInt", box2d.b2ParseUInt);
box2d.b2MakeArray = function(a, b) {
    void 0 === a && (a = 0);
    var c = Array(a);
    if (void 0 !== b)
        for (var e = 0; e < a; ++e)
            c[e] = b(e);
    return c
};
goog.exportSymbol("box2d.b2MakeArray", box2d.b2MakeArray);
box2d.b2MakeNumberArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return 0
    })
};
goog.exportSymbol("box2d.b2MakeNumberArray", box2d.b2MakeNumberArray);
box2d.b2Math = {};
box2d.b2_pi_over_180 = box2d.b2_pi / 180;
goog.exportSymbol("box2d.b2_pi_over_180", box2d.b2_pi_over_180);
box2d.b2_180_over_pi = 180 / box2d.b2_pi;
goog.exportSymbol("box2d.b2_180_over_pi", box2d.b2_180_over_pi);
box2d.b2_two_pi = 2 * box2d.b2_pi;
goog.exportSymbol("box2d.b2_two_pi", box2d.b2_two_pi);
box2d.b2Abs = function(a) {
    return 0 > a ? -a : a
};
goog.exportSymbol("box2d.b2Abs", box2d.b2Abs);
box2d.b2Min = function(a, b) {
    return a < b ? a : b
};
goog.exportSymbol("box2d.b2Min", box2d.b2Min);
box2d.b2Max = function(a, b) {
    return a > b ? a : b
};
goog.exportSymbol("box2d.b2Max", box2d.b2Max);
box2d.b2Clamp = function(a, b, c) {
    return a < b ? b : a > c ? c : a
};
goog.exportSymbol("box2d.b2Clamp", box2d.b2Clamp);
box2d.b2Swap = function(a, b) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1);
    var c = a[0];
    a[0] = b[0];
    b[0] = c
};
goog.exportSymbol("box2d.b2Swap", box2d.b2Swap);
box2d.b2IsValid = function(a) {
    return isFinite(a)
};
goog.exportSymbol("box2d.b2IsValid", box2d.b2IsValid);
box2d.b2Sq = function(a) {
    return a * a
};
goog.exportSymbol("box2d.b2Sq", box2d.b2Sq);
box2d.b2InvSqrt = function(a) {
    return 1 / Math.sqrt(a)
};
goog.exportSymbol("box2d.b2InvSqrt", box2d.b2InvSqrt);
box2d.b2Sqrt = function(a) {
    return Math.sqrt(a)
};
goog.exportSymbol("box2d.b2Sqrt", box2d.b2Sqrt);
box2d.b2Pow = function(a, b) {
    return Math.pow(a, b)
};
goog.exportSymbol("box2d.b2Pow", box2d.b2Pow);
box2d.b2DegToRad = function(a) {
    return a * box2d.b2_pi_over_180
};
goog.exportSymbol("box2d.b2DegToRad", box2d.b2DegToRad);
box2d.b2RadToDeg = function(a) {
    return a * box2d.b2_180_over_pi
};
goog.exportSymbol("box2d.b2RadToDeg", box2d.b2RadToDeg);
box2d.b2Cos = function(a) {
    return Math.cos(a)
};
goog.exportSymbol("box2d.b2Cos", box2d.b2Cos);
box2d.b2Sin = function(a) {
    return Math.sin(a)
};
goog.exportSymbol("box2d.b2Sin", box2d.b2Sin);
box2d.b2Acos = function(a) {
    return Math.acos(a)
};
goog.exportSymbol("box2d.b2Acos", box2d.b2Acos);
box2d.b2Asin = function(a) {
    return Math.asin(a)
};
goog.exportSymbol("box2d.b2Asin", box2d.b2Asin);
box2d.b2Atan2 = function(a, b) {
    return Math.atan2(a, b)
};
goog.exportSymbol("box2d.b2Atan2", box2d.b2Atan2);
box2d.b2NextPowerOfTwo = function(a) {
    a |= a >> 1 & 2147483647;
    a |= a >> 2 & 1073741823;
    a |= a >> 4 & 268435455;
    a |= a >> 8 & 16777215;
    return(a | a >> 16 & 65535) + 1
};
goog.exportSymbol("box2d.b2NextPowerOfTwo", box2d.b2NextPowerOfTwo);
box2d.b2IsPowerOfTwo = function(a) {
    return 0 < a && 0 == (a & a - 1)
};
goog.exportSymbol("box2d.b2IsPowerOfTwo", box2d.b2IsPowerOfTwo);
box2d.b2Random = function() {
    return 2 * Math.random() - 1
};
goog.exportSymbol("box2d.b2Random", box2d.b2Random);
box2d.b2RandomRange = function(a, b) {
    return(b - a) * Math.random() + a
};
goog.exportSymbol("box2d.b2RandomRange", box2d.b2RandomRange);
box2d.b2Vec2 = function(a, b) {
    this.x = a || 0;
    this.y = b || 0
};
goog.exportSymbol("box2d.b2Vec2", box2d.b2Vec2);
box2d.b2Vec2.prototype.x = 0;
goog.exportProperty(box2d.b2Vec2.prototype, "x", box2d.b2Vec2.prototype.x);
box2d.b2Vec2.prototype.y = 0;
goog.exportProperty(box2d.b2Vec2.prototype, "y", box2d.b2Vec2.prototype.y);
box2d.b2Vec2_zero = new box2d.b2Vec2;
goog.exportSymbol("box2d.b2Vec2_zero", box2d.b2Vec2_zero);
box2d.b2Vec2.ZERO = new box2d.b2Vec2;
goog.exportProperty(box2d.b2Vec2, "ZERO", box2d.b2Vec2.ZERO);
box2d.b2Vec2.UNITX = new box2d.b2Vec2(1, 0);
goog.exportProperty(box2d.b2Vec2, "UNITX", box2d.b2Vec2.UNITX);
box2d.b2Vec2.UNITY = new box2d.b2Vec2(0, 1);
goog.exportProperty(box2d.b2Vec2, "UNITY", box2d.b2Vec2.UNITY);
box2d.b2Vec2.s_t0 = new box2d.b2Vec2;
goog.exportProperty(box2d.b2Vec2, "s_t0", box2d.b2Vec2.s_t0);
box2d.b2Vec2.s_t1 = new box2d.b2Vec2;
goog.exportProperty(box2d.b2Vec2, "s_t1", box2d.b2Vec2.s_t1);
box2d.b2Vec2.s_t2 = new box2d.b2Vec2;
goog.exportProperty(box2d.b2Vec2, "s_t2", box2d.b2Vec2.s_t2);
box2d.b2Vec2.s_t3 = new box2d.b2Vec2;
goog.exportProperty(box2d.b2Vec2, "s_t3", box2d.b2Vec2.s_t3);
box2d.b2Vec2.MakeArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return new box2d.b2Vec2
    })
};
goog.exportProperty(box2d.b2Vec2, "MakeArray", box2d.b2Vec2.MakeArray);
box2d.b2Vec2.prototype.Clone = function() {
    return new box2d.b2Vec2(this.x, this.y)
};
goog.exportProperty(box2d.b2Vec2.prototype, "Clone", box2d.b2Vec2.prototype.Clone);
box2d.b2Vec2.prototype.SetZero = function() {
    this.y = this.x = 0;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SetZero", box2d.b2Vec2.prototype.SetZero);
box2d.b2Vec2.prototype.SetXY = function(a, b) {
    this.x = a;
    this.y = b;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SetXY", box2d.b2Vec2.prototype.SetXY);
box2d.b2Vec2.prototype.Copy = function(a) {
    this.x = a.x;
    this.y = a.y;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "Copy", box2d.b2Vec2.prototype.Copy);
box2d.b2Vec2.prototype.SelfAdd = function(a) {
    this.x += a.x;
    this.y += a.y;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfAdd", box2d.b2Vec2.prototype.SelfAdd);
box2d.b2Vec2.prototype.SelfAddXY = function(a, b) {
    this.x += a;
    this.y += b;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfAddXY", box2d.b2Vec2.prototype.SelfAddXY);
box2d.b2Vec2.prototype.SelfSub = function(a) {
    this.x -= a.x;
    this.y -= a.y;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfSub", box2d.b2Vec2.prototype.SelfSub);
box2d.b2Vec2.prototype.SelfSubXY = function(a, b) {
    this.x -= a;
    this.y -= b;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfSubXY", box2d.b2Vec2.prototype.SelfSubXY);
box2d.b2Vec2.prototype.SelfMul = function(a) {
    this.x *= a;
    this.y *= a;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfMul", box2d.b2Vec2.prototype.SelfMul);
box2d.b2Vec2.prototype.SelfMulAdd = function(a, b) {
    this.x += a * b.x;
    this.y += a * b.y;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfMulAdd", box2d.b2Vec2.prototype.SelfMulAdd);
box2d.b2Vec2.prototype.SelfMulSub = function(a, b) {
    this.x -= a * b.x;
    this.y -= a * b.y;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfMulSub", box2d.b2Vec2.prototype.SelfMulSub);
box2d.b2Vec2.prototype.Dot = function(a) {
    return this.x * a.x + this.y * a.y
};
goog.exportProperty(box2d.b2Vec2.prototype, "Dot", box2d.b2Vec2.prototype.Dot);
box2d.b2Vec2.prototype.Cross = function(a) {
    return this.x * a.y - this.y * a.x
};
goog.exportProperty(box2d.b2Vec2.prototype, "Cross", box2d.b2Vec2.prototype.Cross);
box2d.b2Vec2.prototype.GetLength = function() {
    var a = this.x, b = this.y;
    return Math.sqrt(a * a + b * b)
};
goog.exportProperty(box2d.b2Vec2.prototype, "GetLength", box2d.b2Vec2.prototype.GetLength);
box2d.b2Vec2.prototype.GetLengthSquared = function() {
    var a = this.x, b = this.y;
    return a * a + b * b
};
goog.exportProperty(box2d.b2Vec2.prototype, "GetLengthSquared", box2d.b2Vec2.prototype.GetLengthSquared);
box2d.b2Vec2.prototype.Normalize = function() {
    var a = this.GetLength();
    if (a >= box2d.b2_epsilon) {
        var b = 1 / a;
        this.x *= b;
        this.y *= b
    }
    return a
};
goog.exportProperty(box2d.b2Vec2.prototype, "Normalize", box2d.b2Vec2.prototype.Normalize);
box2d.b2Vec2.prototype.SelfNormalize = function() {
    var a = this.GetLength();
    a >= box2d.b2_epsilon && (a = 1 / a, this.x *= a, this.y *= a);
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfNormalize", box2d.b2Vec2.prototype.SelfNormalize);
box2d.b2Vec2.prototype.SelfRotate = function(a, b) {
    var c = this.x, e = this.y;
    this.x = a * c - b * e;
    this.y = b * c + a * e;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfRotate", box2d.b2Vec2.prototype.SelfRotate);
box2d.b2Vec2.prototype.SelfRotateRadians = function(a) {
    return this.SelfRotate(Math.cos(a), Math.sin(a))
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfRotateRadians", box2d.b2Vec2.prototype.SelfRotateRadians);
box2d.b2Vec2.prototype.SelfRotateDegrees = function(a) {
    return this.SelfRotateRadians(box2d.b2DegToRad(a))
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfRotateDegrees", box2d.b2Vec2.prototype.SelfRotateDegrees);
box2d.b2Vec2.prototype.IsValid = function() {
    return isFinite(this.x) && isFinite(this.y)
};
goog.exportProperty(box2d.b2Vec2.prototype, "IsValid", box2d.b2Vec2.prototype.IsValid);
box2d.b2Vec2.prototype.SelfCrossVS = function(a) {
    var b = this.x;
    this.x = a * this.y;
    this.y = -a * b;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfCrossVS", box2d.b2Vec2.prototype.SelfCrossVS);
box2d.b2Vec2.prototype.SelfCrossSV = function(a) {
    var b = this.x;
    this.x = -a * this.y;
    this.y = a * b;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfCrossSV", box2d.b2Vec2.prototype.SelfCrossSV);
box2d.b2Vec2.prototype.SelfMinV = function(a) {
    this.x = box2d.b2Min(this.x, a.x);
    this.y = box2d.b2Min(this.y, a.y);
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfMinV", box2d.b2Vec2.prototype.SelfMinV);
box2d.b2Vec2.prototype.SelfMaxV = function(a) {
    this.x = box2d.b2Max(this.x, a.x);
    this.y = box2d.b2Max(this.y, a.y);
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfMaxV", box2d.b2Vec2.prototype.SelfMaxV);
box2d.b2Vec2.prototype.SelfAbs = function() {
    this.x = box2d.b2Abs(this.x);
    this.y = box2d.b2Abs(this.y);
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfAbs", box2d.b2Vec2.prototype.SelfAbs);
box2d.b2Vec2.prototype.SelfNeg = function() {
    this.x = -this.x;
    this.y = -this.y;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfNeg", box2d.b2Vec2.prototype.SelfNeg);
box2d.b2Vec2.prototype.SelfSkew = function() {
    var a = this.x;
    this.x = -this.y;
    this.y = a;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfSkew", box2d.b2Vec2.prototype.SelfSkew);
box2d.b2AbsV = function(a, b) {
    b.x = box2d.b2Abs(a.x);
    b.y = box2d.b2Abs(a.y);
    return b
};
goog.exportSymbol("box2d.b2AbsV", box2d.b2AbsV);
box2d.b2MinV = function(a, b, c) {
    c.x = box2d.b2Min(a.x, b.x);
    c.y = box2d.b2Min(a.y, b.y);
    return c
};
goog.exportSymbol("box2d.b2MinV", box2d.b2MinV);
box2d.b2MaxV = function(a, b, c) {
    c.x = box2d.b2Max(a.x, b.x);
    c.y = box2d.b2Max(a.y, b.y);
    return c
};
goog.exportSymbol("box2d.b2MaxV", box2d.b2MaxV);
box2d.b2ClampV = function(a, b, c, e) {
    e.x = box2d.b2Clamp(a.x, b.x, c.x);
    e.y = box2d.b2Clamp(a.y, b.y, c.y);
    return e
};
goog.exportSymbol("box2d.b2ClampV", box2d.b2ClampV);
box2d.b2RotateV = function(a, b, c, e) {
    var d = a.x;
    a = a.y;
    e.x = b * d - c * a;
    e.y = c * d + b * a;
    return e
};
goog.exportSymbol("box2d.b2RotateV", box2d.b2RotateV);
box2d.b2RotateRadiansV = function(a, b, c) {
    return box2d.b2RotateV(a, Math.cos(b), Math.sin(b), c)
};
goog.exportSymbol("box2d.b2RotateRadiansV", box2d.b2RotateRadiansV);
box2d.b2RotateDegreesV = function(a, b, c) {
    return box2d.b2RotateRadiansV(a, box2d.b2DegToRad(b), c)
};
goog.exportSymbol("box2d.b2RotateDegreesV", box2d.b2RotateDegreesV);
box2d.b2DotVV = function(a, b) {
    return a.x * b.x + a.y * b.y
};
goog.exportSymbol("box2d.b2DotVV", box2d.b2DotVV);
box2d.b2CrossVV = function(a, b) {
    return a.x * b.y - a.y * b.x
};
goog.exportSymbol("box2d.b2CrossVV", box2d.b2CrossVV);
box2d.b2CrossVS = function(a, b, c) {
    var e = a.x;
    c.x = b * a.y;
    c.y = -b * e;
    return c
};
goog.exportSymbol("box2d.b2CrossVS", box2d.b2CrossVS);
box2d.b2CrossVOne = function(a, b) {
    var c = a.x;
    b.x = a.y;
    b.y = -c;
    return b
};
goog.exportSymbol("box2d.b2CrossVOne", box2d.b2CrossVOne);
box2d.b2CrossSV = function(a, b, c) {
    var e = b.x;
    c.x = -a * b.y;
    c.y = a * e;
    return c
};
goog.exportSymbol("box2d.b2CrossSV", box2d.b2CrossSV);
box2d.b2CrossOneV = function(a, b) {
    var c = a.x;
    b.x = -a.y;
    b.y = c;
    return b
};
goog.exportSymbol("box2d.b2CrossOneV", box2d.b2CrossOneV);
box2d.b2AddVV = function(a, b, c) {
    c.x = a.x + b.x;
    c.y = a.y + b.y;
    return c
};
goog.exportSymbol("box2d.b2AddVV", box2d.b2AddVV);
box2d.b2SubVV = function(a, b, c) {
    c.x = a.x - b.x;
    c.y = a.y - b.y;
    return c
};
goog.exportSymbol("box2d.b2SubVV", box2d.b2SubVV);
box2d.b2MulSV = function(a, b, c) {
    c.x = b.x * a;
    c.y = b.y * a;
    return c
};
goog.exportSymbol("box2d.b2MulSV", box2d.b2MulSV);
box2d.b2AddVMulSV = function(a, b, c, e) {
    e.x = a.x + b * c.x;
    e.y = a.y + b * c.y;
    return e
};
goog.exportSymbol("box2d.b2AddVMulSV", box2d.b2AddVMulSV);
box2d.b2SubVMulSV = function(a, b, c, e) {
    e.x = a.x - b * c.x;
    e.y = a.y - b * c.y;
    return e
};
goog.exportSymbol("box2d.b2SubVMulSV", box2d.b2SubVMulSV);
box2d.b2AddVCrossSV = function(a, b, c, e) {
    var d = c.x;
    e.x = a.x - b * c.y;
    e.y = a.y + b * d;
    return e
};
goog.exportSymbol("box2d.b2AddVCrossSV", box2d.b2AddVCrossSV);
box2d.b2MidVV = function(a, b, c) {
    c.x = 0.5 * (a.x + b.x);
    c.y = 0.5 * (a.y + b.y);
    return c
};
goog.exportSymbol("box2d.b2MidVV", box2d.b2MidVV);
box2d.b2ExtVV = function(a, b, c) {
    c.x = 0.5 * (b.x - a.x);
    c.y = 0.5 * (b.y - a.y);
    return c
};
goog.exportSymbol("box2d.b2ExtVV", box2d.b2ExtVV);
box2d.b2IsEqualToV = function(a, b) {
    return a.x == b.x && a.y == b.y
};
goog.exportSymbol("box2d.b2IsEqualToV", box2d.b2IsEqualToV);
box2d.b2DistanceVV = function(a, b) {
    var c = a.x - b.x, e = a.y - b.y;
    return Math.sqrt(c * c + e * e)
};
goog.exportSymbol("box2d.b2DistanceVV", box2d.b2DistanceVV);
box2d.b2DistanceSquaredVV = function(a, b) {
    var c = a.x - b.x, e = a.y - b.y;
    return c * c + e * e
};
goog.exportSymbol("box2d.b2DistanceSquaredVV", box2d.b2DistanceSquaredVV);
box2d.b2NegV = function(a, b) {
    b.x = -a.x;
    b.y = -a.y;
    return b
};
goog.exportSymbol("box2d.b2NegV", box2d.b2NegV);
box2d.b2Vec3 = function(a, b, c) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = c || 0
};
goog.exportSymbol("box2d.b2Vec3", box2d.b2Vec3);
box2d.b2Vec3.prototype.x = 0;
goog.exportProperty(box2d.b2Vec3.prototype, "x", box2d.b2Vec3.prototype.x);
box2d.b2Vec3.prototype.y = 0;
goog.exportProperty(box2d.b2Vec3.prototype, "y", box2d.b2Vec3.prototype.y);
box2d.b2Vec3.prototype.z = 0;
goog.exportProperty(box2d.b2Vec3.prototype, "z", box2d.b2Vec3.prototype.z);
box2d.b2Vec3.ZERO = new box2d.b2Vec3;
goog.exportProperty(box2d.b2Vec3, "ZERO", box2d.b2Vec3.ZERO);
box2d.b2Vec3.s_t0 = new box2d.b2Vec3;
goog.exportProperty(box2d.b2Vec3, "s_t0", box2d.b2Vec3.s_t0);
box2d.b2Vec3.prototype.Clone = function() {
    return new box2d.b2Vec3(this.x, this.y, this.z)
};
goog.exportProperty(box2d.b2Vec3.prototype, "Clone", box2d.b2Vec3.prototype.Clone);
box2d.b2Vec3.prototype.SetZero = function() {
    this.z = this.y = this.x = 0;
    return this
};
goog.exportProperty(box2d.b2Vec3.prototype, "SetZero", box2d.b2Vec3.prototype.SetZero);
box2d.b2Vec3.prototype.SetXYZ = function(a, b, c) {
    this.x = a;
    this.y = b;
    this.z = c;
    return this
};
goog.exportProperty(box2d.b2Vec3.prototype, "SetXYZ", box2d.b2Vec3.prototype.SetXYZ);
box2d.b2Vec3.prototype.Copy = function(a) {
    this.x = a.x;
    this.y = a.y;
    this.z = a.z;
    return this
};
goog.exportProperty(box2d.b2Vec3.prototype, "Copy", box2d.b2Vec3.prototype.Copy);
box2d.b2Vec3.prototype.SelfNeg = function() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this
};
goog.exportProperty(box2d.b2Vec3.prototype, "SelfNeg", box2d.b2Vec3.prototype.SelfNeg);
box2d.b2Vec3.prototype.SelfAdd = function(a) {
    this.x += a.x;
    this.y += a.y;
    this.z += a.z;
    return this
};
goog.exportProperty(box2d.b2Vec3.prototype, "SelfAdd", box2d.b2Vec3.prototype.SelfAdd);
box2d.b2Vec3.prototype.SelfAddXYZ = function(a, b, c) {
    this.x += a;
    this.y += b;
    this.z += c;
    return this
};
goog.exportProperty(box2d.b2Vec3.prototype, "SelfAddXYZ", box2d.b2Vec3.prototype.SelfAddXYZ);
box2d.b2Vec3.prototype.SelfSub = function(a) {
    this.x -= a.x;
    this.y -= a.y;
    this.z -= a.z;
    return this
};
goog.exportProperty(box2d.b2Vec3.prototype, "SelfSub", box2d.b2Vec3.prototype.SelfSub);
box2d.b2Vec3.prototype.SelfSubXYZ = function(a, b, c) {
    this.x -= a;
    this.y -= b;
    this.z -= c;
    return this
};
goog.exportProperty(box2d.b2Vec3.prototype, "SelfSubXYZ", box2d.b2Vec3.prototype.SelfSubXYZ);
box2d.b2Vec3.prototype.SelfMul = function(a) {
    this.x *= a;
    this.y *= a;
    this.z *= a;
    return this
};
goog.exportProperty(box2d.b2Vec3.prototype, "SelfMul", box2d.b2Vec3.prototype.SelfMul);
box2d.b2DotV3V3 = function(a, b) {
    return a.x * b.x + a.y * b.y + a.z * b.z
};
goog.exportSymbol("box2d.b2DotV3V3", box2d.b2DotV3V3);
box2d.b2CrossV3V3 = function(a, b, c) {
    var e = a.x, d = a.y;
    a = a.z;
    var f = b.x, g = b.y;
    b = b.z;
    c.x = d * b - a * g;
    c.y = a * f - e * b;
    c.z = e * g - d * f;
    return c
};
goog.exportSymbol("box2d.b2CrossV3V3", box2d.b2CrossV3V3);
box2d.b2Mat22 = function() {
    this.ex = new box2d.b2Vec2(1, 0);
    this.ey = new box2d.b2Vec2(0, 1)
};
goog.exportSymbol("box2d.b2Mat22", box2d.b2Mat22);
box2d.b2Mat22.prototype.ex = null;
goog.exportProperty(box2d.b2Mat22.prototype, "ex", box2d.b2Mat22.prototype.ex);
box2d.b2Mat22.prototype.ey = null;
goog.exportProperty(box2d.b2Mat22.prototype, "ey", box2d.b2Mat22.prototype.ey);
box2d.b2Mat22.IDENTITY = new box2d.b2Mat22;
goog.exportProperty(box2d.b2Mat22, "IDENTITY", box2d.b2Mat22.IDENTITY);
box2d.b2Mat22.prototype.Clone = function() {
    return(new box2d.b2Mat22).Copy(this)
};
goog.exportProperty(box2d.b2Mat22.prototype, "Clone", box2d.b2Mat22.prototype.Clone);
box2d.b2Mat22.FromVV = function(a, b) {
    return(new box2d.b2Mat22).SetVV(a, b)
};
goog.exportProperty(box2d.b2Mat22, "FromVV", box2d.b2Mat22.FromVV);
box2d.b2Mat22.FromSSSS = function(a, b, c, e) {
    return(new box2d.b2Mat22).SetSSSS(a, b, c, e)
};
goog.exportProperty(box2d.b2Mat22, "FromSSSS", box2d.b2Mat22.FromSSSS);
box2d.b2Mat22.FromAngleRadians = function(a) {
    return(new box2d.b2Mat22).SetAngleRadians(a)
};
goog.exportProperty(box2d.b2Mat22, "FromAngleRadians", box2d.b2Mat22.FromAngleRadians);
box2d.b2Mat22.prototype.SetSSSS = function(a, b, c, e) {
    this.ex.SetXY(a, c);
    this.ey.SetXY(b, e);
    return this
};
goog.exportProperty(box2d.b2Mat22.prototype, "SetSSSS", box2d.b2Mat22.prototype.SetSSSS);
box2d.b2Mat22.prototype.SetVV = function(a, b) {
    this.ex.Copy(a);
    this.ey.Copy(b);
    return this
};
goog.exportProperty(box2d.b2Mat22.prototype, "SetVV", box2d.b2Mat22.prototype.SetVV);
box2d.b2Mat22.prototype.SetAngle = function(a) {
    var b = Math.cos(a);
    a = Math.sin(a);
    this.ex.SetXY(b, a);
    this.ey.SetXY(-a, b);
    return this
};
goog.exportProperty(box2d.b2Mat22.prototype, "SetAngle", box2d.b2Mat22.prototype.SetAngle);
box2d.b2Mat22.prototype.SetAngleRadians = box2d.b2Mat22.prototype.SetAngle;
box2d.b2Mat22.prototype.SetAngleDegrees = function(a) {
    return this.SetAngle(box2d.b2DegToRad(a))
};
box2d.b2Mat22.prototype.Copy = function(a) {
    this.ex.Copy(a.ex);
    this.ey.Copy(a.ey);
    return this
};
goog.exportProperty(box2d.b2Mat22.prototype, "Copy", box2d.b2Mat22.prototype.Copy);
box2d.b2Mat22.prototype.SetIdentity = function() {
    this.ex.SetXY(1, 0);
    this.ey.SetXY(0, 1);
    return this
};
goog.exportProperty(box2d.b2Mat22.prototype, "SetIdentity", box2d.b2Mat22.prototype.SetIdentity);
box2d.b2Mat22.prototype.SetZero = function() {
    this.ex.SetZero();
    this.ey.SetZero();
    return this
};
goog.exportProperty(box2d.b2Mat22.prototype, "SetZero", box2d.b2Mat22.prototype.SetZero);
box2d.b2Mat22.prototype.GetAngle = function() {
    return Math.atan2(this.ex.y, this.ex.x)
};
goog.exportProperty(box2d.b2Mat22.prototype, "GetAngle", box2d.b2Mat22.prototype.GetAngle);
box2d.b2Mat22.prototype.GetAngleRadians = box2d.b2Mat22.prototype.GetAngle;
box2d.b2Mat22.prototype.GetInverse = function(a) {
    var b = this.ex.x, c = this.ey.x, e = this.ex.y, d = this.ey.y, f = b * d - c * e;
    0 != f && (f = 1 / f);
    a.ex.x = f * d;
    a.ey.x = -f * c;
    a.ex.y = -f * e;
    a.ey.y = f * b;
    return a
};
goog.exportProperty(box2d.b2Mat22.prototype, "GetInverse", box2d.b2Mat22.prototype.GetInverse);
box2d.b2Mat22.prototype.Solve = function(a, b, c) {
    var e = this.ex.x, d = this.ey.x, f = this.ex.y, g = this.ey.y, h = e * g - d * f;
    0 != h && (h = 1 / h);
    c.x = h * (g * a - d * b);
    c.y = h * (e * b - f * a);
    return c
};
goog.exportProperty(box2d.b2Mat22.prototype, "Solve", box2d.b2Mat22.prototype.Solve);
box2d.b2Mat22.prototype.SelfAbs = function() {
    this.ex.SelfAbs();
    this.ey.SelfAbs();
    return this
};
goog.exportProperty(box2d.b2Mat22.prototype, "SelfAbs", box2d.b2Mat22.prototype.SelfAbs);
box2d.b2Mat22.prototype.SelfInv = function() {
    return this.GetInverse(this)
};
goog.exportProperty(box2d.b2Mat22.prototype, "SelfInv", box2d.b2Mat22.prototype.SelfInv);
box2d.b2Mat22.prototype.SelfAddM = function(a) {
    this.ex.SelfAdd(a.ex);
    this.ey.SelfAdd(a.ey);
    return this
};
goog.exportProperty(box2d.b2Mat22.prototype, "SelfAddM", box2d.b2Mat22.prototype.SelfAddM);
box2d.b2Mat22.prototype.SelfSubM = function(a) {
    this.ex.SelfSub(a.ex);
    this.ey.SelfSub(a.ey);
    return this
};
goog.exportProperty(box2d.b2Mat22.prototype, "SelfSubM", box2d.b2Mat22.prototype.SelfSubM);
box2d.b2AbsM = function(a, b) {
    var c = a.ex, e = a.ey;
    b.ex.x = box2d.b2Abs(c.x);
    b.ex.y = box2d.b2Abs(c.y);
    b.ey.x = box2d.b2Abs(e.x);
    b.ey.y = box2d.b2Abs(e.y);
    return b
};
goog.exportSymbol("box2d.b2AbsM", box2d.b2AbsM);
box2d.b2MulMV = function(a, b, c) {
    var e = a.ex;
    a = a.ey;
    var d = b.x;
    b = b.y;
    c.x = e.x * d + a.x * b;
    c.y = e.y * d + a.y * b;
    return c
};
goog.exportSymbol("box2d.b2MulMV", box2d.b2MulMV);
box2d.b2MulTMV = function(a, b, c) {
    var e = a.ex;
    a = a.ey;
    var d = b.x;
    b = b.y;
    c.x = e.x * d + e.y * b;
    c.y = a.x * d + a.y * b;
    return c
};
goog.exportSymbol("box2d.b2MulTMV", box2d.b2MulTMV);
box2d.b2AddMM = function(a, b, c) {
    var e = a.ex;
    a = a.ey;
    var d = b.ex;
    b = b.ey;
    c.ex.x = e.x + d.x;
    c.ex.y = e.y + d.y;
    c.ey.x = a.x + b.x;
    c.ey.y = a.y + b.y;
    return c
};
goog.exportSymbol("box2d.b2AddMM", box2d.b2AddMM);
box2d.b2MulMM = function(a, b, c) {
    var e = a.ex.x, d = a.ex.y, f = a.ey.x;
    a = a.ey.y;
    var g = b.ex.x, h = b.ex.y, l = b.ey.x;
    b = b.ey.y;
    c.ex.x = e * g + f * h;
    c.ex.y = d * g + a * h;
    c.ey.x = e * l + f * b;
    c.ey.y = d * l + a * b;
    return c
};
goog.exportSymbol("box2d.b2MulMM", box2d.b2MulMM);
box2d.b2MulTMM = function(a, b, c) {
    var e = a.ex.x, d = a.ex.y, f = a.ey.x;
    a = a.ey.y;
    var g = b.ex.x, h = b.ex.y, l = b.ey.x;
    b = b.ey.y;
    c.ex.x = e * g + d * h;
    c.ex.y = f * g + a * h;
    c.ey.x = e * l + d * b;
    c.ey.y = f * l + a * b;
    return c
};
goog.exportSymbol("box2d.b2MulTMM", box2d.b2MulTMM);
box2d.b2Mat33 = function() {
    this.ex = new box2d.b2Vec3(1, 0, 0);
    this.ey = new box2d.b2Vec3(0, 1, 0);
    this.ez = new box2d.b2Vec3(0, 0, 1)
};
goog.exportSymbol("box2d.b2Mat33", box2d.b2Mat33);
box2d.b2Mat33.prototype.ex = null;
goog.exportProperty(box2d.b2Mat33.prototype, "ex", box2d.b2Mat33.prototype.ex);
box2d.b2Mat33.prototype.ey = null;
goog.exportProperty(box2d.b2Mat33.prototype, "ey", box2d.b2Mat33.prototype.ey);
box2d.b2Mat33.prototype.ez = null;
goog.exportProperty(box2d.b2Mat33.prototype, "ez", box2d.b2Mat33.prototype.ez);
box2d.b2Mat33.IDENTITY = new box2d.b2Mat33;
goog.exportProperty(box2d.b2Mat33, "IDENTITY", box2d.b2Mat33.IDENTITY);
box2d.b2Mat33.prototype.Clone = function() {
    return(new box2d.b2Mat33).Copy(this)
};
goog.exportProperty(box2d.b2Mat33.prototype, "Clone", box2d.b2Mat33.prototype.Clone);
box2d.b2Mat33.prototype.SetVVV = function(a, b, c) {
    this.ex.Copy(a);
    this.ey.Copy(b);
    this.ez.Copy(c);
    return this
};
goog.exportProperty(box2d.b2Mat33.prototype, "SetVVV", box2d.b2Mat33.prototype.SetVVV);
box2d.b2Mat33.prototype.Copy = function(a) {
    this.ex.Copy(a.ex);
    this.ey.Copy(a.ey);
    this.ez.Copy(a.ez);
    return this
};
goog.exportProperty(box2d.b2Mat33.prototype, "Copy", box2d.b2Mat33.prototype.Copy);
box2d.b2Mat33.prototype.SetIdentity = function() {
    this.ex.SetXYZ(1, 0, 0);
    this.ey.SetXYZ(0, 1, 0);
    this.ez.SetXYZ(0, 0, 1);
    return this
};
goog.exportProperty(box2d.b2Mat33.prototype, "SetIdentity", box2d.b2Mat33.prototype.SetIdentity);
box2d.b2Mat33.prototype.SetZero = function() {
    this.ex.SetZero();
    this.ey.SetZero();
    this.ez.SetZero();
    return this
};
goog.exportProperty(box2d.b2Mat33.prototype, "SetZero", box2d.b2Mat33.prototype.SetZero);
box2d.b2Mat33.prototype.SelfAddM = function(a) {
    this.ex.SelfAdd(a.ex);
    this.ey.SelfAdd(a.ey);
    this.ez.SelfAdd(a.ez);
    return this
};
goog.exportProperty(box2d.b2Mat33.prototype, "SelfAddM", box2d.b2Mat33.prototype.SelfAddM);
box2d.b2Mat33.prototype.Solve33 = function(a, b, c, e) {
    var d = this.ex.x, f = this.ex.y, g = this.ex.z, h = this.ey.x, l = this.ey.y, k = this.ey.z, m = this.ez.x, n = this.ez.y, p = this.ez.z, q = d * (l * p - k * n) + f * (k * m - h * p) + g * (h * n - l * m);
    0 != q && (q = 1 / q);
    e.x = q * (a * (l * p - k * n) + b * (k * m - h * p) + c * (h * n - l * m));
    e.y = q * (d * (b * p - c * n) + f * (c * m - a * p) + g * (a * n - b * m));
    e.z = q * (d * (l * c - k * b) + f * (k * a - h * c) + g * (h * b - l * a));
    return e
};
goog.exportProperty(box2d.b2Mat33.prototype, "Solve33", box2d.b2Mat33.prototype.Solve33);
box2d.b2Mat33.prototype.Solve22 = function(a, b, c) {
    var e = this.ex.x, d = this.ey.x, f = this.ex.y, g = this.ey.y, h = e * g - d * f;
    0 != h && (h = 1 / h);
    c.x = h * (g * a - d * b);
    c.y = h * (e * b - f * a);
    return c
};
goog.exportProperty(box2d.b2Mat33.prototype, "Solve22", box2d.b2Mat33.prototype.Solve22);
box2d.b2Mat33.prototype.GetInverse22 = function(a) {
    var b = this.ex.x, c = this.ey.x, e = this.ex.y, d = this.ey.y, f = b * d - c * e;
    0 != f && (f = 1 / f);
    a.ex.x = f * d;
    a.ey.x = -f * c;
    a.ex.z = 0;
    a.ex.y = -f * e;
    a.ey.y = f * b;
    a.ey.z = 0;
    a.ez.x = 0;
    a.ez.y = 0;
    a.ez.z = 0
};
goog.exportProperty(box2d.b2Mat33.prototype, "GetInverse22", box2d.b2Mat33.prototype.GetInverse22);
box2d.b2Mat33.prototype.GetSymInverse33 = function(a) {
    var b = box2d.b2DotV3V3(this.ex, box2d.b2CrossV3V3(this.ey, this.ez, box2d.b2Vec3.s_t0));
    0 != b && (b = 1 / b);
    var c = this.ex.x, e = this.ey.x, d = this.ez.x, f = this.ey.y, g = this.ez.y, h = this.ez.z;
    a.ex.x = b * (f * h - g * g);
    a.ex.y = b * (d * g - e * h);
    a.ex.z = b * (e * g - d * f);
    a.ey.x = a.ex.y;
    a.ey.y = b * (c * h - d * d);
    a.ey.z = b * (d * e - c * g);
    a.ez.x = a.ex.z;
    a.ez.y = a.ey.z;
    a.ez.z = b * (c * f - e * e)
};
goog.exportProperty(box2d.b2Mat33.prototype, "GetSymInverse33", box2d.b2Mat33.prototype.GetSymInverse33);
box2d.b2MulM33V3 = function(a, b, c) {
    var e = b.x, d = b.y;
    b = b.z;
    c.x = a.ex.x * e + a.ey.x * d + a.ez.x * b;
    c.y = a.ex.y * e + a.ey.y * d + a.ez.y * b;
    c.z = a.ex.z * e + a.ey.z * d + a.ez.z * b;
    return c
};
goog.exportSymbol("box2d.b2MulM33V3", box2d.b2MulM33V3);
box2d.b2MulM33XYZ = function(a, b, c, e, d) {
    d.x = a.ex.x * b + a.ey.x * c + a.ez.x * e;
    d.y = a.ex.y * b + a.ey.y * c + a.ez.y * e;
    d.z = a.ex.z * b + a.ey.z * c + a.ez.z * e;
    return d
};
goog.exportSymbol("box2d.b2MulM33XYZ", box2d.b2MulM33XYZ);
box2d.b2MulM33V2 = function(a, b, c) {
    var e = b.x;
    b = b.y;
    c.x = a.ex.x * e + a.ey.x * b;
    c.y = a.ex.y * e + a.ey.y * b;
    return c
};
goog.exportSymbol("box2d.b2MulM33V2", box2d.b2MulM33V2);
box2d.b2MulM33XY = function(a, b, c, e) {
    e.x = a.ex.x * b + a.ey.x * c;
    e.y = a.ex.y * b + a.ey.y * c;
    return e
};
goog.exportSymbol("box2d.b2MulM33XY", box2d.b2MulM33XY);
box2d.b2Rot = function(a) {
    a && (this.angle = a, this.s = Math.sin(a), this.c = Math.cos(a))
};
goog.exportSymbol("box2d.b2Rot", box2d.b2Rot);
box2d.b2Rot.prototype.angle = 0;
goog.exportProperty(box2d.b2Rot.prototype, "angle", box2d.b2Rot.prototype.angle);
box2d.b2Rot.prototype.s = 0;
goog.exportProperty(box2d.b2Rot.prototype, "s", box2d.b2Rot.prototype.s);
box2d.b2Rot.prototype.c = 1;
goog.exportProperty(box2d.b2Rot.prototype, "c", box2d.b2Rot.prototype.c);
box2d.b2Rot.IDENTITY = new box2d.b2Rot;
goog.exportProperty(box2d.b2Rot, "IDENTITY", box2d.b2Rot.IDENTITY);
box2d.b2Rot.prototype.Clone = function() {
    return(new box2d.b2Rot).Copy(this)
};
goog.exportProperty(box2d.b2Rot.prototype, "Clone", box2d.b2Rot.prototype.Clone);
box2d.b2Rot.prototype.Copy = function(a) {
    this.angle = a.angle;
    this.s = a.s;
    this.c = a.c;
    return this
};
goog.exportProperty(box2d.b2Rot.prototype, "Copy", box2d.b2Rot.prototype.Copy);
box2d.b2Rot.prototype.SetAngle = function(a) {
    this.angle != a && (this.angle = a, this.s = Math.sin(a), this.c = Math.cos(a));
    return this
};
goog.exportProperty(box2d.b2Rot.prototype, "SetAngle", box2d.b2Rot.prototype.SetAngle);
box2d.b2Rot.prototype.SetAngleRadians = box2d.b2Rot.prototype.SetAngle;
box2d.b2Rot.prototype.SetAngleDegrees = function(a) {
    return this.SetAngle(box2d.b2DegToRad(a))
};
box2d.b2Rot.prototype.SetIdentity = function() {
    this.s = this.angle = 0;
    this.c = 1;
    return this
};
goog.exportProperty(box2d.b2Rot.prototype, "SetIdentity", box2d.b2Rot.prototype.SetIdentity);
box2d.b2Rot.prototype.GetAngle = function() {
    return this.angle
};
goog.exportProperty(box2d.b2Rot.prototype, "GetAngle", box2d.b2Rot.prototype.GetAngle);
box2d.b2Rot.prototype.GetAngleRadians = box2d.b2Rot.prototype.GetAngle;
box2d.b2Rot.prototype.GetAngleDegrees = function() {
    return box2d.b2RadToDeg(this.GetAngle())
};
box2d.b2Rot.prototype.GetXAxis = function(a) {
    a.x = this.c;
    a.y = this.s;
    return a
};
goog.exportProperty(box2d.b2Rot.prototype, "GetXAxis", box2d.b2Rot.prototype.GetXAxis);
box2d.b2Rot.prototype.GetYAxis = function(a) {
    a.x = -this.s;
    a.y = this.c;
    return a
};
goog.exportProperty(box2d.b2Rot.prototype, "GetYAxis", box2d.b2Rot.prototype.GetYAxis);
box2d.b2MulRR = function(a, b, c) {
    var e = a.c;
    a = a.s;
    var d = b.c;
    b = b.s;
    c.s = a * d + e * b;
    c.c = e * d - a * b;
    return c
};
goog.exportSymbol("box2d.b2MulRR", box2d.b2MulRR);
box2d.b2MulTRR = function(a, b, c) {
    var e = a.c;
    a = a.s;
    var d = b.c;
    b = b.s;
    c.s = e * b - a * d;
    c.c = e * d + a * b;
    return c
};
goog.exportSymbol("box2d.b2MulTRR", box2d.b2MulTRR);
box2d.b2MulRV = function(a, b, c) {
    var e = a.c;
    a = a.s;
    var d = b.x;
    b = b.y;
    c.x = e * d - a * b;
    c.y = a * d + e * b;
    return c
};
goog.exportSymbol("box2d.b2MulRV", box2d.b2MulRV);
box2d.b2MulTRV = function(a, b, c) {
    var e = a.c;
    a = a.s;
    var d = b.x;
    b = b.y;
    c.x = e * d + a * b;
    c.y = -a * d + e * b;
    return c
};
goog.exportSymbol("box2d.b2MulTRV", box2d.b2MulTRV);
box2d.b2Transform = function() {
    this.p = new box2d.b2Vec2;
    this.q = new box2d.b2Rot
};
goog.exportSymbol("box2d.b2Transform", box2d.b2Transform);
box2d.b2Transform.prototype.p = null;
goog.exportProperty(box2d.b2Transform.prototype, "p", box2d.b2Transform.prototype.p);
box2d.b2Transform.prototype.q = null;
goog.exportProperty(box2d.b2Transform.prototype, "q", box2d.b2Transform.prototype.q);
box2d.b2Transform.IDENTITY = new box2d.b2Transform;
goog.exportProperty(box2d.b2Transform, "IDENTITY", box2d.b2Transform.IDENTITY);
box2d.b2Transform.prototype.Clone = function() {
    return(new box2d.b2Transform).Copy(this)
};
goog.exportProperty(box2d.b2Transform.prototype, "Clone", box2d.b2Transform.prototype.Clone);
box2d.b2Transform.prototype.Copy = function(a) {
    this.p.Copy(a.p);
    this.q.Copy(a.q);
    return this
};
goog.exportProperty(box2d.b2Transform.prototype, "Copy", box2d.b2Transform.prototype.Copy);
box2d.b2Transform.prototype.SetIdentity = function() {
    this.p.SetZero();
    this.q.SetIdentity();
    return this
};
goog.exportProperty(box2d.b2Transform.prototype, "SetIdentity", box2d.b2Transform.prototype.SetIdentity);
box2d.b2Transform.prototype.SetPositionRotation = function(a, b) {
    this.p.Copy(a);
    this.q.Copy(b);
    return this
};
goog.exportProperty(box2d.b2Transform.prototype, "SetPositionRotation", box2d.b2Transform.prototype.SetPositionRotation);
box2d.b2Transform.prototype.SetPositionAngleRadians = function(a, b) {
    this.p.Copy(a);
    this.q.SetAngleRadians(b);
    return this
};
goog.exportProperty(box2d.b2Transform.prototype, "SetPositionAngleRadians", box2d.b2Transform.prototype.SetPositionAngleRadians);
box2d.b2Transform.prototype.SetPosition = function(a) {
    this.p.Copy(a);
    return this
};
goog.exportProperty(box2d.b2Transform.prototype, "SetPosition", box2d.b2Transform.prototype.SetPosition);
box2d.b2Transform.prototype.SetPositionXY = function(a, b) {
    this.p.SetXY(a, b);
    return this
};
goog.exportProperty(box2d.b2Transform.prototype, "SetPositionXY", box2d.b2Transform.prototype.SetPositionXY);
box2d.b2Transform.prototype.SetRotation = function(a) {
    this.q.Copy(a);
    return this
};
goog.exportProperty(box2d.b2Transform.prototype, "SetRotation", box2d.b2Transform.prototype.SetRotation);
box2d.b2Transform.prototype.SetRotationAngleRadians = function(a) {
    this.q.SetAngleRadians(a);
    return this
};
goog.exportProperty(box2d.b2Transform.prototype, "SetRotationAngleRadians", box2d.b2Transform.prototype.SetRotationAngleRadians);
box2d.b2Transform.prototype.GetPosition = function() {
    return this.p
};
goog.exportProperty(box2d.b2Transform.prototype, "GetPosition", box2d.b2Transform.prototype.GetPosition);
box2d.b2Transform.prototype.GetRotation = function() {
    return this.q
};
goog.exportProperty(box2d.b2Transform.prototype, "GetRotation", box2d.b2Transform.prototype.GetRotation);
box2d.b2Transform.prototype.GetRotationAngle = function() {
    return this.q.GetAngle()
};
goog.exportProperty(box2d.b2Transform.prototype, "GetRotationAngle", box2d.b2Transform.prototype.GetRotationAngle);
box2d.b2Transform.prototype.GetRotationAngleRadians = box2d.b2Transform.prototype.GetRotationAngle;
box2d.b2Transform.prototype.GetAngle = function() {
    return this.q.GetAngle()
};
goog.exportProperty(box2d.b2Transform.prototype, "GetAngle", box2d.b2Transform.prototype.GetAngle);
box2d.b2Transform.prototype.GetAngleRadians = box2d.b2Transform.prototype.GetAngle;
box2d.b2MulXV = function(a, b, c) {
    var e = a.q.c, d = a.q.s, f = b.x;
    b = b.y;
    c.x = e * f - d * b + a.p.x;
    c.y = d * f + e * b + a.p.y;
    return c
};
goog.exportSymbol("box2d.b2MulXV", box2d.b2MulXV);
box2d.b2MulTXV = function(a, b, c) {
    var e = a.q.c, d = a.q.s, f = b.x - a.p.x;
    a = b.y - a.p.y;
    c.x = e * f + d * a;
    c.y = -d * f + e * a;
    return c
};
goog.exportSymbol("box2d.b2MulTXV", box2d.b2MulTXV);
box2d.b2MulXX = function(a, b, c) {
    box2d.b2MulRR(a.q, b.q, c.q);
    box2d.b2AddVV(box2d.b2MulRV(a.q, b.p, c.p), a.p, c.p);
    return c
};
goog.exportSymbol("box2d.b2MulXX", box2d.b2MulXX);
box2d.b2MulTXX = function(a, b, c) {
    box2d.b2MulTRR(a.q, b.q, c.q);
    box2d.b2MulTRV(a.q, box2d.b2SubVV(b.p, a.p, c.p), c.p);
    return c
};
goog.exportSymbol("box2d.b2MulTXX", box2d.b2MulTXX);
box2d.b2Sweep = function() {
    this.localCenter = new box2d.b2Vec2;
    this.c0 = new box2d.b2Vec2;
    this.c = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2Sweep", box2d.b2Sweep);
box2d.b2Sweep.prototype.localCenter = null;
goog.exportProperty(box2d.b2Sweep.prototype, "localCenter", box2d.b2Sweep.prototype.localCenter);
box2d.b2Sweep.prototype.c0 = null;
goog.exportProperty(box2d.b2Sweep.prototype, "c0", box2d.b2Sweep.prototype.c0);
box2d.b2Sweep.prototype.c = null;
goog.exportProperty(box2d.b2Sweep.prototype, "c", box2d.b2Sweep.prototype.c);
box2d.b2Sweep.prototype.a0 = 0;
goog.exportProperty(box2d.b2Sweep.prototype, "a0", box2d.b2Sweep.prototype.a0);
box2d.b2Sweep.prototype.a = 0;
goog.exportProperty(box2d.b2Sweep.prototype, "a", box2d.b2Sweep.prototype.a);
box2d.b2Sweep.prototype.alpha0 = 0;
goog.exportProperty(box2d.b2Sweep.prototype, "alpha0", box2d.b2Sweep.prototype.alpha0);
box2d.b2Sweep.prototype.Clone = function() {
    return(new box2d.b2Sweep).Copy(this)
};
goog.exportProperty(box2d.b2Sweep.prototype, "Clone", box2d.b2Sweep.prototype.Clone);
box2d.b2Sweep.prototype.Copy = function(a) {
    this.localCenter.Copy(a.localCenter);
    this.c0.Copy(a.c0);
    this.c.Copy(a.c);
    this.a0 = a.a0;
    this.a = a.a;
    this.alpha0 = a.alpha0;
    return this
};
goog.exportProperty(box2d.b2Sweep.prototype, "Copy", box2d.b2Sweep.prototype.Copy);
box2d.b2Sweep.prototype.GetTransform = function(a, b) {
    var c = 1 - b;
    a.p.x = c * this.c0.x + b * this.c.x;
    a.p.y = c * this.c0.y + b * this.c.y;
    a.q.SetAngleRadians(c * this.a0 + b * this.a);
    a.p.SelfSub(box2d.b2MulRV(a.q, this.localCenter, box2d.b2Vec2.s_t0));
    return a
};
goog.exportProperty(box2d.b2Sweep.prototype, "GetTransform", box2d.b2Sweep.prototype.GetTransform);
box2d.b2Sweep.prototype.Advance = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(1 > this.alpha0);
    var b = (a - this.alpha0) / (1 - this.alpha0), c = 1 - b;
    this.c0.x = c * this.c0.x + b * this.c.x;
    this.c0.y = c * this.c0.y + b * this.c.y;
    this.a0 = c * this.a0 + b * this.a;
    this.alpha0 = a
};
goog.exportProperty(box2d.b2Sweep.prototype, "Advance", box2d.b2Sweep.prototype.Advance);
box2d.b2Sweep.prototype.Normalize = function() {
    var a = box2d.b2_two_pi * Math.floor(this.a0 / box2d.b2_two_pi);
    this.a0 -= a;
    this.a -= a
};
goog.exportProperty(box2d.b2Sweep.prototype, "Normalize", box2d.b2Sweep.prototype.Normalize);
box2d.b2ControllerEdge = function() {
};
goog.exportSymbol("box2d.b2ControllerEdge", box2d.b2ControllerEdge);
box2d.b2ControllerEdge.prototype.controller = null;
goog.exportProperty(box2d.b2ControllerEdge.prototype, "controller", box2d.b2ControllerEdge.prototype.controller);
box2d.b2ControllerEdge.prototype.body = null;
goog.exportProperty(box2d.b2ControllerEdge.prototype, "body", box2d.b2ControllerEdge.prototype.body);
box2d.b2ControllerEdge.prototype.prevBody = null;
goog.exportProperty(box2d.b2ControllerEdge.prototype, "prevBody", box2d.b2ControllerEdge.prototype.prevBody);
box2d.b2ControllerEdge.prototype.nextBody = null;
goog.exportProperty(box2d.b2ControllerEdge.prototype, "nextBody", box2d.b2ControllerEdge.prototype.nextBody);
box2d.b2ControllerEdge.prototype.prevController = null;
goog.exportProperty(box2d.b2ControllerEdge.prototype, "prevController", box2d.b2ControllerEdge.prototype.prevController);
box2d.b2ControllerEdge.prototype.nextController = null;
goog.exportProperty(box2d.b2ControllerEdge.prototype, "nextController", box2d.b2ControllerEdge.prototype.nextController);
box2d.b2Controller = function() {
};
goog.exportSymbol("box2d.b2Controller", box2d.b2Controller);
box2d.b2Controller.prototype.m_world = null;
goog.exportProperty(box2d.b2Controller.prototype, "m_world", box2d.b2Controller.prototype.m_world);
box2d.b2Controller.prototype.m_bodyList = null;
goog.exportProperty(box2d.b2Controller.prototype, "m_bodyList", box2d.b2Controller.prototype.m_bodyList);
box2d.b2Controller.prototype.m_bodyCount = 0;
goog.exportProperty(box2d.b2Controller.prototype, "m_bodyCount", box2d.b2Controller.prototype.m_bodyCount);
box2d.b2Controller.prototype.m_prev = null;
goog.exportProperty(box2d.b2Controller.prototype, "m_prev", box2d.b2Controller.prototype.m_prev);
box2d.b2Controller.prototype.m_next = null;
goog.exportProperty(box2d.b2Controller.prototype, "m_next", box2d.b2Controller.prototype.m_next);
box2d.b2Controller.prototype.Step = function(a) {
};
goog.exportProperty(box2d.b2Controller.prototype, "Step", box2d.b2Controller.prototype.Step);
box2d.b2Controller.prototype.Draw = function(a) {
};
goog.exportProperty(box2d.b2Controller.prototype, "Draw", box2d.b2Controller.prototype.Draw);
box2d.b2Controller.prototype.GetNext = function() {
    return this.m_next
};
goog.exportProperty(box2d.b2Controller.prototype, "GetNext", box2d.b2Controller.prototype.GetNext);
box2d.b2Controller.prototype.GetPrev = function() {
    return this.m_prev
};
goog.exportProperty(box2d.b2Controller.prototype, "GetPrev", box2d.b2Controller.prototype.GetPrev);
box2d.b2Controller.prototype.GetWorld = function() {
    return this.m_world
};
goog.exportProperty(box2d.b2Controller.prototype, "GetWorld", box2d.b2Controller.prototype.GetWorld);
box2d.b2Controller.prototype.GetBodyList = function() {
    return this.m_bodyList
};
goog.exportProperty(box2d.b2Controller.prototype, "GetBodyList", box2d.b2Controller.prototype.GetBodyList);
box2d.b2Controller.prototype.AddBody = function(a) {
    var b = new box2d.b2ControllerEdge;
    b.body = a;
    b.controller = this;
    b.nextBody = this.m_bodyList;
    b.prevBody = null;
    this.m_bodyList && (this.m_bodyList.prevBody = b);
    this.m_bodyList = b;
    ++this.m_bodyCount;
    b.nextController = a.m_controllerList;
    b.prevController = null;
    a.m_controllerList && (a.m_controllerList.prevController = b);
    a.m_controllerList = b;
    ++a.m_controllerCount
};
goog.exportProperty(box2d.b2Controller.prototype, "AddBody", box2d.b2Controller.prototype.AddBody);
box2d.b2Controller.prototype.RemoveBody = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < this.m_bodyCount);
    for (var b = this.m_bodyList; b && b.body != a; )
        b = b.nextBody;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(null != b);
    b.prevBody && (b.prevBody.nextBody = b.nextBody);
    b.nextBody && (b.nextBody.prevBody = b.prevBody);
    this.m_bodyList == b && (this.m_bodyList = b.nextBody);
    --this.m_bodyCount;
    b.nextController && (b.nextController.prevController = b.prevController);
    b.prevController && (b.prevController.nextController = b.nextController);
    a.m_controllerList == b && (a.m_controllerList = b.nextController);
    --a.m_controllerCount
};
goog.exportProperty(box2d.b2Controller.prototype, "RemoveBody", box2d.b2Controller.prototype.RemoveBody);
box2d.b2Controller.prototype.Clear = function() {
    for (; this.m_bodyList; )
        this.RemoveBody(this.m_bodyList.body);
    this.m_bodyCount = 0
};
goog.exportProperty(box2d.b2Controller.prototype, "Clear", box2d.b2Controller.prototype.Clear);
box2d.b2ConstantAccelController = function() {
    box2d.b2Controller.call(this);
    this.A = new box2d.b2Vec2(0, 0)
};
goog.inherits(box2d.b2ConstantAccelController, box2d.b2Controller);
goog.exportSymbol("box2d.b2ConstantAccelController", box2d.b2ConstantAccelController);
box2d.b2ConstantAccelController.prototype.A = null;
goog.exportProperty(box2d.b2ConstantAccelController.prototype, "A", box2d.b2ConstantAccelController.prototype.A);
box2d.b2ConstantAccelController.prototype.Step = function(a) {
    a = box2d.b2MulSV(a.dt, this.A, box2d.b2ConstantAccelController.prototype.Step.s_dtA);
    for (var b = this.m_bodyList; b; b = b.nextBody) {
        var c = b.body;
        c.IsAwake() && c.SetLinearVelocity(box2d.b2AddVV(c.GetLinearVelocity(), a, box2d.b2Vec2.s_t0))
    }
};
goog.exportProperty(box2d.b2ConstantAccelController.prototype, "Step", box2d.b2ConstantAccelController.prototype.Step);
box2d.b2ConstantAccelController.prototype.Step.s_dtA = new box2d.b2Vec2;
box2d.b2JointType = {e_unknownJoint: 0, e_revoluteJoint: 1, e_prismaticJoint: 2, e_distanceJoint: 3, e_pulleyJoint: 4, e_mouseJoint: 5, e_gearJoint: 6, e_wheelJoint: 7, e_weldJoint: 8, e_frictionJoint: 9, e_ropeJoint: 10, e_motorJoint: 11, e_areaJoint: 12};
goog.exportSymbol("box2d.b2JointType", box2d.b2JointType);
goog.exportProperty(box2d.b2JointType, "e_unknownJoint", box2d.b2JointType.e_unknownJoint);
goog.exportProperty(box2d.b2JointType, "e_revoluteJoint", box2d.b2JointType.e_revoluteJoint);
goog.exportProperty(box2d.b2JointType, "e_prismaticJoint", box2d.b2JointType.e_prismaticJoint);
goog.exportProperty(box2d.b2JointType, "e_distanceJoint", box2d.b2JointType.e_distanceJoint);
goog.exportProperty(box2d.b2JointType, "e_pulleyJoint", box2d.b2JointType.e_pulleyJoint);
goog.exportProperty(box2d.b2JointType, "e_mouseJoint", box2d.b2JointType.e_mouseJoint);
goog.exportProperty(box2d.b2JointType, "e_gearJoint", box2d.b2JointType.e_gearJoint);
goog.exportProperty(box2d.b2JointType, "e_wheelJoint", box2d.b2JointType.e_wheelJoint);
goog.exportProperty(box2d.b2JointType, "e_weldJoint", box2d.b2JointType.e_weldJoint);
goog.exportProperty(box2d.b2JointType, "e_frictionJoint", box2d.b2JointType.e_frictionJoint);
goog.exportProperty(box2d.b2JointType, "e_ropeJoint", box2d.b2JointType.e_ropeJoint);
goog.exportProperty(box2d.b2JointType, "e_motorJoint", box2d.b2JointType.e_motorJoint);
goog.exportProperty(box2d.b2JointType, "e_areaJoint", box2d.b2JointType.e_areaJoint);
box2d.b2LimitState = {e_inactiveLimit: 0, e_atLowerLimit: 1, e_atUpperLimit: 2, e_equalLimits: 3};
goog.exportSymbol("box2d.b2LimitState", box2d.b2LimitState);
goog.exportProperty(box2d.b2LimitState, "e_inactiveLimit", box2d.b2LimitState.e_inactiveLimit);
goog.exportProperty(box2d.b2LimitState, "e_atLowerLimit", box2d.b2LimitState.e_atLowerLimit);
goog.exportProperty(box2d.b2LimitState, "e_atUpperLimit", box2d.b2LimitState.e_atUpperLimit);
goog.exportProperty(box2d.b2LimitState, "e_equalLimits", box2d.b2LimitState.e_equalLimits);
box2d.b2Jacobian = function() {
    this.linear = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2Jacobian", box2d.b2Jacobian);
box2d.b2Jacobian.prototype.linear = null;
goog.exportProperty(box2d.b2Jacobian.prototype, "linear", box2d.b2Jacobian.prototype.linear);
box2d.b2Jacobian.prototype.angularA = 0;
goog.exportProperty(box2d.b2Jacobian.prototype, "angularA", box2d.b2Jacobian.prototype.angularA);
box2d.b2Jacobian.prototype.angularB = 0;
goog.exportProperty(box2d.b2Jacobian.prototype, "angularB", box2d.b2Jacobian.prototype.angularB);
box2d.b2Jacobian.prototype.SetZero = function() {
    this.linear.SetZero();
    this.angularB = this.angularA = 0;
    return this
};
goog.exportProperty(box2d.b2Jacobian.prototype, "SetZero", box2d.b2Jacobian.prototype.SetZero);
box2d.b2Jacobian.prototype.Set = function(a, b, c) {
    this.linear.Copy(a);
    this.angularA = b;
    this.angularB = c;
    return this
};
goog.exportProperty(box2d.b2Jacobian.prototype, "Set", box2d.b2Jacobian.prototype.Set);
box2d.b2JointEdge = function() {
};
goog.exportSymbol("box2d.b2JointEdge", box2d.b2JointEdge);
box2d.b2JointEdge.prototype.other = null;
goog.exportProperty(box2d.b2JointEdge.prototype, "other", box2d.b2JointEdge.prototype.other);
box2d.b2JointEdge.prototype.joint = null;
goog.exportProperty(box2d.b2JointEdge.prototype, "joint", box2d.b2JointEdge.prototype.joint);
box2d.b2JointEdge.prototype.prev = null;
goog.exportProperty(box2d.b2JointEdge.prototype, "prev", box2d.b2JointEdge.prototype.prev);
box2d.b2JointEdge.prototype.next = null;
goog.exportProperty(box2d.b2JointEdge.prototype, "next", box2d.b2JointEdge.prototype.next);
box2d.b2JointDef = function(a) {
    this.type = a
};
goog.exportSymbol("box2d.b2JointDef", box2d.b2JointDef);
box2d.b2JointDef.prototype.type = box2d.b2JointType.e_unknownJoint;
goog.exportProperty(box2d.b2JointDef.prototype, "type", box2d.b2JointDef.prototype.type);
box2d.b2JointDef.prototype.userData = null;
goog.exportProperty(box2d.b2JointDef.prototype, "userData", box2d.b2JointDef.prototype.userData);
box2d.b2JointDef.prototype.bodyA = null;
goog.exportProperty(box2d.b2JointDef.prototype, "bodyA", box2d.b2JointDef.prototype.bodyA);
box2d.b2JointDef.prototype.bodyB = null;
goog.exportProperty(box2d.b2JointDef.prototype, "bodyB", box2d.b2JointDef.prototype.bodyB);
box2d.b2JointDef.prototype.collideConnected = !1;
goog.exportProperty(box2d.b2JointDef.prototype, "collideConnected", box2d.b2JointDef.prototype.collideConnected);
box2d.b2Joint = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.bodyA != a.bodyB);
    this.m_type = a.type;
    this.m_edgeA = new box2d.b2JointEdge;
    this.m_edgeB = new box2d.b2JointEdge;
    this.m_bodyA = a.bodyA;
    this.m_bodyB = a.bodyB;
    this.m_collideConnected = a.collideConnected;
    this.m_userData = a.userData
};
goog.exportSymbol("box2d.b2Joint", box2d.b2Joint);
box2d.b2Joint.prototype.m_type = box2d.b2JointType.e_unknownJoint;
goog.exportProperty(box2d.b2Joint.prototype, "m_type", box2d.b2Joint.prototype.m_type);
box2d.b2Joint.prototype.m_prev = null;
goog.exportProperty(box2d.b2Joint.prototype, "m_prev", box2d.b2Joint.prototype.m_prev);
box2d.b2Joint.prototype.m_next = null;
goog.exportProperty(box2d.b2Joint.prototype, "m_next", box2d.b2Joint.prototype.m_next);
box2d.b2Joint.prototype.m_edgeA = null;
goog.exportProperty(box2d.b2Joint.prototype, "m_edgeA", box2d.b2Joint.prototype.m_edgeA);
box2d.b2Joint.prototype.m_edgeB = null;
goog.exportProperty(box2d.b2Joint.prototype, "m_edgeB", box2d.b2Joint.prototype.m_edgeB);
box2d.b2Joint.prototype.m_bodyA = null;
goog.exportProperty(box2d.b2Joint.prototype, "m_bodyA", box2d.b2Joint.prototype.m_bodyA);
box2d.b2Joint.prototype.m_bodyB = null;
goog.exportProperty(box2d.b2Joint.prototype, "m_bodyB", box2d.b2Joint.prototype.m_bodyB);
box2d.b2Joint.prototype.m_index = 0;
goog.exportProperty(box2d.b2Joint.prototype, "m_index", box2d.b2Joint.prototype.m_index);
box2d.b2Joint.prototype.m_islandFlag = !1;
goog.exportProperty(box2d.b2Joint.prototype, "m_islandFlag", box2d.b2Joint.prototype.m_islandFlag);
box2d.b2Joint.prototype.m_collideConnected = !1;
goog.exportProperty(box2d.b2Joint.prototype, "m_collideConnected", box2d.b2Joint.prototype.m_collideConnected);
box2d.b2Joint.prototype.m_userData = null;
goog.exportProperty(box2d.b2Joint.prototype, "m_userData", box2d.b2Joint.prototype.m_userData);
box2d.b2Joint.prototype.GetAnchorA = function(a) {
    return a.SetZero()
};
goog.exportProperty(box2d.b2Joint.prototype, "GetAnchorA", box2d.b2Joint.prototype.GetAnchorA);
box2d.b2Joint.prototype.GetAnchorB = function(a) {
    return a.SetZero()
};
goog.exportProperty(box2d.b2Joint.prototype, "GetAnchorB", box2d.b2Joint.prototype.GetAnchorB);
box2d.b2Joint.prototype.GetReactionForce = function(a, b) {
    return b.SetZero()
};
goog.exportProperty(box2d.b2Joint.prototype, "GetReactionForce", box2d.b2Joint.prototype.GetReactionForce);
box2d.b2Joint.prototype.GetReactionTorque = function(a) {
    return 0
};
goog.exportProperty(box2d.b2Joint.prototype, "GetReactionTorque", box2d.b2Joint.prototype.GetReactionTorque);
box2d.b2Joint.prototype.InitVelocityConstraints = function(a) {
};
goog.exportProperty(box2d.b2Joint.prototype, "InitVelocityConstraints", box2d.b2Joint.prototype.InitVelocityConstraints);
box2d.b2Joint.prototype.SolveVelocityConstraints = function(a) {
};
goog.exportProperty(box2d.b2Joint.prototype, "SolveVelocityConstraints", box2d.b2Joint.prototype.SolveVelocityConstraints);
box2d.b2Joint.prototype.SolvePositionConstraints = function(a) {
    return!1
};
goog.exportProperty(box2d.b2Joint.prototype, "SolvePositionConstraints", box2d.b2Joint.prototype.SolvePositionConstraints);
box2d.b2Joint.prototype.GetType = function() {
    return this.m_type
};
goog.exportProperty(box2d.b2Joint.prototype, "GetType", box2d.b2Joint.prototype.GetType);
box2d.b2Joint.prototype.GetBodyA = function() {
    return this.m_bodyA
};
goog.exportProperty(box2d.b2Joint.prototype, "GetBodyA", box2d.b2Joint.prototype.GetBodyA);
box2d.b2Joint.prototype.GetBodyB = function() {
    return this.m_bodyB
};
goog.exportProperty(box2d.b2Joint.prototype, "GetBodyB", box2d.b2Joint.prototype.GetBodyB);
box2d.b2Joint.prototype.GetNext = function() {
    return this.m_next
};
goog.exportProperty(box2d.b2Joint.prototype, "GetNext", box2d.b2Joint.prototype.GetNext);
box2d.b2Joint.prototype.GetUserData = function() {
    return this.m_userData
};
goog.exportProperty(box2d.b2Joint.prototype, "GetUserData", box2d.b2Joint.prototype.GetUserData);
box2d.b2Joint.prototype.SetUserData = function(a) {
    this.m_userData = a
};
goog.exportProperty(box2d.b2Joint.prototype, "SetUserData", box2d.b2Joint.prototype.SetUserData);
box2d.b2Joint.prototype.GetCollideConnected = function() {
    return this.m_collideConnected
};
goog.exportProperty(box2d.b2Joint.prototype, "GetCollideConnected", box2d.b2Joint.prototype.GetCollideConnected);
box2d.b2Joint.prototype.Dump = function() {
    box2d.DEBUG && box2d.b2Log("// Dump is not supported for this joint type.\n")
};
goog.exportProperty(box2d.b2Joint.prototype, "Dump", box2d.b2Joint.prototype.Dump);
box2d.b2Joint.prototype.IsActive = function() {
    return this.m_bodyA.IsActive() && this.m_bodyB.IsActive()
};
goog.exportProperty(box2d.b2Joint.prototype, "IsActive", box2d.b2Joint.prototype.IsActive);
box2d.b2Joint.prototype.ShiftOrigin = function(a) {
};
goog.exportProperty(box2d.b2Joint.prototype, "ShiftOrigin", box2d.b2Joint.prototype.ShiftOrigin);
box2d.b2RevoluteJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_revoluteJoint);
    this.localAnchorA = new box2d.b2Vec2(0, 0);
    this.localAnchorB = new box2d.b2Vec2(0, 0)
};
goog.inherits(box2d.b2RevoluteJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2RevoluteJointDef", box2d.b2RevoluteJointDef);
box2d.b2RevoluteJointDef.prototype.localAnchorA = null;
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "localAnchorA", box2d.b2RevoluteJointDef.prototype.localAnchorA);
box2d.b2RevoluteJointDef.prototype.localAnchorB = null;
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "localAnchorB", box2d.b2RevoluteJointDef.prototype.localAnchorB);
box2d.b2RevoluteJointDef.prototype.referenceAngle = 0;
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "referenceAngle", box2d.b2RevoluteJointDef.prototype.referenceAngle);
box2d.b2RevoluteJointDef.prototype.enableLimit = !1;
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "enableLimit", box2d.b2RevoluteJointDef.prototype.enableLimit);
box2d.b2RevoluteJointDef.prototype.lowerAngle = 0;
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "lowerAngle", box2d.b2RevoluteJointDef.prototype.lowerAngle);
box2d.b2RevoluteJointDef.prototype.upperAngle = 0;
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "upperAngle", box2d.b2RevoluteJointDef.prototype.upperAngle);
box2d.b2RevoluteJointDef.prototype.enableMotor = !1;
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "enableMotor", box2d.b2RevoluteJointDef.prototype.enableMotor);
box2d.b2RevoluteJointDef.prototype.motorSpeed = 0;
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "motorSpeed", box2d.b2RevoluteJointDef.prototype.motorSpeed);
box2d.b2RevoluteJointDef.prototype.maxMotorTorque = 0;
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "maxMotorTorque", box2d.b2RevoluteJointDef.prototype.maxMotorTorque);
box2d.b2RevoluteJointDef.prototype.Initialize = function(a, b, c) {
    this.bodyA = a;
    this.bodyB = b;
    this.bodyA.GetLocalPoint(c, this.localAnchorA);
    this.bodyB.GetLocalPoint(c, this.localAnchorB);
    this.referenceAngle = this.bodyB.GetAngleRadians() - this.bodyA.GetAngleRadians()
};
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "Initialize", box2d.b2RevoluteJointDef.prototype.Initialize);
box2d.b2RevoluteJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_localAnchorA = new box2d.b2Vec2;
    this.m_localAnchorB = new box2d.b2Vec2;
    this.m_impulse = new box2d.b2Vec3;
    this.m_rA = new box2d.b2Vec2;
    this.m_rB = new box2d.b2Vec2;
    this.m_localCenterA = new box2d.b2Vec2;
    this.m_localCenterB = new box2d.b2Vec2;
    this.m_mass = new box2d.b2Mat33;
    this.m_qA = new box2d.b2Rot;
    this.m_qB = new box2d.b2Rot;
    this.m_lalcA = new box2d.b2Vec2;
    this.m_lalcB = new box2d.b2Vec2;
    this.m_K = new box2d.b2Mat22;
    this.m_localAnchorA.Copy(a.localAnchorA);
    this.m_localAnchorB.Copy(a.localAnchorB);
    this.m_referenceAngle = a.referenceAngle;
    this.m_impulse.SetZero();
    this.m_motorImpulse = 0;
    this.m_lowerAngle = a.lowerAngle;
    this.m_upperAngle = a.upperAngle;
    this.m_maxMotorTorque = a.maxMotorTorque;
    this.m_motorSpeed = a.motorSpeed;
    this.m_enableLimit = a.enableLimit;
    this.m_enableMotor = a.enableMotor;
    this.m_limitState = box2d.b2LimitState.e_inactiveLimit
};
goog.inherits(box2d.b2RevoluteJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2RevoluteJoint", box2d.b2RevoluteJoint);
box2d.b2RevoluteJoint.prototype.m_localAnchorA = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_localAnchorA", box2d.b2RevoluteJoint.prototype.m_localAnchorA);
box2d.b2RevoluteJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_localAnchorB", box2d.b2RevoluteJoint.prototype.m_localAnchorB);
box2d.b2RevoluteJoint.prototype.m_impulse = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_impulse", box2d.b2RevoluteJoint.prototype.m_impulse);
box2d.b2RevoluteJoint.prototype.m_motorImpulse = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_motorImpulse", box2d.b2RevoluteJoint.prototype.m_motorImpulse);
box2d.b2RevoluteJoint.prototype.m_enableMotor = !1;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_enableMotor", box2d.b2RevoluteJoint.prototype.m_enableMotor);
box2d.b2RevoluteJoint.prototype.m_maxMotorTorque = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_maxMotorTorque", box2d.b2RevoluteJoint.prototype.m_maxMotorTorque);
box2d.b2RevoluteJoint.prototype.m_motorSpeed = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_motorSpeed", box2d.b2RevoluteJoint.prototype.m_motorSpeed);
box2d.b2RevoluteJoint.prototype.m_enableLimit = !1;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_enableLimit", box2d.b2RevoluteJoint.prototype.m_enableLimit);
box2d.b2RevoluteJoint.prototype.m_referenceAngle = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_referenceAngle", box2d.b2RevoluteJoint.prototype.m_referenceAngle);
box2d.b2RevoluteJoint.prototype.m_lowerAngle = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_lowerAngle", box2d.b2RevoluteJoint.prototype.m_lowerAngle);
box2d.b2RevoluteJoint.prototype.m_upperAngle = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_upperAngle", box2d.b2RevoluteJoint.prototype.m_upperAngle);
box2d.b2RevoluteJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_indexA", box2d.b2RevoluteJoint.prototype.m_indexA);
box2d.b2RevoluteJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_indexB", box2d.b2RevoluteJoint.prototype.m_indexB);
box2d.b2RevoluteJoint.prototype.m_rA = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_rA", box2d.b2RevoluteJoint.prototype.m_rA);
box2d.b2RevoluteJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_rB", box2d.b2RevoluteJoint.prototype.m_rB);
box2d.b2RevoluteJoint.prototype.m_localCenterA = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_localCenterA", box2d.b2RevoluteJoint.prototype.m_localCenterA);
box2d.b2RevoluteJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_localCenterB", box2d.b2RevoluteJoint.prototype.m_localCenterB);
box2d.b2RevoluteJoint.prototype.m_invMassA = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_invMassA", box2d.b2RevoluteJoint.prototype.m_invMassA);
box2d.b2RevoluteJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_invMassB", box2d.b2RevoluteJoint.prototype.m_invMassB);
box2d.b2RevoluteJoint.prototype.m_invIA = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_invIA", box2d.b2RevoluteJoint.prototype.m_invIA);
box2d.b2RevoluteJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_invIB", box2d.b2RevoluteJoint.prototype.m_invIB);
box2d.b2RevoluteJoint.prototype.m_mass = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_mass", box2d.b2RevoluteJoint.prototype.m_mass);
box2d.b2RevoluteJoint.prototype.m_motorMass = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_motorMass", box2d.b2RevoluteJoint.prototype.m_motorMass);
box2d.b2RevoluteJoint.prototype.m_limitState = box2d.b2LimitState.e_inactiveLimit;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_limitState", box2d.b2RevoluteJoint.prototype.m_limitState);
box2d.b2RevoluteJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_qA", box2d.b2RevoluteJoint.prototype.m_qA);
box2d.b2RevoluteJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_qB", box2d.b2RevoluteJoint.prototype.m_qB);
box2d.b2RevoluteJoint.prototype.m_lalcA = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_lalcA", box2d.b2RevoluteJoint.prototype.m_lalcA);
box2d.b2RevoluteJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_lalcB", box2d.b2RevoluteJoint.prototype.m_lalcB);
box2d.b2RevoluteJoint.prototype.m_K = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_K", box2d.b2RevoluteJoint.prototype.m_K);
box2d.b2RevoluteJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassA = this.m_bodyA.m_invMass;
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIA = this.m_bodyA.m_invI;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = a.positions[this.m_indexA].a, c = a.velocities[this.m_indexA].v, e = a.velocities[this.m_indexA].w,
            d = a.positions[this.m_indexB].a, f = a.velocities[this.m_indexB].v, g = a.velocities[this.m_indexB].w, h = this.m_qA.SetAngleRadians(b), l = this.m_qB.SetAngleRadians(d);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    box2d.b2MulRV(h, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    box2d.b2MulRV(l, this.m_lalcB, this.m_rB);
    var h = this.m_invMassA, l = this.m_invMassB, k = this.m_invIA, m = this.m_invIB, n = 0 == k + m;
    this.m_mass.ex.x = h + l + this.m_rA.y * this.m_rA.y * k + this.m_rB.y *
            this.m_rB.y * m;
    this.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * k - this.m_rB.y * this.m_rB.x * m;
    this.m_mass.ez.x = -this.m_rA.y * k - this.m_rB.y * m;
    this.m_mass.ex.y = this.m_mass.ey.x;
    this.m_mass.ey.y = h + l + this.m_rA.x * this.m_rA.x * k + this.m_rB.x * this.m_rB.x * m;
    this.m_mass.ez.y = this.m_rA.x * k + this.m_rB.x * m;
    this.m_mass.ex.z = this.m_mass.ez.x;
    this.m_mass.ey.z = this.m_mass.ez.y;
    this.m_mass.ez.z = k + m;
    this.m_motorMass = k + m;
    0 < this.m_motorMass && (this.m_motorMass = 1 / this.m_motorMass);
    if (!1 == this.m_enableMotor || n)
        this.m_motorImpulse = 0;
    this.m_enableLimit && !1 == n ? (b = d - b - this.m_referenceAngle, box2d.b2Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * box2d.b2_angularSlop ? this.m_limitState = box2d.b2LimitState.e_equalLimits : b <= this.m_lowerAngle ? (this.m_limitState != box2d.b2LimitState.e_atLowerLimit && (this.m_impulse.z = 0), this.m_limitState = box2d.b2LimitState.e_atLowerLimit) : b >= this.m_upperAngle ? (this.m_limitState != box2d.b2LimitState.e_atUpperLimit && (this.m_impulse.z = 0), this.m_limitState = box2d.b2LimitState.e_atUpperLimit) : (this.m_limitState = box2d.b2LimitState.e_inactiveLimit,
            this.m_impulse.z = 0)) : this.m_limitState = box2d.b2LimitState.e_inactiveLimit;
    a.step.warmStarting ? (this.m_impulse.SelfMul(a.step.dtRatio), this.m_motorImpulse *= a.step.dtRatio, b = box2d.b2RevoluteJoint.prototype.InitVelocityConstraints.s_P.SetXY(this.m_impulse.x, this.m_impulse.y), c.SelfMulSub(h, b), e -= k * (box2d.b2CrossVV(this.m_rA, b) + this.m_motorImpulse + this.m_impulse.z), f.SelfMulAdd(l, b), g += m * (box2d.b2CrossVV(this.m_rB, b) + this.m_motorImpulse + this.m_impulse.z)) : (this.m_impulse.SetZero(), this.m_motorImpulse =
            0);
    a.velocities[this.m_indexA].w = e;
    a.velocities[this.m_indexB].w = g
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "InitVelocityConstraints", box2d.b2RevoluteJoint.prototype.InitVelocityConstraints);
box2d.b2RevoluteJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.velocities[this.m_indexB].v, d = a.velocities[this.m_indexB].w, f = this.m_invMassA, g = this.m_invMassB, h = this.m_invIA, l = this.m_invIB, k = 0 == h + l;
    if (this.m_enableMotor && this.m_limitState != box2d.b2LimitState.e_equalLimits && !1 == k) {
        var m = d - c - this.m_motorSpeed, m = -this.m_motorMass * m, n = this.m_motorImpulse, p = a.step.dt * this.m_maxMotorTorque;
        this.m_motorImpulse = box2d.b2Clamp(this.m_motorImpulse +
                m, -p, p);
        m = this.m_motorImpulse - n;
        c -= h * m;
        d += l * m
    }
    this.m_enableLimit && this.m_limitState != box2d.b2LimitState.e_inactiveLimit && !1 == k ? (k = box2d.b2SubVV(box2d.b2AddVCrossSV(e, d, this.m_rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(b, c, this.m_rA, box2d.b2Vec2.s_t1), box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot1), m = this.m_mass.Solve33(k.x, k.y, d - c, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse3).SelfNeg(), this.m_limitState == box2d.b2LimitState.e_equalLimits ? this.m_impulse.SelfAdd(m) :
            this.m_limitState == box2d.b2LimitState.e_atLowerLimit ? (n = this.m_impulse.z + m.z, 0 > n ? (n = -k.x + this.m_impulse.z * this.m_mass.ez.x, k = -k.y + this.m_impulse.z * this.m_mass.ez.y, k = this.m_mass.Solve22(n, k, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_reduced), m.x = k.x, m.y = k.y, m.z = -this.m_impulse.z, this.m_impulse.x += k.x, this.m_impulse.y += k.y, this.m_impulse.z = 0) : this.m_impulse.SelfAdd(m)) : this.m_limitState == box2d.b2LimitState.e_atUpperLimit && (n = this.m_impulse.z + m.z, 0 < n ? (n = -k.x + this.m_impulse.z * this.m_mass.ez.x,
            k = -k.y + this.m_impulse.z * this.m_mass.ez.y, k = this.m_mass.Solve22(n, k, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_reduced), m.x = k.x, m.y = k.y, m.z = -this.m_impulse.z, this.m_impulse.x += k.x, this.m_impulse.y += k.y, this.m_impulse.z = 0) : this.m_impulse.SelfAdd(m)), k = box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_P.SetXY(m.x, m.y), b.SelfMulSub(f, k), c -= h * (box2d.b2CrossVV(this.m_rA, k) + m.z), e.SelfMulAdd(g, k), d += l * (box2d.b2CrossVV(this.m_rB, k) + m.z)) : (m = box2d.b2SubVV(box2d.b2AddVCrossSV(e, d, this.m_rB,
            box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(b, c, this.m_rA, box2d.b2Vec2.s_t1), box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot), m = this.m_mass.Solve22(-m.x, -m.y, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse2), this.m_impulse.x += m.x, this.m_impulse.y += m.y, b.SelfMulSub(f, m), c -= h * box2d.b2CrossVV(this.m_rA, m), e.SelfMulAdd(g, m), d += l * box2d.b2CrossVV(this.m_rB, m));
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = d
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "SolveVelocityConstraints", box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints);
box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2;
box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot1 = new box2d.b2Vec2;
box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse3 = new box2d.b2Vec3;
box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_reduced = new box2d.b2Vec2;
box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse2 = new box2d.b2Vec2;
box2d.b2RevoluteJoint.prototype.SolvePositionConstraints = function(a) {
    var b = a.positions[this.m_indexA].c, c = a.positions[this.m_indexA].a, e = a.positions[this.m_indexB].c, d = a.positions[this.m_indexB].a, f = this.m_qA.SetAngleRadians(c), g = this.m_qB.SetAngleRadians(d), h = 0, l = 0, l = 0 == this.m_invIA + this.m_invIB;
    if (this.m_enableLimit && this.m_limitState != box2d.b2LimitState.e_inactiveLimit && !1 == l) {
        var k = d - c - this.m_referenceAngle, l = 0;
        this.m_limitState == box2d.b2LimitState.e_equalLimits ? (k = box2d.b2Clamp(k - this.m_lowerAngle,
                -box2d.b2_maxAngularCorrection, box2d.b2_maxAngularCorrection), l = -this.m_motorMass * k, h = box2d.b2Abs(k)) : this.m_limitState == box2d.b2LimitState.e_atLowerLimit ? (k -= this.m_lowerAngle, h = -k, k = box2d.b2Clamp(k + box2d.b2_angularSlop, -box2d.b2_maxAngularCorrection, 0), l = -this.m_motorMass * k) : this.m_limitState == box2d.b2LimitState.e_atUpperLimit && (h = k -= this.m_upperAngle, k = box2d.b2Clamp(k - box2d.b2_angularSlop, 0, box2d.b2_maxAngularCorrection), l = -this.m_motorMass * k);
        c -= this.m_invIA * l;
        d += this.m_invIB * l
    }
    f.SetAngleRadians(c);
    g.SetAngleRadians(d);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    f = box2d.b2MulRV(f, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var g = box2d.b2MulRV(g, this.m_lalcB, this.m_rB), k = box2d.b2SubVV(box2d.b2AddVV(e, g, box2d.b2Vec2.s_t0), box2d.b2AddVV(b, f, box2d.b2Vec2.s_t1), box2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_C), l = k.GetLength(), m = this.m_invMassA, n = this.m_invMassB, p = this.m_invIA, q = this.m_invIB, r = this.m_K;
    r.ex.x = m + n +
            p * f.y * f.y + q * g.y * g.y;
    r.ex.y = -p * f.x * f.y - q * g.x * g.y;
    r.ey.x = r.ex.y;
    r.ey.y = m + n + p * f.x * f.x + q * g.x * g.x;
    k = r.Solve(k.x, k.y, box2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_impulse).SelfNeg();
    b.SelfMulSub(m, k);
    c -= p * box2d.b2CrossVV(f, k);
    e.SelfMulAdd(n, k);
    d += q * box2d.b2CrossVV(g, k);
    a.positions[this.m_indexA].a = c;
    a.positions[this.m_indexB].a = d;
    return l <= box2d.b2_linearSlop && h <= box2d.b2_angularSlop
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "SolvePositionConstraints", box2d.b2RevoluteJoint.prototype.SolvePositionConstraints);
box2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_C = new box2d.b2Vec2;
box2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_impulse = new box2d.b2Vec2;
box2d.b2RevoluteJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, a)
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetAnchorA", box2d.b2RevoluteJoint.prototype.GetAnchorA);
box2d.b2RevoluteJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetAnchorB", box2d.b2RevoluteJoint.prototype.GetAnchorB);
box2d.b2RevoluteJoint.prototype.GetReactionForce = function(a, b) {
    return b.SetXY(a * this.m_impulse.x, a * this.m_impulse.y)
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetReactionForce", box2d.b2RevoluteJoint.prototype.GetReactionForce);
box2d.b2RevoluteJoint.prototype.GetReactionTorque = function(a) {
    return a * this.m_impulse.z
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetReactionTorque", box2d.b2RevoluteJoint.prototype.GetReactionTorque);
box2d.b2RevoluteJoint.prototype.GetLocalAnchorA = function(a) {
    return a.Copy(this.m_localAnchorA)
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetLocalAnchorA", box2d.b2RevoluteJoint.prototype.GetLocalAnchorA);
box2d.b2RevoluteJoint.prototype.GetLocalAnchorB = function(a) {
    return a.Copy(this.m_localAnchorB)
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetLocalAnchorB", box2d.b2RevoluteJoint.prototype.GetLocalAnchorB);
box2d.b2RevoluteJoint.prototype.GetReferenceAngle = function() {
    return this.m_referenceAngle
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetReferenceAngle", box2d.b2RevoluteJoint.prototype.GetReferenceAngle);
box2d.b2RevoluteJoint.prototype.GetJointAngleRadians = function() {
    return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetJointAngleRadians", box2d.b2RevoluteJoint.prototype.GetJointAngleRadians);
box2d.b2RevoluteJoint.prototype.GetJointSpeed = function() {
    return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetJointSpeed", box2d.b2RevoluteJoint.prototype.GetJointSpeed);
box2d.b2RevoluteJoint.prototype.IsMotorEnabled = function() {
    return this.m_enableMotor
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "IsMotorEnabled", box2d.b2RevoluteJoint.prototype.IsMotorEnabled);
box2d.b2RevoluteJoint.prototype.EnableMotor = function(a) {
    this.m_enableMotor != a && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor = a)
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "EnableMotor", box2d.b2RevoluteJoint.prototype.EnableMotor);
box2d.b2RevoluteJoint.prototype.GetMotorTorque = function(a) {
    return a * this.m_motorImpulse
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetMotorTorque", box2d.b2RevoluteJoint.prototype.GetMotorTorque);
box2d.b2RevoluteJoint.prototype.GetMotorSpeed = function() {
    return this.m_motorSpeed
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetMotorSpeed", box2d.b2RevoluteJoint.prototype.GetMotorSpeed);
box2d.b2RevoluteJoint.prototype.SetMaxMotorTorque = function(a) {
    this.m_maxMotorTorque = a
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "SetMaxMotorTorque", box2d.b2RevoluteJoint.prototype.SetMaxMotorTorque);
box2d.b2RevoluteJoint.prototype.GetMaxMotorTorque = function() {
    return this.m_maxMotorTorque
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetMaxMotorTorque", box2d.b2RevoluteJoint.prototype.GetMaxMotorTorque);
box2d.b2RevoluteJoint.prototype.IsLimitEnabled = function() {
    return this.m_enableLimit
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "IsLimitEnabled", box2d.b2RevoluteJoint.prototype.IsLimitEnabled);
box2d.b2RevoluteJoint.prototype.EnableLimit = function(a) {
    a != this.m_enableLimit && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableLimit = a, this.m_impulse.z = 0)
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "EnableLimit", box2d.b2RevoluteJoint.prototype.EnableLimit);
box2d.b2RevoluteJoint.prototype.GetLowerLimit = function() {
    return this.m_lowerAngle
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetLowerLimit", box2d.b2RevoluteJoint.prototype.GetLowerLimit);
box2d.b2RevoluteJoint.prototype.GetUpperLimit = function() {
    return this.m_upperAngle
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetUpperLimit", box2d.b2RevoluteJoint.prototype.GetUpperLimit);
box2d.b2RevoluteJoint.prototype.SetLimits = function(a, b) {
    if (a != this.m_lowerAngle || b != this.m_upperAngle)
        this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_impulse.z = 0, this.m_lowerAngle = a, this.m_upperAngle = b
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "SetLimits", box2d.b2RevoluteJoint.prototype.SetLimits);
box2d.b2RevoluteJoint.prototype.SetMotorSpeed = function(a) {
    this.m_motorSpeed != a && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = a)
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "SetMotorSpeed", box2d.b2RevoluteJoint.prototype.SetMotorSpeed);
box2d.b2RevoluteJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2RevoluteJointDef*/ var jd = new box2d.b2RevoluteJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
        box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n",
                this.m_localAnchorB.x, this.m_localAnchorB.y);
        box2d.b2Log("  jd.referenceAngle = %.15f;\n", this.m_referenceAngle);
        box2d.b2Log("  jd.enableLimit = %s;\n", this.m_enableLimit ? "true" : "false");
        box2d.b2Log("  jd.lowerAngle = %.15f;\n", this.m_lowerAngle);
        box2d.b2Log("  jd.upperAngle = %.15f;\n", this.m_upperAngle);
        box2d.b2Log("  jd.enableMotor = %s;\n", this.m_enableMotor ? "true" : "false");
        box2d.b2Log("  jd.motorSpeed = %.15f;\n", this.m_motorSpeed);
        box2d.b2Log("  jd.maxMotorTorque = %.15f;\n", this.m_maxMotorTorque);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "Dump", box2d.b2RevoluteJoint.prototype.Dump);
box2d.b2PrismaticJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_prismaticJoint);
    this.localAnchorA = new box2d.b2Vec2;
    this.localAnchorB = new box2d.b2Vec2;
    this.localAxisA = new box2d.b2Vec2(1, 0)
};
goog.inherits(box2d.b2PrismaticJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2PrismaticJointDef", box2d.b2PrismaticJointDef);
box2d.b2PrismaticJointDef.prototype.localAnchorA = null;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "localAnchorA", box2d.b2PrismaticJointDef.prototype.localAnchorA);
box2d.b2PrismaticJointDef.prototype.localAnchorB = null;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "localAnchorB", box2d.b2PrismaticJointDef.prototype.localAnchorB);
box2d.b2PrismaticJointDef.prototype.localAxisA = null;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "localAxisA", box2d.b2PrismaticJointDef.prototype.localAxisA);
box2d.b2PrismaticJointDef.prototype.referenceAngle = 0;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "referenceAngle", box2d.b2PrismaticJointDef.prototype.referenceAngle);
box2d.b2PrismaticJointDef.prototype.enableLimit = !1;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "enableLimit", box2d.b2PrismaticJointDef.prototype.enableLimit);
box2d.b2PrismaticJointDef.prototype.lowerTranslation = 0;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "lowerTranslation", box2d.b2PrismaticJointDef.prototype.lowerTranslation);
box2d.b2PrismaticJointDef.prototype.upperTranslation = 0;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "upperTranslation", box2d.b2PrismaticJointDef.prototype.upperTranslation);
box2d.b2PrismaticJointDef.prototype.enableMotor = !1;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "enableMotor", box2d.b2PrismaticJointDef.prototype.enableMotor);
box2d.b2PrismaticJointDef.prototype.maxMotorForce = 0;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "maxMotorForce", box2d.b2PrismaticJointDef.prototype.maxMotorForce);
box2d.b2PrismaticJointDef.prototype.motorSpeed = 0;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "motorSpeed", box2d.b2PrismaticJointDef.prototype.motorSpeed);
box2d.b2PrismaticJointDef.prototype.Initialize = function(a, b, c, e) {
    this.bodyA = a;
    this.bodyB = b;
    this.bodyA.GetLocalPoint(c, this.localAnchorA);
    this.bodyB.GetLocalPoint(c, this.localAnchorB);
    this.bodyA.GetLocalVector(e, this.localAxisA);
    this.referenceAngle = this.bodyB.GetAngleRadians() - this.bodyA.GetAngleRadians()
};
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "Initialize", box2d.b2PrismaticJointDef.prototype.Initialize);
box2d.b2PrismaticJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_localAnchorA = a.localAnchorA.Clone();
    this.m_localAnchorB = a.localAnchorB.Clone();
    this.m_localXAxisA = a.localAxisA.Clone().SelfNormalize();
    this.m_localYAxisA = box2d.b2CrossOneV(this.m_localXAxisA, new box2d.b2Vec2);
    this.m_referenceAngle = a.referenceAngle;
    this.m_impulse = new box2d.b2Vec3(0, 0, 0);
    this.m_lowerTranslation = a.lowerTranslation;
    this.m_upperTranslation = a.upperTranslation;
    this.m_maxMotorForce = a.maxMotorForce;
    this.m_motorSpeed = a.motorSpeed;
    this.m_enableLimit = a.enableLimit;
    this.m_enableMotor = a.enableMotor;
    this.m_localCenterA = new box2d.b2Vec2;
    this.m_localCenterB = new box2d.b2Vec2;
    this.m_axis = new box2d.b2Vec2(0, 0);
    this.m_perp = new box2d.b2Vec2(0, 0);
    this.m_K = new box2d.b2Mat33;
    this.m_K3 = new box2d.b2Mat33;
    this.m_K2 = new box2d.b2Mat22;
    this.m_qA = new box2d.b2Rot;
    this.m_qB = new box2d.b2Rot;
    this.m_lalcA = new box2d.b2Vec2;
    this.m_lalcB = new box2d.b2Vec2;
    this.m_rA = new box2d.b2Vec2;
    this.m_rB = new box2d.b2Vec2
};
goog.inherits(box2d.b2PrismaticJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2PrismaticJoint", box2d.b2PrismaticJoint);
box2d.b2PrismaticJoint.prototype.m_localAnchorA = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_localAnchorA", box2d.b2PrismaticJoint.prototype.m_localAnchorA);
box2d.b2PrismaticJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_localAnchorB", box2d.b2PrismaticJoint.prototype.m_localAnchorB);
box2d.b2PrismaticJoint.prototype.m_localXAxisA = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_localXAxisA", box2d.b2PrismaticJoint.prototype.m_localXAxisA);
box2d.b2PrismaticJoint.prototype.m_localYAxisA = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_localYAxisA", box2d.b2PrismaticJoint.prototype.m_localYAxisA);
box2d.b2PrismaticJoint.prototype.m_referenceAngle = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_referenceAngle", box2d.b2PrismaticJoint.prototype.m_referenceAngle);
box2d.b2PrismaticJoint.prototype.m_impulse = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_impulse", box2d.b2PrismaticJoint.prototype.m_impulse);
box2d.b2PrismaticJoint.prototype.m_motorImpulse = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_motorImpulse", box2d.b2PrismaticJoint.prototype.m_motorImpulse);
box2d.b2PrismaticJoint.prototype.m_lowerTranslation = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_lowerTranslation", box2d.b2PrismaticJoint.prototype.m_lowerTranslation);
box2d.b2PrismaticJoint.prototype.m_upperTranslation = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_upperTranslation", box2d.b2PrismaticJoint.prototype.m_upperTranslation);
box2d.b2PrismaticJoint.prototype.m_maxMotorForce = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_maxMotorForce", box2d.b2PrismaticJoint.prototype.m_maxMotorForce);
box2d.b2PrismaticJoint.prototype.m_motorSpeed = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_motorSpeed", box2d.b2PrismaticJoint.prototype.m_motorSpeed);
box2d.b2PrismaticJoint.prototype.m_enableLimit = !1;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_enableLimit", box2d.b2PrismaticJoint.prototype.m_enableLimit);
box2d.b2PrismaticJoint.prototype.m_enableMotor = !1;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_enableMotor", box2d.b2PrismaticJoint.prototype.m_enableMotor);
box2d.b2PrismaticJoint.prototype.m_limitState = box2d.b2LimitState.e_inactiveLimit;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_limitState", box2d.b2PrismaticJoint.prototype.m_limitState);
box2d.b2PrismaticJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_indexA", box2d.b2PrismaticJoint.prototype.m_indexA);
box2d.b2PrismaticJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_indexB", box2d.b2PrismaticJoint.prototype.m_indexB);
box2d.b2PrismaticJoint.prototype.m_localCenterA = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_localCenterA", box2d.b2PrismaticJoint.prototype.m_localCenterA);
box2d.b2PrismaticJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_localCenterB", box2d.b2PrismaticJoint.prototype.m_localCenterB);
box2d.b2PrismaticJoint.prototype.m_invMassA = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_invMassA", box2d.b2PrismaticJoint.prototype.m_invMassA);
box2d.b2PrismaticJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_invMassB", box2d.b2PrismaticJoint.prototype.m_invMassB);
box2d.b2PrismaticJoint.prototype.m_invIA = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_invIA", box2d.b2PrismaticJoint.prototype.m_invIA);
box2d.b2PrismaticJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_invIB", box2d.b2PrismaticJoint.prototype.m_invIB);
box2d.b2PrismaticJoint.prototype.m_axis = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_axis", box2d.b2PrismaticJoint.prototype.m_axis);
box2d.b2PrismaticJoint.prototype.m_perp = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_perp", box2d.b2PrismaticJoint.prototype.m_perp);
box2d.b2PrismaticJoint.prototype.m_s1 = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_s1", box2d.b2PrismaticJoint.prototype.m_s1);
box2d.b2PrismaticJoint.prototype.m_s2 = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_s2", box2d.b2PrismaticJoint.prototype.m_s2);
box2d.b2PrismaticJoint.prototype.m_a1 = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_a1", box2d.b2PrismaticJoint.prototype.m_a1);
box2d.b2PrismaticJoint.prototype.m_a2 = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_a2", box2d.b2PrismaticJoint.prototype.m_a2);
box2d.b2PrismaticJoint.prototype.m_K = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_K", box2d.b2PrismaticJoint.prototype.m_K);
box2d.b2PrismaticJoint.prototype.m_K3 = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_K3", box2d.b2PrismaticJoint.prototype.m_K3);
box2d.b2PrismaticJoint.prototype.m_K2 = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_K2", box2d.b2PrismaticJoint.prototype.m_K2);
box2d.b2PrismaticJoint.prototype.m_motorMass = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_motorMass", box2d.b2PrismaticJoint.prototype.m_motorMass);
box2d.b2PrismaticJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_qA", box2d.b2PrismaticJoint.prototype.m_qA);
box2d.b2PrismaticJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_qB", box2d.b2PrismaticJoint.prototype.m_qB);
box2d.b2PrismaticJoint.prototype.m_lalcA = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_lalcA", box2d.b2PrismaticJoint.prototype.m_lalcA);
box2d.b2PrismaticJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_lalcB", box2d.b2PrismaticJoint.prototype.m_lalcB);
box2d.b2PrismaticJoint.prototype.m_rA = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_rA", box2d.b2PrismaticJoint.prototype.m_rA);
box2d.b2PrismaticJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_rB", box2d.b2PrismaticJoint.prototype.m_rB);
box2d.b2PrismaticJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassA = this.m_bodyA.m_invMass;
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIA = this.m_bodyA.m_invI;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = a.positions[this.m_indexA].c, c = a.velocities[this.m_indexA].v, e = a.velocities[this.m_indexA].w,
            d = a.positions[this.m_indexB].c, f = a.positions[this.m_indexB].a, g = a.velocities[this.m_indexB].v, h = a.velocities[this.m_indexB].w, l = this.m_qA.SetAngleRadians(a.positions[this.m_indexA].a), f = this.m_qB.SetAngleRadians(f);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    var k = box2d.b2MulRV(l, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var m = box2d.b2MulRV(f, this.m_lalcB, this.m_rB), n = box2d.b2AddVV(box2d.b2SubVV(d, b, box2d.b2Vec2.s_t0), box2d.b2SubVV(m,
            k, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_d), b = this.m_invMassA, d = this.m_invMassB, f = this.m_invIA, p = this.m_invIB;
    box2d.b2MulRV(l, this.m_localXAxisA, this.m_axis);
    this.m_a1 = box2d.b2CrossVV(box2d.b2AddVV(n, k, box2d.b2Vec2.s_t0), this.m_axis);
    this.m_a2 = box2d.b2CrossVV(m, this.m_axis);
    this.m_motorMass = b + d + f * this.m_a1 * this.m_a1 + p * this.m_a2 * this.m_a2;
    0 < this.m_motorMass && (this.m_motorMass = 1 / this.m_motorMass);
    box2d.b2MulRV(l, this.m_localYAxisA, this.m_perp);
    this.m_s1 = box2d.b2CrossVV(box2d.b2AddVV(n,
            k, box2d.b2Vec2.s_t0), this.m_perp);
    this.m_s2 = box2d.b2CrossVV(m, this.m_perp);
    this.m_K.ex.x = b + d + f * this.m_s1 * this.m_s1 + p * this.m_s2 * this.m_s2;
    this.m_K.ex.y = f * this.m_s1 + p * this.m_s2;
    this.m_K.ex.z = f * this.m_s1 * this.m_a1 + p * this.m_s2 * this.m_a2;
    this.m_K.ey.x = this.m_K.ex.y;
    this.m_K.ey.y = f + p;
    0 == this.m_K.ey.y && (this.m_K.ey.y = 1);
    this.m_K.ey.z = f * this.m_a1 + p * this.m_a2;
    this.m_K.ez.x = this.m_K.ex.z;
    this.m_K.ez.y = this.m_K.ey.z;
    this.m_K.ez.z = b + d + f * this.m_a1 * this.m_a1 + p * this.m_a2 * this.m_a2;
    this.m_enableLimit ? (l = box2d.b2DotVV(this.m_axis,
            n), box2d.b2Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * box2d.b2_linearSlop ? this.m_limitState = box2d.b2LimitState.e_equalLimits : l <= this.m_lowerTranslation ? this.m_limitState != box2d.b2LimitState.e_atLowerLimit && (this.m_limitState = box2d.b2LimitState.e_atLowerLimit, this.m_impulse.z = 0) : l >= this.m_upperTranslation ? this.m_limitState != box2d.b2LimitState.e_atUpperLimit && (this.m_limitState = box2d.b2LimitState.e_atUpperLimit, this.m_impulse.z = 0) : (this.m_limitState = box2d.b2LimitState.e_inactiveLimit, this.m_impulse.z =
            0)) : (this.m_limitState = box2d.b2LimitState.e_inactiveLimit, this.m_impulse.z = 0);
    !1 == this.m_enableMotor && (this.m_motorImpulse = 0);
    a.step.warmStarting ? (this.m_impulse.SelfMul(a.step.dtRatio), this.m_motorImpulse *= a.step.dtRatio, l = box2d.b2AddVV(box2d.b2MulSV(this.m_impulse.x, this.m_perp, box2d.b2Vec2.s_t0), box2d.b2MulSV(this.m_motorImpulse + this.m_impulse.z, this.m_axis, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_P), k = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse +
            this.m_impulse.z) * this.m_a1, m = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2, c.SelfMulSub(b, l), e -= f * k, g.SelfMulAdd(d, l), h += p * m) : (this.m_impulse.SetZero(), this.m_motorImpulse = 0);
    a.velocities[this.m_indexA].w = e;
    a.velocities[this.m_indexB].w = h
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "InitVelocityConstraints", box2d.b2PrismaticJoint.prototype.InitVelocityConstraints);
box2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_d = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.velocities[this.m_indexB].v, d = a.velocities[this.m_indexB].w, f = this.m_invMassA, g = this.m_invMassB, h = this.m_invIA, l = this.m_invIB;
    if (this.m_enableMotor && this.m_limitState != box2d.b2LimitState.e_equalLimits) {
        var k = box2d.b2DotVV(this.m_axis, box2d.b2SubVV(e, b, box2d.b2Vec2.s_t0)) + this.m_a2 * d - this.m_a1 * c, k = this.m_motorMass * (this.m_motorSpeed - k), m = this.m_motorImpulse,
                n = a.step.dt * this.m_maxMotorForce;
        this.m_motorImpulse = box2d.b2Clamp(this.m_motorImpulse + k, -n, n);
        k = this.m_motorImpulse - m;
        m = box2d.b2MulSV(k, this.m_axis, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P);
        n = k * this.m_a1;
        k *= this.m_a2;
        b.SelfMulSub(f, m);
        c -= h * n;
        e.SelfMulAdd(g, m);
        d += l * k
    }
    var n = box2d.b2DotVV(this.m_perp, box2d.b2SubVV(e, b, box2d.b2Vec2.s_t0)) + this.m_s2 * d - this.m_s1 * c, p = d - c;
    this.m_enableLimit && this.m_limitState != box2d.b2LimitState.e_inactiveLimit ? (k = box2d.b2DotVV(this.m_axis, box2d.b2SubVV(e,
            b, box2d.b2Vec2.s_t0)) + this.m_a2 * d - this.m_a1 * c, m = box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f1.Copy(this.m_impulse), k = this.m_K.Solve33(-n, -p, -k, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df3), this.m_impulse.SelfAdd(k), this.m_limitState == box2d.b2LimitState.e_atLowerLimit ? this.m_impulse.z = box2d.b2Max(this.m_impulse.z, 0) : this.m_limitState == box2d.b2LimitState.e_atUpperLimit && (this.m_impulse.z = box2d.b2Min(this.m_impulse.z, 0)), n = this.m_K.Solve22(-n - (this.m_impulse.z - m.z) *
            this.m_K.ez.x, -p - (this.m_impulse.z - m.z) * this.m_K.ez.y, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f2r), n.x += m.x, n.y += m.y, this.m_impulse.x = n.x, this.m_impulse.y = n.y, k.x = this.m_impulse.x - m.x, k.y = this.m_impulse.y - m.y, k.z = this.m_impulse.z - m.z, m = box2d.b2AddVV(box2d.b2MulSV(k.x, this.m_perp, box2d.b2Vec2.s_t0), box2d.b2MulSV(k.z, this.m_axis, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P), n = k.x * this.m_s1 + k.y + k.z * this.m_a1, k = k.x * this.m_s2 + k.y + k.z * this.m_a2) : (k =
            this.m_K.Solve22(-n, -p, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df2), this.m_impulse.x += k.x, this.m_impulse.y += k.y, m = box2d.b2MulSV(k.x, this.m_perp, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P), n = k.x * this.m_s1 + k.y, k = k.x * this.m_s2 + k.y);
    b.SelfMulSub(f, m);
    c -= h * n;
    e.SelfMulAdd(g, m);
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = d + l * k
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "SolveVelocityConstraints", box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints);
box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f2r = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f1 = new box2d.b2Vec3;
box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df3 = new box2d.b2Vec3;
box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df2 = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.SolvePositionConstraints = function(a) {
    var b = a.positions[this.m_indexA].c, c = a.positions[this.m_indexA].a, e = a.positions[this.m_indexB].c, d = a.positions[this.m_indexB].a, f = this.m_qA.SetAngleRadians(c), g = this.m_qB.SetAngleRadians(d), h = this.m_invMassA, l = this.m_invMassB, k = this.m_invIA, m = this.m_invIB, n = box2d.b2MulRV(f, this.m_lalcA, this.m_rA), p = box2d.b2MulRV(g, this.m_lalcB, this.m_rB), q = box2d.b2SubVV(box2d.b2AddVV(e, p, box2d.b2Vec2.s_t0), box2d.b2AddVV(b, n, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_d),
            r = box2d.b2MulRV(f, this.m_localXAxisA, this.m_axis), t = box2d.b2CrossVV(box2d.b2AddVV(q, n, box2d.b2Vec2.s_t0), r), g = box2d.b2CrossVV(p, r), f = box2d.b2MulRV(f, this.m_localYAxisA, this.m_perp), s = box2d.b2CrossVV(box2d.b2AddVV(q, n, box2d.b2Vec2.s_t0), f), u = box2d.b2CrossVV(p, f), v = box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse, y = box2d.b2DotVV(f, q), D = d - c - this.m_referenceAngle, n = box2d.b2Abs(y), p = box2d.b2Abs(D), x = !1, w = 0;
    this.m_enableLimit && (q = box2d.b2DotVV(r, q), box2d.b2Abs(this.m_upperTranslation -
            this.m_lowerTranslation) < 2 * box2d.b2_linearSlop ? (w = box2d.b2Clamp(q, -box2d.b2_maxLinearCorrection, box2d.b2_maxLinearCorrection), n = box2d.b2Max(n, box2d.b2Abs(q)), x = !0) : q <= this.m_lowerTranslation ? (w = box2d.b2Clamp(q - this.m_lowerTranslation + box2d.b2_linearSlop, -box2d.b2_maxLinearCorrection, 0), n = box2d.b2Max(n, this.m_lowerTranslation - q), x = !0) : q >= this.m_upperTranslation && (w = box2d.b2Clamp(q - this.m_upperTranslation - box2d.b2_linearSlop, 0, box2d.b2_maxLinearCorrection), n = box2d.b2Max(n, q - this.m_upperTranslation),
            x = !0));
    if (x) {
        var q = k * s + m * u, C = k * s * t + m * u * g, x = k + m;
        0 == x && (x = 1);
        var A = k * t + m * g, E = h + l + k * t * t + m * g * g, B = this.m_K3;
        B.ex.SetXYZ(h + l + k * s * s + m * u * u, q, C);
        B.ey.SetXYZ(q, x, A);
        B.ez.SetXYZ(C, A, E);
        v = B.Solve33(-y, -D, -w, v)
    } else
        q = k * s + m * u, x = k + m, 0 == x && (x = 1), w = this.m_K2, w.ex.SetXY(h + l + k * s * s + m * u * u, q), w.ey.SetXY(q, x), y = w.Solve(-y, -D, box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse1), v.x = y.x, v.y = y.y, v.z = 0;
    r = box2d.b2AddVV(box2d.b2MulSV(v.x, f, box2d.b2Vec2.s_t0), box2d.b2MulSV(v.z, r, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_P);
    t = v.x * s + v.y + v.z * t;
    g = v.x * u + v.y + v.z * g;
    b.SelfMulSub(h, r);
    c -= k * t;
    e.SelfMulAdd(l, r);
    a.positions[this.m_indexA].a = c;
    a.positions[this.m_indexB].a = d + m * g;
    return n <= box2d.b2_linearSlop && p <= box2d.b2_angularSlop
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "SolvePositionConstraints", box2d.b2PrismaticJoint.prototype.SolvePositionConstraints);
box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_d = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse = new box2d.b2Vec3;
box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse1 = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, a)
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetAnchorA", box2d.b2PrismaticJoint.prototype.GetAnchorA);
box2d.b2PrismaticJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetAnchorB", box2d.b2PrismaticJoint.prototype.GetAnchorB);
box2d.b2PrismaticJoint.prototype.GetReactionForce = function(a, b) {
    return b.SetXY(a * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), a * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y))
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetReactionForce", box2d.b2PrismaticJoint.prototype.GetReactionForce);
box2d.b2PrismaticJoint.prototype.GetReactionTorque = function(a) {
    return a * this.m_impulse.y
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetReactionTorque", box2d.b2PrismaticJoint.prototype.GetReactionTorque);
box2d.b2PrismaticJoint.prototype.GetLocalAnchorA = function(a) {
    return a.Copy(this.m_localAnchorA)
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetLocalAnchorA", box2d.b2PrismaticJoint.prototype.GetLocalAnchorA);
box2d.b2PrismaticJoint.prototype.GetLocalAnchorB = function(a) {
    return a.Copy(this.m_localAnchorB)
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetLocalAnchorB", box2d.b2PrismaticJoint.prototype.GetLocalAnchorB);
box2d.b2PrismaticJoint.prototype.GetLocalAxisA = function(a) {
    return a.Copy(this.m_localXAxisA)
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetLocalAxisA", box2d.b2PrismaticJoint.prototype.GetLocalAxisA);
box2d.b2PrismaticJoint.prototype.GetReferenceAngle = function() {
    return this.m_referenceAngle
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetReferenceAngle", box2d.b2PrismaticJoint.prototype.GetReferenceAngle);
box2d.b2PrismaticJoint.prototype.GetJointTranslation = function() {
    var a = this.m_bodyA.GetWorldPoint(this.m_localAnchorA, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pA), b = this.m_bodyB.GetWorldPoint(this.m_localAnchorB, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pB), a = box2d.b2SubVV(b, a, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_d), b = this.m_bodyA.GetWorldVector(this.m_localXAxisA, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_axis);
    return box2d.b2DotVV(a, b)
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetJointTranslation", box2d.b2PrismaticJoint.prototype.GetJointTranslation);
box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pA = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pB = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_d = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_axis = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.GetJointSpeed = function() {
    var a = this.m_bodyA, b = this.m_bodyB;
    box2d.b2SubVV(this.m_localAnchorA, a.m_sweep.localCenter, this.m_lalcA);
    var c = box2d.b2MulRV(a.m_xf.q, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, b.m_sweep.localCenter, this.m_lalcB);
    var e = box2d.b2MulRV(b.m_xf.q, this.m_lalcB, this.m_rB), d = box2d.b2AddVV(a.m_sweep.c, c, box2d.b2Vec2.s_t0), f = box2d.b2AddVV(b.m_sweep.c, e, box2d.b2Vec2.s_t1), d = box2d.b2SubVV(f, d, box2d.b2Vec2.s_t2), f = a.GetWorldVector(this.m_localXAxisA,
            this.m_axis), g = a.m_linearVelocity, h = b.m_linearVelocity, a = a.m_angularVelocity, b = b.m_angularVelocity;
    return box2d.b2DotVV(d, box2d.b2CrossSV(a, f, box2d.b2Vec2.s_t0)) + box2d.b2DotVV(f, box2d.b2SubVV(box2d.b2AddVCrossSV(h, b, e, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(g, a, c, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t0))
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetJointSpeed", box2d.b2PrismaticJoint.prototype.GetJointSpeed);
box2d.b2PrismaticJoint.prototype.IsLimitEnabled = function() {
    return this.m_enableLimit
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "IsLimitEnabled", box2d.b2PrismaticJoint.prototype.IsLimitEnabled);
box2d.b2PrismaticJoint.prototype.EnableLimit = function(a) {
    a != this.m_enableLimit && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableLimit = a, this.m_impulse.z = 0)
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "EnableLimit", box2d.b2PrismaticJoint.prototype.EnableLimit);
box2d.b2PrismaticJoint.prototype.GetLowerLimit = function() {
    return this.m_lowerTranslation
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetLowerLimit", box2d.b2PrismaticJoint.prototype.GetLowerLimit);
box2d.b2PrismaticJoint.prototype.GetUpperLimit = function() {
    return this.m_upperTranslation
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetUpperLimit", box2d.b2PrismaticJoint.prototype.GetUpperLimit);
box2d.b2PrismaticJoint.prototype.SetLimits = function(a, b) {
    if (a != this.m_lowerTranslation || b != this.m_upperTranslation)
        this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_lowerTranslation = a, this.m_upperTranslation = b, this.m_impulse.z = 0
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "SetLimits", box2d.b2PrismaticJoint.prototype.SetLimits);
box2d.b2PrismaticJoint.prototype.IsMotorEnabled = function() {
    return this.m_enableMotor
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "IsMotorEnabled", box2d.b2PrismaticJoint.prototype.IsMotorEnabled);
box2d.b2PrismaticJoint.prototype.EnableMotor = function(a) {
    this.m_bodyA.SetAwake(!0);
    this.m_bodyB.SetAwake(!0);
    this.m_enableMotor = a
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "EnableMotor", box2d.b2PrismaticJoint.prototype.EnableMotor);
box2d.b2PrismaticJoint.prototype.SetMotorSpeed = function(a) {
    this.m_bodyA.SetAwake(!0);
    this.m_bodyB.SetAwake(!0);
    this.m_motorSpeed = a
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "SetMotorSpeed", box2d.b2PrismaticJoint.prototype.SetMotorSpeed);
box2d.b2PrismaticJoint.prototype.GetMotorSpeed = function() {
    return this.m_motorSpeed
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetMotorSpeed", box2d.b2PrismaticJoint.prototype.GetMotorSpeed);
box2d.b2PrismaticJoint.prototype.SetMaxMotorForce = function(a) {
    this.m_bodyA.SetAwake(!0);
    this.m_bodyB.SetAwake(!0);
    this.m_maxMotorForce = a
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "SetMaxMotorForce", box2d.b2PrismaticJoint.prototype.SetMaxMotorForce);
box2d.b2PrismaticJoint.prototype.GetMaxMotorForce = function() {
    return this.m_maxMotorForce
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetMaxMotorForce", box2d.b2PrismaticJoint.prototype.GetMaxMotorForce);
box2d.b2PrismaticJoint.prototype.GetMotorForce = function(a) {
    return a * this.m_motorImpulse
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetMotorForce", box2d.b2PrismaticJoint.prototype.GetMotorForce);
box2d.b2PrismaticJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2PrismaticJointDef*/ var jd = new box2d.b2PrismaticJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
        box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n",
                this.m_localAnchorB.x, this.m_localAnchorB.y);
        box2d.b2Log("  jd.localAxisA.SetXY(%.15f, %.15f);\n", this.m_localXAxisA.x, this.m_localXAxisA.y);
        box2d.b2Log("  jd.referenceAngle = %.15f;\n", this.m_referenceAngle);
        box2d.b2Log("  jd.enableLimit = %s;\n", this.m_enableLimit ? "true" : "false");
        box2d.b2Log("  jd.lowerTranslation = %.15f;\n", this.m_lowerTranslation);
        box2d.b2Log("  jd.upperTranslation = %.15f;\n", this.m_upperTranslation);
        box2d.b2Log("  jd.enableMotor = %s;\n", this.m_enableMotor ? "true" : "false");
        box2d.b2Log("  jd.motorSpeed = %.15f;\n", this.m_motorSpeed);
        box2d.b2Log("  jd.maxMotorForce = %.15f;\n", this.m_maxMotorForce);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "Dump", box2d.b2PrismaticJoint.prototype.Dump);
box2d.b2GearJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_gearJoint)
};
goog.inherits(box2d.b2GearJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2GearJointDef", box2d.b2GearJointDef);
box2d.b2GearJointDef.prototype.joint1 = null;
goog.exportProperty(box2d.b2GearJointDef.prototype, "joint1", box2d.b2GearJointDef.prototype.joint1);
box2d.b2GearJointDef.prototype.joint2 = null;
goog.exportProperty(box2d.b2GearJointDef.prototype, "joint2", box2d.b2GearJointDef.prototype.joint2);
box2d.b2GearJointDef.prototype.ratio = 1;
goog.exportProperty(box2d.b2GearJointDef.prototype, "ratio", box2d.b2GearJointDef.prototype.ratio);
box2d.b2GearJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_joint1 = a.joint1;
    this.m_joint2 = a.joint2;
    this.m_localAnchorA = new box2d.b2Vec2;
    this.m_localAnchorB = new box2d.b2Vec2;
    this.m_localAnchorC = new box2d.b2Vec2;
    this.m_localAnchorD = new box2d.b2Vec2;
    this.m_localAxisC = new box2d.b2Vec2;
    this.m_localAxisD = new box2d.b2Vec2;
    this.m_lcA = new box2d.b2Vec2;
    this.m_lcB = new box2d.b2Vec2;
    this.m_lcC = new box2d.b2Vec2;
    this.m_lcD = new box2d.b2Vec2;
    this.m_JvAC = new box2d.b2Vec2;
    this.m_JvBD = new box2d.b2Vec2;
    this.m_qA =
            new box2d.b2Rot;
    this.m_qB = new box2d.b2Rot;
    this.m_qC = new box2d.b2Rot;
    this.m_qD = new box2d.b2Rot;
    this.m_lalcA = new box2d.b2Vec2;
    this.m_lalcB = new box2d.b2Vec2;
    this.m_lalcC = new box2d.b2Vec2;
    this.m_lalcD = new box2d.b2Vec2;
    this.m_typeA = this.m_joint1.GetType();
    this.m_typeB = this.m_joint2.GetType();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_typeA == box2d.b2JointType.e_revoluteJoint || this.m_typeA == box2d.b2JointType.e_prismaticJoint);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_typeB == box2d.b2JointType.e_revoluteJoint ||
            this.m_typeB == box2d.b2JointType.e_prismaticJoint);
    var b, c;
    this.m_bodyC = this.m_joint1.GetBodyA();
    this.m_bodyA = this.m_joint1.GetBodyB();
    b = this.m_bodyA.m_xf;
    var e = this.m_bodyA.m_sweep.a;
    c = this.m_bodyC.m_xf;
    var d = this.m_bodyC.m_sweep.a;
    this.m_typeA == box2d.b2JointType.e_revoluteJoint ? (c = a.joint1, this.m_localAnchorC.Copy(c.m_localAnchorA), this.m_localAnchorA.Copy(c.m_localAnchorB), this.m_referenceAngleA = c.m_referenceAngle, this.m_localAxisC.SetZero(), b = e - d - this.m_referenceAngleA) : (d = a.joint1, this.m_localAnchorC.Copy(d.m_localAnchorA),
            this.m_localAnchorA.Copy(d.m_localAnchorB), this.m_referenceAngleA = d.m_referenceAngle, this.m_localAxisC.Copy(d.m_localXAxisA), e = this.m_localAnchorC, b = box2d.b2MulTRV(c.q, box2d.b2AddVV(box2d.b2MulRV(b.q, this.m_localAnchorA, box2d.b2Vec2.s_t0), box2d.b2SubVV(b.p, c.p, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), b = box2d.b2DotVV(box2d.b2SubVV(b, e, box2d.b2Vec2.s_t0), this.m_localAxisC));
    this.m_bodyD = this.m_joint2.GetBodyA();
    this.m_bodyB = this.m_joint2.GetBodyB();
    c = this.m_bodyB.m_xf;
    var d = this.m_bodyB.m_sweep.a,
            e = this.m_bodyD.m_xf, f = this.m_bodyD.m_sweep.a;
    this.m_typeB == box2d.b2JointType.e_revoluteJoint ? (c = a.joint2, this.m_localAnchorD.Copy(c.m_localAnchorA), this.m_localAnchorB.Copy(c.m_localAnchorB), this.m_referenceAngleB = c.m_referenceAngle, this.m_localAxisD.SetZero(), c = d - f - this.m_referenceAngleB) : (d = a.joint2, this.m_localAnchorD.Copy(d.m_localAnchorA), this.m_localAnchorB.Copy(d.m_localAnchorB), this.m_referenceAngleB = d.m_referenceAngle, this.m_localAxisD.Copy(d.m_localXAxisA), d = this.m_localAnchorD, c = box2d.b2MulTRV(e.q,
            box2d.b2AddVV(box2d.b2MulRV(c.q, this.m_localAnchorB, box2d.b2Vec2.s_t0), box2d.b2SubVV(c.p, e.p, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), c = box2d.b2DotVV(box2d.b2SubVV(c, d, box2d.b2Vec2.s_t0), this.m_localAxisD));
    this.m_ratio = a.ratio;
    this.m_constant = b + this.m_ratio * c;
    this.m_impulse = 0
};
goog.inherits(box2d.b2GearJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2GearJoint", box2d.b2GearJoint);
box2d.b2GearJoint.prototype.m_joint1 = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_joint1", box2d.b2GearJoint.prototype.m_joint1);
box2d.b2GearJoint.prototype.m_joint2 = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_joint2", box2d.b2GearJoint.prototype.m_joint2);
box2d.b2GearJoint.prototype.m_typeA = box2d.b2JointType.e_unknownJoint;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_typeA", box2d.b2GearJoint.prototype.m_typeA);
box2d.b2GearJoint.prototype.m_typeB = box2d.b2JointType.e_unknownJoint;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_typeB", box2d.b2GearJoint.prototype.m_typeB);
box2d.b2GearJoint.prototype.m_bodyC = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_bodyC", box2d.b2GearJoint.prototype.m_bodyC);
box2d.b2GearJoint.prototype.m_bodyD = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_bodyD", box2d.b2GearJoint.prototype.m_bodyD);
box2d.b2GearJoint.prototype.m_localAnchorA = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_localAnchorA", box2d.b2GearJoint.prototype.m_localAnchorA);
box2d.b2GearJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_localAnchorB", box2d.b2GearJoint.prototype.m_localAnchorB);
box2d.b2GearJoint.prototype.m_localAnchorC = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_localAnchorC", box2d.b2GearJoint.prototype.m_localAnchorC);
box2d.b2GearJoint.prototype.m_localAnchorD = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_localAnchorD", box2d.b2GearJoint.prototype.m_localAnchorD);
box2d.b2GearJoint.prototype.m_localAxisC = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_localAxisC", box2d.b2GearJoint.prototype.m_localAxisC);
box2d.b2GearJoint.prototype.m_localAxisD = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_localAxisD", box2d.b2GearJoint.prototype.m_localAxisD);
box2d.b2GearJoint.prototype.m_referenceAngleA = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_referenceAngleA", box2d.b2GearJoint.prototype.m_referenceAngleA);
box2d.b2GearJoint.prototype.m_referenceAngleB = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_referenceAngleB", box2d.b2GearJoint.prototype.m_referenceAngleB);
box2d.b2GearJoint.prototype.m_constant = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_constant", box2d.b2GearJoint.prototype.m_constant);
box2d.b2GearJoint.prototype.m_ratio = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_ratio", box2d.b2GearJoint.prototype.m_ratio);
box2d.b2GearJoint.prototype.m_impulse = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_impulse", box2d.b2GearJoint.prototype.m_impulse);
box2d.b2GearJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_indexA", box2d.b2GearJoint.prototype.m_indexA);
box2d.b2GearJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_indexB", box2d.b2GearJoint.prototype.m_indexB);
box2d.b2GearJoint.prototype.m_indexC = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_indexC", box2d.b2GearJoint.prototype.m_indexC);
box2d.b2GearJoint.prototype.m_indexD = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_indexD", box2d.b2GearJoint.prototype.m_indexD);
box2d.b2GearJoint.prototype.m_lcA = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_lcA", box2d.b2GearJoint.prototype.m_lcA);
box2d.b2GearJoint.prototype.m_lcB = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_lcB", box2d.b2GearJoint.prototype.m_lcB);
box2d.b2GearJoint.prototype.m_lcC = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_lcC", box2d.b2GearJoint.prototype.m_lcC);
box2d.b2GearJoint.prototype.m_lcD = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_lcD", box2d.b2GearJoint.prototype.m_lcD);
box2d.b2GearJoint.prototype.m_mA = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_mA", box2d.b2GearJoint.prototype.m_mA);
box2d.b2GearJoint.prototype.m_mB = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_mB", box2d.b2GearJoint.prototype.m_mB);
box2d.b2GearJoint.prototype.m_mC = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_mC", box2d.b2GearJoint.prototype.m_mC);
box2d.b2GearJoint.prototype.m_mD = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_mD", box2d.b2GearJoint.prototype.m_mD);
box2d.b2GearJoint.prototype.m_iA = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_iA", box2d.b2GearJoint.prototype.m_iA);
box2d.b2GearJoint.prototype.m_iB = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_iB", box2d.b2GearJoint.prototype.m_iB);
box2d.b2GearJoint.prototype.m_iC = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_iC", box2d.b2GearJoint.prototype.m_iC);
box2d.b2GearJoint.prototype.m_iD = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_iD", box2d.b2GearJoint.prototype.m_iD);
box2d.b2GearJoint.prototype.m_JvAC = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_JvAC", box2d.b2GearJoint.prototype.m_JvAC);
box2d.b2GearJoint.prototype.m_JvBD = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_JvBD", box2d.b2GearJoint.prototype.m_JvBD);
box2d.b2GearJoint.prototype.m_JwA = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_JwA", box2d.b2GearJoint.prototype.m_JwA);
box2d.b2GearJoint.prototype.m_JwB = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_JwB", box2d.b2GearJoint.prototype.m_JwB);
box2d.b2GearJoint.prototype.m_JwC = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_JwC", box2d.b2GearJoint.prototype.m_JwC);
box2d.b2GearJoint.prototype.m_JwD = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_JwD", box2d.b2GearJoint.prototype.m_JwD);
box2d.b2GearJoint.prototype.m_mass = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_mass", box2d.b2GearJoint.prototype.m_mass);
box2d.b2GearJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_qA", box2d.b2GearJoint.prototype.m_qA);
box2d.b2GearJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_qB", box2d.b2GearJoint.prototype.m_qB);
box2d.b2GearJoint.prototype.m_qC = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_qC", box2d.b2GearJoint.prototype.m_qC);
box2d.b2GearJoint.prototype.m_qD = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_qD", box2d.b2GearJoint.prototype.m_qD);
box2d.b2GearJoint.prototype.m_lalcA = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_lalcA", box2d.b2GearJoint.prototype.m_lalcA);
box2d.b2GearJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_lalcB", box2d.b2GearJoint.prototype.m_lalcB);
box2d.b2GearJoint.prototype.m_lalcC = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_lalcC", box2d.b2GearJoint.prototype.m_lalcC);
box2d.b2GearJoint.prototype.m_lalcD = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_lalcD", box2d.b2GearJoint.prototype.m_lalcD);
box2d.b2GearJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_indexC = this.m_bodyC.m_islandIndex;
    this.m_indexD = this.m_bodyD.m_islandIndex;
    this.m_lcA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_lcB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_lcC.Copy(this.m_bodyC.m_sweep.localCenter);
    this.m_lcD.Copy(this.m_bodyD.m_sweep.localCenter);
    this.m_mA = this.m_bodyA.m_invMass;
    this.m_mB = this.m_bodyB.m_invMass;
    this.m_mC =
            this.m_bodyC.m_invMass;
    this.m_mD = this.m_bodyD.m_invMass;
    this.m_iA = this.m_bodyA.m_invI;
    this.m_iB = this.m_bodyB.m_invI;
    this.m_iC = this.m_bodyC.m_invI;
    this.m_iD = this.m_bodyD.m_invI;
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.positions[this.m_indexB].a, d = a.velocities[this.m_indexB].v, f = a.velocities[this.m_indexB].w, g = a.positions[this.m_indexC].a, h = a.velocities[this.m_indexC].v, l = a.velocities[this.m_indexC].w, k = a.positions[this.m_indexD].a, m = a.velocities[this.m_indexD].v, n = a.velocities[this.m_indexD].w,
            p = this.m_qA.SetAngleRadians(a.positions[this.m_indexA].a), e = this.m_qB.SetAngleRadians(e), q = this.m_qC.SetAngleRadians(g), g = this.m_qD.SetAngleRadians(k);
    this.m_mass = 0;
    this.m_typeA == box2d.b2JointType.e_revoluteJoint ? (this.m_JvAC.SetZero(), this.m_JwC = this.m_JwA = 1, this.m_mass += this.m_iA + this.m_iC) : (k = box2d.b2MulRV(q, this.m_localAxisC, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_u), box2d.b2SubVV(this.m_localAnchorC, this.m_lcC, this.m_lalcC), q = box2d.b2MulRV(q, this.m_lalcC, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rC),
            box2d.b2SubVV(this.m_localAnchorA, this.m_lcA, this.m_lalcA), p = box2d.b2MulRV(p, this.m_lalcA, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rA), this.m_JvAC.Copy(k), this.m_JwC = box2d.b2CrossVV(q, k), this.m_JwA = box2d.b2CrossVV(p, k), this.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA);
    this.m_typeB == box2d.b2JointType.e_revoluteJoint ? (this.m_JvBD.SetZero(), this.m_JwD = this.m_JwB = this.m_ratio, this.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD)) : (k =
            box2d.b2MulRV(g, this.m_localAxisD, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_u), box2d.b2SubVV(this.m_localAnchorD, this.m_lcD, this.m_lalcD), p = box2d.b2MulRV(g, this.m_lalcD, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rD), box2d.b2SubVV(this.m_localAnchorB, this.m_lcB, this.m_lalcB), e = box2d.b2MulRV(e, this.m_lalcB, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rB), box2d.b2MulSV(this.m_ratio, k, this.m_JvBD), this.m_JwD = this.m_ratio * box2d.b2CrossVV(p, k), this.m_JwB = this.m_ratio * box2d.b2CrossVV(e,
            k), this.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB);
    this.m_mass = 0 < this.m_mass ? 1 / this.m_mass : 0;
    a.step.warmStarting ? (b.SelfMulAdd(this.m_mA * this.m_impulse, this.m_JvAC), c += this.m_iA * this.m_impulse * this.m_JwA, d.SelfMulAdd(this.m_mB * this.m_impulse, this.m_JvBD), f += this.m_iB * this.m_impulse * this.m_JwB, h.SelfMulSub(this.m_mC * this.m_impulse, this.m_JvAC), l -= this.m_iC * this.m_impulse * this.m_JwC, m.SelfMulSub(this.m_mD * this.m_impulse, this.m_JvBD),
            n -= this.m_iD * this.m_impulse * this.m_JwD) : this.m_impulse = 0;
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = f;
    a.velocities[this.m_indexC].w = l;
    a.velocities[this.m_indexD].w = n
};
box2d.b2GearJoint.prototype.InitVelocityConstraints.s_u = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rA = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rB = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rC = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rD = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.velocities[this.m_indexB].v, d = a.velocities[this.m_indexB].w, f = a.velocities[this.m_indexC].v, g = a.velocities[this.m_indexC].w, h = a.velocities[this.m_indexD].v, l = a.velocities[this.m_indexD].w, k = box2d.b2DotVV(this.m_JvAC, box2d.b2SubVV(b, f, box2d.b2Vec2.s_t0)) + box2d.b2DotVV(this.m_JvBD, box2d.b2SubVV(e, h, box2d.b2Vec2.s_t0)), k = k + (this.m_JwA * c - this.m_JwC * g + (this.m_JwB * d - this.m_JwD *
            l)), k = -this.m_mass * k;
    this.m_impulse += k;
    b.SelfMulAdd(this.m_mA * k, this.m_JvAC);
    c += this.m_iA * k * this.m_JwA;
    e.SelfMulAdd(this.m_mB * k, this.m_JvBD);
    d += this.m_iB * k * this.m_JwB;
    f.SelfMulSub(this.m_mC * k, this.m_JvAC);
    g -= this.m_iC * k * this.m_JwC;
    h.SelfMulSub(this.m_mD * k, this.m_JvBD);
    l -= this.m_iD * k * this.m_JwD;
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = d;
    a.velocities[this.m_indexC].w = g;
    a.velocities[this.m_indexD].w = l
};
box2d.b2GearJoint.prototype.SolvePositionConstraints = function(a) {
    var b = a.positions[this.m_indexA].c, c = a.positions[this.m_indexA].a, e = a.positions[this.m_indexB].c, d = a.positions[this.m_indexB].a, f = a.positions[this.m_indexC].c, g = a.positions[this.m_indexC].a, h = a.positions[this.m_indexD].c, l = a.positions[this.m_indexD].a, k = this.m_qA.SetAngleRadians(c), m = this.m_qB.SetAngleRadians(d), n = this.m_qC.SetAngleRadians(g), p = this.m_qD.SetAngleRadians(l), q = this.m_JvAC, r = this.m_JvBD, t, s, u = 0;
    if (this.m_typeA == box2d.b2JointType.e_revoluteJoint)
        q.SetZero(),
                k = t = 1, u += this.m_iA + this.m_iC, n = c - g - this.m_referenceAngleA;
    else {
        s = box2d.b2MulRV(n, this.m_localAxisC, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_u);
        t = box2d.b2MulRV(n, this.m_lalcC, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rC);
        var v = box2d.b2MulRV(k, this.m_lalcA, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rA);
        q.Copy(s);
        k = box2d.b2CrossVV(t, s);
        t = box2d.b2CrossVV(v, s);
        u += this.m_mC + this.m_mA + this.m_iC * k * k + this.m_iA * t * t;
        s = this.m_lalcC;
        n = box2d.b2MulTRV(n, box2d.b2AddVV(v, box2d.b2SubVV(b,
                f, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0);
        n = box2d.b2DotVV(box2d.b2SubVV(n, s, box2d.b2Vec2.s_t0), this.m_localAxisC)
    }
    if (this.m_typeB == box2d.b2JointType.e_revoluteJoint)
        r.SetZero(), m = s = this.m_ratio, u += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD), p = d - l - this.m_referenceAngleB;
    else {
        s = box2d.b2MulRV(p, this.m_localAxisD, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_u);
        var y = box2d.b2MulRV(p, this.m_lalcD, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rD), v = box2d.b2MulRV(m,
                this.m_lalcB, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rB);
        box2d.b2MulSV(this.m_ratio, s, r);
        m = this.m_ratio * box2d.b2CrossVV(y, s);
        s = this.m_ratio * box2d.b2CrossVV(v, s);
        u += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * m * m + this.m_iB * s * s;
        y = this.m_lalcD;
        p = box2d.b2MulTRV(p, box2d.b2AddVV(v, box2d.b2SubVV(e, h, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0);
        p = box2d.b2DotVV(box2d.b2SubVV(p, y, box2d.b2Vec2.s_t0), this.m_localAxisD)
    }
    p = n + this.m_ratio * p - this.m_constant;
    n = 0;
    0 < u && (n = -p /
            u);
    b.SelfMulAdd(this.m_mA * n, q);
    c += this.m_iA * n * t;
    e.SelfMulAdd(this.m_mB * n, r);
    d += this.m_iB * n * s;
    f.SelfMulSub(this.m_mC * n, q);
    g -= this.m_iC * n * k;
    h.SelfMulSub(this.m_mD * n, r);
    l -= this.m_iD * n * m;
    a.positions[this.m_indexA].a = c;
    a.positions[this.m_indexB].a = d;
    a.positions[this.m_indexC].a = g;
    a.positions[this.m_indexD].a = l;
    return 0 < box2d.b2_linearSlop
};
goog.exportProperty(box2d.b2GearJoint.prototype, "SolvePositionConstraints", box2d.b2GearJoint.prototype.SolvePositionConstraints);
box2d.b2GearJoint.prototype.SolvePositionConstraints.s_u = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rA = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rB = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rC = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rD = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, a)
};
goog.exportProperty(box2d.b2GearJoint.prototype, "GetAnchorA", box2d.b2GearJoint.prototype.GetAnchorA);
box2d.b2GearJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2GearJoint.prototype, "GetAnchorB", box2d.b2GearJoint.prototype.GetAnchorB);
box2d.b2GearJoint.prototype.GetReactionForce = function(a, b) {
    return box2d.b2MulSV(a * this.m_impulse, this.m_JvAC, b)
};
goog.exportProperty(box2d.b2GearJoint.prototype, "GetReactionForce", box2d.b2GearJoint.prototype.GetReactionForce);
box2d.b2GearJoint.prototype.GetReactionTorque = function(a) {
    return a * this.m_impulse * this.m_JwA
};
goog.exportProperty(box2d.b2GearJoint.prototype, "GetReactionTorque", box2d.b2GearJoint.prototype.GetReactionTorque);
box2d.b2GearJoint.prototype.GetJoint1 = function() {
    return this.m_joint1
};
goog.exportProperty(box2d.b2GearJoint.prototype, "GetJoint1", box2d.b2GearJoint.prototype.GetJoint1);
box2d.b2GearJoint.prototype.GetJoint2 = function() {
    return this.m_joint2
};
goog.exportProperty(box2d.b2GearJoint.prototype, "GetJoint2", box2d.b2GearJoint.prototype.GetJoint2);
box2d.b2GearJoint.prototype.GetRatio = function() {
    return this.m_ratio
};
goog.exportProperty(box2d.b2GearJoint.prototype, "GetRatio", box2d.b2GearJoint.prototype.GetRatio);
box2d.b2GearJoint.prototype.SetRatio = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a));
    this.m_ratio = a
};
goog.exportProperty(box2d.b2GearJoint.prototype, "SetRatio", box2d.b2GearJoint.prototype.SetRatio);
box2d.b2GearJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex, c = this.m_joint1.m_index, e = this.m_joint2.m_index;
        box2d.b2Log("  /*box2d.b2GearJointDef*/ var jd = new box2d.b2GearJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.joint1 = joints[%d];\n", c);
        box2d.b2Log("  jd.joint2 = joints[%d];\n",
                e);
        box2d.b2Log("  jd.ratio = %.15f;\n", this.m_ratio);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
};
goog.exportProperty(box2d.b2GearJoint.prototype, "Dump", box2d.b2GearJoint.prototype.Dump);
box2d.b2DistanceProxy = function() {
    this.m_buffer = box2d.b2Vec2.MakeArray(2)
};
goog.exportSymbol("box2d.b2DistanceProxy", box2d.b2DistanceProxy);
box2d.b2DistanceProxy.prototype.m_buffer = null;
goog.exportProperty(box2d.b2DistanceProxy.prototype, "m_buffer", box2d.b2DistanceProxy.prototype.m_buffer);
box2d.b2DistanceProxy.prototype.m_vertices = null;
goog.exportProperty(box2d.b2DistanceProxy.prototype, "m_vertices", box2d.b2DistanceProxy.prototype.m_vertices);
box2d.b2DistanceProxy.prototype.m_count = 0;
goog.exportProperty(box2d.b2DistanceProxy.prototype, "m_count", box2d.b2DistanceProxy.prototype.m_count);
box2d.b2DistanceProxy.prototype.m_radius = 0;
goog.exportProperty(box2d.b2DistanceProxy.prototype, "m_radius", box2d.b2DistanceProxy.prototype.m_radius);
box2d.b2DistanceProxy.prototype.Reset = function() {
    this.m_vertices = null;
    this.m_radius = this.m_count = 0;
    return this
};
goog.exportProperty(box2d.b2DistanceProxy.prototype, "Reset", box2d.b2DistanceProxy.prototype.Reset);
box2d.b2DistanceProxy.prototype.SetShape = function(a, b) {
    a.SetupDistanceProxy(this, b)
};
goog.exportProperty(box2d.b2DistanceProxy.prototype, "SetShape", box2d.b2DistanceProxy.prototype.SetShape);
box2d.b2DistanceProxy.prototype.GetSupport = function(a) {
    for (var b = 0, c = box2d.b2DotVV(this.m_vertices[0], a), e = 1; e < this.m_count; ++e) {
        var d = box2d.b2DotVV(this.m_vertices[e], a);
        d > c && (b = e, c = d)
    }
    return b
};
goog.exportProperty(box2d.b2DistanceProxy.prototype, "GetSupport", box2d.b2DistanceProxy.prototype.GetSupport);
box2d.b2DistanceProxy.prototype.GetSupportVertex = function(a, b) {
    for (var c = 0, e = box2d.b2DotVV(this.m_vertices[0], a), d = 1; d < this.m_count; ++d) {
        var f = box2d.b2DotVV(this.m_vertices[d], a);
        f > e && (c = d, e = f)
    }
    return b.Copy(this.m_vertices[c])
};
goog.exportProperty(box2d.b2DistanceProxy.prototype, "GetSupportVertex", box2d.b2DistanceProxy.prototype.GetSupportVertex);
box2d.b2DistanceProxy.prototype.GetVertexCount = function() {
    return this.m_count
};
goog.exportProperty(box2d.b2DistanceProxy.prototype, "GetVertexCount", box2d.b2DistanceProxy.prototype.GetVertexCount);
box2d.b2DistanceProxy.prototype.GetVertex = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= a && a < this.m_count);
    return this.m_vertices[a]
};
goog.exportProperty(box2d.b2DistanceProxy.prototype, "GetVertex", box2d.b2DistanceProxy.prototype.GetVertex);
box2d.b2SimplexCache = function() {
    this.indexA = box2d.b2MakeNumberArray(3);
    this.indexB = box2d.b2MakeNumberArray(3)
};
goog.exportSymbol("box2d.b2SimplexCache", box2d.b2SimplexCache);
box2d.b2SimplexCache.prototype.metric = 0;
goog.exportProperty(box2d.b2SimplexCache.prototype, "metric", box2d.b2SimplexCache.prototype.metric);
box2d.b2SimplexCache.prototype.count = 0;
goog.exportProperty(box2d.b2SimplexCache.prototype, "count", box2d.b2SimplexCache.prototype.count);
box2d.b2SimplexCache.prototype.indexA = null;
goog.exportProperty(box2d.b2SimplexCache.prototype, "indexA", box2d.b2SimplexCache.prototype.indexA);
box2d.b2SimplexCache.prototype.indexB = null;
goog.exportProperty(box2d.b2SimplexCache.prototype, "indexB", box2d.b2SimplexCache.prototype.indexB);
box2d.b2SimplexCache.prototype.Reset = function() {
    this.count = this.metric = 0;
    return this
};
goog.exportProperty(box2d.b2SimplexCache.prototype, "Reset", box2d.b2SimplexCache.prototype.Reset);
box2d.b2DistanceInput = function() {
    this.proxyA = new box2d.b2DistanceProxy;
    this.proxyB = new box2d.b2DistanceProxy;
    this.transformA = new box2d.b2Transform;
    this.transformB = new box2d.b2Transform
};
goog.exportSymbol("box2d.b2DistanceInput", box2d.b2DistanceInput);
box2d.b2DistanceInput.prototype.proxyA = null;
goog.exportProperty(box2d.b2DistanceInput.prototype, "proxyA", box2d.b2DistanceInput.prototype.proxyA);
box2d.b2DistanceInput.prototype.proxyB = null;
goog.exportProperty(box2d.b2DistanceInput.prototype, "proxyB", box2d.b2DistanceInput.prototype.proxyB);
box2d.b2DistanceInput.prototype.transformA = null;
goog.exportProperty(box2d.b2DistanceInput.prototype, "transformA", box2d.b2DistanceInput.prototype.transformA);
box2d.b2DistanceInput.prototype.transformB = null;
goog.exportProperty(box2d.b2DistanceInput.prototype, "transformB", box2d.b2DistanceInput.prototype.transformB);
box2d.b2DistanceInput.prototype.useRadii = !1;
goog.exportProperty(box2d.b2DistanceInput.prototype, "useRadii", box2d.b2DistanceInput.prototype.useRadii);
box2d.b2DistanceInput.prototype.Reset = function() {
    this.proxyA.Reset();
    this.proxyB.Reset();
    this.transformA.SetIdentity();
    this.transformB.SetIdentity();
    this.useRadii = !1;
    return this
};
goog.exportProperty(box2d.b2DistanceInput.prototype, "Reset", box2d.b2DistanceInput.prototype.Reset);
box2d.b2DistanceOutput = function() {
    this.pointA = new box2d.b2Vec2;
    this.pointB = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2DistanceOutput", box2d.b2DistanceOutput);
box2d.b2DistanceOutput.prototype.pointA = null;
goog.exportProperty(box2d.b2DistanceOutput.prototype, "pointA", box2d.b2DistanceOutput.prototype.pointA);
box2d.b2DistanceOutput.prototype.pointB = null;
goog.exportProperty(box2d.b2DistanceOutput.prototype, "pointB", box2d.b2DistanceOutput.prototype.pointB);
box2d.b2DistanceOutput.prototype.distance = 0;
goog.exportProperty(box2d.b2DistanceOutput.prototype, "distance", box2d.b2DistanceOutput.prototype.distance);
box2d.b2DistanceOutput.prototype.iterations = 0;
goog.exportProperty(box2d.b2DistanceOutput.prototype, "iterations", box2d.b2DistanceOutput.prototype.iterations);
box2d.b2DistanceOutput.prototype.Reset = function() {
    this.pointA.SetZero();
    this.pointB.SetZero();
    this.iterations = this.distance = 0;
    return this
};
goog.exportProperty(box2d.b2DistanceOutput.prototype, "Reset", box2d.b2DistanceOutput.prototype.Reset);
box2d.b2_gjkCalls = 0;
goog.exportSymbol("box2d.b2_gjkCalls", box2d.b2_gjkCalls);
box2d.b2_gjkIters = 0;
goog.exportSymbol("box2d.b2_gjkIters", box2d.b2_gjkIters);
box2d.b2_gjkMaxIters = 0;
goog.exportSymbol("box2d.b2_gjkMaxIters", box2d.b2_gjkMaxIters);
box2d.b2SimplexVertex = function() {
    this.wA = new box2d.b2Vec2;
    this.wB = new box2d.b2Vec2;
    this.w = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2SimplexVertex", box2d.b2SimplexVertex);
box2d.b2SimplexVertex.prototype.wA = null;
goog.exportProperty(box2d.b2SimplexVertex.prototype, "wA", box2d.b2SimplexVertex.prototype.wA);
box2d.b2SimplexVertex.prototype.wB = null;
goog.exportProperty(box2d.b2SimplexVertex.prototype, "wB", box2d.b2SimplexVertex.prototype.wB);
box2d.b2SimplexVertex.prototype.w = null;
goog.exportProperty(box2d.b2SimplexVertex.prototype, "w", box2d.b2SimplexVertex.prototype.w);
box2d.b2SimplexVertex.prototype.a = 0;
goog.exportProperty(box2d.b2SimplexVertex.prototype, "a", box2d.b2SimplexVertex.prototype.a);
box2d.b2SimplexVertex.prototype.indexA = 0;
goog.exportProperty(box2d.b2SimplexVertex.prototype, "indexA", box2d.b2SimplexVertex.prototype.indexA);
box2d.b2SimplexVertex.prototype.indexB = 0;
goog.exportProperty(box2d.b2SimplexVertex.prototype, "indexB", box2d.b2SimplexVertex.prototype.indexB);
box2d.b2SimplexVertex.prototype.Copy = function(a) {
    this.wA.Copy(a.wA);
    this.wB.Copy(a.wB);
    this.w.Copy(a.w);
    this.a = a.a;
    this.indexA = a.indexA;
    this.indexB = a.indexB;
    return this
};
goog.exportProperty(box2d.b2SimplexVertex.prototype, "Copy", box2d.b2SimplexVertex.prototype.Copy);
box2d.b2Simplex = function() {
    this.m_v1 = new box2d.b2SimplexVertex;
    this.m_v2 = new box2d.b2SimplexVertex;
    this.m_v3 = new box2d.b2SimplexVertex;
    this.m_vertices = Array(3);
    this.m_vertices[0] = this.m_v1;
    this.m_vertices[1] = this.m_v2;
    this.m_vertices[2] = this.m_v3
};
goog.exportSymbol("box2d.b2Simplex", box2d.b2Simplex);
box2d.b2Simplex.prototype.m_v1 = null;
goog.exportProperty(box2d.b2Simplex.prototype, "m_v1", box2d.b2Simplex.prototype.m_v1);
box2d.b2Simplex.prototype.m_v2 = null;
goog.exportProperty(box2d.b2Simplex.prototype, "m_v2", box2d.b2Simplex.prototype.m_v2);
box2d.b2Simplex.prototype.m_v3 = null;
goog.exportProperty(box2d.b2Simplex.prototype, "m_v3", box2d.b2Simplex.prototype.m_v3);
box2d.b2Simplex.prototype.m_vertices = null;
goog.exportProperty(box2d.b2Simplex.prototype, "m_vertices", box2d.b2Simplex.prototype.m_vertices);
box2d.b2Simplex.prototype.m_count = 0;
goog.exportProperty(box2d.b2Simplex.prototype, "m_count", box2d.b2Simplex.prototype.m_count);
box2d.b2Simplex.prototype.ReadCache = function(a, b, c, e, d) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= a.count && 3 >= a.count);
    this.m_count = a.count;
    for (var f = this.m_vertices, g = 0; g < this.m_count; ++g) {
        var h = f[g];
        h.indexA = a.indexA[g];
        h.indexB = a.indexB[g];
        var l = b.GetVertex(h.indexA), k = e.GetVertex(h.indexB);
        box2d.b2MulXV(c, l, h.wA);
        box2d.b2MulXV(d, k, h.wB);
        box2d.b2SubVV(h.wB, h.wA, h.w);
        h.a = 0
    }
    1 < this.m_count && (a = a.metric, g = this.GetMetric(), g < 0.5 * a || 2 * a < g || g < box2d.b2_epsilon) && (this.m_count = 0);
    0 == this.m_count && (h = f[0],
            h.indexA = 0, h.indexB = 0, l = b.GetVertex(0), k = e.GetVertex(0), box2d.b2MulXV(c, l, h.wA), box2d.b2MulXV(d, k, h.wB), box2d.b2SubVV(h.wB, h.wA, h.w), this.m_count = h.a = 1)
};
goog.exportProperty(box2d.b2Simplex.prototype, "ReadCache", box2d.b2Simplex.prototype.ReadCache);
box2d.b2Simplex.prototype.WriteCache = function(a) {
    a.metric = this.GetMetric();
    a.count = this.m_count;
    for (var b = this.m_vertices, c = 0; c < this.m_count; ++c)
        a.indexA[c] = b[c].indexA, a.indexB[c] = b[c].indexB
};
goog.exportProperty(box2d.b2Simplex.prototype, "WriteCache", box2d.b2Simplex.prototype.WriteCache);
box2d.b2Simplex.prototype.GetSearchDirection = function(a) {
    switch (this.m_count) {
        case 1:
            return box2d.b2NegV(this.m_v1.w, a);
        case 2:
            var b = box2d.b2SubVV(this.m_v2.w, this.m_v1.w, a);
            return 0 < box2d.b2CrossVV(b, box2d.b2NegV(this.m_v1.w, box2d.b2Vec2.s_t0)) ? box2d.b2CrossOneV(b, a) : box2d.b2CrossVOne(b, a);
        default:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), a.SetZero()
        }
};
goog.exportProperty(box2d.b2Simplex.prototype, "GetSearchDirection", box2d.b2Simplex.prototype.GetSearchDirection);
box2d.b2Simplex.prototype.GetClosestPoint = function(a) {
    switch (this.m_count) {
        case 0:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), a.SetZero();
        case 1:
            return a.Copy(this.m_v1.w);
        case 2:
            return a.SetXY(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
        case 3:
            return a.SetZero();
        default:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), a.SetZero()
        }
};
goog.exportProperty(box2d.b2Simplex.prototype, "GetClosestPoint", box2d.b2Simplex.prototype.GetClosestPoint);
box2d.b2Simplex.prototype.GetWitnessPoints = function(a, b) {
    switch (this.m_count) {
        case 0:
            box2d.ENABLE_ASSERTS && box2d.b2Assert(!1);
            break;
        case 1:
            a.Copy(this.m_v1.wA);
            b.Copy(this.m_v1.wB);
            break;
        case 2:
            a.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;
            a.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;
            b.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;
            b.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
            break;
        case 3:
            b.x = a.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x +
                    this.m_v3.a * this.m_v3.wA.x;
            b.y = a.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
            break;
        default:
            box2d.ENABLE_ASSERTS && box2d.b2Assert(!1)
        }
};
goog.exportProperty(box2d.b2Simplex.prototype, "GetWitnessPoints", box2d.b2Simplex.prototype.GetWitnessPoints);
box2d.b2Simplex.prototype.GetMetric = function() {
    switch (this.m_count) {
        case 0:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), 0;
        case 1:
            return 0;
        case 2:
            return box2d.b2DistanceVV(this.m_v1.w, this.m_v2.w);
        case 3:
            return box2d.b2CrossVV(box2d.b2SubVV(this.m_v2.w, this.m_v1.w, box2d.b2Vec2.s_t0), box2d.b2SubVV(this.m_v3.w, this.m_v1.w, box2d.b2Vec2.s_t1));
        default:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), 0
        }
};
goog.exportProperty(box2d.b2Simplex.prototype, "GetMetric", box2d.b2Simplex.prototype.GetMetric);
box2d.b2Simplex.prototype.Solve2 = function() {
    var a = this.m_v1.w, b = this.m_v2.w, c = box2d.b2SubVV(b, a, box2d.b2Simplex.s_e12), a = -box2d.b2DotVV(a, c);
    0 >= a ? this.m_count = this.m_v1.a = 1 : (b = box2d.b2DotVV(b, c), 0 >= b ? (this.m_count = this.m_v2.a = 1, this.m_v1.Copy(this.m_v2)) : (c = 1 / (b + a), this.m_v1.a = b * c, this.m_v2.a = a * c, this.m_count = 2))
};
goog.exportProperty(box2d.b2Simplex.prototype, "Solve2", box2d.b2Simplex.prototype.Solve2);
box2d.b2Simplex.prototype.Solve3 = function() {
    var a = this.m_v1.w, b = this.m_v2.w, c = this.m_v3.w, e = box2d.b2SubVV(b, a, box2d.b2Simplex.s_e12), d = box2d.b2DotVV(a, e), f = box2d.b2DotVV(b, e), d = -d, g = box2d.b2SubVV(c, a, box2d.b2Simplex.s_e13), h = box2d.b2DotVV(a, g), l = box2d.b2DotVV(c, g), h = -h, k = box2d.b2SubVV(c, b, box2d.b2Simplex.s_e23), m = box2d.b2DotVV(b, k), k = box2d.b2DotVV(c, k), m = -m, g = box2d.b2CrossVV(e, g), e = g * box2d.b2CrossVV(b, c), c = g * box2d.b2CrossVV(c, a), a = g * box2d.b2CrossVV(a, b);
    0 >= d && 0 >= h ? this.m_count = this.m_v1.a = 1 : 0 < f &&
            0 < d && 0 >= a ? (l = 1 / (f + d), this.m_v1.a = f * l, this.m_v2.a = d * l, this.m_count = 2) : 0 < l && 0 < h && 0 >= c ? (f = 1 / (l + h), this.m_v1.a = l * f, this.m_v3.a = h * f, this.m_count = 2, this.m_v2.Copy(this.m_v3)) : 0 >= f && 0 >= m ? (this.m_count = this.m_v2.a = 1, this.m_v1.Copy(this.m_v2)) : 0 >= l && 0 >= k ? (this.m_count = this.m_v3.a = 1, this.m_v1.Copy(this.m_v3)) : 0 < k && 0 < m && 0 >= e ? (f = 1 / (k + m), this.m_v2.a = k * f, this.m_v3.a = m * f, this.m_count = 2, this.m_v1.Copy(this.m_v3)) : (f = 1 / (e + c + a), this.m_v1.a = e * f, this.m_v2.a = c * f, this.m_v3.a = a * f, this.m_count = 3)
};
goog.exportProperty(box2d.b2Simplex.prototype, "Solve3", box2d.b2Simplex.prototype.Solve3);
box2d.b2Simplex.s_e12 = new box2d.b2Vec2;
box2d.b2Simplex.s_e13 = new box2d.b2Vec2;
box2d.b2Simplex.s_e23 = new box2d.b2Vec2;
box2d.b2Distance = function(a, b, c) {
    ++box2d.b2_gjkCalls;
    var e = c.proxyA, d = c.proxyB, f = c.transformA, g = c.transformB, h = box2d.b2Distance.s_simplex;
    h.ReadCache(b, e, f, d, g);
    for (var l = h.m_vertices, k = box2d.b2Distance.s_saveA, m = box2d.b2Distance.s_saveB, n = 0, p = 0; 20 > p; ) {
        for (var n = h.m_count, q = 0; q < n; ++q)
            k[q] = l[q].indexA, m[q] = l[q].indexB;
        switch (h.m_count) {
            case 1:
                break;
            case 2:
                h.Solve2();
                break;
            case 3:
                h.Solve3();
                break;
            default:
                box2d.ENABLE_ASSERTS && box2d.b2Assert(!1)
        }
        if (3 == h.m_count)
            break;
        var r = h.GetClosestPoint(box2d.b2Distance.s_p);
        r.GetLengthSquared();
        q = h.GetSearchDirection(box2d.b2Distance.s_d);
        if (q.GetLengthSquared() < box2d.b2_epsilon_sq)
            break;
        r = l[h.m_count];
        r.indexA = e.GetSupport(box2d.b2MulTRV(f.q, box2d.b2NegV(q, box2d.b2Vec2.s_t0), box2d.b2Distance.s_supportA));
        box2d.b2MulXV(f, e.GetVertex(r.indexA), r.wA);
        r.indexB = d.GetSupport(box2d.b2MulTRV(g.q, q, box2d.b2Distance.s_supportB));
        box2d.b2MulXV(g, d.GetVertex(r.indexB), r.wB);
        box2d.b2SubVV(r.wB, r.wA, r.w);
        ++p;
        ++box2d.b2_gjkIters;
        for (var t = !1, q = 0; q < n; ++q)
            if (r.indexA == k[q] && r.indexB ==
                    m[q]) {
                t = !0;
                break
            }
        if (t)
            break;
        ++h.m_count
    }
    box2d.b2_gjkMaxIters = box2d.b2Max(box2d.b2_gjkMaxIters, p);
    h.GetWitnessPoints(a.pointA, a.pointB);
    a.distance = box2d.b2DistanceVV(a.pointA, a.pointB);
    a.iterations = p;
    h.WriteCache(b);
    c.useRadii && (b = e.m_radius, d = d.m_radius, a.distance > b + d && a.distance > box2d.b2_epsilon ? (a.distance -= b + d, c = box2d.b2SubVV(a.pointB, a.pointA, box2d.b2Distance.s_normal), c.Normalize(), a.pointA.SelfMulAdd(b, c), a.pointB.SelfMulSub(d, c)) : (r = box2d.b2MidVV(a.pointA, a.pointB, box2d.b2Distance.s_p), a.pointA.Copy(r),
            a.pointB.Copy(r), a.distance = 0))
};
goog.exportSymbol("box2d.b2Distance", box2d.b2Distance);
box2d.b2Distance.s_simplex = new box2d.b2Simplex;
box2d.b2Distance.s_saveA = box2d.b2MakeNumberArray(3);
box2d.b2Distance.s_saveB = box2d.b2MakeNumberArray(3);
box2d.b2Distance.s_p = new box2d.b2Vec2;
box2d.b2Distance.s_d = new box2d.b2Vec2;
box2d.b2Distance.s_normal = new box2d.b2Vec2;
box2d.b2Distance.s_supportA = new box2d.b2Vec2;
box2d.b2Distance.s_supportB = new box2d.b2Vec2;
box2d.b2WeldJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_weldJoint);
    this.localAnchorA = new box2d.b2Vec2;
    this.localAnchorB = new box2d.b2Vec2
};
goog.inherits(box2d.b2WeldJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2WeldJointDef", box2d.b2WeldJointDef);
box2d.b2WeldJointDef.prototype.localAnchorA = null;
goog.exportProperty(box2d.b2WeldJointDef.prototype, "localAnchorA", box2d.b2WeldJointDef.prototype.localAnchorA);
box2d.b2WeldJointDef.prototype.localAnchorB = null;
goog.exportProperty(box2d.b2WeldJointDef.prototype, "localAnchorB", box2d.b2WeldJointDef.prototype.localAnchorB);
box2d.b2WeldJointDef.prototype.referenceAngle = 0;
goog.exportProperty(box2d.b2WeldJointDef.prototype, "referenceAngle", box2d.b2WeldJointDef.prototype.referenceAngle);
box2d.b2WeldJointDef.prototype.frequencyHz = 0;
goog.exportProperty(box2d.b2WeldJointDef.prototype, "frequencyHz", box2d.b2WeldJointDef.prototype.frequencyHz);
box2d.b2WeldJointDef.prototype.dampingRatio = 0;
goog.exportProperty(box2d.b2WeldJointDef.prototype, "dampingRatio", box2d.b2WeldJointDef.prototype.dampingRatio);
box2d.b2WeldJointDef.prototype.Initialize = function(a, b, c) {
    this.bodyA = a;
    this.bodyB = b;
    this.bodyA.GetLocalPoint(c, this.localAnchorA);
    this.bodyB.GetLocalPoint(c, this.localAnchorB);
    this.referenceAngle = this.bodyB.GetAngleRadians() - this.bodyA.GetAngleRadians()
};
goog.exportProperty(box2d.b2WeldJointDef.prototype, "Initialize", box2d.b2WeldJointDef.prototype.Initialize);
box2d.b2WeldJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_frequencyHz = a.frequencyHz;
    this.m_dampingRatio = a.dampingRatio;
    this.m_localAnchorA = a.localAnchorA.Clone();
    this.m_localAnchorB = a.localAnchorB.Clone();
    this.m_referenceAngle = a.referenceAngle;
    this.m_impulse = new box2d.b2Vec3(0, 0, 0);
    this.m_rA = new box2d.b2Vec2;
    this.m_rB = new box2d.b2Vec2;
    this.m_localCenterA = new box2d.b2Vec2;
    this.m_localCenterB = new box2d.b2Vec2;
    this.m_mass = new box2d.b2Mat33;
    this.m_qA = new box2d.b2Rot;
    this.m_qB = new box2d.b2Rot;
    this.m_lalcA =
            new box2d.b2Vec2;
    this.m_lalcB = new box2d.b2Vec2;
    this.m_K = new box2d.b2Mat33
};
goog.inherits(box2d.b2WeldJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2WeldJoint", box2d.b2WeldJoint);
box2d.b2WeldJoint.prototype.m_frequencyHz = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_frequencyHz", box2d.b2WeldJoint.prototype.m_frequencyHz);
box2d.b2WeldJoint.prototype.m_dampingRatio = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_dampingRatio", box2d.b2WeldJoint.prototype.m_dampingRatio);
box2d.b2WeldJoint.prototype.m_bias = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_bias", box2d.b2WeldJoint.prototype.m_bias);
box2d.b2WeldJoint.prototype.m_localAnchorA = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_localAnchorA", box2d.b2WeldJoint.prototype.m_localAnchorA);
box2d.b2WeldJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_localAnchorB", box2d.b2WeldJoint.prototype.m_localAnchorB);
box2d.b2WeldJoint.prototype.m_referenceAngle = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_referenceAngle", box2d.b2WeldJoint.prototype.m_referenceAngle);
box2d.b2WeldJoint.prototype.m_gamma = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_gamma", box2d.b2WeldJoint.prototype.m_gamma);
box2d.b2WeldJoint.prototype.m_impulse = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_impulse", box2d.b2WeldJoint.prototype.m_impulse);
box2d.b2WeldJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_indexA", box2d.b2WeldJoint.prototype.m_indexA);
box2d.b2WeldJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_indexB", box2d.b2WeldJoint.prototype.m_indexB);
box2d.b2WeldJoint.prototype.m_rA = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_rA", box2d.b2WeldJoint.prototype.m_rA);
box2d.b2WeldJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_rB", box2d.b2WeldJoint.prototype.m_rB);
box2d.b2WeldJoint.prototype.m_localCenterA = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_localCenterA", box2d.b2WeldJoint.prototype.m_localCenterA);
box2d.b2WeldJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_localCenterB", box2d.b2WeldJoint.prototype.m_localCenterB);
box2d.b2WeldJoint.prototype.m_invMassA = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_invMassA", box2d.b2WeldJoint.prototype.m_invMassA);
box2d.b2WeldJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_invMassB", box2d.b2WeldJoint.prototype.m_invMassB);
box2d.b2WeldJoint.prototype.m_invIA = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_invIA", box2d.b2WeldJoint.prototype.m_invIA);
box2d.b2WeldJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_invIB", box2d.b2WeldJoint.prototype.m_invIB);
box2d.b2WeldJoint.prototype.m_mass = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_mass", box2d.b2WeldJoint.prototype.m_mass);
box2d.b2WeldJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_qA", box2d.b2WeldJoint.prototype.m_qA);
box2d.b2WeldJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_qB", box2d.b2WeldJoint.prototype.m_qB);
box2d.b2WeldJoint.prototype.m_lalcA = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_lalcA", box2d.b2WeldJoint.prototype.m_lalcA);
box2d.b2WeldJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_lalcB", box2d.b2WeldJoint.prototype.m_lalcB);
box2d.b2WeldJoint.prototype.m_K = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_K", box2d.b2WeldJoint.prototype.m_K);
box2d.b2WeldJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassA = this.m_bodyA.m_invMass;
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIA = this.m_bodyA.m_invI;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = a.positions[this.m_indexA].a, c = a.velocities[this.m_indexA].v, e = a.velocities[this.m_indexA].w,
            d = a.positions[this.m_indexB].a, f = a.velocities[this.m_indexB].v, g = a.velocities[this.m_indexB].w, h = this.m_qA.SetAngleRadians(b), l = this.m_qB.SetAngleRadians(d);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    box2d.b2MulRV(h, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    box2d.b2MulRV(l, this.m_lalcB, this.m_rB);
    var h = this.m_invMassA, l = this.m_invMassB, k = this.m_invIA, m = this.m_invIB, n = this.m_K;
    n.ex.x = h + l + this.m_rA.y * this.m_rA.y * k + this.m_rB.y *
            this.m_rB.y * m;
    n.ey.x = -this.m_rA.y * this.m_rA.x * k - this.m_rB.y * this.m_rB.x * m;
    n.ez.x = -this.m_rA.y * k - this.m_rB.y * m;
    n.ex.y = n.ey.x;
    n.ey.y = h + l + this.m_rA.x * this.m_rA.x * k + this.m_rB.x * this.m_rB.x * m;
    n.ez.y = this.m_rA.x * k + this.m_rB.x * m;
    n.ex.z = n.ez.x;
    n.ey.z = n.ez.y;
    n.ez.z = k + m;
    if (0 < this.m_frequencyHz) {
        n.GetInverse22(this.m_mass);
        var n = k + m, p = 0 < n ? 1 / n : 0, b = d - b - this.m_referenceAngle, d = 2 * box2d.b2_pi * this.m_frequencyHz, q = p * d * d, r = a.step.dt;
        this.m_gamma = r * (2 * p * this.m_dampingRatio * d + r * q);
        this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma :
                0;
        this.m_bias = b * r * q * this.m_gamma;
        n += this.m_gamma;
        this.m_mass.ez.z = 0 != n ? 1 / n : 0
    } else
        n.GetSymInverse33(this.m_mass), this.m_bias = this.m_gamma = 0;
    a.step.warmStarting ? (this.m_impulse.SelfMul(a.step.dtRatio), n = box2d.b2WeldJoint.prototype.InitVelocityConstraints.s_P.SetXY(this.m_impulse.x, this.m_impulse.y), c.SelfMulSub(h, n), e -= k * (box2d.b2CrossVV(this.m_rA, n) + this.m_impulse.z), f.SelfMulAdd(l, n), g += m * (box2d.b2CrossVV(this.m_rB, n) + this.m_impulse.z)) : this.m_impulse.SetZero();
    a.velocities[this.m_indexA].w = e;
    a.velocities[this.m_indexB].w =
    g
};
box2d.b2WeldJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2WeldJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.velocities[this.m_indexB].v, d = a.velocities[this.m_indexB].w, f = this.m_invMassA, g = this.m_invMassB, h = this.m_invIA, l = this.m_invIB;
    if (0 < this.m_frequencyHz) {
        var k = -this.m_mass.ez.z * (d - c + this.m_bias + this.m_gamma * this.m_impulse.z);
        this.m_impulse.z += k;
        c -= h * k;
        d += l * k;
        k = box2d.b2SubVV(box2d.b2AddVCrossSV(e, d, this.m_rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(b, c, this.m_rA, box2d.b2Vec2.s_t1),
                box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_Cdot1);
        k = box2d.b2MulM33XY(this.m_mass, k.x, k.y, box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse1).SelfNeg();
        this.m_impulse.x += k.x;
        this.m_impulse.y += k.y;
        b.SelfMulSub(f, k);
        c -= h * box2d.b2CrossVV(this.m_rA, k);
        e.SelfMulAdd(g, k);
        d += l * box2d.b2CrossVV(this.m_rB, k)
    } else {
        var k = box2d.b2SubVV(box2d.b2AddVCrossSV(e, d, this.m_rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(b, c, this.m_rA, box2d.b2Vec2.s_t1), box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_Cdot1),
                m = box2d.b2MulM33XYZ(this.m_mass, k.x, k.y, d - c, box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse).SelfNeg();
        this.m_impulse.SelfAdd(m);
        k = box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_P.SetXY(m.x, m.y);
        b.SelfMulSub(f, k);
        c -= h * (box2d.b2CrossVV(this.m_rA, k) + m.z);
        e.SelfMulAdd(g, k);
        d += l * (box2d.b2CrossVV(this.m_rB, k) + m.z)
    }
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = d
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "SolveVelocityConstraints", box2d.b2WeldJoint.prototype.SolveVelocityConstraints);
box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_Cdot1 = new box2d.b2Vec2;
box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse1 = new box2d.b2Vec2;
box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse = new box2d.b2Vec3;
box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2WeldJoint.prototype.SolvePositionConstraints = function(a) {
    var b = a.positions[this.m_indexA].c, c = a.positions[this.m_indexA].a, e = a.positions[this.m_indexB].c, d = a.positions[this.m_indexB].a, f = this.m_qA.SetAngleRadians(c), g = this.m_qB.SetAngleRadians(d), h = this.m_invMassA, l = this.m_invMassB, k = this.m_invIA, m = this.m_invIB;
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    var n = box2d.b2MulRV(f, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var p = box2d.b2MulRV(g, this.m_lalcB, this.m_rB), q = this.m_K;
    q.ex.x = h + l + n.y * n.y * k + p.y * p.y * m;
    q.ey.x = -n.y * n.x * k - p.y * p.x * m;
    q.ez.x = -n.y * k - p.y * m;
    q.ex.y = q.ey.x;
    q.ey.y = h + l + n.x * n.x * k + p.x * p.x * m;
    q.ez.y = n.x * k + p.x * m;
    q.ex.z = q.ez.x;
    q.ey.z = q.ez.y;
    q.ez.z = k + m;
    if (0 < this.m_frequencyHz) {
        var r = box2d.b2SubVV(box2d.b2AddVV(e, p, box2d.b2Vec2.s_t0), box2d.b2AddVV(b, n, box2d.b2Vec2.s_t1), box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_C1), g = r.GetLength(), f = 0, q = q.Solve22(r.x, r.y, box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_P).SelfNeg();
        b.SelfMulSub(h, q);
        c -= k * box2d.b2CrossVV(n, q);
        e.SelfMulAdd(l, q);
        d += m * box2d.b2CrossVV(p, q)
    } else
        r = box2d.b2SubVV(box2d.b2AddVV(e, p, box2d.b2Vec2.s_t0), box2d.b2AddVV(b, n, box2d.b2Vec2.s_t1), box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_C1), n = d - c - this.m_referenceAngle, g = r.GetLength(), f = box2d.b2Abs(n), n = q.Solve33(r.x, r.y, n, box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_impulse).SelfNeg(), q = box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_P.SetXY(n.x, n.y), b.SelfMulSub(h, q), c -= k * (box2d.b2CrossVV(this.m_rA,
                q) + n.z), e.SelfMulAdd(l, q), d += m * (box2d.b2CrossVV(this.m_rB, q) + n.z);
    a.positions[this.m_indexA].a = c;
    a.positions[this.m_indexB].a = d;
    return g <= box2d.b2_linearSlop && f <= box2d.b2_angularSlop
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "SolvePositionConstraints", box2d.b2WeldJoint.prototype.SolvePositionConstraints);
box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_C1 = new box2d.b2Vec2;
box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2;
box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_impulse = new box2d.b2Vec3;
box2d.b2WeldJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, a)
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "GetAnchorA", box2d.b2WeldJoint.prototype.GetAnchorA);
box2d.b2WeldJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "GetAnchorB", box2d.b2WeldJoint.prototype.GetAnchorB);
box2d.b2WeldJoint.prototype.GetReactionForce = function(a, b) {
    return b.SetXY(a * this.m_impulse.x, a * this.m_impulse.y)
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "GetReactionForce", box2d.b2WeldJoint.prototype.GetReactionForce);
box2d.b2WeldJoint.prototype.GetReactionTorque = function(a) {
    return a * this.m_impulse.z
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "GetReactionTorque", box2d.b2WeldJoint.prototype.GetReactionTorque);
box2d.b2WeldJoint.prototype.GetLocalAnchorA = function(a) {
    return a.Copy(this.m_localAnchorA)
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "GetLocalAnchorA", box2d.b2WeldJoint.prototype.GetLocalAnchorA);
box2d.b2WeldJoint.prototype.GetLocalAnchorB = function(a) {
    return a.Copy(this.m_localAnchorB)
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "GetLocalAnchorB", box2d.b2WeldJoint.prototype.GetLocalAnchorB);
box2d.b2WeldJoint.prototype.GetReferenceAngle = function() {
    return this.m_referenceAngle
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "GetReferenceAngle", box2d.b2WeldJoint.prototype.GetReferenceAngle);
box2d.b2WeldJoint.prototype.SetFrequency = function(a) {
    this.m_frequencyHz = a
};
box2d.b2WeldJoint.prototype.GetFrequency = function() {
    return this.m_frequencyHz
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "GetFrequency", box2d.b2WeldJoint.prototype.GetFrequency);
box2d.b2WeldJoint.prototype.SetDampingRatio = function(a) {
    this.m_dampingRatio = a
};
box2d.b2WeldJoint.prototype.GetDampingRatio = function() {
    return this.m_dampingRatio
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "GetDampingRatio", box2d.b2WeldJoint.prototype.GetDampingRatio);
box2d.b2WeldJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2WeldJointDef*/ var jd = new box2d.b2WeldJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
        box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n",
                this.m_localAnchorB.x, this.m_localAnchorB.y);
        box2d.b2Log("  jd.referenceAngle = %.15f;\n", this.m_referenceAngle);
        box2d.b2Log("  jd.frequencyHz = %.15f;\n", this.m_frequencyHz);
        box2d.b2Log("  jd.dampingRatio = %.15f;\n", this.m_dampingRatio);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "Dump", box2d.b2WeldJoint.prototype.Dump);
box2d.b2RopeJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_ropeJoint);
    this.localAnchorA = new box2d.b2Vec2(-1, 0);
    this.localAnchorB = new box2d.b2Vec2(1, 0)
};
goog.inherits(box2d.b2RopeJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2RopeJointDef", box2d.b2RopeJointDef);
box2d.b2RopeJointDef.prototype.localAnchorA = null;
goog.exportProperty(box2d.b2RopeJointDef.prototype, "localAnchorA", box2d.b2RopeJointDef.prototype.localAnchorA);
box2d.b2RopeJointDef.prototype.localAnchorB = null;
goog.exportProperty(box2d.b2RopeJointDef.prototype, "localAnchorB", box2d.b2RopeJointDef.prototype.localAnchorB);
box2d.b2RopeJointDef.prototype.maxLength = 0;
goog.exportProperty(box2d.b2RopeJointDef.prototype, "maxLength", box2d.b2RopeJointDef.prototype.maxLength);
box2d.b2RopeJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_localAnchorA = a.localAnchorA.Clone();
    this.m_localAnchorB = a.localAnchorB.Clone();
    this.m_maxLength = a.maxLength;
    this.m_u = new box2d.b2Vec2;
    this.m_rA = new box2d.b2Vec2;
    this.m_rB = new box2d.b2Vec2;
    this.m_localCenterA = new box2d.b2Vec2;
    this.m_localCenterB = new box2d.b2Vec2;
    this.m_qA = new box2d.b2Rot;
    this.m_qB = new box2d.b2Rot;
    this.m_lalcA = new box2d.b2Vec2;
    this.m_lalcB = new box2d.b2Vec2
};
goog.inherits(box2d.b2RopeJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2RopeJoint", box2d.b2RopeJoint);
box2d.b2RopeJoint.prototype.m_localAnchorA = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_localAnchorA", box2d.b2RopeJoint.prototype.m_localAnchorA);
box2d.b2RopeJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_localAnchorB", box2d.b2RopeJoint.prototype.m_localAnchorB);
box2d.b2RopeJoint.prototype.m_maxLength = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_maxLength", box2d.b2RopeJoint.prototype.m_maxLength);
box2d.b2RopeJoint.prototype.m_length = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_length", box2d.b2RopeJoint.prototype.m_length);
box2d.b2RopeJoint.prototype.m_impulse = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_impulse", box2d.b2RopeJoint.prototype.m_impulse);
box2d.b2RopeJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_indexA", box2d.b2RopeJoint.prototype.m_indexA);
box2d.b2RopeJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_indexB", box2d.b2RopeJoint.prototype.m_indexB);
box2d.b2RopeJoint.prototype.m_u = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_u", box2d.b2RopeJoint.prototype.m_u);
box2d.b2RopeJoint.prototype.m_rA = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_rA", box2d.b2RopeJoint.prototype.m_rA);
box2d.b2RopeJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_rB", box2d.b2RopeJoint.prototype.m_rB);
box2d.b2RopeJoint.prototype.m_localCenterA = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_localCenterA", box2d.b2RopeJoint.prototype.m_localCenterA);
box2d.b2RopeJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_localCenterB", box2d.b2RopeJoint.prototype.m_localCenterB);
box2d.b2RopeJoint.prototype.m_invMassA = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_invMassA", box2d.b2RopeJoint.prototype.m_invMassA);
box2d.b2RopeJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_invMassB", box2d.b2RopeJoint.prototype.m_invMassB);
box2d.b2RopeJoint.prototype.m_invIA = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_invIA", box2d.b2RopeJoint.prototype.m_invIA);
box2d.b2RopeJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_invIB", box2d.b2RopeJoint.prototype.m_invIB);
box2d.b2RopeJoint.prototype.m_mass = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_mass", box2d.b2RopeJoint.prototype.m_mass);
box2d.b2RopeJoint.prototype.m_state = box2d.b2LimitState.e_inactiveLimit;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_state", box2d.b2RopeJoint.prototype.m_state);
box2d.b2RopeJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_qA", box2d.b2RopeJoint.prototype.m_qA);
box2d.b2RopeJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_qB", box2d.b2RopeJoint.prototype.m_qB);
box2d.b2RopeJoint.prototype.m_lalcA = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_lalcA", box2d.b2RopeJoint.prototype.m_lalcA);
box2d.b2RopeJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_lalcB", box2d.b2RopeJoint.prototype.m_lalcB);
box2d.b2RopeJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassA = this.m_bodyA.m_invMass;
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIA = this.m_bodyA.m_invI;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = a.positions[this.m_indexA].c, c = a.velocities[this.m_indexA].v, e = a.velocities[this.m_indexA].w,
            d = a.positions[this.m_indexB].c, f = a.positions[this.m_indexB].a, g = a.velocities[this.m_indexB].v, h = a.velocities[this.m_indexB].w, l = this.m_qA.SetAngleRadians(a.positions[this.m_indexA].a), f = this.m_qB.SetAngleRadians(f);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    box2d.b2MulRV(l, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    box2d.b2MulRV(f, this.m_lalcB, this.m_rB);
    this.m_u.Copy(d).SelfAdd(this.m_rB).SelfSub(b).SelfSub(this.m_rA);
    this.m_length =
            this.m_u.GetLength();
    this.m_state = 0 < this.m_length - this.m_maxLength ? box2d.b2LimitState.e_atUpperLimit : box2d.b2LimitState.e_inactiveLimit;
    this.m_length > box2d.b2_linearSlop ? (this.m_u.SelfMul(1 / this.m_length), b = box2d.b2CrossVV(this.m_rA, this.m_u), d = box2d.b2CrossVV(this.m_rB, this.m_u), b = this.m_invMassA + this.m_invIA * b * b + this.m_invMassB + this.m_invIB * d * d, this.m_mass = 0 != b ? 1 / b : 0, a.step.warmStarting ? (this.m_impulse *= a.step.dtRatio, b = box2d.b2MulSV(this.m_impulse, this.m_u, box2d.b2RopeJoint.prototype.InitVelocityConstraints.s_P),
            c.SelfMulSub(this.m_invMassA, b), e -= this.m_invIA * box2d.b2CrossVV(this.m_rA, b), g.SelfMulAdd(this.m_invMassB, b), h += this.m_invIB * box2d.b2CrossVV(this.m_rB, b)) : this.m_impulse = 0, a.velocities[this.m_indexA].w = e, a.velocities[this.m_indexB].w = h) : (this.m_u.SetZero(), this.m_impulse = this.m_mass = 0)
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "InitVelocityConstraints", box2d.b2RopeJoint.prototype.InitVelocityConstraints);
box2d.b2RopeJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2RopeJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.velocities[this.m_indexB].v, d = a.velocities[this.m_indexB].w, f = box2d.b2AddVCrossSV(b, c, this.m_rA, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpA), g = box2d.b2AddVCrossSV(e, d, this.m_rB, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpB), h = this.m_length - this.m_maxLength, f = box2d.b2DotVV(this.m_u, box2d.b2SubVV(g, f, box2d.b2Vec2.s_t0));
    0 > h && (f += a.step.inv_dt *
            h);
    h = -this.m_mass * f;
    f = this.m_impulse;
    this.m_impulse = box2d.b2Min(0, this.m_impulse + h);
    h = this.m_impulse - f;
    h = box2d.b2MulSV(h, this.m_u, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_P);
    b.SelfMulSub(this.m_invMassA, h);
    c -= this.m_invIA * box2d.b2CrossVV(this.m_rA, h);
    e.SelfMulAdd(this.m_invMassB, h);
    d += this.m_invIB * box2d.b2CrossVV(this.m_rB, h);
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = d
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "SolveVelocityConstraints", box2d.b2RopeJoint.prototype.SolveVelocityConstraints);
box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpA = new box2d.b2Vec2;
box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpB = new box2d.b2Vec2;
box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2RopeJoint.prototype.SolvePositionConstraints = function(a) {
    var b = a.positions[this.m_indexA].c, c = a.positions[this.m_indexA].a, e = a.positions[this.m_indexB].c, d = a.positions[this.m_indexB].a, f = this.m_qA.SetAngleRadians(c), g = this.m_qB.SetAngleRadians(d);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    f = box2d.b2MulRV(f, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var g = box2d.b2MulRV(g, this.m_lalcB, this.m_rB), h = this.m_u.Copy(e).SelfAdd(g).SelfSub(b).SelfSub(f),
            l = h.Normalize(), k = l - this.m_maxLength, k = box2d.b2Clamp(k, 0, box2d.b2_maxLinearCorrection), h = box2d.b2MulSV(-this.m_mass * k, h, box2d.b2RopeJoint.prototype.SolvePositionConstraints.s_P);
    b.SelfMulSub(this.m_invMassA, h);
    c -= this.m_invIA * box2d.b2CrossVV(f, h);
    e.SelfMulAdd(this.m_invMassB, h);
    d += this.m_invIB * box2d.b2CrossVV(g, h);
    a.positions[this.m_indexA].a = c;
    a.positions[this.m_indexB].a = d;
    return l - this.m_maxLength < box2d.b2_linearSlop
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "SolvePositionConstraints", box2d.b2RopeJoint.prototype.SolvePositionConstraints);
box2d.b2RopeJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2;
box2d.b2RopeJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, a)
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "GetAnchorA", box2d.b2RopeJoint.prototype.GetAnchorA);
box2d.b2RopeJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "GetAnchorB", box2d.b2RopeJoint.prototype.GetAnchorB);
box2d.b2RopeJoint.prototype.GetReactionForce = function(a, b) {
    return box2d.b2MulSV(a * this.m_impulse, this.m_u, b)
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "GetReactionForce", box2d.b2RopeJoint.prototype.GetReactionForce);
box2d.b2RopeJoint.prototype.GetReactionTorque = function(a) {
    return 0
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "GetReactionTorque", box2d.b2RopeJoint.prototype.GetReactionTorque);
box2d.b2RopeJoint.prototype.GetLocalAnchorA = function(a) {
    return a.Copy(this.m_localAnchorA)
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "GetLocalAnchorA", box2d.b2RopeJoint.prototype.GetLocalAnchorA);
box2d.b2RopeJoint.prototype.GetLocalAnchorB = function(a) {
    return a.Copy(this.m_localAnchorB)
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "GetLocalAnchorB", box2d.b2RopeJoint.prototype.GetLocalAnchorB);
box2d.b2RopeJoint.prototype.SetMaxLength = function(a) {
    this.m_maxLength = a
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "SetMaxLength", box2d.b2RopeJoint.prototype.SetMaxLength);
box2d.b2RopeJoint.prototype.GetMaxLength = function() {
    return this.m_maxLength
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "GetMaxLength", box2d.b2RopeJoint.prototype.GetMaxLength);
box2d.b2RopeJoint.prototype.GetLimitState = function() {
    return this.m_state
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "GetLimitState", box2d.b2RopeJoint.prototype.GetLimitState);
box2d.b2RopeJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2RopeJointDef*/ var jd = new box2d.b2RopeJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
        box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n",
                this.m_localAnchorB.x, this.m_localAnchorB.y);
        box2d.b2Log("  jd.maxLength = %.15f;\n", this.m_maxLength);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "Dump", box2d.b2RopeJoint.prototype.Dump);
box2d.b2GravityController = function() {
    box2d.b2Controller.call(this)
};
goog.inherits(box2d.b2GravityController, box2d.b2Controller);
goog.exportSymbol("box2d.b2GravityController", box2d.b2GravityController);
box2d.b2GravityController.prototype.G = 1;
goog.exportProperty(box2d.b2GravityController.prototype, "G", box2d.b2GravityController.prototype.G);
box2d.b2GravityController.prototype.invSqr = !0;
goog.exportProperty(box2d.b2GravityController.prototype, "invSqr", box2d.b2GravityController.prototype.invSqr);
box2d.b2GravityController.prototype.Step = function(a) {
    if (this.invSqr)
        for (a = this.m_bodyList; a; a = a.nextBody)
            for (var b = a.body, c = b.GetWorldCenter(), e = b.GetMass(), d = this.m_bodyList; d != a; d = d.nextBody) {
                var f = d.body, g = f.GetWorldCenter(), h = f.GetMass(), l = g.x - c.x, k = g.y - c.y, m = l * l + k * k;
                m < box2d.b2_epsilon || (l = box2d.b2GravityController.prototype.Step.s_f.SetXY(l, k), l.SelfMul(this.G / m / box2d.b2Sqrt(m) * e * h), b.IsAwake() && b.ApplyForce(l, c), f.IsAwake() && f.ApplyForce(l.SelfMul(-1), g))
            }
    else
        for (a = this.m_bodyList; a; a = a.nextBody)
            for (b =
                    a.body, c = b.GetWorldCenter(), e = b.GetMass(), d = this.m_bodyList; d != a; d = d.nextBody)
                f = d.body, g = f.GetWorldCenter(), h = f.GetMass(), l = g.x - c.x, k = g.y - c.y, m = l * l + k * k, m < box2d.b2_epsilon || (l = box2d.b2GravityController.prototype.Step.s_f.SetXY(l, k), l.SelfMul(this.G / m * e * h), b.IsAwake() && b.ApplyForce(l, c), f.IsAwake() && f.ApplyForce(l.SelfMul(-1), g))
};
goog.exportProperty(box2d.b2GravityController.prototype, "Step", box2d.b2GravityController.prototype.Step);
box2d.b2GravityController.prototype.Step.s_f = new box2d.b2Vec2;
box2d.b2Profile = function() {
};
goog.exportSymbol("box2d.b2Profile", box2d.b2Profile);
box2d.b2Profile.prototype.step = 0;
goog.exportProperty(box2d.b2Profile.prototype, "step", box2d.b2Profile.prototype.step);
box2d.b2Profile.prototype.collide = 0;
goog.exportProperty(box2d.b2Profile.prototype, "collide", box2d.b2Profile.prototype.collide);
box2d.b2Profile.prototype.solve = 0;
goog.exportProperty(box2d.b2Profile.prototype, "solve", box2d.b2Profile.prototype.solve);
box2d.b2Profile.prototype.solveInit = 0;
goog.exportProperty(box2d.b2Profile.prototype, "solveInit", box2d.b2Profile.prototype.solveInit);
box2d.b2Profile.prototype.solveVelocity = 0;
goog.exportProperty(box2d.b2Profile.prototype, "solveVelocity", box2d.b2Profile.prototype.solveVelocity);
box2d.b2Profile.prototype.solvePosition = 0;
goog.exportProperty(box2d.b2Profile.prototype, "solvePosition", box2d.b2Profile.prototype.solvePosition);
box2d.b2Profile.prototype.broadphase = 0;
goog.exportProperty(box2d.b2Profile.prototype, "broadphase", box2d.b2Profile.prototype.broadphase);
box2d.b2Profile.prototype.solveTOI = 0;
goog.exportProperty(box2d.b2Profile.prototype, "solveTOI", box2d.b2Profile.prototype.solveTOI);
box2d.b2Profile.prototype.Reset = function() {
    this.solveTOI = this.broadphase = this.solvePosition = this.solveVelocity = this.solveInit = this.solve = this.collide = this.step = 0;
    return this
};
goog.exportProperty(box2d.b2Profile.prototype, "Reset", box2d.b2Profile.prototype.Reset);
box2d.b2TimeStep = function() {
};
goog.exportSymbol("box2d.b2TimeStep", box2d.b2TimeStep);
box2d.b2TimeStep.prototype.dt = 0;
goog.exportProperty(box2d.b2TimeStep.prototype, "dt", box2d.b2TimeStep.prototype.dt);
box2d.b2TimeStep.prototype.inv_dt = 0;
goog.exportProperty(box2d.b2TimeStep.prototype, "inv_dt", box2d.b2TimeStep.prototype.inv_dt);
box2d.b2TimeStep.prototype.dtRatio = 0;
goog.exportProperty(box2d.b2TimeStep.prototype, "dtRatio", box2d.b2TimeStep.prototype.dtRatio);
box2d.b2TimeStep.prototype.velocityIterations = 0;
goog.exportProperty(box2d.b2TimeStep.prototype, "velocityIterations", box2d.b2TimeStep.prototype.velocityIterations);
box2d.b2TimeStep.prototype.positionIterations = 0;
goog.exportProperty(box2d.b2TimeStep.prototype, "positionIterations", box2d.b2TimeStep.prototype.positionIterations);
box2d.b2TimeStep.prototype.warmStarting = !1;
goog.exportProperty(box2d.b2TimeStep.prototype, "warmStarting", box2d.b2TimeStep.prototype.warmStarting);
box2d.b2TimeStep.prototype.Copy = function(a) {
    this.dt = a.dt;
    this.inv_dt = a.inv_dt;
    this.dtRatio = a.dtRatio;
    this.positionIterations = a.positionIterations;
    this.velocityIterations = a.velocityIterations;
    this.warmStarting = a.warmStarting;
    return this
};
goog.exportProperty(box2d.b2TimeStep.prototype, "Copy", box2d.b2TimeStep.prototype.Copy);
box2d.b2Position = function() {
    this.c = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2Position", box2d.b2Position);
box2d.b2Position.prototype.c = null;
goog.exportProperty(box2d.b2Position.prototype, "c", box2d.b2Position.prototype.c);
box2d.b2Position.prototype.a = 0;
goog.exportProperty(box2d.b2Position.prototype, "a", box2d.b2Position.prototype.a);
box2d.b2Position.MakeArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return new box2d.b2Position
    })
};
goog.exportProperty(box2d.b2Position, "MakeArray", box2d.b2Position.MakeArray);
box2d.b2Velocity = function() {
    this.v = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2Velocity", box2d.b2Velocity);
box2d.b2Velocity.prototype.v = null;
goog.exportProperty(box2d.b2Velocity.prototype, "v", box2d.b2Velocity.prototype.v);
box2d.b2Velocity.prototype.w = 0;
goog.exportProperty(box2d.b2Velocity.prototype, "w", box2d.b2Velocity.prototype.w);
box2d.b2Velocity.MakeArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return new box2d.b2Velocity
    })
};
goog.exportProperty(box2d.b2Velocity, "MakeArray", box2d.b2Velocity.MakeArray);
box2d.b2SolverData = function() {
    this.step = new box2d.b2TimeStep
};
goog.exportSymbol("box2d.b2SolverData", box2d.b2SolverData);
box2d.b2SolverData.prototype.step = null;
goog.exportProperty(box2d.b2SolverData.prototype, "step", box2d.b2SolverData.prototype.step);
box2d.b2SolverData.prototype.positions = null;
goog.exportProperty(box2d.b2SolverData.prototype, "positions", box2d.b2SolverData.prototype.positions);
box2d.b2SolverData.prototype.velocities = null;
goog.exportProperty(box2d.b2SolverData.prototype, "velocities", box2d.b2SolverData.prototype.velocities);
box2d.b2Collision = {};
box2d.b2ContactFeatureType = {e_vertex: 0, e_face: 1};
goog.exportSymbol("box2d.b2ContactFeatureType", box2d.b2ContactFeatureType);
goog.exportProperty(box2d.b2ContactFeatureType, "e_vertex", box2d.b2ContactFeatureType.e_vertex);
goog.exportProperty(box2d.b2ContactFeatureType, "e_face", box2d.b2ContactFeatureType.e_face);
box2d.b2ContactFeature = function(a) {
    this._id = a
};
goog.exportSymbol("box2d.b2ContactFeature", box2d.b2ContactFeature);
box2d.b2ContactFeature.prototype._id = null;
goog.exportProperty(box2d.b2ContactFeature.prototype, "_id", box2d.b2ContactFeature.prototype._id);
box2d.b2ContactFeature.prototype._indexA = 0;
goog.exportProperty(box2d.b2ContactFeature.prototype, "_indexA", box2d.b2ContactFeature.prototype._indexA);
box2d.b2ContactFeature.prototype._indexB = 0;
goog.exportProperty(box2d.b2ContactFeature.prototype, "_indexB", box2d.b2ContactFeature.prototype._indexB);
box2d.b2ContactFeature.prototype._typeA = 0;
goog.exportProperty(box2d.b2ContactFeature.prototype, "_typeA", box2d.b2ContactFeature.prototype._typeA);
box2d.b2ContactFeature.prototype._typeB = 0;
goog.exportProperty(box2d.b2ContactFeature.prototype, "_typeB", box2d.b2ContactFeature.prototype._typeB);
Object.defineProperty(box2d.b2ContactFeature.prototype, "indexA", {enumerable: !1, configurable: !0, get: function() {
        return this._indexA
    }, set: function(a) {
        this._indexA = a;
        this._id._key = this._id._key & 4294967040 | this._indexA & 255
    }});
Object.defineProperty(box2d.b2ContactFeature.prototype, "indexB", {enumerable: !1, configurable: !0, get: function() {
        return this._indexB
    }, set: function(a) {
        this._indexB = a;
        this._id._key = this._id._key & 4294902015 | this._indexB << 8 & 65280
    }});
Object.defineProperty(box2d.b2ContactFeature.prototype, "typeA", {enumerable: !1, configurable: !0, get: function() {
        return this._typeA
    }, set: function(a) {
        this._typeA = a;
        this._id._key = this._id._key & 4278255615 | this._typeA << 16 & 16711680
    }});
Object.defineProperty(box2d.b2ContactFeature.prototype, "typeB", {enumerable: !1, configurable: !0, get: function() {
        return this._typeB
    }, set: function(a) {
        this._typeB = a;
        this._id._key = this._id._key & 16777215 | this._typeB << 24 & 4278190080
    }});
box2d.b2ContactID = function() {
    this.cf = new box2d.b2ContactFeature(this)
};
goog.exportSymbol("box2d.b2ContactID", box2d.b2ContactID);
box2d.b2ContactID.prototype.cf = null;
goog.exportProperty(box2d.b2ContactID.prototype, "cf", box2d.b2ContactID.prototype.cf);
box2d.b2ContactID.prototype.key = 0;
goog.exportProperty(box2d.b2ContactID.prototype, "key", box2d.b2ContactID.prototype.key);
box2d.b2ContactID.prototype.Copy = function(a) {
    this.key = a.key;
    return this
};
goog.exportProperty(box2d.b2ContactID.prototype, "Copy", box2d.b2ContactID.prototype.Copy);
box2d.b2ContactID.prototype.Clone = function() {
    return(new box2d.b2ContactID).Copy(this)
};
goog.exportProperty(box2d.b2ContactID.prototype, "Clone", box2d.b2ContactID.prototype.Clone);
Object.defineProperty(box2d.b2ContactID.prototype, "key", {enumerable: !1, configurable: !0, get: function() {
        return this._key
    }, set: function(a) {
        this._key = a;
        this.cf._indexA = this._key & 255;
        this.cf._indexB = this._key >> 8 & 255;
        this.cf._typeA = this._key >> 16 & 255;
        this.cf._typeB = this._key >> 24 & 255
    }});
box2d.b2ManifoldPoint = function() {
    this.localPoint = new box2d.b2Vec2;
    this.id = new box2d.b2ContactID
};
goog.exportSymbol("box2d.b2ManifoldPoint", box2d.b2ManifoldPoint);
box2d.b2ManifoldPoint.prototype.localPoint = null;
goog.exportProperty(box2d.b2ManifoldPoint.prototype, "localPoint", box2d.b2ManifoldPoint.prototype.localPoint);
box2d.b2ManifoldPoint.prototype.normalImpulse = 0;
goog.exportProperty(box2d.b2ManifoldPoint.prototype, "normalImpulse", box2d.b2ManifoldPoint.prototype.normalImpulse);
box2d.b2ManifoldPoint.prototype.tangentImpulse = 0;
goog.exportProperty(box2d.b2ManifoldPoint.prototype, "tangentImpulse", box2d.b2ManifoldPoint.prototype.tangentImpulse);
box2d.b2ManifoldPoint.prototype.id = null;
goog.exportProperty(box2d.b2ManifoldPoint.prototype, "id", box2d.b2ManifoldPoint.prototype.id);
box2d.b2ManifoldPoint.MakeArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return new box2d.b2ManifoldPoint
    })
};
goog.exportProperty(box2d.b2ManifoldPoint, "MakeArray", box2d.b2ManifoldPoint.MakeArray);
box2d.b2ManifoldPoint.prototype.Reset = function() {
    this.localPoint.SetZero();
    this.tangentImpulse = this.normalImpulse = 0;
    this.id.key = 0
};
goog.exportProperty(box2d.b2ManifoldPoint.prototype, "Reset", box2d.b2ManifoldPoint.prototype.Reset);
box2d.b2ManifoldPoint.prototype.Copy = function(a) {
    this.localPoint.Copy(a.localPoint);
    this.normalImpulse = a.normalImpulse;
    this.tangentImpulse = a.tangentImpulse;
    this.id.Copy(a.id);
    return this
};
goog.exportProperty(box2d.b2ManifoldPoint.prototype, "Copy", box2d.b2ManifoldPoint.prototype.Copy);
box2d.b2ManifoldType = {e_unknown: -1, e_circles: 0, e_faceA: 1, e_faceB: 2};
goog.exportSymbol("box2d.b2ManifoldType", box2d.b2ManifoldType);
goog.exportProperty(box2d.b2ManifoldType, "e_unknown", box2d.b2ManifoldType.e_unknown);
goog.exportProperty(box2d.b2ManifoldType, "e_circles", box2d.b2ManifoldType.e_circles);
goog.exportProperty(box2d.b2ManifoldType, "e_faceA", box2d.b2ManifoldType.e_faceA);
goog.exportProperty(box2d.b2ManifoldType, "e_faceB", box2d.b2ManifoldType.e_faceB);
box2d.b2Manifold = function() {
    this.points = box2d.b2ManifoldPoint.MakeArray(box2d.b2_maxManifoldPoints);
    this.localNormal = new box2d.b2Vec2;
    this.localPoint = new box2d.b2Vec2;
    this.type = box2d.b2ManifoldType.e_unknown;
    this.pointCount = 0
};
goog.exportSymbol("box2d.b2Manifold", box2d.b2Manifold);
box2d.b2Manifold.prototype.points = null;
goog.exportProperty(box2d.b2Manifold.prototype, "points", box2d.b2Manifold.prototype.points);
box2d.b2Manifold.prototype.localNormal = null;
goog.exportProperty(box2d.b2Manifold.prototype, "localNormal", box2d.b2Manifold.prototype.localNormal);
box2d.b2Manifold.prototype.localPoint = null;
goog.exportProperty(box2d.b2Manifold.prototype, "localPoint", box2d.b2Manifold.prototype.localPoint);
box2d.b2Manifold.prototype.type = box2d.b2ManifoldType.e_unknown;
goog.exportProperty(box2d.b2Manifold.prototype, "type", box2d.b2Manifold.prototype.type);
box2d.b2Manifold.prototype.pointCount = 0;
goog.exportProperty(box2d.b2Manifold.prototype, "pointCount", box2d.b2Manifold.prototype.pointCount);
box2d.b2Manifold.prototype.Reset = function() {
    for (var a = 0, b = box2d.b2_maxManifoldPoints; a < b; ++a)
        this.points[a].Reset();
    this.localNormal.SetZero();
    this.localPoint.SetZero();
    this.type = box2d.b2ManifoldType.e_unknown;
    this.pointCount = 0
};
goog.exportProperty(box2d.b2Manifold.prototype, "Reset", box2d.b2Manifold.prototype.Reset);
box2d.b2Manifold.prototype.Copy = function(a) {
    this.pointCount = a.pointCount;
    for (var b = 0, c = box2d.b2_maxManifoldPoints; b < c; ++b)
        this.points[b].Copy(a.points[b]);
    this.localNormal.Copy(a.localNormal);
    this.localPoint.Copy(a.localPoint);
    this.type = a.type;
    return this
};
goog.exportProperty(box2d.b2Manifold.prototype, "Copy", box2d.b2Manifold.prototype.Copy);
box2d.b2Manifold.prototype.Clone = function() {
    return(new box2d.b2Manifold).Copy(this)
};
goog.exportProperty(box2d.b2Manifold.prototype, "Clone", box2d.b2Manifold.prototype.Clone);
box2d.b2WorldManifold = function() {
    this.normal = new box2d.b2Vec2;
    this.points = box2d.b2Vec2.MakeArray(box2d.b2_maxManifoldPoints)
};
goog.exportSymbol("box2d.b2WorldManifold", box2d.b2WorldManifold);
box2d.b2WorldManifold.prototype.normal = null;
goog.exportProperty(box2d.b2WorldManifold.prototype, "normal", box2d.b2WorldManifold.prototype.normal);
box2d.b2WorldManifold.prototype.points = null;
goog.exportProperty(box2d.b2WorldManifold.prototype, "points", box2d.b2WorldManifold.prototype.points);
box2d.b2WorldManifold.prototype.Initialize = function(a, b, c, e, d) {
    if (0 != a.pointCount)
        switch (a.type) {
            case box2d.b2ManifoldType.e_circles:
                this.normal.SetXY(1, 0);
                b = box2d.b2MulXV(b, a.localPoint, box2d.b2WorldManifold.prototype.Initialize.s_pointA);
                a = box2d.b2MulXV(e, a.points[0].localPoint, box2d.b2WorldManifold.prototype.Initialize.s_pointB);
                box2d.b2DistanceSquaredVV(b, a) > box2d.b2_epsilon_sq && box2d.b2SubVV(a, b, this.normal).SelfNormalize();
                var f = box2d.b2AddVMulSV(b, c, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cA),
                        g = box2d.b2SubVMulSV(a, d, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cB);
                box2d.b2MidVV(f, g, this.points[0]);
                break;
            case box2d.b2ManifoldType.e_faceA:
                box2d.b2MulRV(b.q, a.localNormal, this.normal);
                for (var h = box2d.b2MulXV(b, a.localPoint, box2d.b2WorldManifold.prototype.Initialize.s_planePoint), l = 0, k = a.pointCount; l < k; ++l) {
                    var m = box2d.b2MulXV(e, a.points[l].localPoint, box2d.b2WorldManifold.prototype.Initialize.s_clipPoint), f = c - box2d.b2DotVV(box2d.b2SubVV(m, h, box2d.b2Vec2.s_t0), this.normal), f = box2d.b2AddVMulSV(m,
                            f, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cA), g = box2d.b2SubVMulSV(m, d, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cB);
                    box2d.b2MidVV(f, g, this.points[l])
                }
                break;
            case box2d.b2ManifoldType.e_faceB:
                box2d.b2MulRV(e.q, a.localNormal, this.normal);
                h = box2d.b2MulXV(e, a.localPoint, box2d.b2WorldManifold.prototype.Initialize.s_planePoint);
                l = 0;
                for (k = a.pointCount; l < k; ++l)
                    m = box2d.b2MulXV(b, a.points[l].localPoint, box2d.b2WorldManifold.prototype.Initialize.s_clipPoint), f = d - box2d.b2DotVV(box2d.b2SubVV(m,
                            h, box2d.b2Vec2.s_t0), this.normal), g = box2d.b2AddVMulSV(m, f, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cB), f = box2d.b2SubVMulSV(m, c, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cA), box2d.b2MidVV(f, g, this.points[l]);
                this.normal.SelfNeg()
            }
};
goog.exportProperty(box2d.b2WorldManifold.prototype, "Initialize", box2d.b2WorldManifold.prototype.Initialize);
box2d.b2WorldManifold.prototype.Initialize.s_pointA = new box2d.b2Vec2;
box2d.b2WorldManifold.prototype.Initialize.s_pointB = new box2d.b2Vec2;
box2d.b2WorldManifold.prototype.Initialize.s_cA = new box2d.b2Vec2;
box2d.b2WorldManifold.prototype.Initialize.s_cB = new box2d.b2Vec2;
box2d.b2WorldManifold.prototype.Initialize.s_planePoint = new box2d.b2Vec2;
box2d.b2WorldManifold.prototype.Initialize.s_clipPoint = new box2d.b2Vec2;
box2d.b2PointState = {b2_nullState: 0, b2_addState: 1, b2_persistState: 2, b2_removeState: 3};
goog.exportSymbol("box2d.b2PointState", box2d.b2PointState);
goog.exportProperty(box2d.b2PointState, "b2_nullState   ", box2d.b2PointState.b2_nullState);
goog.exportProperty(box2d.b2PointState, "b2_addState    ", box2d.b2PointState.b2_addState);
goog.exportProperty(box2d.b2PointState, "b2_persistState", box2d.b2PointState.b2_persistState);
goog.exportProperty(box2d.b2PointState, "b2_removeState ", box2d.b2PointState.b2_removeState);
box2d.b2GetPointStates = function(a, b, c, e) {
    for (var d = 0, f = c.pointCount; d < f; ++d) {
        var g = c.points[d].id, g = g.key;
        a[d] = box2d.b2PointState.b2_removeState;
        for (var h = 0, l = e.pointCount; h < l; ++h)
            if (e.points[h].id.key == g) {
                a[d] = box2d.b2PointState.b2_persistState;
                break
            }
    }
    for (f = box2d.b2_maxManifoldPoints; d < f; ++d)
        a[d] = box2d.b2PointState.b2_nullState;
    d = 0;
    for (f = e.pointCount; d < f; ++d)
        for (g = e.points[d].id, g = g.key, b[d] = box2d.b2PointState.b2_addState, h = 0, l = c.pointCount; h < l; ++h)
            if (c.points[h].id.key == g) {
                b[d] = box2d.b2PointState.b2_persistState;
                break
            }
    for (f = box2d.b2_maxManifoldPoints; d < f; ++d)
        b[d] = box2d.b2PointState.b2_nullState
};
goog.exportSymbol("box2d.b2GetPointStates", box2d.b2GetPointStates);
box2d.b2ClipVertex = function() {
    this.v = new box2d.b2Vec2;
    this.id = new box2d.b2ContactID
};
goog.exportSymbol("box2d.b2ClipVertex", box2d.b2ClipVertex);
box2d.b2ClipVertex.prototype.v = null;
goog.exportProperty(box2d.b2ClipVertex.prototype, "v", box2d.b2ClipVertex.prototype.v);
box2d.b2ClipVertex.prototype.id = null;
goog.exportProperty(box2d.b2ClipVertex.prototype, "id", box2d.b2ClipVertex.prototype.id);
box2d.b2ClipVertex.MakeArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return new box2d.b2ClipVertex
    })
};
goog.exportProperty(box2d.b2ClipVertex, "MakeArray", box2d.b2ClipVertex.MakeArray);
box2d.b2ClipVertex.prototype.Copy = function(a) {
    this.v.Copy(a.v);
    this.id.Copy(a.id);
    return this
};
goog.exportProperty(box2d.b2ClipVertex.prototype, "Copy", box2d.b2ClipVertex.prototype.Copy);
box2d.b2RayCastInput = function() {
    this.p1 = new box2d.b2Vec2;
    this.p2 = new box2d.b2Vec2;
    this.maxFraction = 1
};
goog.exportSymbol("box2d.b2RayCastInput", box2d.b2RayCastInput);
box2d.b2RayCastInput.prototype.p1 = null;
goog.exportProperty(box2d.b2RayCastInput.prototype, "p1", box2d.b2RayCastInput.prototype.p1);
box2d.b2RayCastInput.prototype.p2 = null;
goog.exportProperty(box2d.b2RayCastInput.prototype, "p2", box2d.b2RayCastInput.prototype.p2);
box2d.b2RayCastInput.prototype.maxFraction = 1;
goog.exportProperty(box2d.b2RayCastInput.prototype, "maxFraction", box2d.b2RayCastInput.prototype.maxFraction);
box2d.b2RayCastInput.prototype.Copy = function(a) {
    this.p1.Copy(a.p1);
    this.p2.Copy(a.p2);
    this.maxFraction = a.maxFraction;
    return this
};
goog.exportProperty(box2d.b2RayCastInput.prototype, "Copy", box2d.b2RayCastInput.prototype.Copy);
box2d.b2RayCastOutput = function() {
    this.normal = new box2d.b2Vec2;
    this.fraction = 0
};
goog.exportSymbol("box2d.b2RayCastOutput", box2d.b2RayCastOutput);
box2d.b2RayCastOutput.prototype.normal = null;
goog.exportProperty(box2d.b2RayCastOutput.prototype, "normal", box2d.b2RayCastOutput.prototype.normal);
box2d.b2RayCastOutput.prototype.fraction = 0;
goog.exportProperty(box2d.b2RayCastOutput.prototype, "fraction", box2d.b2RayCastOutput.prototype.fraction);
box2d.b2RayCastOutput.prototype.Copy = function(a) {
    this.normal.Copy(a.normal);
    this.fraction = a.fraction;
    return this
};
goog.exportProperty(box2d.b2RayCastOutput.prototype, "Copy", box2d.b2RayCastOutput.prototype.Copy);
box2d.b2AABB = function() {
    this.lowerBound = new box2d.b2Vec2;
    this.upperBound = new box2d.b2Vec2;
    this.m_out_center = new box2d.b2Vec2;
    this.m_out_extent = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2AABB", box2d.b2AABB);
box2d.b2AABB.prototype.lowerBound = null;
goog.exportProperty(box2d.b2AABB.prototype, "lowerBound", box2d.b2AABB.prototype.lowerBound);
box2d.b2AABB.prototype.upperBound = null;
goog.exportProperty(box2d.b2AABB.prototype, "upperBound", box2d.b2AABB.prototype.upperBound);
box2d.b2AABB.prototype.m_out_center = null;
goog.exportProperty(box2d.b2AABB.prototype, "m_out_center", box2d.b2AABB.prototype.m_out_center);
box2d.b2AABB.prototype.m_out_extent = null;
goog.exportProperty(box2d.b2AABB.prototype, "m_out_extent", box2d.b2AABB.prototype.m_out_extent);
box2d.b2AABB.prototype.Copy = function(a) {
    this.lowerBound.Copy(a.lowerBound);
    this.upperBound.Copy(a.upperBound);
    return this
};
goog.exportProperty(box2d.b2AABB.prototype, "Copy", box2d.b2AABB.prototype.Copy);
box2d.b2AABB.prototype.IsValid = function() {
    var a = this.upperBound.y - this.lowerBound.y;
    return a = (a = 0 <= this.upperBound.x - this.lowerBound.x && 0 <= a) && this.lowerBound.IsValid() && this.upperBound.IsValid()
};
goog.exportProperty(box2d.b2AABB.prototype, "IsValid", box2d.b2AABB.prototype.IsValid);
box2d.b2AABB.prototype.GetCenter = function() {
    return box2d.b2MidVV(this.lowerBound, this.upperBound, this.m_out_center)
};
goog.exportProperty(box2d.b2AABB.prototype, "GetCenter", box2d.b2AABB.prototype.GetCenter);
box2d.b2AABB.prototype.GetExtents = function() {
    return box2d.b2ExtVV(this.lowerBound, this.upperBound, this.m_out_extent)
};
goog.exportProperty(box2d.b2AABB.prototype, "GetExtents", box2d.b2AABB.prototype.GetExtents);
box2d.b2AABB.prototype.GetPerimeter = function() {
    return 2 * (this.upperBound.x - this.lowerBound.x + (this.upperBound.y - this.lowerBound.y))
};
goog.exportProperty(box2d.b2AABB.prototype, "GetPerimeter", box2d.b2AABB.prototype.GetPerimeter);
box2d.b2AABB.prototype.Combine1 = function(a) {
    this.lowerBound.x = box2d.b2Min(this.lowerBound.x, a.lowerBound.x);
    this.lowerBound.y = box2d.b2Min(this.lowerBound.y, a.lowerBound.y);
    this.upperBound.x = box2d.b2Max(this.upperBound.x, a.upperBound.x);
    this.upperBound.y = box2d.b2Max(this.upperBound.y, a.upperBound.y);
    return this
};
goog.exportProperty(box2d.b2AABB.prototype, "Combine1", box2d.b2AABB.prototype.Combine1);
box2d.b2AABB.prototype.Combine2 = function(a, b) {
    this.lowerBound.x = box2d.b2Min(a.lowerBound.x, b.lowerBound.x);
    this.lowerBound.y = box2d.b2Min(a.lowerBound.y, b.lowerBound.y);
    this.upperBound.x = box2d.b2Max(a.upperBound.x, b.upperBound.x);
    this.upperBound.y = box2d.b2Max(a.upperBound.y, b.upperBound.y);
    return this
};
goog.exportProperty(box2d.b2AABB.prototype, "Combine2", box2d.b2AABB.prototype.Combine2);
box2d.b2AABB.Combine = function(a, b, c) {
    c.Combine2(a, b);
    return c
};
goog.exportProperty(box2d.b2AABB, "Combine", box2d.b2AABB.Combine);
box2d.b2AABB.prototype.Contains = function(a) {
    var b;
    return b = (b = (b = (b = this.lowerBound.x <= a.lowerBound.x) && this.lowerBound.y <= a.lowerBound.y) && a.upperBound.x <= this.upperBound.x) && a.upperBound.y <= this.upperBound.y
};
goog.exportProperty(box2d.b2AABB.prototype, "Contains", box2d.b2AABB.prototype.Contains);
box2d.b2AABB.prototype.RayCast = function(a, b) {
    var c = -box2d.b2_maxFloat, e = box2d.b2_maxFloat, d = b.p1.x, f = b.p1.y, g = b.p2.x - b.p1.x, h = b.p2.y - b.p1.y, l = box2d.b2Abs(g), k = box2d.b2Abs(h), m = a.normal;
    if (l < box2d.b2_epsilon) {
        if (d < this.lowerBound.x || this.upperBound.x < d)
            return!1
    } else if (l = 1 / g, g = (this.lowerBound.x - d) * l, d = (this.upperBound.x - d) * l, l = -1, g > d && (l = g, g = d, d = l, l = 1), g > c && (m.x = l, m.y = 0, c = g), e = box2d.b2Min(e, d), c > e)
        return!1;
    if (k < box2d.b2_epsilon) {
        if (f < this.lowerBound.y || this.upperBound.y < f)
            return!1
    } else if (l = 1 / h, g =
            (this.lowerBound.y - f) * l, d = (this.upperBound.y - f) * l, l = -1, g > d && (l = g, g = d, d = l, l = 1), g > c && (m.x = 0, m.y = l, c = g), e = box2d.b2Min(e, d), c > e)
        return!1;
    if (0 > c || b.maxFraction < c)
        return!1;
    a.fraction = c;
    return!0
};
goog.exportProperty(box2d.b2AABB.prototype, "RayCast", box2d.b2AABB.prototype.RayCast);
box2d.b2AABB.prototype.TestOverlap = function(a) {
    var b = a.lowerBound.y - this.upperBound.y, c = this.lowerBound.y - a.upperBound.y;
    return 0 < a.lowerBound.x - this.upperBound.x || 0 < b || 0 < this.lowerBound.x - a.upperBound.x || 0 < c ? !1 : !0
};
goog.exportProperty(box2d.b2AABB.prototype, "TestOverlap", box2d.b2AABB.prototype.TestOverlap);
box2d.b2TestOverlapAABB = function(a, b) {
    var c = b.lowerBound.y - a.upperBound.y, e = a.lowerBound.y - b.upperBound.y;
    return 0 < b.lowerBound.x - a.upperBound.x || 0 < c || 0 < a.lowerBound.x - b.upperBound.x || 0 < e ? !1 : !0
};
goog.exportSymbol("box2d.b2TestOverlapAABB", box2d.b2TestOverlapAABB);
box2d.b2ClipSegmentToLine = function(a, b, c, e, d) {
    var f = 0, g = b[0];
    b = b[1];
    var h = box2d.b2DotVV(c, g.v) - e;
    c = box2d.b2DotVV(c, b.v) - e;
    0 >= h && a[f++].Copy(g);
    0 >= c && a[f++].Copy(b);
    0 > h * c && (c = h / (h - c), e = a[f].v, e.x = g.v.x + c * (b.v.x - g.v.x), e.y = g.v.y + c * (b.v.y - g.v.y), a = a[f].id, a.cf.indexA = d, a.cf.indexB = g.id.cf.indexB, a.cf.typeA = box2d.b2ContactFeatureType.e_vertex, a.cf.typeB = box2d.b2ContactFeatureType.e_face, ++f);
    return f
};
goog.exportSymbol("box2d.b2ClipSegmentToLine", box2d.b2ClipSegmentToLine);
box2d.b2TestOverlapShape = function(a, b, c, e, d, f) {
    var g = box2d.b2TestOverlapShape.s_input.Reset();
    g.proxyA.SetShape(a, b);
    g.proxyB.SetShape(c, e);
    g.transformA.Copy(d);
    g.transformB.Copy(f);
    g.useRadii = !0;
    a = box2d.b2TestOverlapShape.s_simplexCache.Reset();
    a.count = 0;
    b = box2d.b2TestOverlapShape.s_output.Reset();
    box2d.b2Distance(b, a, g);
    return b.distance < 10 * box2d.b2_epsilon
};
goog.exportSymbol("box2d.b2TestOverlapShape", box2d.b2TestOverlapShape);
box2d.b2TestOverlapShape.s_input = new box2d.b2DistanceInput;
box2d.b2TestOverlapShape.s_simplexCache = new box2d.b2SimplexCache;
box2d.b2TestOverlapShape.s_output = new box2d.b2DistanceOutput;
box2d.b2Timer = function() {
    this.m_start = (new Date).getTime()
};
goog.exportSymbol("box2d.b2Timer", box2d.b2Timer);
box2d.b2Timer.prototype.m_start = 0;
goog.exportProperty(box2d.b2Timer.prototype, "m_start", box2d.b2Timer.prototype.m_start);
box2d.b2Timer.prototype.Reset = function() {
    this.m_start = (new Date).getTime();
    return this
};
goog.exportProperty(box2d.b2Timer.prototype, "Reset", box2d.b2Timer.prototype.Reset);
box2d.b2Timer.prototype.GetMilliseconds = function() {
    return(new Date).getTime() - this.m_start
};
goog.exportProperty(box2d.b2Timer.prototype, "GetMilliseconds", box2d.b2Timer.prototype.GetMilliseconds);
box2d.b2Counter = function() {
};
goog.exportSymbol("box2d.b2Counter", box2d.b2Counter);
box2d.b2Counter.prototype.m_count = 0;
goog.exportProperty(box2d.b2Counter.prototype, "m_count", box2d.b2Counter.prototype.m_count);
box2d.b2Counter.prototype.m_min_count = 0;
goog.exportProperty(box2d.b2Counter.prototype, "m_min_count", box2d.b2Counter.prototype.m_min_count);
box2d.b2Counter.prototype.m_max_count = 0;
goog.exportProperty(box2d.b2Counter.prototype, "m_max_count", box2d.b2Counter.prototype.m_max_count);
box2d.b2Counter.prototype.GetCount = function() {
    return this.m_count
};
goog.exportProperty(box2d.b2Counter.prototype, "GetCount", box2d.b2Counter.prototype.GetCount);
box2d.b2Counter.prototype.GetMinCount = function() {
    return this.m_min_count
};
goog.exportProperty(box2d.b2Counter.prototype, "GetMinCount", box2d.b2Counter.prototype.GetMinCount);
box2d.b2Counter.prototype.GetMaxCount = function() {
    return this.m_max_count
};
goog.exportProperty(box2d.b2Counter.prototype, "GetMaxCount", box2d.b2Counter.prototype.GetMaxCount);
box2d.b2Counter.prototype.ResetCount = function() {
    var a = this.m_count;
    this.m_count = 0;
    return a
};
goog.exportProperty(box2d.b2Counter.prototype, "ResetCount", box2d.b2Counter.prototype.ResetCount);
box2d.b2Counter.prototype.ResetMinCount = function() {
    this.m_min_count = 0
};
goog.exportProperty(box2d.b2Counter.prototype, "ResetMinCount", box2d.b2Counter.prototype.ResetMinCount);
box2d.b2Counter.prototype.ResetMaxCount = function() {
    this.m_max_count = 0
};
goog.exportProperty(box2d.b2Counter.prototype, "ResetMaxCount", box2d.b2Counter.prototype.ResetMaxCount);
box2d.b2Counter.prototype.Increment = function() {
    this.m_count++;
    this.m_max_count < this.m_count && (this.m_max_count = this.m_count)
};
goog.exportProperty(box2d.b2Counter.prototype, "Increment", box2d.b2Counter.prototype.Increment);
box2d.b2Counter.prototype.Decrement = function() {
    this.m_count--;
    this.m_min_count > this.m_count && (this.m_min_count = this.m_count)
};
goog.exportProperty(box2d.b2Counter.prototype, "Decrement", box2d.b2Counter.prototype.Decrement);
box2d.b2_toiTime = 0;
goog.exportSymbol("box2d.b2_toiTime", box2d.b2_toiTime);
box2d.b2_toiMaxTime = 0;
goog.exportSymbol("box2d.b2_toiMaxTime", box2d.b2_toiMaxTime);
box2d.b2_toiCalls = 0;
goog.exportSymbol("box2d.b2_toiCalls", box2d.b2_toiCalls);
box2d.b2_toiIters = 0;
goog.exportSymbol("box2d.b2_toiIters", box2d.b2_toiIters);
box2d.b2_toiMaxIters = 0;
goog.exportSymbol("box2d.b2_toiMaxIters", box2d.b2_toiMaxIters);
box2d.b2_toiRootIters = 0;
goog.exportSymbol("box2d.b2_toiRootIters", box2d.b2_toiRootIters);
box2d.b2_toiMaxRootIters = 0;
goog.exportSymbol("box2d.b2_toiMaxRootIters", box2d.b2_toiMaxRootIters);
box2d.b2TOIInput = function() {
    this.proxyA = new box2d.b2DistanceProxy;
    this.proxyB = new box2d.b2DistanceProxy;
    this.sweepA = new box2d.b2Sweep;
    this.sweepB = new box2d.b2Sweep
};
goog.exportSymbol("box2d.b2TOIInput", box2d.b2TOIInput);
box2d.b2TOIInput.prototype.proxyA = null;
goog.exportProperty(box2d.b2TOIInput.prototype, "proxyA", box2d.b2TOIInput.prototype.proxyA);
box2d.b2TOIInput.prototype.proxyB = null;
goog.exportProperty(box2d.b2TOIInput.prototype, "proxyB", box2d.b2TOIInput.prototype.proxyB);
box2d.b2TOIInput.prototype.sweepA = null;
goog.exportProperty(box2d.b2TOIInput.prototype, "sweepA", box2d.b2TOIInput.prototype.sweepA);
box2d.b2TOIInput.prototype.sweepB = null;
goog.exportProperty(box2d.b2TOIInput.prototype, "sweepB", box2d.b2TOIInput.prototype.sweepB);
box2d.b2TOIInput.prototype.tMax = 0;
goog.exportProperty(box2d.b2TOIInput.prototype, "tMax", box2d.b2TOIInput.prototype.tMax);
box2d.b2TOIOutputState = {e_unknown: 0, e_failed: 1, e_overlapped: 2, e_touching: 3, e_separated: 4};
goog.exportSymbol("box2d.b2TOIOutputState", box2d.b2TOIOutputState);
goog.exportProperty(box2d.b2TOIOutputState, "e_unknown", box2d.b2TOIOutputState.e_unknown);
goog.exportProperty(box2d.b2TOIOutputState, "e_failed", box2d.b2TOIOutputState.e_failed);
goog.exportProperty(box2d.b2TOIOutputState, "e_overlapped", box2d.b2TOIOutputState.e_overlapped);
goog.exportProperty(box2d.b2TOIOutputState, "e_touching", box2d.b2TOIOutputState.e_touching);
goog.exportProperty(box2d.b2TOIOutputState, "e_separated", box2d.b2TOIOutputState.e_separated);
box2d.b2TOIOutput = function() {
};
goog.exportSymbol("box2d.b2TOIOutput", box2d.b2TOIOutput);
box2d.b2TOIOutput.prototype.state = box2d.b2TOIOutputState.e_unknown;
goog.exportProperty(box2d.b2TOIOutput.prototype, "state", box2d.b2TOIOutput.prototype.state);
box2d.b2TOIOutput.prototype.t = 0;
goog.exportProperty(box2d.b2TOIOutput.prototype, "t", box2d.b2TOIOutput.prototype.t);
box2d.b2SeparationFunctionType = {e_unknown: -1, e_points: 0, e_faceA: 1, e_faceB: 2};
goog.exportSymbol("box2d.b2SeparationFunctionType", box2d.b2SeparationFunctionType);
goog.exportProperty(box2d.b2SeparationFunctionType, "e_unknown", box2d.b2SeparationFunctionType.e_unknown);
goog.exportProperty(box2d.b2SeparationFunctionType, "e_points", box2d.b2SeparationFunctionType.e_points);
goog.exportProperty(box2d.b2SeparationFunctionType, "e_faceA", box2d.b2SeparationFunctionType.e_faceA);
goog.exportProperty(box2d.b2SeparationFunctionType, "e_faceB", box2d.b2SeparationFunctionType.e_faceB);
box2d.b2SeparationFunction = function() {
    this.m_sweepA = new box2d.b2Sweep;
    this.m_sweepB = new box2d.b2Sweep;
    this.m_localPoint = new box2d.b2Vec2;
    this.m_axis = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2SeparationFunction", box2d.b2SeparationFunction);
box2d.b2SeparationFunction.prototype.m_proxyA = null;
goog.exportProperty(box2d.b2SeparationFunction.prototype, "m_proxyA", box2d.b2SeparationFunction.prototype.m_proxyA);
box2d.b2SeparationFunction.prototype.m_proxyB = null;
goog.exportProperty(box2d.b2SeparationFunction.prototype, "m_proxyB", box2d.b2SeparationFunction.prototype.m_proxyB);
box2d.b2SeparationFunction.prototype.m_sweepA = null;
goog.exportProperty(box2d.b2SeparationFunction.prototype, "m_sweepA", box2d.b2SeparationFunction.prototype.m_sweepA);
box2d.b2SeparationFunction.prototype.m_sweepB = null;
goog.exportProperty(box2d.b2SeparationFunction.prototype, "m_sweepB", box2d.b2SeparationFunction.prototype.m_sweepB);
box2d.b2SeparationFunction.prototype.m_type = box2d.b2SeparationFunctionType.e_unknown;
goog.exportProperty(box2d.b2SeparationFunction.prototype, "m_type", box2d.b2SeparationFunction.prototype.m_type);
box2d.b2SeparationFunction.prototype.m_localPoint = null;
goog.exportProperty(box2d.b2SeparationFunction.prototype, "m_localPoint", box2d.b2SeparationFunction.prototype.m_localPoint);
box2d.b2SeparationFunction.prototype.m_axis = null;
goog.exportProperty(box2d.b2SeparationFunction.prototype, "m_axis", box2d.b2SeparationFunction.prototype.m_axis);
box2d.b2SeparationFunction.prototype.Initialize = function(a, b, c, e, d, f) {
    this.m_proxyA = b;
    this.m_proxyB = e;
    b = a.count;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < b && 3 > b);
    this.m_sweepA.Copy(c);
    this.m_sweepB.Copy(d);
    c = box2d.b2TimeOfImpact.s_xfA;
    d = box2d.b2TimeOfImpact.s_xfB;
    this.m_sweepA.GetTransform(c, f);
    this.m_sweepB.GetTransform(d, f);
    1 == b ? (this.m_type = box2d.b2SeparationFunctionType.e_points, b = this.m_proxyA.GetVertex(a.indexA[0]), a = this.m_proxyB.GetVertex(a.indexB[0]), c = box2d.b2MulXV(c, b, box2d.b2TimeOfImpact.s_pointA),
            d = box2d.b2MulXV(d, a, box2d.b2TimeOfImpact.s_pointB), box2d.b2SubVV(d, c, this.m_axis), a = this.m_axis.Normalize()) : (a.indexA[0] == a.indexA[1] ? (this.m_type = box2d.b2SeparationFunctionType.e_faceB, b = this.m_proxyB.GetVertex(a.indexB[0]), e = this.m_proxyB.GetVertex(a.indexB[1]), box2d.b2CrossVOne(box2d.b2SubVV(e, b, box2d.b2Vec2.s_t0), this.m_axis).SelfNormalize(), f = box2d.b2MulRV(d.q, this.m_axis, box2d.b2TimeOfImpact.s_normal), box2d.b2MidVV(b, e, this.m_localPoint), d = box2d.b2MulXV(d, this.m_localPoint, box2d.b2TimeOfImpact.s_pointB),
            b = this.m_proxyA.GetVertex(a.indexA[0]), c = box2d.b2MulXV(c, b, box2d.b2TimeOfImpact.s_pointA), a = box2d.b2DotVV(box2d.b2SubVV(c, d, box2d.b2Vec2.s_t0), f)) : (this.m_type = box2d.b2SeparationFunctionType.e_faceA, b = this.m_proxyA.GetVertex(a.indexA[0]), e = this.m_proxyA.GetVertex(a.indexA[1]), box2d.b2CrossVOne(box2d.b2SubVV(e, b, box2d.b2Vec2.s_t0), this.m_axis).SelfNormalize(), f = box2d.b2MulRV(c.q, this.m_axis, box2d.b2TimeOfImpact.s_normal), box2d.b2MidVV(b, e, this.m_localPoint), c = box2d.b2MulXV(c, this.m_localPoint, box2d.b2TimeOfImpact.s_pointA),
            a = this.m_proxyB.GetVertex(a.indexB[0]), d = box2d.b2MulXV(d, a, box2d.b2TimeOfImpact.s_pointB), a = box2d.b2DotVV(box2d.b2SubVV(d, c, box2d.b2Vec2.s_t0), f)), 0 > a && (this.m_axis.SelfNeg(), a = -a));
    return a
};
goog.exportProperty(box2d.b2SeparationFunction.prototype, "Initialize", box2d.b2SeparationFunction.prototype.Initialize);
box2d.b2SeparationFunction.prototype.FindMinSeparation = function(a, b, c) {
    var e = box2d.b2TimeOfImpact.s_xfA, d = box2d.b2TimeOfImpact.s_xfB;
    this.m_sweepA.GetTransform(e, c);
    this.m_sweepB.GetTransform(d, c);
    switch (this.m_type) {
        case box2d.b2SeparationFunctionType.e_points:
            var f = box2d.b2MulTRV(e.q, this.m_axis, box2d.b2TimeOfImpact.s_axisA), g = box2d.b2MulTRV(d.q, box2d.b2NegV(this.m_axis, box2d.b2Vec2.s_t0), box2d.b2TimeOfImpact.s_axisB);
            a[0] = this.m_proxyA.GetSupport(f);
            b[0] = this.m_proxyB.GetSupport(g);
            a = this.m_proxyA.GetVertex(a[0]);
            b = this.m_proxyB.GetVertex(b[0]);
            e = box2d.b2MulXV(e, a, box2d.b2TimeOfImpact.s_pointA);
            d = box2d.b2MulXV(d, b, box2d.b2TimeOfImpact.s_pointB);
            return b = box2d.b2DotVV(box2d.b2SubVV(d, e, box2d.b2Vec2.s_t0), this.m_axis);
        case box2d.b2SeparationFunctionType.e_faceA:
            return c = box2d.b2MulRV(e.q, this.m_axis, box2d.b2TimeOfImpact.s_normal), e = box2d.b2MulXV(e, this.m_localPoint, box2d.b2TimeOfImpact.s_pointA), g = box2d.b2MulTRV(d.q, box2d.b2NegV(c, box2d.b2Vec2.s_t0), box2d.b2TimeOfImpact.s_axisB), a[0] = -1, b[0] = this.m_proxyB.GetSupport(g),
                    b = this.m_proxyB.GetVertex(b[0]), d = box2d.b2MulXV(d, b, box2d.b2TimeOfImpact.s_pointB), b = box2d.b2DotVV(box2d.b2SubVV(d, e, box2d.b2Vec2.s_t0), c);
        case box2d.b2SeparationFunctionType.e_faceB:
            return c = box2d.b2MulRV(d.q, this.m_axis, box2d.b2TimeOfImpact.s_normal), d = box2d.b2MulXV(d, this.m_localPoint, box2d.b2TimeOfImpact.s_pointB), f = box2d.b2MulTRV(e.q, box2d.b2NegV(c, box2d.b2Vec2.s_t0), box2d.b2TimeOfImpact.s_axisA), b[0] = -1, a[0] = this.m_proxyA.GetSupport(f), a = this.m_proxyA.GetVertex(a[0]), e = box2d.b2MulXV(e, a, box2d.b2TimeOfImpact.s_pointA),
                    b = box2d.b2DotVV(box2d.b2SubVV(e, d, box2d.b2Vec2.s_t0), c);
        default:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), a[0] = -1, b[0] = -1, 0
        }
};
goog.exportProperty(box2d.b2SeparationFunction.prototype, "FindMinSeparation", box2d.b2SeparationFunction.prototype.FindMinSeparation);
box2d.b2SeparationFunction.prototype.Evaluate = function(a, b, c) {
    var e = box2d.b2TimeOfImpact.s_xfA, d = box2d.b2TimeOfImpact.s_xfB;
    this.m_sweepA.GetTransform(e, c);
    this.m_sweepB.GetTransform(d, c);
    switch (this.m_type) {
        case box2d.b2SeparationFunctionType.e_points:
            return a = this.m_proxyA.GetVertex(a), b = this.m_proxyB.GetVertex(b), e = box2d.b2MulXV(e, a, box2d.b2TimeOfImpact.s_pointA), d = box2d.b2MulXV(d, b, box2d.b2TimeOfImpact.s_pointB), e = box2d.b2DotVV(box2d.b2SubVV(d, e, box2d.b2Vec2.s_t0), this.m_axis);
        case box2d.b2SeparationFunctionType.e_faceA:
            return c =
                    box2d.b2MulRV(e.q, this.m_axis, box2d.b2TimeOfImpact.s_normal), e = box2d.b2MulXV(e, this.m_localPoint, box2d.b2TimeOfImpact.s_pointA), b = this.m_proxyB.GetVertex(b), d = box2d.b2MulXV(d, b, box2d.b2TimeOfImpact.s_pointB), e = box2d.b2DotVV(box2d.b2SubVV(d, e, box2d.b2Vec2.s_t0), c);
        case box2d.b2SeparationFunctionType.e_faceB:
            return c = box2d.b2MulRV(d.q, this.m_axis, box2d.b2TimeOfImpact.s_normal), d = box2d.b2MulXV(d, this.m_localPoint, box2d.b2TimeOfImpact.s_pointB), a = this.m_proxyA.GetVertex(a), e = box2d.b2MulXV(e, a, box2d.b2TimeOfImpact.s_pointA),
                    e = box2d.b2DotVV(box2d.b2SubVV(e, d, box2d.b2Vec2.s_t0), c);
        default:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), 0
        }
};
goog.exportProperty(box2d.b2SeparationFunction.prototype, "Evaluate", box2d.b2SeparationFunction.prototype.Evaluate);
box2d.b2TimeOfImpact = function(a, b) {
    var c = box2d.b2TimeOfImpact.s_timer.Reset();
    ++box2d.b2_toiCalls;
    a.state = box2d.b2TOIOutputState.e_unknown;
    a.t = b.tMax;
    var e = b.proxyA, d = b.proxyB, f = box2d.b2TimeOfImpact.s_sweepA.Copy(b.sweepA), g = box2d.b2TimeOfImpact.s_sweepB.Copy(b.sweepB);
    f.Normalize();
    g.Normalize();
    var h = b.tMax, l = box2d.b2Max(box2d.b2_linearSlop, e.m_radius + d.m_radius - 3 * box2d.b2_linearSlop), k = 0.25 * box2d.b2_linearSlop;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(l > k);
    var m = 0, n = 0, p = box2d.b2TimeOfImpact.s_cache;
    p.count = 0;
    var q = box2d.b2TimeOfImpact.s_distanceInput;
    q.proxyA = b.proxyA;
    q.proxyB = b.proxyB;
    for (q.useRadii = !1; ; ) {
        var r = box2d.b2TimeOfImpact.s_xfA, t = box2d.b2TimeOfImpact.s_xfB;
        f.GetTransform(r, m);
        g.GetTransform(t, m);
        q.transformA.Copy(r);
        q.transformB.Copy(t);
        r = box2d.b2TimeOfImpact.s_distanceOutput;
        box2d.b2Distance(r, p, q);
        if (0 >= r.distance) {
            a.state = box2d.b2TOIOutputState.e_overlapped;
            a.t = 0;
            break
        }
        if (r.distance < l + k) {
            a.state = box2d.b2TOIOutputState.e_touching;
            a.t = m;
            break
        }
        r = box2d.b2TimeOfImpact.s_fcn;
        r.Initialize(p,
                e, f, d, g, m);
        for (var t = !1, s = h, u = 0; ; ) {
            var v = box2d.b2TimeOfImpact.s_indexA, y = box2d.b2TimeOfImpact.s_indexB, D = r.FindMinSeparation(v, y, s);
            if (D > l + k) {
                a.state = box2d.b2TOIOutputState.e_separated;
                a.t = h;
                t = !0;
                break
            }
            if (D > l - k) {
                m = s;
                break
            }
            var x = r.Evaluate(v[0], y[0], m);
            if (x < l - k) {
                a.state = box2d.b2TOIOutputState.e_failed;
                a.t = m;
                t = !0;
                break
            }
            if (x <= l + k) {
                a.state = box2d.b2TOIOutputState.e_touching;
                a.t = m;
                t = !0;
                break
            }
            for (var w = 0, C = m, A = s; ; ) {
                var E = 0, E = w & 1 ? C + (l - x) * (A - C) / (D - x) : 0.5 * (C + A);
                ++w;
                ++box2d.b2_toiRootIters;
                var B = r.Evaluate(v[0],
                        y[0], E);
                if (box2d.b2Abs(B - l) < k) {
                    s = E;
                    break
                }
                B > l ? (C = E, x = B) : (A = E, D = B);
                if (50 == w)
                    break
            }
            box2d.b2_toiMaxRootIters = box2d.b2Max(box2d.b2_toiMaxRootIters, w);
            ++u;
            if (u == box2d.b2_maxPolygonVertices)
                break
        }
        ++n;
        ++box2d.b2_toiIters;
        if (t)
            break;
        if (20 == n) {
            a.state = box2d.b2TOIOutputState.e_failed;
            a.t = m;
            break
        }
    }
    box2d.b2_toiMaxIters = box2d.b2Max(box2d.b2_toiMaxIters, n);
    c = c.GetMilliseconds();
    box2d.b2_toiMaxTime = box2d.b2Max(box2d.b2_toiMaxTime, c);
    box2d.b2_toiTime += c
};
goog.exportSymbol("box2d.b2TimeOfImpact", box2d.b2TimeOfImpact);
box2d.b2TimeOfImpact.s_timer = new box2d.b2Timer;
box2d.b2TimeOfImpact.s_cache = new box2d.b2SimplexCache;
box2d.b2TimeOfImpact.s_distanceInput = new box2d.b2DistanceInput;
box2d.b2TimeOfImpact.s_distanceOutput = new box2d.b2DistanceOutput;
box2d.b2TimeOfImpact.s_xfA = new box2d.b2Transform;
box2d.b2TimeOfImpact.s_xfB = new box2d.b2Transform;
box2d.b2TimeOfImpact.s_indexA = box2d.b2MakeNumberArray(1);
box2d.b2TimeOfImpact.s_indexB = box2d.b2MakeNumberArray(1);
box2d.b2TimeOfImpact.s_fcn = new box2d.b2SeparationFunction;
box2d.b2TimeOfImpact.s_sweepA = new box2d.b2Sweep;
box2d.b2TimeOfImpact.s_sweepB = new box2d.b2Sweep;
box2d.b2TimeOfImpact.s_pointA = new box2d.b2Vec2;
box2d.b2TimeOfImpact.s_pointB = new box2d.b2Vec2;
box2d.b2TimeOfImpact.s_normal = new box2d.b2Vec2;
box2d.b2TimeOfImpact.s_axisA = new box2d.b2Vec2;
box2d.b2TimeOfImpact.s_axisB = new box2d.b2Vec2;
box2d.b2MixFriction = function(a, b) {
    return box2d.b2Sqrt(a * b)
};
goog.exportSymbol("box2d.b2MixFriction", box2d.b2MixFriction);
box2d.b2MixRestitution = function(a, b) {
    return a > b ? a : b
};
goog.exportSymbol("box2d.b2MixRestitution", box2d.b2MixRestitution);
box2d.b2ContactEdge = function() {
};
goog.exportSymbol("box2d.b2ContactEdge", box2d.b2ContactEdge);
box2d.b2ContactEdge.prototype.other = null;
goog.exportProperty(box2d.b2ContactEdge.prototype, "other", box2d.b2ContactEdge.prototype.other);
box2d.b2ContactEdge.prototype.contact = null;
goog.exportProperty(box2d.b2ContactEdge.prototype, "contact", box2d.b2ContactEdge.prototype.contact);
box2d.b2ContactEdge.prototype.prev = null;
goog.exportProperty(box2d.b2ContactEdge.prototype, "prev", box2d.b2ContactEdge.prototype.prev);
box2d.b2ContactEdge.prototype.next = null;
goog.exportProperty(box2d.b2ContactEdge.prototype, "next", box2d.b2ContactEdge.prototype.next);
box2d.b2ContactFlag = {e_none: 0, e_islandFlag: 1, e_touchingFlag: 2, e_enabledFlag: 4, e_filterFlag: 8, e_bulletHitFlag: 16, e_toiFlag: 32};
goog.exportProperty(box2d.b2ContactFlag, "e_none", box2d.b2ContactFlag.e_none);
goog.exportProperty(box2d.b2ContactFlag, "e_islandFlag", box2d.b2ContactFlag.e_islandFlag);
goog.exportProperty(box2d.b2ContactFlag, "e_touchingFlag", box2d.b2ContactFlag.e_touchingFlag);
goog.exportProperty(box2d.b2ContactFlag, "e_enabledFlag", box2d.b2ContactFlag.e_enabledFlag);
goog.exportProperty(box2d.b2ContactFlag, "e_filterFlag", box2d.b2ContactFlag.e_filterFlag);
goog.exportProperty(box2d.b2ContactFlag, "e_bulletHitFlag", box2d.b2ContactFlag.e_bulletHitFlag);
goog.exportProperty(box2d.b2ContactFlag, "e_toiFlag", box2d.b2ContactFlag.e_toiFlag);
box2d.b2Contact = function() {
    this.m_nodeA = new box2d.b2ContactEdge;
    this.m_nodeB = new box2d.b2ContactEdge;
    this.m_manifold = new box2d.b2Manifold;
    this.m_oldManifold = new box2d.b2Manifold
};
goog.exportSymbol("box2d.b2Contact", box2d.b2Contact);
box2d.b2Contact.prototype.m_flags = box2d.b2ContactFlag.e_none;
goog.exportProperty(box2d.b2Contact.prototype, "m_flags", box2d.b2Contact.prototype.m_flags);
box2d.b2Contact.prototype.m_prev = null;
goog.exportProperty(box2d.b2Contact.prototype, "m_prev", box2d.b2Contact.prototype.m_prev);
box2d.b2Contact.prototype.m_next = null;
goog.exportProperty(box2d.b2Contact.prototype, "m_next", box2d.b2Contact.prototype.m_next);
box2d.b2Contact.prototype.m_nodeA = null;
goog.exportProperty(box2d.b2Contact.prototype, "m_nodeA", box2d.b2Contact.prototype.m_nodeA);
box2d.b2Contact.prototype.m_nodeB = null;
goog.exportProperty(box2d.b2Contact.prototype, "m_nodeB", box2d.b2Contact.prototype.m_nodeB);
box2d.b2Contact.prototype.m_fixtureA = null;
goog.exportProperty(box2d.b2Contact.prototype, "m_fixtureA", box2d.b2Contact.prototype.m_fixtureA);
box2d.b2Contact.prototype.m_fixtureB = null;
goog.exportProperty(box2d.b2Contact.prototype, "m_fixtureB", box2d.b2Contact.prototype.m_fixtureB);
box2d.b2Contact.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2Contact.prototype, "m_indexA", box2d.b2Contact.prototype.m_indexA);
box2d.b2Contact.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2Contact.prototype, "m_indexB", box2d.b2Contact.prototype.m_indexB);
box2d.b2Contact.prototype.m_manifold = null;
goog.exportProperty(box2d.b2Contact.prototype, "m_manifold", box2d.b2Contact.prototype.m_manifold);
box2d.b2Contact.prototype.m_toiCount = 0;
goog.exportProperty(box2d.b2Contact.prototype, "m_toiCount", box2d.b2Contact.prototype.m_toiCount);
box2d.b2Contact.prototype.m_toi = 0;
goog.exportProperty(box2d.b2Contact.prototype, "m_toi", box2d.b2Contact.prototype.m_toi);
box2d.b2Contact.prototype.m_friction = 0;
goog.exportProperty(box2d.b2Contact.prototype, "m_friction", box2d.b2Contact.prototype.m_friction);
box2d.b2Contact.prototype.m_restitution = 0;
goog.exportProperty(box2d.b2Contact.prototype, "m_restitution", box2d.b2Contact.prototype.m_restitution);
box2d.b2Contact.prototype.m_tangentSpeed = 0;
goog.exportProperty(box2d.b2Contact.prototype, "m_tangentSpeed", box2d.b2Contact.prototype.m_tangentSpeed);
box2d.b2Contact.prototype.m_oldManifold = null;
goog.exportProperty(box2d.b2Contact.prototype, "m_oldManifold", box2d.b2Contact.prototype.m_oldManifold);
box2d.b2Contact.prototype.GetManifold = function() {
    return this.m_manifold
};
goog.exportProperty(box2d.b2Contact.prototype, "GetManifold", box2d.b2Contact.prototype.GetManifold);
box2d.b2Contact.prototype.GetWorldManifold = function(a) {
    var b = this.m_fixtureA.GetBody(), c = this.m_fixtureB.GetBody(), e = this.m_fixtureA.GetShape(), d = this.m_fixtureB.GetShape();
    a.Initialize(this.m_manifold, b.GetTransform(), e.m_radius, c.GetTransform(), d.m_radius)
};
goog.exportProperty(box2d.b2Contact.prototype, "GetWorldManifold", box2d.b2Contact.prototype.GetWorldManifold);
box2d.b2Contact.prototype.IsTouching = function() {
    return(this.m_flags & box2d.b2ContactFlag.e_touchingFlag) == box2d.b2ContactFlag.e_touchingFlag
};
goog.exportProperty(box2d.b2Contact.prototype, "IsTouching", box2d.b2Contact.prototype.IsTouching);
box2d.b2Contact.prototype.SetEnabled = function(a) {
    this.m_flags = a ? this.m_flags | box2d.b2ContactFlag.e_enabledFlag : this.m_flags & ~box2d.b2ContactFlag.e_enabledFlag
};
goog.exportProperty(box2d.b2Contact.prototype, "SetEnabled", box2d.b2Contact.prototype.SetEnabled);
box2d.b2Contact.prototype.IsEnabled = function() {
    return(this.m_flags & box2d.b2ContactFlag.e_enabledFlag) == box2d.b2ContactFlag.e_enabledFlag
};
goog.exportProperty(box2d.b2Contact.prototype, "IsEnabled", box2d.b2Contact.prototype.IsEnabled);
box2d.b2Contact.prototype.GetNext = function() {
    return this.m_next
};
goog.exportProperty(box2d.b2Contact.prototype, "GetNext", box2d.b2Contact.prototype.GetNext);
box2d.b2Contact.prototype.GetFixtureA = function() {
    return this.m_fixtureA
};
goog.exportProperty(box2d.b2Contact.prototype, "GetFixtureA", box2d.b2Contact.prototype.GetFixtureA);
box2d.b2Contact.prototype.GetChildIndexA = function() {
    return this.m_indexA
};
goog.exportProperty(box2d.b2Contact.prototype, "GetChildIndexA", box2d.b2Contact.prototype.GetChildIndexA);
box2d.b2Contact.prototype.GetFixtureB = function() {
    return this.m_fixtureB
};
goog.exportProperty(box2d.b2Contact.prototype, "GetFixtureB", box2d.b2Contact.prototype.GetFixtureB);
box2d.b2Contact.prototype.GetChildIndexB = function() {
    return this.m_indexB
};
goog.exportProperty(box2d.b2Contact.prototype, "GetChildIndexB", box2d.b2Contact.prototype.GetChildIndexB);
box2d.b2Contact.prototype.Evaluate = function(a, b, c) {
};
goog.exportProperty(box2d.b2Contact.prototype, "Evaluate", box2d.b2Contact.prototype.Evaluate);
box2d.b2Contact.prototype.FlagForFiltering = function() {
    this.m_flags |= box2d.b2ContactFlag.e_filterFlag
};
goog.exportProperty(box2d.b2Contact.prototype, "FlagForFiltering", box2d.b2Contact.prototype.FlagForFiltering);
box2d.b2Contact.prototype.SetFriction = function(a) {
    this.m_friction = a
};
goog.exportProperty(box2d.b2Contact.prototype, "SetFriction", box2d.b2Contact.prototype.SetFriction);
box2d.b2Contact.prototype.GetFriction = function() {
    return this.m_friction
};
goog.exportProperty(box2d.b2Contact.prototype, "GetFriction", box2d.b2Contact.prototype.GetFriction);
box2d.b2Contact.prototype.ResetFriction = function() {
    this.m_friction = box2d.b2MixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction)
};
goog.exportProperty(box2d.b2Contact.prototype, "ResetFriction", box2d.b2Contact.prototype.ResetFriction);
box2d.b2Contact.prototype.SetRestitution = function(a) {
    this.m_restitution = a
};
goog.exportProperty(box2d.b2Contact.prototype, "SetRestitution", box2d.b2Contact.prototype.SetRestitution);
box2d.b2Contact.prototype.GetRestitution = function() {
    return this.m_restitution
};
goog.exportProperty(box2d.b2Contact.prototype, "GetRestitution", box2d.b2Contact.prototype.GetRestitution);
box2d.b2Contact.prototype.ResetRestitution = function() {
    this.m_restitution = box2d.b2MixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution)
};
goog.exportProperty(box2d.b2Contact.prototype, "ResetRestitution", box2d.b2Contact.prototype.ResetRestitution);
box2d.b2Contact.prototype.SetTangentSpeed = function(a) {
    this.m_tangentSpeed = a
};
goog.exportProperty(box2d.b2Contact.prototype, "SetTangentSpeed", box2d.b2Contact.prototype.SetTangentSpeed);
box2d.b2Contact.prototype.GetTangentSpeed = function() {
    return this.m_tangentSpeed
};
goog.exportProperty(box2d.b2Contact.prototype, "GetTangentSpeed", box2d.b2Contact.prototype.GetTangentSpeed);
box2d.b2Contact.prototype.Reset = function(a, b, c, e) {
    this.m_flags = box2d.b2ContactFlag.e_enabledFlag;
    this.m_fixtureA = a;
    this.m_fixtureB = c;
    this.m_indexA = b;
    this.m_indexB = e;
    this.m_manifold.pointCount = 0;
    this.m_next = this.m_prev = null;
    this.m_nodeA.contact = null;
    this.m_nodeA.prev = null;
    this.m_nodeA.next = null;
    this.m_nodeA.other = null;
    this.m_nodeB.contact = null;
    this.m_nodeB.prev = null;
    this.m_nodeB.next = null;
    this.m_nodeB.other = null;
    this.m_toiCount = 0;
    this.m_friction = box2d.b2MixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);
    this.m_restitution = box2d.b2MixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution)
};
goog.exportProperty(box2d.b2Contact.prototype, "Reset", box2d.b2Contact.prototype.Reset);
box2d.b2Contact.prototype.Update = function(a) {
    var b = this.m_oldManifold;
    this.m_oldManifold = this.m_manifold;
    this.m_manifold = b;
    this.m_flags |= box2d.b2ContactFlag.e_enabledFlag;
    var c = !1, b = (this.m_flags & box2d.b2ContactFlag.e_touchingFlag) == box2d.b2ContactFlag.e_touchingFlag, e = this.m_fixtureA.IsSensor(), d = this.m_fixtureB.IsSensor(), e = e || d, d = this.m_fixtureA.GetBody(), f = this.m_fixtureB.GetBody(), c = d.GetTransform(), g = f.GetTransform();
    if (e)
        d = this.m_fixtureA.GetShape(), f = this.m_fixtureB.GetShape(), c = box2d.b2TestOverlapShape(d,
                this.m_indexA, f, this.m_indexB, c, g), this.m_manifold.pointCount = 0;
    else {
        this.Evaluate(this.m_manifold, c, g);
        c = 0 < this.m_manifold.pointCount;
        for (g = 0; g < this.m_manifold.pointCount; ++g) {
            var h = this.m_manifold.points[g];
            h.normalImpulse = 0;
            h.tangentImpulse = 0;
            for (var l = h.id, k = 0; k < this.m_oldManifold.pointCount; ++k) {
                var m = this.m_oldManifold.points[k];
                if (m.id.key == l.key) {
                    h.normalImpulse = m.normalImpulse;
                    h.tangentImpulse = m.tangentImpulse;
                    break
                }
            }
        }
        c != b && (d.SetAwake(!0), f.SetAwake(!0))
    }
    this.m_flags = c ? this.m_flags | box2d.b2ContactFlag.e_touchingFlag :
            this.m_flags & ~box2d.b2ContactFlag.e_touchingFlag;
    !1 == b && (!0 == c && a) && a.BeginContact(this);
    !0 == b && (!1 == c && a) && a.EndContact(this);
    !1 == e && (c && a) && a.PreSolve(this, this.m_oldManifold)
};
goog.exportProperty(box2d.b2Contact.prototype, "Update", box2d.b2Contact.prototype.Update);
box2d.b2Contact.prototype.ComputeTOI = function(a, b) {
    var c = box2d.b2Contact.prototype.ComputeTOI.s_input;
    c.proxyA.SetShape(this.m_fixtureA.GetShape(), this.m_indexA);
    c.proxyB.SetShape(this.m_fixtureB.GetShape(), this.m_indexB);
    c.sweepA.Copy(a);
    c.sweepB.Copy(b);
    c.tMax = box2d.b2_linearSlop;
    var e = box2d.b2Contact.prototype.ComputeTOI.s_output;
    box2d.b2TimeOfImpact(e, c);
    return e.t
};
goog.exportProperty(box2d.b2Contact.prototype, "ComputeTOI", box2d.b2Contact.prototype.ComputeTOI);
box2d.b2Contact.prototype.ComputeTOI.s_input = new box2d.b2TOIInput;
box2d.b2Contact.prototype.ComputeTOI.s_output = new box2d.b2TOIOutput;
box2d.b2PolygonAndCircleContact = function() {
    box2d.b2Contact.call(this)
};
goog.inherits(box2d.b2PolygonAndCircleContact, box2d.b2Contact);
goog.exportSymbol("box2d.b2PolygonAndCircleContact", box2d.b2PolygonAndCircleContact);
box2d.b2PolygonAndCircleContact.Create = function(a) {
    return new box2d.b2PolygonAndCircleContact
};
goog.exportProperty(box2d.b2PolygonAndCircleContact, "Create", box2d.b2PolygonAndCircleContact.Create);
box2d.b2PolygonAndCircleContact.Destroy = function(a, b) {
};
goog.exportProperty(box2d.b2PolygonAndCircleContact, "Destroy", box2d.b2PolygonAndCircleContact.Destroy);
box2d.b2PolygonAndCircleContact.prototype.Reset = function(a, b, c, e) {
    box2d.b2PolygonAndCircleContact.superClass_.Reset.call(this, a, b, c, e);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.GetType() == box2d.b2ShapeType.e_polygonShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(c.GetType() == box2d.b2ShapeType.e_circleShape)
};
goog.exportProperty(box2d.b2PolygonAndCircleContact.prototype, "Reset", box2d.b2PolygonAndCircleContact.prototype.Reset);
box2d.b2PolygonAndCircleContact.prototype.Evaluate = function(a, b, c) {
    var e = this.m_fixtureA.GetShape(), d = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e instanceof box2d.b2PolygonShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(d instanceof box2d.b2CircleShape);
    box2d.b2CollidePolygonAndCircle(a, e instanceof box2d.b2PolygonShape ? e : null, b, d instanceof box2d.b2CircleShape ? d : null, c)
};
goog.exportProperty(box2d.b2PolygonAndCircleContact.prototype, "Evaluate", box2d.b2PolygonAndCircleContact.prototype.Evaluate);
box2d.b2EdgeAndPolygonContact = function() {
    box2d.b2Contact.call(this)
};
goog.inherits(box2d.b2EdgeAndPolygonContact, box2d.b2Contact);
goog.exportSymbol("box2d.b2EdgeAndPolygonContact", box2d.b2EdgeAndPolygonContact);
box2d.b2EdgeAndPolygonContact.Create = function(a) {
    return new box2d.b2EdgeAndPolygonContact
};
goog.exportProperty(box2d.b2EdgeAndPolygonContact, "Create", box2d.b2EdgeAndPolygonContact.Create);
box2d.b2EdgeAndPolygonContact.Destroy = function(a, b) {
};
goog.exportProperty(box2d.b2EdgeAndPolygonContact, "Destroy", box2d.b2EdgeAndPolygonContact.Destroy);
box2d.b2EdgeAndPolygonContact.prototype.Reset = function(a, b, c, e) {
    box2d.b2EdgeAndPolygonContact.superClass_.Reset.call(this, a, b, c, e);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.GetType() == box2d.b2ShapeType.e_edgeShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(c.GetType() == box2d.b2ShapeType.e_polygonShape)
};
goog.exportProperty(box2d.b2EdgeAndPolygonContact.prototype, "Reset", box2d.b2EdgeAndPolygonContact.prototype.Reset);
box2d.b2EdgeAndPolygonContact.prototype.Evaluate = function(a, b, c) {
    var e = this.m_fixtureA.GetShape(), d = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e instanceof box2d.b2EdgeShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(d instanceof box2d.b2PolygonShape);
    box2d.b2CollideEdgeAndPolygon(a, e instanceof box2d.b2EdgeShape ? e : null, b, d instanceof box2d.b2PolygonShape ? d : null, c)
};
goog.exportProperty(box2d.b2EdgeAndPolygonContact.prototype, "Evaluate", box2d.b2EdgeAndPolygonContact.prototype.Evaluate);
box2d.b2MassData = function() {
    this.center = new box2d.b2Vec2(0, 0)
};
goog.exportSymbol("box2d.b2MassData", box2d.b2MassData);
box2d.b2MassData.prototype.mass = 0;
goog.exportProperty(box2d.b2MassData.prototype, "mass", box2d.b2MassData.prototype.mass);
box2d.b2MassData.prototype.center = null;
goog.exportProperty(box2d.b2MassData.prototype, "center", box2d.b2MassData.prototype.center);
box2d.b2MassData.prototype.I = 0;
goog.exportProperty(box2d.b2MassData.prototype, "I", box2d.b2MassData.prototype.I);
box2d.b2ShapeType = {e_unknown: -1, e_circleShape: 0, e_edgeShape: 1, e_polygonShape: 2, e_chainShape: 3, e_shapeTypeCount: 4};
goog.exportSymbol("box2d.b2ShapeType", box2d.b2ShapeType);
goog.exportProperty(box2d.b2ShapeType, "e_unknown", box2d.b2ShapeType.e_unknown);
goog.exportProperty(box2d.b2ShapeType, "e_circleShape", box2d.b2ShapeType.e_circleShape);
goog.exportProperty(box2d.b2ShapeType, "e_edgeShape", box2d.b2ShapeType.e_edgeShape);
goog.exportProperty(box2d.b2ShapeType, "e_polygonShape", box2d.b2ShapeType.e_polygonShape);
goog.exportProperty(box2d.b2ShapeType, "e_chainShape", box2d.b2ShapeType.e_chainShape);
goog.exportProperty(box2d.b2ShapeType, "e_shapeTypeCount", box2d.b2ShapeType.e_shapeTypeCount);
box2d.b2Shape = function(a, b) {
    this.m_type = a;
    this.m_radius = b
};
goog.exportSymbol("box2d.b2Shape", box2d.b2Shape);
box2d.b2Shape.prototype.m_type = box2d.b2ShapeType.e_unknown;
goog.exportProperty(box2d.b2Shape.prototype, "m_type", box2d.b2Shape.prototype.m_type);
box2d.b2Shape.prototype.m_radius = 0;
goog.exportProperty(box2d.b2Shape.prototype, "m_radius", box2d.b2Shape.prototype.m_radius);
box2d.b2Shape.prototype.Clone = function() {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1);
    return null
};
goog.exportProperty(box2d.b2Shape.prototype, "Clone", box2d.b2Shape.prototype.Clone);
box2d.b2Shape.prototype.Copy = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_type == a.m_type);
    this.m_radius = a.m_radius;
    return this
};
goog.exportProperty(box2d.b2Shape.prototype, "Copy", box2d.b2Shape.prototype.Copy);
box2d.b2Shape.prototype.GetType = function() {
    return this.m_type
};
goog.exportProperty(box2d.b2Shape.prototype, "GetType", box2d.b2Shape.prototype.GetType);
box2d.b2Shape.prototype.GetChildCount = function() {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual");
    return 0
};
goog.exportProperty(box2d.b2Shape.prototype, "GetChildCount", box2d.b2Shape.prototype.GetChildCount);
box2d.b2Shape.prototype.TestPoint = function(a, b) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual");
    return!1
};
goog.exportProperty(box2d.b2Shape.prototype, "TestPoint", box2d.b2Shape.prototype.TestPoint);
box2d.b2Shape.prototype.RayCast = function(a, b, c, e) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual");
    return!1
};
goog.exportProperty(box2d.b2Shape.prototype, "RayCast", box2d.b2Shape.prototype.RayCast);
box2d.b2Shape.prototype.ComputeAABB = function(a, b, c) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual")
};
goog.exportProperty(box2d.b2Shape.prototype, "ComputeAABB", box2d.b2Shape.prototype.ComputeAABB);
box2d.b2Shape.prototype.ComputeMass = function(a, b) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual")
};
goog.exportProperty(box2d.b2Shape.prototype, "ComputeMass", box2d.b2Shape.prototype.ComputeMass);
box2d.b2Shape.prototype.SetupDistanceProxy = function(a, b) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual")
};
box2d.b2Shape.prototype.ComputeSubmergedArea = function(a, b, c, e) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual");
    return 0
};
goog.exportProperty(box2d.b2Shape.prototype, "ComputeSubmergedArea", box2d.b2Shape.prototype.ComputeSubmergedArea);
box2d.b2Shape.prototype.Dump = function() {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual")
};
goog.exportProperty(box2d.b2Shape.prototype, "Dump", box2d.b2Shape.prototype.Dump);
box2d.b2PolygonShape = function() {
    box2d.b2Shape.call(this, box2d.b2ShapeType.e_polygonShape, box2d.b2_polygonRadius);
    this.m_centroid = new box2d.b2Vec2(0, 0);
    this.m_vertices = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices);
    this.m_normals = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices)
};
goog.inherits(box2d.b2PolygonShape, box2d.b2Shape);
goog.exportSymbol("box2d.b2PolygonShape", box2d.b2PolygonShape);
box2d.b2PolygonShape.prototype.m_centroid = null;
goog.exportProperty(box2d.b2PolygonShape.prototype, "m_centroid", box2d.b2PolygonShape.prototype.m_centroid);
box2d.b2PolygonShape.prototype.m_vertices = null;
goog.exportProperty(box2d.b2PolygonShape.prototype, "m_vertices", box2d.b2PolygonShape.prototype.m_vertices);
box2d.b2PolygonShape.prototype.m_normals = null;
goog.exportProperty(box2d.b2PolygonShape.prototype, "m_normals", box2d.b2PolygonShape.prototype.m_normals);
box2d.b2PolygonShape.prototype.m_count = 0;
goog.exportProperty(box2d.b2PolygonShape.prototype, "m_count", box2d.b2PolygonShape.prototype.m_count);
box2d.b2PolygonShape.prototype.Clone = function() {
    return(new box2d.b2PolygonShape).Copy(this)
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "Clone", box2d.b2PolygonShape.prototype.Clone);
box2d.b2PolygonShape.prototype.Copy = function(a) {
    box2d.b2PolygonShape.superClass_.Copy.call(this, a);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a instanceof box2d.b2PolygonShape);
    this.m_centroid.Copy(a.m_centroid);
    this.m_count = a.m_count;
    for (var b = 0, c = this.m_count; b < c; ++b)
        this.m_vertices[b].Copy(a.m_vertices[b]), this.m_normals[b].Copy(a.m_normals[b]);
    return this
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "Copy", box2d.b2PolygonShape.prototype.Copy);
box2d.b2PolygonShape.prototype.SetAsBox = function(a, b) {
    this.m_count = 4;
    this.m_vertices[0].SetXY(-a, -b);
    this.m_vertices[1].SetXY(a, -b);
    this.m_vertices[2].SetXY(a, b);
    this.m_vertices[3].SetXY(-a, b);
    this.m_normals[0].SetXY(0, -1);
    this.m_normals[1].SetXY(1, 0);
    this.m_normals[2].SetXY(0, 1);
    this.m_normals[3].SetXY(-1, 0);
    this.m_centroid.SetZero();
    return this
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "SetAsBox", box2d.b2PolygonShape.prototype.SetAsBox);
box2d.b2PolygonShape.prototype.SetAsOrientedBox = function(a, b, c, e) {
    this.m_count = 4;
    this.m_vertices[0].SetXY(-a, -b);
    this.m_vertices[1].SetXY(a, -b);
    this.m_vertices[2].SetXY(a, b);
    this.m_vertices[3].SetXY(-a, b);
    this.m_normals[0].SetXY(0, -1);
    this.m_normals[1].SetXY(1, 0);
    this.m_normals[2].SetXY(0, 1);
    this.m_normals[3].SetXY(-1, 0);
    this.m_centroid.Copy(c);
    a = new box2d.b2Transform;
    a.SetPosition(c);
    a.SetRotationAngleRadians(e);
    c = 0;
    for (e = this.m_count; c < e; ++c)
        box2d.b2MulXV(a, this.m_vertices[c], this.m_vertices[c]),
                box2d.b2MulRV(a.q, this.m_normals[c], this.m_normals[c]);
    return this
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "SetAsOrientedBox", box2d.b2PolygonShape.prototype.SetAsOrientedBox);
box2d.b2PolygonShape.prototype.Set = function(a, b) {
    void 0 === b && (b = a.length);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(3 <= b && b <= box2d.b2_maxPolygonVertices);
    if (3 > b)
        return this.SetAsBox(1, 1);
    for (var c = box2d.b2Min(b, box2d.b2_maxPolygonVertices), e = box2d.b2PolygonShape.prototype.Set.s_ps, d = 0; d < c; ++d)
        e[d].Copy(a[d]);
    for (var f = 0, g = e[0].x, d = 1; d < b; ++d) {
        var h = e[d].x;
        if (h > g || h == g && e[d].y < e[f].y)
            f = d, g = h
    }
    h = box2d.b2PolygonShape.prototype.Set.s_hull;
    g = 0;
    for (d = f; ; ) {
        h[g] = d;
        for (var l = 0, k = 1; k < c; ++k)
            if (l == d)
                l = k;
            else {
                var m =
                        box2d.b2SubVV(e[l], e[h[g]], box2d.b2PolygonShape.prototype.Set.s_r), n = box2d.b2SubVV(e[k], e[h[g]], box2d.b2PolygonShape.prototype.Set.s_v), p = box2d.b2CrossVV(m, n);
                0 > p && (l = k);
                0 == p && n.GetLengthSquared() > m.GetLengthSquared() && (l = k)
            }
        ++g;
        d = l;
        if (l == f)
            break
    }
    this.m_count = g;
    for (d = 0; d < g; ++d)
        this.m_vertices[d].Copy(e[h[d]]);
    d = 0;
    for (c = g; d < c; ++d)
        e = box2d.b2SubVV(this.m_vertices[(d + 1) % c], this.m_vertices[d], box2d.b2Vec2.s_t0), box2d.ENABLE_ASSERTS && box2d.b2Assert(e.GetLengthSquared() > box2d.b2_epsilon_sq), box2d.b2CrossVOne(e,
                this.m_normals[d]).SelfNormalize();
    box2d.b2PolygonShape.ComputeCentroid(this.m_vertices, g, this.m_centroid);
    return this
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "Set", box2d.b2PolygonShape.prototype.Set);
box2d.b2PolygonShape.prototype.Set.s_ps = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices);
box2d.b2PolygonShape.prototype.Set.s_hull = box2d.b2MakeNumberArray(box2d.b2_maxPolygonVertices);
box2d.b2PolygonShape.prototype.Set.s_r = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.Set.s_v = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.SetAsVector = function(a, b) {
    this.Set(a, b);
    return this
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "SetAsVector", box2d.b2PolygonShape.prototype.SetAsVector);
box2d.b2PolygonShape.prototype.SetAsArray = function(a, b) {
    this.Set(a, b);
    return this
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "SetAsArray", box2d.b2PolygonShape.prototype.SetAsArray);
box2d.b2PolygonShape.prototype.GetChildCount = function() {
    return 1
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "GetChildCount", box2d.b2PolygonShape.prototype.GetChildCount);
box2d.b2PolygonShape.prototype.TestPoint = function(a, b) {
    for (var c = box2d.b2MulTXV(a, b, box2d.b2PolygonShape.prototype.TestPoint.s_pLocal), e = 0, d = this.m_count; e < d; ++e)
        if (0 < box2d.b2DotVV(this.m_normals[e], box2d.b2SubVV(c, this.m_vertices[e], box2d.b2Vec2.s_t0)))
            return!1;
    return!0
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "TestPoint", box2d.b2PolygonShape.prototype.TestPoint);
box2d.b2PolygonShape.prototype.TestPoint.s_pLocal = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.RayCast = function(a, b, c, e) {
    e = box2d.b2MulTXV(c, b.p1, box2d.b2PolygonShape.prototype.RayCast.s_p1);
    for (var d = box2d.b2MulTXV(c, b.p2, box2d.b2PolygonShape.prototype.RayCast.s_p2), d = box2d.b2SubVV(d, e, box2d.b2PolygonShape.prototype.RayCast.s_d), f = 0, g = b.maxFraction, h = -1, l = 0, k = this.m_count; l < k; ++l) {
        var m = box2d.b2DotVV(this.m_normals[l], box2d.b2SubVV(this.m_vertices[l], e, box2d.b2Vec2.s_t0)), n = box2d.b2DotVV(this.m_normals[l], d);
        if (0 == n) {
            if (0 > m)
                return!1
        } else
            0 > n && m < f * n ? (f = m / n, h = l) :
                    0 < n && m < g * n && (g = m / n);
        if (g < f)
            return!1
    }
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= f && f <= b.maxFraction);
    return 0 <= h ? (a.fraction = f, box2d.b2MulRV(c.q, this.m_normals[h], a.normal), !0) : !1
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "RayCast", box2d.b2PolygonShape.prototype.RayCast);
box2d.b2PolygonShape.prototype.RayCast.s_p1 = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.RayCast.s_p2 = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.RayCast.s_d = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.ComputeAABB = function(a, b, c) {
    c = box2d.b2MulXV(b, this.m_vertices[0], a.lowerBound);
    a = a.upperBound.Copy(c);
    for (var e = 0, d = this.m_count; e < d; ++e) {
        var f = box2d.b2MulXV(b, this.m_vertices[e], box2d.b2PolygonShape.prototype.ComputeAABB.s_v);
        box2d.b2MinV(f, c, c);
        box2d.b2MaxV(f, a, a)
    }
    b = this.m_radius;
    c.SelfSubXY(b, b);
    a.SelfAddXY(b, b)
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "ComputeAABB", box2d.b2PolygonShape.prototype.ComputeAABB);
box2d.b2PolygonShape.prototype.ComputeAABB.s_v = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.ComputeMass = function(a, b) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(3 <= this.m_count);
    for (var c = box2d.b2PolygonShape.prototype.ComputeMass.s_center.SetZero(), e = 0, d = 0, f = box2d.b2PolygonShape.prototype.ComputeMass.s_s.SetZero(), g = 0, h = this.m_count; g < h; ++g)
        f.SelfAdd(this.m_vertices[g]);
    f.SelfMul(1 / this.m_count);
    for (var l = 1 / 3, g = 0, h = this.m_count; g < h; ++g) {
        var k = box2d.b2SubVV(this.m_vertices[g], f, box2d.b2PolygonShape.prototype.ComputeMass.s_e1), m = box2d.b2SubVV(this.m_vertices[(g + 1) %
        h], f, box2d.b2PolygonShape.prototype.ComputeMass.s_e2), n = box2d.b2CrossVV(k, m), p = 0.5 * n, e = e + p;
        c.SelfAdd(box2d.b2MulSV(p * l, box2d.b2AddVV(k, m, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t1));
        var p = k.x, k = k.y, q = m.x, m = m.y, d = d + 0.25 * l * n * (p * p + q * p + q * q + (k * k + m * k + m * m))
    }
    a.mass = b * e;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e > box2d.b2_epsilon);
    c.SelfMul(1 / e);
    box2d.b2AddVV(c, f, a.center);
    a.I = b * d;
    a.I += a.mass * (box2d.b2DotVV(a.center, a.center) - box2d.b2DotVV(c, c))
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "ComputeMass", box2d.b2PolygonShape.prototype.ComputeMass);
box2d.b2PolygonShape.prototype.ComputeMass.s_center = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.ComputeMass.s_s = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.ComputeMass.s_e1 = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.ComputeMass.s_e2 = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.Validate = function() {
    for (var a = 0; a < this.m_count; ++a)
        for (var b = a, c = (a + 1) % this.m_count, e = this.m_vertices[b], d = box2d.b2SubVV(this.m_vertices[c], e, box2d.b2PolygonShape.prototype.Validate.s_e), f = 0; f < this.m_count; ++f)
            if (f != b && f != c) {
                var g = box2d.b2SubVV(this.m_vertices[f], e, box2d.b2PolygonShape.prototype.Validate.s_v);
                if (0 > box2d.b2CrossVV(d, g))
                    return!1
            }
    return!0
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "Validate", box2d.b2PolygonShape.prototype.Validate);
box2d.b2PolygonShape.prototype.Validate.s_e = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.Validate.s_v = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.SetupDistanceProxy = function(a, b) {
    a.m_vertices = this.m_vertices;
    a.m_count = this.m_count;
    a.m_radius = this.m_radius
};
box2d.b2PolygonShape.prototype.ComputeSubmergedArea = function(a, b, c, e) {
    var d = box2d.b2MulTRV(c.q, a, box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_normalL), f = b - box2d.b2DotVV(a, c.p), g = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_depths, h = 0, l = -1;
    b = -1;
    var k = !1;
    a = 0;
    for (var m = this.m_count; a < m; ++a) {
        g[a] = box2d.b2DotVV(d, this.m_vertices[a]) - f;
        var n = g[a] < -box2d.b2_epsilon;
        0 < a && (n ? k || (l = a - 1, h++) : k && (b = a - 1, h++));
        k = n
    }
    switch (h) {
        case 0:
            return k ? (a = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_md,
                    this.ComputeMass(a, 1), box2d.b2MulXV(c, a.center, e), a.mass) : 0;
        case 1:
            -1 == l ? l = this.m_count - 1 : b = this.m_count - 1
    }
    a = (l + 1) % this.m_count;
    d = (b + 1) % this.m_count;
    f = (0 - g[l]) / (g[a] - g[l]);
    g = (0 - g[b]) / (g[d] - g[b]);
    l = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_intoVec.SetXY(this.m_vertices[l].x * (1 - f) + this.m_vertices[a].x * f, this.m_vertices[l].y * (1 - f) + this.m_vertices[a].y * f);
    b = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_outoVec.SetXY(this.m_vertices[b].x * (1 - g) + this.m_vertices[d].x * g, this.m_vertices[b].y *
            (1 - g) + this.m_vertices[d].y * g);
    g = 0;
    f = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_center.SetZero();
    h = this.m_vertices[a];
    for (k = null; a != d; )
        a = (a + 1) % this.m_count, k = a == d ? b : this.m_vertices[a], m = 0.5 * ((h.x - l.x) * (k.y - l.y) - (h.y - l.y) * (k.x - l.x)), g += m, f.x += m * (l.x + h.x + k.x) / 3, f.y += m * (l.y + h.y + k.y) / 3, h = k;
    f.SelfMul(1 / g);
    box2d.b2MulXV(c, f, e);
    return g
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "ComputeSubmergedArea", box2d.b2PolygonShape.prototype.ComputeSubmergedArea);
box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_normalL = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_depths = box2d.b2MakeNumberArray(box2d.b2_maxPolygonVertices);
box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_md = new box2d.b2MassData;
box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_intoVec = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_outoVec = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_center = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.Dump = function() {
    box2d.b2Log("    /*box2d.b2PolygonShape*/ var shape = new box2d.b2PolygonShape();\n");
    box2d.b2Log("    /*box2d.b2Vec2[]*/ var vs = box2d.b2Vec2.MakeArray(%d);\n", box2d.b2_maxPolygonVertices);
    for (var a = 0; a < this.m_count; ++a)
        box2d.b2Log("    vs[%d].SetXY(%.15f, %.15f);\n", a, this.m_vertices[a].x, this.m_vertices[a].y);
    box2d.b2Log("    shape.Set(vs, %d);\n", this.m_count)
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "Dump", box2d.b2PolygonShape.prototype.Dump);
box2d.b2PolygonShape.ComputeCentroid = function(a, b, c) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(3 <= b);
    c.SetZero();
    for (var e = 0, d = box2d.b2PolygonShape.ComputeCentroid.s_pRef.SetZero(), f = 1 / 3, g = 0; g < b; ++g) {
        var h = d, l = a[g], k = a[(g + 1) % b], m = box2d.b2SubVV(l, h, box2d.b2PolygonShape.ComputeCentroid.s_e1), n = box2d.b2SubVV(k, h, box2d.b2PolygonShape.ComputeCentroid.s_e2), m = 0.5 * box2d.b2CrossVV(m, n), e = e + m;
        c.x += m * f * (h.x + l.x + k.x);
        c.y += m * f * (h.y + l.y + k.y)
    }
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e > box2d.b2_epsilon);
    c.SelfMul(1 / e);
    return c
};
goog.exportProperty(box2d.b2PolygonShape, "ComputeCentroid", box2d.b2PolygonShape.ComputeCentroid);
box2d.b2PolygonShape.ComputeCentroid.s_pRef = new box2d.b2Vec2;
box2d.b2PolygonShape.ComputeCentroid.s_e1 = new box2d.b2Vec2;
box2d.b2PolygonShape.ComputeCentroid.s_e2 = new box2d.b2Vec2;
box2d.b2CollideEdge = {};
box2d.b2CollideEdgeAndCircle = function(a, b, c, e, d) {
    a.pointCount = 0;
    c = box2d.b2MulTXV(c, box2d.b2MulXV(d, e.m_p, box2d.b2Vec2.s_t0), box2d.b2CollideEdgeAndCircle.s_Q);
    var f = b.m_vertex1, g = b.m_vertex2, h = box2d.b2SubVV(g, f, box2d.b2CollideEdgeAndCircle.s_e), l = box2d.b2DotVV(h, box2d.b2SubVV(g, c, box2d.b2Vec2.s_t0)), k = box2d.b2DotVV(h, box2d.b2SubVV(c, f, box2d.b2Vec2.s_t0)), m = b.m_radius + e.m_radius;
    d = box2d.b2CollideEdgeAndCircle.s_id;
    d.cf.indexB = 0;
    d.cf.typeB = box2d.b2ContactFeatureType.e_vertex;
    if (0 >= k) {
        var n = f, l = box2d.b2SubVV(c,
                n, box2d.b2CollideEdgeAndCircle.s_d), l = box2d.b2DotVV(l, l);
        if (!(l > m * m)) {
            if (b.m_hasVertex0 && (b = box2d.b2SubVV(f, b.m_vertex0, box2d.b2CollideEdgeAndCircle.s_e1), 0 < box2d.b2DotVV(b, box2d.b2SubVV(f, c, box2d.b2Vec2.s_t0))))
                return;
            d.cf.indexA = 0;
            d.cf.typeA = box2d.b2ContactFeatureType.e_vertex;
            a.pointCount = 1;
            a.type = box2d.b2ManifoldType.e_circles;
            a.localNormal.SetZero();
            a.localPoint.Copy(n);
            a.points[0].id.Copy(d);
            a.points[0].localPoint.Copy(e.m_p)
        }
    } else if (0 >= l) {
        if (n = g, l = box2d.b2SubVV(c, n, box2d.b2CollideEdgeAndCircle.s_d),
                l = box2d.b2DotVV(l, l), !(l > m * m)) {
            if (b.m_hasVertex3 && (f = box2d.b2SubVV(b.m_vertex3, g, box2d.b2CollideEdgeAndCircle.s_e2), 0 < box2d.b2DotVV(f, box2d.b2SubVV(c, g, box2d.b2Vec2.s_t0))))
                return;
            d.cf.indexA = 1;
            d.cf.typeA = box2d.b2ContactFeatureType.e_vertex;
            a.pointCount = 1;
            a.type = box2d.b2ManifoldType.e_circles;
            a.localNormal.SetZero();
            a.localPoint.Copy(n);
            a.points[0].id.Copy(d);
            a.points[0].localPoint.Copy(e.m_p)
        }
    } else
        b = box2d.b2DotVV(h, h), box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < b), n = box2d.b2CollideEdgeAndCircle.s_P,
                n.x = 1 / b * (l * f.x + k * g.x), n.y = 1 / b * (l * f.y + k * g.y), l = box2d.b2SubVV(c, n, box2d.b2CollideEdgeAndCircle.s_d), l = box2d.b2DotVV(l, l), l > m * m || (n = box2d.b2CollideEdgeAndCircle.s_n.SetXY(-h.y, h.x), 0 > box2d.b2DotVV(n, box2d.b2SubVV(c, f, box2d.b2Vec2.s_t0)) && n.SetXY(-n.x, -n.y), n.Normalize(), d.cf.indexA = 0, d.cf.typeA = box2d.b2ContactFeatureType.e_face, a.pointCount = 1, a.type = box2d.b2ManifoldType.e_faceA, a.localNormal.Copy(n), a.localPoint.Copy(f), a.points[0].id.Copy(d), a.points[0].localPoint.Copy(e.m_p))
};
goog.exportSymbol("box2d.b2CollideEdgeAndCircle", box2d.b2CollideEdgeAndCircle);
box2d.b2CollideEdgeAndCircle.s_Q = new box2d.b2Vec2;
box2d.b2CollideEdgeAndCircle.s_e = new box2d.b2Vec2;
box2d.b2CollideEdgeAndCircle.s_d = new box2d.b2Vec2;
box2d.b2CollideEdgeAndCircle.s_e1 = new box2d.b2Vec2;
box2d.b2CollideEdgeAndCircle.s_e2 = new box2d.b2Vec2;
box2d.b2CollideEdgeAndCircle.s_P = new box2d.b2Vec2;
box2d.b2CollideEdgeAndCircle.s_n = new box2d.b2Vec2;
box2d.b2CollideEdgeAndCircle.s_id = new box2d.b2ContactID;
box2d.b2EPAxisType = {e_unknown: 0, e_edgeA: 1, e_edgeB: 2};
goog.exportSymbol("box2d.b2EPAxisType", box2d.b2EPAxisType);
goog.exportProperty(box2d.b2EPAxisType, "e_unknown", box2d.b2EPAxisType.e_unknown);
goog.exportProperty(box2d.b2EPAxisType, "e_edgeA", box2d.b2EPAxisType.e_edgeA);
goog.exportProperty(box2d.b2EPAxisType, "e_edgeB", box2d.b2EPAxisType.e_edgeB);
box2d.b2EPAxis = function() {
};
goog.exportSymbol("box2d.b2EPAxis", box2d.b2EPAxis);
box2d.b2EPAxis.prototype.type = box2d.b2EPAxisType.e_unknown;
goog.exportProperty(box2d.b2EPAxis.prototype, "type", box2d.b2EPAxis.prototype.type);
box2d.b2EPAxis.prototype.index = 0;
goog.exportProperty(box2d.b2EPAxis.prototype, "index", box2d.b2EPAxis.prototype.index);
box2d.b2EPAxis.prototype.separation = 0;
goog.exportProperty(box2d.b2EPAxis.prototype, "separation", box2d.b2EPAxis.prototype.separation);
box2d.b2TempPolygon = function() {
    this.vertices = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices);
    this.normals = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices);
    this.count = 0
};
goog.exportSymbol("box2d.b2TempPolygon", box2d.b2TempPolygon);
box2d.b2TempPolygon.prototype.vertices = null;
goog.exportProperty(box2d.b2TempPolygon.prototype, "vertices", box2d.b2TempPolygon.prototype.vertices);
box2d.b2TempPolygon.prototype.normals = null;
goog.exportProperty(box2d.b2TempPolygon.prototype, "normals", box2d.b2TempPolygon.prototype.normals);
box2d.b2TempPolygon.prototype.count = 0;
goog.exportProperty(box2d.b2TempPolygon.prototype, "count", box2d.b2TempPolygon.prototype.count);
box2d.b2ReferenceFace = function() {
    this.i2 = this.i1 = 0;
    this.v1 = new box2d.b2Vec2;
    this.v2 = new box2d.b2Vec2;
    this.normal = new box2d.b2Vec2;
    this.sideNormal1 = new box2d.b2Vec2;
    this.sideOffset1 = 0;
    this.sideNormal2 = new box2d.b2Vec2;
    this.sideOffset2 = 0
};
goog.exportSymbol("box2d.b2ReferenceFace", box2d.b2ReferenceFace);
box2d.b2ReferenceFace.prototype.i1 = 0;
goog.exportProperty(box2d.b2ReferenceFace.prototype, "i1", box2d.b2ReferenceFace.prototype.i1);
box2d.b2ReferenceFace.prototype.i2 = 0;
goog.exportProperty(box2d.b2ReferenceFace.prototype, "i2", box2d.b2ReferenceFace.prototype.i2);
box2d.b2ReferenceFace.prototype.v1 = null;
goog.exportProperty(box2d.b2ReferenceFace.prototype, "v1", box2d.b2ReferenceFace.prototype.v1);
box2d.b2ReferenceFace.prototype.v2 = null;
goog.exportProperty(box2d.b2ReferenceFace.prototype, "v2", box2d.b2ReferenceFace.prototype.v2);
box2d.b2ReferenceFace.prototype.normal = null;
goog.exportProperty(box2d.b2ReferenceFace.prototype, "normal", box2d.b2ReferenceFace.prototype.normal);
box2d.b2ReferenceFace.prototype.sideNormal1 = null;
goog.exportProperty(box2d.b2ReferenceFace.prototype, "sideNormal1", box2d.b2ReferenceFace.prototype.sideNormal1);
box2d.b2ReferenceFace.prototype.sideOffset1 = 0;
goog.exportProperty(box2d.b2ReferenceFace.prototype, "sideOffset1", box2d.b2ReferenceFace.prototype.sideOffset1);
box2d.b2ReferenceFace.prototype.sideNormal2 = null;
goog.exportProperty(box2d.b2ReferenceFace.prototype, "sideNormal2", box2d.b2ReferenceFace.prototype.sideNormal2);
box2d.b2ReferenceFace.prototype.sideOffset2 = 0;
goog.exportProperty(box2d.b2ReferenceFace.prototype, "sideOffset2", box2d.b2ReferenceFace.prototype.sideOffset2);
box2d.b2EPColliderVertexType = {e_isolated: 0, e_concave: 1, e_convex: 2};
goog.exportSymbol("box2d.b2EPColliderVertexType", box2d.b2EPColliderVertexType);
goog.exportProperty(box2d.b2EPColliderVertexType, "e_isolated", box2d.b2EPColliderVertexType.e_isolated);
goog.exportProperty(box2d.b2EPColliderVertexType, "e_concave", box2d.b2EPColliderVertexType.e_concave);
goog.exportProperty(box2d.b2EPColliderVertexType, "e_convex", box2d.b2EPColliderVertexType.e_convex);
box2d.b2EPCollider = function() {
    this.m_polygonB = new box2d.b2TempPolygon;
    this.m_xf = new box2d.b2Transform;
    this.m_centroidB = new box2d.b2Vec2;
    this.m_v0 = new box2d.b2Vec2;
    this.m_v1 = new box2d.b2Vec2;
    this.m_v2 = new box2d.b2Vec2;
    this.m_v3 = new box2d.b2Vec2;
    this.m_normal0 = new box2d.b2Vec2;
    this.m_normal1 = new box2d.b2Vec2;
    this.m_normal2 = new box2d.b2Vec2;
    this.m_normal = new box2d.b2Vec2;
    this.m_type2 = this.m_type1 = box2d.b2EPColliderVertexType.e_isolated;
    this.m_lowerLimit = new box2d.b2Vec2;
    this.m_upperLimit = new box2d.b2Vec2;
    this.m_radius = 0;
    this.m_front = !1
};
goog.exportSymbol("box2d.b2EPCollider", box2d.b2EPCollider);
box2d.b2EPCollider.prototype.m_polygonB = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_polygonB", box2d.b2EPCollider.prototype.m_polygonB);
box2d.b2EPCollider.prototype.m_xf = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_xf", box2d.b2EPCollider.prototype.m_xf);
box2d.b2EPCollider.prototype.m_centroidB = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_centroidB", box2d.b2EPCollider.prototype.m_centroidB);
box2d.b2EPCollider.prototype.m_v0 = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_v0", box2d.b2EPCollider.prototype.m_v0);
box2d.b2EPCollider.prototype.m_v1 = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_v1", box2d.b2EPCollider.prototype.m_v1);
box2d.b2EPCollider.prototype.m_v2 = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_v2", box2d.b2EPCollider.prototype.m_v2);
box2d.b2EPCollider.prototype.m_v3 = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_v3", box2d.b2EPCollider.prototype.m_v3);
box2d.b2EPCollider.prototype.m_normal0 = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_normal0", box2d.b2EPCollider.prototype.m_normal0);
box2d.b2EPCollider.prototype.m_normal1 = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_normal1", box2d.b2EPCollider.prototype.m_normal1);
box2d.b2EPCollider.prototype.m_normal2 = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_normal2", box2d.b2EPCollider.prototype.m_normal2);
box2d.b2EPCollider.prototype.m_normal = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_normal", box2d.b2EPCollider.prototype.m_normal);
box2d.b2EPCollider.prototype.m_type1 = box2d.b2EPColliderVertexType.e_isolated;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_type1", box2d.b2EPCollider.prototype.m_type1);
box2d.b2EPCollider.prototype.m_type2 = box2d.b2EPColliderVertexType.e_isolated;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_type2", box2d.b2EPCollider.prototype.m_type2);
box2d.b2EPCollider.prototype.m_lowerLimit = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_lowerLimit", box2d.b2EPCollider.prototype.m_lowerLimit);
box2d.b2EPCollider.prototype.m_upperLimit = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_upperLimit", box2d.b2EPCollider.prototype.m_upperLimit);
box2d.b2EPCollider.prototype.m_radius = 0;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_radius", box2d.b2EPCollider.prototype.m_radius);
box2d.b2EPCollider.prototype.m_front = !1;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_front", box2d.b2EPCollider.prototype.m_front);
box2d.b2EPCollider.prototype.Collide = function(a, b, c, e, d) {
    box2d.b2MulTXX(c, d, this.m_xf);
    box2d.b2MulXV(this.m_xf, e.m_centroid, this.m_centroidB);
    this.m_v0.Copy(b.m_vertex0);
    this.m_v1.Copy(b.m_vertex1);
    this.m_v2.Copy(b.m_vertex2);
    this.m_v3.Copy(b.m_vertex3);
    c = b.m_hasVertex0;
    b = b.m_hasVertex3;
    d = box2d.b2SubVV(this.m_v2, this.m_v1, box2d.b2EPCollider.s_edge1);
    d.Normalize();
    this.m_normal1.SetXY(d.y, -d.x);
    var f = box2d.b2DotVV(this.m_normal1, box2d.b2SubVV(this.m_centroidB, this.m_v1, box2d.b2Vec2.s_t0)), g = 0, h = 0,
            l = !1, k = !1;
    c && (g = box2d.b2SubVV(this.m_v1, this.m_v0, box2d.b2EPCollider.s_edge0), g.Normalize(), this.m_normal0.SetXY(g.y, -g.x), l = 0 <= box2d.b2CrossVV(g, d), g = box2d.b2DotVV(this.m_normal0, box2d.b2SubVV(this.m_centroidB, this.m_v0, box2d.b2Vec2.s_t0)));
    b && (h = box2d.b2SubVV(this.m_v3, this.m_v2, box2d.b2EPCollider.s_edge2), h.Normalize(), this.m_normal2.SetXY(h.y, -h.x), k = 0 < box2d.b2CrossVV(d, h), h = box2d.b2DotVV(this.m_normal2, box2d.b2SubVV(this.m_centroidB, this.m_v2, box2d.b2Vec2.s_t0)));
    c && b ? l && k ? (this.m_front = 0 <= g ||
            0 <= f || 0 <= h) ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal0), this.m_upperLimit.Copy(this.m_normal2)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal1).SelfNeg()) : l ? (this.m_front = 0 <= g || 0 <= f && 0 <= h) ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal0), this.m_upperLimit.Copy(this.m_normal1)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal2).SelfNeg(),
            this.m_upperLimit.Copy(this.m_normal1).SelfNeg()) : k ? (this.m_front = 0 <= h || 0 <= g && 0 <= f) ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal2)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal0).SelfNeg()) : (this.m_front = 0 <= g && 0 <= f && 0 <= h) ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal1)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(),
            this.m_lowerLimit.Copy(this.m_normal2).SelfNeg(), this.m_upperLimit.Copy(this.m_normal0).SelfNeg()) : c ? l ? ((this.m_front = 0 <= g || 0 <= f) ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal0)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1)), this.m_upperLimit.Copy(this.m_normal1).SelfNeg()) : (this.m_front = 0 <= g && 0 <= f) ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal1).SelfNeg()) : (this.m_normal.Copy(this.m_normal1).SelfNeg(),
            this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal0).SelfNeg()) : b ? k ? (this.m_front = 0 <= f || 0 <= h) ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal2)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal1)) : ((this.m_front = 0 <= f && 0 <= h) ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg()) : (this.m_normal.Copy(this.m_normal1).SelfNeg(),
            this.m_lowerLimit.Copy(this.m_normal2).SelfNeg()), this.m_upperLimit.Copy(this.m_normal1)) : (this.m_front = 0 <= f) ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal1).SelfNeg()) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal1));
    this.m_polygonB.count = e.m_count;
    f = 0;
    for (g = e.m_count; f < g; ++f)
        box2d.b2MulXV(this.m_xf, e.m_vertices[f], this.m_polygonB.vertices[f]), box2d.b2MulRV(this.m_xf.q,
                e.m_normals[f], this.m_polygonB.normals[f]);
    this.m_radius = 2 * box2d.b2_polygonRadius;
    a.pointCount = 0;
    c = this.ComputeEdgeSeparation(box2d.b2EPCollider.s_edgeAxis);
    if (!(c.type == box2d.b2EPAxisType.e_unknown || c.separation > this.m_radius || (b = this.ComputePolygonSeparation(box2d.b2EPCollider.s_polygonAxis), b.type != box2d.b2EPAxisType.e_unknown && b.separation > this.m_radius))) {
        c = b.type == box2d.b2EPAxisType.e_unknown ? c : b.separation > 0.98 * c.separation + 0.001 ? b : c;
        d = box2d.b2EPCollider.s_ie;
        b = box2d.b2EPCollider.s_rf;
        if (c.type ==
                box2d.b2EPAxisType.e_edgeA) {
            a.type = box2d.b2ManifoldType.e_faceA;
            h = 0;
            l = box2d.b2DotVV(this.m_normal, this.m_polygonB.normals[0]);
            f = 1;
            for (g = this.m_polygonB.count; f < g; ++f)
                k = box2d.b2DotVV(this.m_normal, this.m_polygonB.normals[f]), k < l && (l = k, h = f);
            g = h;
            f = (g + 1) % this.m_polygonB.count;
            h = d[0];
            h.v.Copy(this.m_polygonB.vertices[g]);
            h.id.cf.indexA = 0;
            h.id.cf.indexB = g;
            h.id.cf.typeA = box2d.b2ContactFeatureType.e_face;
            h.id.cf.typeB = box2d.b2ContactFeatureType.e_vertex;
            g = d[1];
            g.v.Copy(this.m_polygonB.vertices[f]);
            g.id.cf.indexA =
                    0;
            g.id.cf.indexB = f;
            g.id.cf.typeA = box2d.b2ContactFeatureType.e_face;
            g.id.cf.typeB = box2d.b2ContactFeatureType.e_vertex;
            this.m_front ? (b.i1 = 0, b.i2 = 1, b.v1.Copy(this.m_v1), b.v2.Copy(this.m_v2), b.normal.Copy(this.m_normal1)) : (b.i1 = 1, b.i2 = 0, b.v1.Copy(this.m_v2), b.v2.Copy(this.m_v1), b.normal.Copy(this.m_normal1).SelfNeg())
        } else
            a.type = box2d.b2ManifoldType.e_faceB, h = d[0], h.v.Copy(this.m_v1), h.id.cf.indexA = 0, h.id.cf.indexB = c.index, h.id.cf.typeA = box2d.b2ContactFeatureType.e_vertex, h.id.cf.typeB = box2d.b2ContactFeatureType.e_face,
                    g = d[1], g.v.Copy(this.m_v2), g.id.cf.indexA = 0, g.id.cf.indexB = c.index, g.id.cf.typeA = box2d.b2ContactFeatureType.e_vertex, g.id.cf.typeB = box2d.b2ContactFeatureType.e_face, b.i1 = c.index, b.i2 = (b.i1 + 1) % this.m_polygonB.count, b.v1.Copy(this.m_polygonB.vertices[b.i1]), b.v2.Copy(this.m_polygonB.vertices[b.i2]), b.normal.Copy(this.m_polygonB.normals[b.i1]);
        b.sideNormal1.SetXY(b.normal.y, -b.normal.x);
        b.sideNormal2.Copy(b.sideNormal1).SelfNeg();
        b.sideOffset1 = box2d.b2DotVV(b.sideNormal1, b.v1);
        b.sideOffset2 = box2d.b2DotVV(b.sideNormal2,
                b.v2);
        f = box2d.b2EPCollider.s_clipPoints1;
        h = box2d.b2EPCollider.s_clipPoints2;
        g = 0;
        g = box2d.b2ClipSegmentToLine(f, d, b.sideNormal1, b.sideOffset1, b.i1);
        if (!(g < box2d.b2_maxManifoldPoints || (g = box2d.b2ClipSegmentToLine(h, f, b.sideNormal2, b.sideOffset2, b.i2), g < box2d.b2_maxManifoldPoints))) {
            c.type == box2d.b2EPAxisType.e_edgeA ? (a.localNormal.Copy(b.normal), a.localPoint.Copy(b.v1)) : (a.localNormal.Copy(e.m_normals[b.i1]), a.localPoint.Copy(e.m_vertices[b.i1]));
            f = e = 0;
            for (g = box2d.b2_maxManifoldPoints; f < g; ++f)
                box2d.b2DotVV(b.normal,
                        box2d.b2SubVV(h[f].v, b.v1, box2d.b2Vec2.s_t0)) <= this.m_radius && (d = a.points[e], c.type == box2d.b2EPAxisType.e_edgeA ? (box2d.b2MulTXV(this.m_xf, h[f].v, d.localPoint), d.id = h[f].id) : (d.localPoint.Copy(h[f].v), d.id.cf.typeA = h[f].id.cf.typeB, d.id.cf.typeB = h[f].id.cf.typeA, d.id.cf.indexA = h[f].id.cf.indexB, d.id.cf.indexB = h[f].id.cf.indexA), ++e);
            a.pointCount = e
        }
    }
};
goog.exportProperty(box2d.b2EPCollider.prototype, "Collide", box2d.b2EPCollider.prototype.Collide);
box2d.b2EPCollider.s_edge1 = new box2d.b2Vec2;
box2d.b2EPCollider.s_edge0 = new box2d.b2Vec2;
box2d.b2EPCollider.s_edge2 = new box2d.b2Vec2;
box2d.b2EPCollider.s_ie = box2d.b2ClipVertex.MakeArray(2);
box2d.b2EPCollider.s_rf = new box2d.b2ReferenceFace;
box2d.b2EPCollider.s_clipPoints1 = box2d.b2ClipVertex.MakeArray(2);
box2d.b2EPCollider.s_clipPoints2 = box2d.b2ClipVertex.MakeArray(2);
box2d.b2EPCollider.s_edgeAxis = new box2d.b2EPAxis;
box2d.b2EPCollider.s_polygonAxis = new box2d.b2EPAxis;
box2d.b2EPCollider.prototype.ComputeEdgeSeparation = function(a) {
    a.type = box2d.b2EPAxisType.e_edgeA;
    a.index = this.m_front ? 0 : 1;
    a.separation = box2d.b2_maxFloat;
    for (var b = 0, c = this.m_polygonB.count; b < c; ++b) {
        var e = box2d.b2DotVV(this.m_normal, box2d.b2SubVV(this.m_polygonB.vertices[b], this.m_v1, box2d.b2Vec2.s_t0));
        e < a.separation && (a.separation = e)
    }
    return a
};
goog.exportProperty(box2d.b2EPCollider.prototype, "ComputeEdgeSeparation", box2d.b2EPCollider.prototype.ComputeEdgeSeparation);
box2d.b2EPCollider.prototype.ComputePolygonSeparation = function(a) {
    a.type = box2d.b2EPAxisType.e_unknown;
    a.index = -1;
    a.separation = -box2d.b2_maxFloat;
    for (var b = box2d.b2EPCollider.s_perp.SetXY(-this.m_normal.y, this.m_normal.x), c = 0, e = this.m_polygonB.count; c < e; ++c) {
        var d = box2d.b2NegV(this.m_polygonB.normals[c], box2d.b2EPCollider.s_n), f = box2d.b2DotVV(d, box2d.b2SubVV(this.m_polygonB.vertices[c], this.m_v1, box2d.b2Vec2.s_t0)), g = box2d.b2DotVV(d, box2d.b2SubVV(this.m_polygonB.vertices[c], this.m_v2, box2d.b2Vec2.s_t0)),
                f = box2d.b2Min(f, g);
        if (f > this.m_radius) {
            a.type = box2d.b2EPAxisType.e_edgeB;
            a.index = c;
            a.separation = f;
            break
        }
        if (0 <= box2d.b2DotVV(d, b)) {
            if (box2d.b2DotVV(box2d.b2SubVV(d, this.m_upperLimit, box2d.b2Vec2.s_t0), this.m_normal) < -box2d.b2_angularSlop)
                continue
        } else if (box2d.b2DotVV(box2d.b2SubVV(d, this.m_lowerLimit, box2d.b2Vec2.s_t0), this.m_normal) < -box2d.b2_angularSlop)
            continue;
        f > a.separation && (a.type = box2d.b2EPAxisType.e_edgeB, a.index = c, a.separation = f)
    }
    return a
};
goog.exportProperty(box2d.b2EPCollider.prototype, "ComputePolygonSeparation", box2d.b2EPCollider.prototype.ComputePolygonSeparation);
box2d.b2EPCollider.s_n = new box2d.b2Vec2;
box2d.b2EPCollider.s_perp = new box2d.b2Vec2;
box2d.b2CollideEdgeAndPolygon = function(a, b, c, e, d) {
    box2d.b2CollideEdgeAndPolygon.s_collider.Collide(a, b, c, e, d)
};
goog.exportSymbol("box2d.b2CollideEdgeAndPolygon", box2d.b2CollideEdgeAndPolygon);
box2d.b2CollideEdgeAndPolygon.s_collider = new box2d.b2EPCollider;
box2d.b2EdgeShape = function() {
    box2d.b2Shape.call(this, box2d.b2ShapeType.e_edgeShape, box2d.b2_polygonRadius);
    this.m_vertex1 = new box2d.b2Vec2;
    this.m_vertex2 = new box2d.b2Vec2;
    this.m_vertex0 = new box2d.b2Vec2;
    this.m_vertex3 = new box2d.b2Vec2
};
goog.inherits(box2d.b2EdgeShape, box2d.b2Shape);
goog.exportSymbol("box2d.b2EdgeShape", box2d.b2EdgeShape);
box2d.b2EdgeShape.prototype.m_vertex1 = null;
goog.exportProperty(box2d.b2EdgeShape.prototype, "m_vertex1", box2d.b2EdgeShape.prototype.m_vertex1);
box2d.b2EdgeShape.prototype.m_vertex2 = null;
goog.exportProperty(box2d.b2EdgeShape.prototype, "m_vertex2", box2d.b2EdgeShape.prototype.m_vertex2);
box2d.b2EdgeShape.prototype.m_vertex0 = null;
goog.exportProperty(box2d.b2EdgeShape.prototype, "m_vertex0", box2d.b2EdgeShape.prototype.m_vertex0);
box2d.b2EdgeShape.prototype.m_vertex3 = null;
goog.exportProperty(box2d.b2EdgeShape.prototype, "m_vertex3", box2d.b2EdgeShape.prototype.m_vertex3);
box2d.b2EdgeShape.prototype.m_hasVertex0 = !1;
goog.exportProperty(box2d.b2EdgeShape.prototype, "m_hasVertex0", box2d.b2EdgeShape.prototype.m_hasVertex0);
box2d.b2EdgeShape.prototype.m_hasVertex3 = !1;
goog.exportProperty(box2d.b2EdgeShape.prototype, "m_hasVertex3", box2d.b2EdgeShape.prototype.m_hasVertex3);
box2d.b2EdgeShape.prototype.Set = function(a, b) {
    this.m_vertex1.Copy(a);
    this.m_vertex2.Copy(b);
    this.m_hasVertex3 = this.m_hasVertex0 = !1;
    return this
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "Set", box2d.b2EdgeShape.prototype.Set);
box2d.b2EdgeShape.prototype.SetAsEdge = box2d.b2EdgeShape.prototype.Set;
box2d.b2EdgeShape.prototype.Clone = function() {
    return(new box2d.b2EdgeShape).Copy(this)
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "Clone", box2d.b2EdgeShape.prototype.Clone);
box2d.b2EdgeShape.prototype.Copy = function(a) {
    box2d.b2EdgeShape.superClass_.Copy.call(this, a);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a instanceof box2d.b2EdgeShape);
    this.m_vertex1.Copy(a.m_vertex1);
    this.m_vertex2.Copy(a.m_vertex2);
    this.m_vertex0.Copy(a.m_vertex0);
    this.m_vertex3.Copy(a.m_vertex3);
    this.m_hasVertex0 = a.m_hasVertex0;
    this.m_hasVertex3 = a.m_hasVertex3;
    return this
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "Copy", box2d.b2EdgeShape.prototype.Copy);
box2d.b2EdgeShape.prototype.GetChildCount = function() {
    return 1
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "GetChildCount", box2d.b2EdgeShape.prototype.GetChildCount);
box2d.b2EdgeShape.prototype.TestPoint = function(a, b) {
    return!1
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "TestPoint", box2d.b2EdgeShape.prototype.TestPoint);
box2d.b2EdgeShape.prototype.RayCast = function(a, b, c, e) {
    var d = box2d.b2MulTXV(c, b.p1, box2d.b2EdgeShape.prototype.RayCast.s_p1);
    e = box2d.b2MulTXV(c, b.p2, box2d.b2EdgeShape.prototype.RayCast.s_p2);
    var f = box2d.b2SubVV(e, d, box2d.b2EdgeShape.prototype.RayCast.s_d);
    e = this.m_vertex1;
    var g = this.m_vertex2, h = box2d.b2SubVV(g, e, box2d.b2EdgeShape.prototype.RayCast.s_e), l = a.normal.SetXY(h.y, -h.x).SelfNormalize(), h = box2d.b2DotVV(l, box2d.b2SubVV(e, d, box2d.b2Vec2.s_t0)), l = box2d.b2DotVV(l, f);
    if (0 == l)
        return!1;
    l = h / l;
    if (0 >
            l || b.maxFraction < l)
        return!1;
    b = box2d.b2AddVMulSV(d, l, f, box2d.b2EdgeShape.prototype.RayCast.s_q);
    d = box2d.b2SubVV(g, e, box2d.b2EdgeShape.prototype.RayCast.s_r);
    g = box2d.b2DotVV(d, d);
    if (0 == g)
        return!1;
    e = box2d.b2DotVV(box2d.b2SubVV(b, e, box2d.b2Vec2.s_t0), d) / g;
    if (0 > e || 1 < e)
        return!1;
    a.fraction = l;
    box2d.b2MulRV(c.q, a.normal, a.normal);
    0 < h && a.normal.SelfNeg();
    return!0
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "RayCast", box2d.b2EdgeShape.prototype.RayCast);
box2d.b2EdgeShape.prototype.RayCast.s_p1 = new box2d.b2Vec2;
box2d.b2EdgeShape.prototype.RayCast.s_p2 = new box2d.b2Vec2;
box2d.b2EdgeShape.prototype.RayCast.s_d = new box2d.b2Vec2;
box2d.b2EdgeShape.prototype.RayCast.s_e = new box2d.b2Vec2;
box2d.b2EdgeShape.prototype.RayCast.s_q = new box2d.b2Vec2;
box2d.b2EdgeShape.prototype.RayCast.s_r = new box2d.b2Vec2;
box2d.b2EdgeShape.prototype.ComputeAABB = function(a, b, c) {
    c = box2d.b2MulXV(b, this.m_vertex1, box2d.b2EdgeShape.prototype.ComputeAABB.s_v1);
    b = box2d.b2MulXV(b, this.m_vertex2, box2d.b2EdgeShape.prototype.ComputeAABB.s_v2);
    box2d.b2MinV(c, b, a.lowerBound);
    box2d.b2MaxV(c, b, a.upperBound);
    b = this.m_radius;
    a.lowerBound.SelfSubXY(b, b);
    a.upperBound.SelfAddXY(b, b)
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "ComputeAABB", box2d.b2EdgeShape.prototype.ComputeAABB);
box2d.b2EdgeShape.prototype.ComputeAABB.s_v1 = new box2d.b2Vec2;
box2d.b2EdgeShape.prototype.ComputeAABB.s_v2 = new box2d.b2Vec2;
box2d.b2EdgeShape.prototype.ComputeMass = function(a, b) {
    a.mass = 0;
    box2d.b2MidVV(this.m_vertex1, this.m_vertex2, a.center);
    a.I = 0
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "ComputeMass", box2d.b2EdgeShape.prototype.ComputeMass);
box2d.b2EdgeShape.prototype.SetupDistanceProxy = function(a, b) {
    a.m_vertices = Array(2);
    a.m_vertices[0] = this.m_vertex1;
    a.m_vertices[1] = this.m_vertex2;
    a.m_count = 2;
    a.m_radius = this.m_radius
};
box2d.b2EdgeShape.prototype.ComputeSubmergedArea = function(a, b, c, e) {
    e.SetZero();
    return 0
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "ComputeSubmergedArea", box2d.b2EdgeShape.prototype.ComputeSubmergedArea);
box2d.b2EdgeShape.prototype.Dump = function() {
    box2d.b2Log("    /*box2d.b2EdgeShape*/ var shape = new box2d.b2EdgeShape();\n");
    box2d.b2Log("    shape.m_radius = %.15f;\n", this.m_radius);
    box2d.b2Log("    shape.m_vertex0.SetXY(%.15f, %.15f);\n", this.m_vertex0.x, this.m_vertex0.y);
    box2d.b2Log("    shape.m_vertex1.SetXY(%.15f, %.15f);\n", this.m_vertex1.x, this.m_vertex1.y);
    box2d.b2Log("    shape.m_vertex2.SetXY(%.15f, %.15f);\n", this.m_vertex2.x, this.m_vertex2.y);
    box2d.b2Log("    shape.m_vertex3.SetXY(%.15f, %.15f);\n",
            this.m_vertex3.x, this.m_vertex3.y);
    box2d.b2Log("    shape.m_hasVertex0 = %s;\n", this.m_hasVertex0);
    box2d.b2Log("    shape.m_hasVertex3 = %s;\n", this.m_hasVertex3)
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "Dump", box2d.b2EdgeShape.prototype.Dump);
box2d.b2ChainShape = function() {
    box2d.b2Shape.call(this, box2d.b2ShapeType.e_chainShape, box2d.b2_polygonRadius);
    this.m_prevVertex = new box2d.b2Vec2;
    this.m_nextVertex = new box2d.b2Vec2
};
goog.inherits(box2d.b2ChainShape, box2d.b2Shape);
goog.exportSymbol("box2d.b2ChainShape", box2d.b2ChainShape);
box2d.b2ChainShape.prototype.m_vertices = null;
goog.exportProperty(box2d.b2ChainShape.prototype, "m_vertices", box2d.b2ChainShape.prototype.m_vertices);
box2d.b2ChainShape.prototype.m_count = 0;
goog.exportProperty(box2d.b2ChainShape.prototype, "m_count", box2d.b2ChainShape.prototype.m_count);
box2d.b2ChainShape.prototype.m_prevVertex = null;
goog.exportProperty(box2d.b2ChainShape.prototype, "m_prevVertex", box2d.b2ChainShape.prototype.m_prevVertex);
box2d.b2ChainShape.prototype.m_nextVertex = null;
goog.exportProperty(box2d.b2ChainShape.prototype, "m_nextVertex", box2d.b2ChainShape.prototype.m_nextVertex);
box2d.b2ChainShape.prototype.m_hasPrevVertex = !1;
goog.exportProperty(box2d.b2ChainShape.prototype, "m_hasPrevVertex", box2d.b2ChainShape.prototype.m_hasPrevVertex);
box2d.b2ChainShape.prototype.m_hasNextVertex = !1;
goog.exportProperty(box2d.b2ChainShape.prototype, "m_hasNextVertex", box2d.b2ChainShape.prototype.m_hasNextVertex);
box2d.b2ChainShape.prototype.CreateLoop = function(a, b) {
    b = b || a.length;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(null == this.m_vertices && 0 == this.m_count);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(3 <= b);
    if (box2d.ENABLE_ASSERTS)
        for (var c = 1; c < b; ++c)
            box2d.b2Assert(box2d.b2DistanceSquaredVV(a[c - 1], a[c]) > box2d.b2_linearSlop * box2d.b2_linearSlop);
    this.m_count = b + 1;
    this.m_vertices = box2d.b2Vec2.MakeArray(this.m_count);
    for (c = 0; c < b; ++c)
        this.m_vertices[c].Copy(a[c]);
    this.m_vertices[b].Copy(this.m_vertices[0]);
    this.m_prevVertex.Copy(this.m_vertices[this.m_count -
    2]);
    this.m_nextVertex.Copy(this.m_vertices[1]);
    this.m_hasNextVertex = this.m_hasPrevVertex = !0;
    return this
};
goog.exportProperty(box2d.b2ChainShape.prototype, "CreateLoop", box2d.b2ChainShape.prototype.CreateLoop);
box2d.b2ChainShape.prototype.CreateChain = function(a, b) {
    b = b || a.length;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(null == this.m_vertices && 0 == this.m_count);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(2 <= b);
    if (box2d.ENABLE_ASSERTS)
        for (var c = 1; c < b; ++c)
            box2d.b2Assert(box2d.b2DistanceSquaredVV(a[c - 1], a[c]) > box2d.b2_linearSlop * box2d.b2_linearSlop);
    this.m_count = b;
    this.m_vertices = box2d.b2Vec2.MakeArray(b);
    for (c = 0; c < b; ++c)
        this.m_vertices[c].Copy(a[c]);
    this.m_hasNextVertex = this.m_hasPrevVertex = !1;
    return this
};
goog.exportProperty(box2d.b2ChainShape.prototype, "CreateChain", box2d.b2ChainShape.prototype.CreateChain);
box2d.b2ChainShape.prototype.SetPrevVertex = function(a) {
    this.m_prevVertex.Copy(a);
    this.m_hasPrevVertex = !0;
    return this
};
goog.exportProperty(box2d.b2ChainShape.prototype, "SetPrevVertex", box2d.b2ChainShape.prototype.SetPrevVertex);
box2d.b2ChainShape.prototype.SetNextVertex = function(a) {
    this.m_nextVertex.Copy(a);
    this.m_hasNextVertex = !0;
    return this
};
goog.exportProperty(box2d.b2ChainShape.prototype, "SetNextVertex", box2d.b2ChainShape.prototype.SetNextVertex);
box2d.b2ChainShape.prototype.Clone = function() {
    return(new box2d.b2ChainShape).Copy(this)
};
goog.exportProperty(box2d.b2ChainShape.prototype, "Clone", box2d.b2ChainShape.prototype.Clone);
box2d.b2ChainShape.prototype.Copy = function(a) {
    box2d.b2ChainShape.superClass_.Copy.call(this, a);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a instanceof box2d.b2ChainShape);
    this.CreateChain(a.m_vertices, a.m_count);
    this.m_prevVertex.Copy(a.m_prevVertex);
    this.m_nextVertex.Copy(a.m_nextVertex);
    this.m_hasPrevVertex = a.m_hasPrevVertex;
    this.m_hasNextVertex = a.m_hasNextVertex;
    return this
};
goog.exportProperty(box2d.b2ChainShape.prototype, "Copy", box2d.b2ChainShape.prototype.Copy);
box2d.b2ChainShape.prototype.GetChildCount = function() {
    return this.m_count - 1
};
goog.exportProperty(box2d.b2ChainShape.prototype, "GetChildCount", box2d.b2ChainShape.prototype.GetChildCount);
box2d.b2ChainShape.prototype.GetChildEdge = function(a, b) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= b && b < this.m_count - 1);
    a.m_type = box2d.b2ShapeType.e_edgeShape;
    a.m_radius = this.m_radius;
    a.m_vertex1.Copy(this.m_vertices[b]);
    a.m_vertex2.Copy(this.m_vertices[b + 1]);
    0 < b ? (a.m_vertex0.Copy(this.m_vertices[b - 1]), a.m_hasVertex0 = !0) : (a.m_vertex0.Copy(this.m_prevVertex), a.m_hasVertex0 = this.m_hasPrevVertex);
    b < this.m_count - 2 ? (a.m_vertex3.Copy(this.m_vertices[b + 2]), a.m_hasVertex3 = !0) : (a.m_vertex3.Copy(this.m_nextVertex),
            a.m_hasVertex3 = this.m_hasNextVertex)
};
goog.exportProperty(box2d.b2ChainShape.prototype, "GetChildEdge", box2d.b2ChainShape.prototype.GetChildEdge);
box2d.b2ChainShape.prototype.TestPoint = function(a, b) {
    return!1
};
goog.exportProperty(box2d.b2ChainShape.prototype, "TestPoint", box2d.b2ChainShape.prototype.TestPoint);
box2d.b2ChainShape.prototype.RayCast = function(a, b, c, e) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e < this.m_count);
    var d = box2d.b2ChainShape.s_edgeShape;
    d.m_vertex1.Copy(this.m_vertices[e]);
    d.m_vertex2.Copy(this.m_vertices[(e + 1) % this.m_count]);
    return d.RayCast(a, b, c, 0)
};
goog.exportProperty(box2d.b2ChainShape.prototype, "RayCast", box2d.b2ChainShape.prototype.RayCast);
box2d.b2ChainShape.s_edgeShape = new box2d.b2EdgeShape;
goog.exportProperty(box2d.b2ChainShape, "s_edgeShape", box2d.b2ChainShape.s_edgeShape);
box2d.b2ChainShape.prototype.ComputeAABB = function(a, b, c) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(c < this.m_count);
    var e = this.m_vertices[(c + 1) % this.m_count];
    c = box2d.b2MulXV(b, this.m_vertices[c], box2d.b2ChainShape.prototype.ComputeAABB.s_v1);
    b = box2d.b2MulXV(b, e, box2d.b2ChainShape.prototype.ComputeAABB.s_v2);
    box2d.b2MinV(c, b, a.lowerBound);
    box2d.b2MaxV(c, b, a.upperBound)
};
goog.exportProperty(box2d.b2ChainShape.prototype, "ComputeAABB", box2d.b2ChainShape.prototype.ComputeAABB);
box2d.b2ChainShape.prototype.ComputeAABB.s_v1 = new box2d.b2Vec2;
goog.exportProperty(box2d.b2ChainShape.prototype.ComputeAABB, "s_v1", box2d.b2ChainShape.prototype.ComputeAABB.s_v1);
box2d.b2ChainShape.prototype.ComputeAABB.s_v2 = new box2d.b2Vec2;
goog.exportProperty(box2d.b2ChainShape.prototype.ComputeAABB, "s_v2", box2d.b2ChainShape.prototype.ComputeAABB.s_v2);
box2d.b2ChainShape.prototype.ComputeMass = function(a, b) {
    a.mass = 0;
    a.center.SetZero();
    a.I = 0
};
goog.exportProperty(box2d.b2ChainShape.prototype, "ComputeMass", box2d.b2ChainShape.prototype.ComputeMass);
box2d.b2ChainShape.prototype.SetupDistanceProxy = function(a, b) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= b && b < this.m_count);
    a.m_buffer[0].Copy(this.m_vertices[b]);
    b + 1 < this.m_count ? a.m_buffer[1].Copy(this.m_vertices[b + 1]) : a.m_buffer[1].Copy(this.m_vertices[0]);
    a.m_vertices = a.m_buffer;
    a.m_count = 2;
    a.m_radius = this.m_radius
};
box2d.b2ChainShape.prototype.ComputeSubmergedArea = function(a, b, c, e) {
    e.SetZero();
    return 0
};
goog.exportProperty(box2d.b2ChainShape.prototype, "ComputeSubmergedArea", box2d.b2ChainShape.prototype.ComputeSubmergedArea);
box2d.b2ChainShape.prototype.Dump = function() {
    box2d.b2Log("    /*box2d.b2ChainShape*/ var shape = new box2d.b2ChainShape();\n");
    box2d.b2Log("    /*box2d.b2Vec2[]*/ var vs = box2d.b2Vec2.MakeArray(%d);\n", box2d.b2_maxPolygonVertices);
    for (var a = 0; a < this.m_count; ++a)
        box2d.b2Log("    vs[%d].SetXY(%.15f, %.15f);\n", a, this.m_vertices[a].x, this.m_vertices[a].y);
    box2d.b2Log("    shape.CreateChain(vs, %d);\n", this.m_count);
    box2d.b2Log("    shape.m_prevVertex.SetXY(%.15f, %.15f);\n", this.m_prevVertex.x, this.m_prevVertex.y);
    box2d.b2Log("    shape.m_nextVertex.SetXY(%.15f, %.15f);\n", this.m_nextVertex.x, this.m_nextVertex.y);
    box2d.b2Log("    shape.m_hasPrevVertex = %s;\n", this.m_hasPrevVertex ? "true" : "false");
    box2d.b2Log("    shape.m_hasNextVertex = %s;\n", this.m_hasNextVertex ? "true" : "false")
};
goog.exportProperty(box2d.b2ChainShape.prototype, "Dump", box2d.b2ChainShape.prototype.Dump);
box2d.b2ChainAndPolygonContact = function() {
    box2d.b2Contact.call(this)
};
goog.inherits(box2d.b2ChainAndPolygonContact, box2d.b2Contact);
goog.exportSymbol("box2d.b2ChainAndPolygonContact", box2d.b2ChainAndPolygonContact);
box2d.b2ChainAndPolygonContact.Create = function(a) {
    return new box2d.b2ChainAndPolygonContact
};
goog.exportProperty(box2d.b2ChainAndPolygonContact, "Create", box2d.b2ChainAndPolygonContact.Create);
box2d.b2ChainAndPolygonContact.Destroy = function(a, b) {
};
goog.exportProperty(box2d.b2ChainAndPolygonContact, "Destroy", box2d.b2ChainAndPolygonContact.Destroy);
box2d.b2ChainAndPolygonContact.prototype.Reset = function(a, b, c, e) {
    box2d.b2ChainAndPolygonContact.superClass_.Reset.call(this, a, b, c, e);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.GetType() == box2d.b2ShapeType.e_chainShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(c.GetType() == box2d.b2ShapeType.e_polygonShape)
};
goog.exportProperty(box2d.b2ChainAndPolygonContact.prototype, "Reset", box2d.b2ChainAndPolygonContact.prototype.Reset);
box2d.b2ChainAndPolygonContact.prototype.Evaluate = function(a, b, c) {
    var e = this.m_fixtureA.GetShape(), d = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e instanceof box2d.b2ChainShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(d instanceof box2d.b2PolygonShape);
    var f = box2d.b2ChainAndPolygonContact.prototype.Evaluate.s_edge;
    (e instanceof box2d.b2ChainShape ? e : null).GetChildEdge(f, this.m_indexA);
    box2d.b2CollideEdgeAndPolygon(a, f, b, d instanceof box2d.b2PolygonShape ? d : null, c)
};
goog.exportProperty(box2d.b2ChainAndPolygonContact.prototype, "Evaluate", box2d.b2ChainAndPolygonContact.prototype.Evaluate);
box2d.b2ChainAndPolygonContact.prototype.Evaluate.s_edge = new box2d.b2EdgeShape;
box2d.b2CollidePolygon = {};
box2d.b2EdgeSeparation = function(a, b, c, e, d) {
    var f = a.m_count, g = a.m_vertices, h = a.m_normals;
    a = e.m_count;
    e = e.m_vertices;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= c && c < f);
    for (var f = box2d.b2MulRV(b.q, h[c], box2d.b2EdgeSeparation.s_normal1World), l = box2d.b2MulTRV(d.q, f, box2d.b2EdgeSeparation.s_normal1), h = 0, k = box2d.b2_maxFloat, m = 0; m < a; ++m) {
        var n = box2d.b2DotVV(e[m], l);
        n < k && (k = n, h = m)
    }
    b = box2d.b2MulXV(b, g[c], box2d.b2EdgeSeparation.s_v1);
    d = box2d.b2MulXV(d, e[h], box2d.b2EdgeSeparation.s_v2);
    return box2d.b2DotVV(box2d.b2SubVV(d,
            b, box2d.b2Vec2.s_t0), f)
};
goog.exportSymbol("box2d.b2EdgeSeparation", box2d.b2EdgeSeparation);
box2d.b2EdgeSeparation.s_normal1World = new box2d.b2Vec2;
box2d.b2EdgeSeparation.s_normal1 = new box2d.b2Vec2;
box2d.b2EdgeSeparation.s_v1 = new box2d.b2Vec2;
box2d.b2EdgeSeparation.s_v2 = new box2d.b2Vec2;
box2d.b2FindMaxSeparation = function(a, b, c, e, d) {
    for (var f = b.m_count, g = b.m_normals, h = box2d.b2SubVV(box2d.b2MulXV(d, e.m_centroid, box2d.b2Vec2.s_t0), box2d.b2MulXV(c, b.m_centroid, box2d.b2Vec2.s_t1), box2d.b2FindMaxSeparation.s_d), l = box2d.b2MulTRV(c.q, h, box2d.b2FindMaxSeparation.s_dLocal1), h = 0, k = -box2d.b2_maxFloat, m = 0; m < f; ++m) {
        var n = box2d.b2DotVV(g[m], l);
        n > k && (k = n, h = m)
    }
    var g = box2d.b2EdgeSeparation(b, c, h, e, d), l = (h + f - 1) % f, k = box2d.b2EdgeSeparation(b, c, l, e, d), m = (h + 1) % f, n = box2d.b2EdgeSeparation(b, c, m, e, d), p = 0,
            q = 0, r = 0;
    if (k > g && k > n)
        r = -1, p = l, q = k;
    else if (n > g)
        r = 1, p = m, q = n;
    else
        return a[0] = h, g;
    for (; ; )
        if (h = -1 == r ? (p + f - 1) % f : (p + 1) % f, g = box2d.b2EdgeSeparation(b, c, h, e, d), g > q)
            p = h, q = g;
        else
            break;
    a[0] = p;
    return q
};
goog.exportSymbol("box2d.b2FindMaxSeparation", box2d.b2FindMaxSeparation);
box2d.b2FindMaxSeparation.s_d = new box2d.b2Vec2;
box2d.b2FindMaxSeparation.s_dLocal1 = new box2d.b2Vec2;
box2d.b2FindIncidentEdge = function(a, b, c, e, d, f) {
    var g = b.m_count, h = b.m_normals, l = d.m_count;
    b = d.m_vertices;
    d = d.m_normals;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= e && e < g);
    c = box2d.b2MulTRV(f.q, box2d.b2MulRV(c.q, h[e], box2d.b2Vec2.s_t0), box2d.b2FindIncidentEdge.s_normal1);
    for (var g = 0, h = box2d.b2_maxFloat, k = 0; k < l; ++k) {
        var m = box2d.b2DotVV(c, d[k]);
        m < h && (h = m, g = k)
    }
    d = g;
    l = (d + 1) % l;
    c = a[0];
    box2d.b2MulXV(f, b[d], c.v);
    c = c.id.cf;
    c.indexA = e;
    c.indexB = d;
    c.typeA = box2d.b2ContactFeatureType.e_face;
    c.typeB = box2d.b2ContactFeatureType.e_vertex;
    a = a[1];
    box2d.b2MulXV(f, b[l], a.v);
    f = a.id.cf;
    f.indexA = e;
    f.indexB = l;
    f.typeA = box2d.b2ContactFeatureType.e_face;
    f.typeB = box2d.b2ContactFeatureType.e_vertex
};
goog.exportSymbol("box2d.b2FindIncidentEdge", box2d.b2FindIncidentEdge);
box2d.b2FindIncidentEdge.s_normal1 = new box2d.b2Vec2;
box2d.b2CollidePolygons = function(a, b, c, e, d) {
    a.pointCount = 0;
    var f = b.m_radius + e.m_radius, g = box2d.b2CollidePolygons.s_edgeA;
    g[0] = 0;
    var h = box2d.b2FindMaxSeparation(g, b, c, e, d);
    if (!(h > f)) {
        var l = box2d.b2CollidePolygons.s_edgeB;
        l[0] = 0;
        var k = box2d.b2FindMaxSeparation(l, e, d, b, c);
        if (!(k > f)) {
            var m = 0, n = 0;
            k > 0.98 * h + 0.001 ? (h = e, e = b, b = d, m = l[0], a.type = box2d.b2ManifoldType.e_faceB, n = 1) : (h = b, b = c, c = d, m = g[0], a.type = box2d.b2ManifoldType.e_faceA, n = 0);
            g = box2d.b2CollidePolygons.s_incidentEdge;
            box2d.b2FindIncidentEdge(g, h, b,
                    m, e, c);
            d = h.m_vertices;
            var l = m, h = (m + 1) % h.m_count, p = d[l], q = d[h], m = box2d.b2SubVV(q, p, box2d.b2CollidePolygons.s_localTangent);
            m.Normalize();
            d = box2d.b2CrossVOne(m, box2d.b2CollidePolygons.s_localNormal);
            e = box2d.b2MidVV(p, q, box2d.b2CollidePolygons.s_planePoint);
            var k = box2d.b2MulRV(b.q, m, box2d.b2CollidePolygons.s_tangent), m = box2d.b2CrossVOne(k, box2d.b2CollidePolygons.s_normal), p = box2d.b2MulXV(b, p, box2d.b2CollidePolygons.s_v11), r = box2d.b2MulXV(b, q, box2d.b2CollidePolygons.s_v12);
            b = box2d.b2DotVV(m, p);
            var q =
                    -box2d.b2DotVV(k, p) + f, r = box2d.b2DotVV(k, r) + f, t = box2d.b2CollidePolygons.s_clipPoints1, p = box2d.b2CollidePolygons.s_clipPoints2, s = box2d.b2NegV(k, box2d.b2CollidePolygons.s_ntangent), g = box2d.b2ClipSegmentToLine(t, g, s, q, l);
            if (!(2 > g || (g = box2d.b2ClipSegmentToLine(p, t, k, r, h), 2 > g))) {
                a.localNormal.Copy(d);
                a.localPoint.Copy(e);
                for (l = g = 0; l < box2d.b2_maxManifoldPoints; ++l)
                    d = p[l], box2d.b2DotVV(m, d.v) - b <= f && (h = a.points[g], box2d.b2MulTXV(c, d.v, h.localPoint), h.id.Copy(d.id), n && (d = h.id.cf, h.id.cf.indexA = d.indexB, h.id.cf.indexB =
                            d.indexA, h.id.cf.typeA = d.typeB, h.id.cf.typeB = d.typeA), ++g);
                a.pointCount = g
            }
        }
    }
};
goog.exportSymbol("box2d.b2CollidePolygons", box2d.b2CollidePolygons);
box2d.b2CollidePolygons.s_incidentEdge = box2d.b2ClipVertex.MakeArray(2);
box2d.b2CollidePolygons.s_clipPoints1 = box2d.b2ClipVertex.MakeArray(2);
box2d.b2CollidePolygons.s_clipPoints2 = box2d.b2ClipVertex.MakeArray(2);
box2d.b2CollidePolygons.s_edgeA = box2d.b2MakeNumberArray(1);
box2d.b2CollidePolygons.s_edgeB = box2d.b2MakeNumberArray(1);
box2d.b2CollidePolygons.s_localTangent = new box2d.b2Vec2;
box2d.b2CollidePolygons.s_localNormal = new box2d.b2Vec2;
box2d.b2CollidePolygons.s_planePoint = new box2d.b2Vec2;
box2d.b2CollidePolygons.s_normal = new box2d.b2Vec2;
box2d.b2CollidePolygons.s_tangent = new box2d.b2Vec2;
box2d.b2CollidePolygons.s_ntangent = new box2d.b2Vec2;
box2d.b2CollidePolygons.s_v11 = new box2d.b2Vec2;
box2d.b2CollidePolygons.s_v12 = new box2d.b2Vec2;
box2d.b2PolygonContact = function() {
    box2d.b2Contact.call(this)
};
goog.inherits(box2d.b2PolygonContact, box2d.b2Contact);
goog.exportSymbol("box2d.b2PolygonContact", box2d.b2PolygonContact);
box2d.b2PolygonContact.Create = function(a) {
    return new box2d.b2PolygonContact
};
goog.exportProperty(box2d.b2PolygonContact, "Create", box2d.b2PolygonContact.Create);
box2d.b2PolygonContact.Destroy = function(a, b) {
};
goog.exportProperty(box2d.b2PolygonContact, "Destroy", box2d.b2PolygonContact.Destroy);
box2d.b2PolygonContact.prototype.Reset = function(a, b, c, e) {
    box2d.b2PolygonContact.superClass_.Reset.call(this, a, b, c, e)
};
goog.exportProperty(box2d.b2PolygonContact.prototype, "Reset", box2d.b2PolygonContact.prototype.Reset);
box2d.b2PolygonContact.prototype.Evaluate = function(a, b, c) {
    var e = this.m_fixtureA.GetShape(), d = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e instanceof box2d.b2PolygonShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(d instanceof box2d.b2PolygonShape);
    box2d.b2CollidePolygons(a, e instanceof box2d.b2PolygonShape ? e : null, b, d instanceof box2d.b2PolygonShape ? d : null, c)
};
goog.exportProperty(box2d.b2PolygonContact.prototype, "Evaluate", box2d.b2PolygonContact.prototype.Evaluate);
box2d.b2CollideCircle = {};
box2d.b2CollideCircles = function(a, b, c, e, d) {
    a.pointCount = 0;
    c = box2d.b2MulXV(c, b.m_p, box2d.b2CollideCircles.s_pA);
    d = box2d.b2MulXV(d, e.m_p, box2d.b2CollideCircles.s_pB);
    d = box2d.b2DistanceSquaredVV(c, d);
    c = b.m_radius + e.m_radius;
    d > c * c || (a.type = box2d.b2ManifoldType.e_circles, a.localPoint.Copy(b.m_p), a.localNormal.SetZero(), a.pointCount = 1, a.points[0].localPoint.Copy(e.m_p), a.points[0].id.key = 0)
};
goog.exportSymbol("box2d.b2CollideCircles", box2d.b2CollideCircles);
box2d.b2CollideCircles.s_pA = new box2d.b2Vec2;
box2d.b2CollideCircles.s_pB = new box2d.b2Vec2;
box2d.b2CollidePolygonAndCircle = function(a, b, c, e, d) {
    a.pointCount = 0;
    d = box2d.b2MulXV(d, e.m_p, box2d.b2CollidePolygonAndCircle.s_c);
    c = box2d.b2MulTXV(c, d, box2d.b2CollidePolygonAndCircle.s_cLocal);
    var f = 0, g = -box2d.b2_maxFloat;
    d = b.m_radius + e.m_radius;
    var h = b.m_count, l = b.m_vertices;
    b = b.m_normals;
    for (var k = 0; k < h; ++k) {
        var m = box2d.b2DotVV(b[k], box2d.b2SubVV(c, l[k], box2d.b2Vec2.s_t0));
        if (m > d)
            return;
        m > g && (g = m, f = k)
    }
    k = f;
    m = l[k];
    h = l[(k + 1) % h];
    g < box2d.b2_epsilon ? (a.pointCount = 1, a.type = box2d.b2ManifoldType.e_faceA, a.localNormal.Copy(b[f]),
            box2d.b2MidVV(m, h, a.localPoint), a.points[0].localPoint.Copy(e.m_p), a.points[0].id.key = 0) : (g = box2d.b2DotVV(box2d.b2SubVV(c, m, box2d.b2Vec2.s_t0), box2d.b2SubVV(h, m, box2d.b2Vec2.s_t1)), f = box2d.b2DotVV(box2d.b2SubVV(c, h, box2d.b2Vec2.s_t0), box2d.b2SubVV(m, h, box2d.b2Vec2.s_t1)), 0 >= g ? box2d.b2DistanceSquaredVV(c, m) > d * d || (a.pointCount = 1, a.type = box2d.b2ManifoldType.e_faceA, box2d.b2SubVV(c, m, a.localNormal).SelfNormalize(), a.localPoint.Copy(m), a.points[0].localPoint.Copy(e.m_p), a.points[0].id.key = 0) : 0 >= f ? box2d.b2DistanceSquaredVV(c,
            h) > d * d || (a.pointCount = 1, a.type = box2d.b2ManifoldType.e_faceA, box2d.b2SubVV(c, h, a.localNormal).SelfNormalize(), a.localPoint.Copy(h), a.points[0].localPoint.Copy(e.m_p), a.points[0].id.key = 0) : (f = box2d.b2MidVV(m, h, box2d.b2CollidePolygonAndCircle.s_faceCenter), g = box2d.b2DotVV(box2d.b2SubVV(c, f, box2d.b2Vec2.s_t1), b[k]), g > d || (a.pointCount = 1, a.type = box2d.b2ManifoldType.e_faceA, a.localNormal.Copy(b[k]).SelfNormalize(), a.localPoint.Copy(f), a.points[0].localPoint.Copy(e.m_p), a.points[0].id.key = 0)))
};
goog.exportSymbol("box2d.b2CollidePolygonAndCircle", box2d.b2CollidePolygonAndCircle);
box2d.b2CollidePolygonAndCircle.s_c = new box2d.b2Vec2;
box2d.b2CollidePolygonAndCircle.s_cLocal = new box2d.b2Vec2;
box2d.b2CollidePolygonAndCircle.s_faceCenter = new box2d.b2Vec2;
box2d.b2CircleContact = function() {
    box2d.b2Contact.call(this)
};
goog.inherits(box2d.b2CircleContact, box2d.b2Contact);
goog.exportSymbol("box2d.b2CircleContact", box2d.b2CircleContact);
box2d.b2CircleContact.Create = function(a) {
    return new box2d.b2CircleContact
};
goog.exportProperty(box2d.b2CircleContact, "Create", box2d.b2CircleContact.Create);
box2d.b2CircleContact.Destroy = function(a, b) {
};
goog.exportProperty(box2d.b2CircleContact, "Destroy", box2d.b2CircleContact.Destroy);
box2d.b2CircleContact.prototype.Reset = function(a, b, c, e) {
    box2d.b2CircleContact.superClass_.Reset.call(this, a, b, c, e)
};
goog.exportProperty(box2d.b2CircleContact.prototype, "Reset", box2d.b2CircleContact.prototype.Reset);
box2d.b2CircleContact.prototype.Evaluate = function(a, b, c) {
    var e = this.m_fixtureA.GetShape(), d = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e instanceof box2d.b2CircleShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(d instanceof box2d.b2CircleShape);
    box2d.b2CollideCircles(a, e instanceof box2d.b2CircleShape ? e : null, b, d instanceof box2d.b2CircleShape ? d : null, c)
};
goog.exportProperty(box2d.b2CircleContact.prototype, "Evaluate", box2d.b2CircleContact.prototype.Evaluate);
box2d.b2ChainAndCircleContact = function() {
    box2d.b2Contact.call(this)
};
goog.inherits(box2d.b2ChainAndCircleContact, box2d.b2Contact);
goog.exportSymbol("box2d.b2ChainAndCircleContact", box2d.b2ChainAndCircleContact);
box2d.b2ChainAndCircleContact.Create = function(a) {
    return new box2d.b2ChainAndCircleContact
};
goog.exportProperty(box2d.b2ChainAndCircleContact, "Create", box2d.b2ChainAndCircleContact.Create);
box2d.b2ChainAndCircleContact.Destroy = function(a, b) {
};
goog.exportProperty(box2d.b2ChainAndCircleContact, "Destroy", box2d.b2ChainAndCircleContact.Destroy);
box2d.b2ChainAndCircleContact.prototype.Reset = function(a, b, c, e) {
    box2d.b2ChainAndCircleContact.superClass_.Reset.call(this, a, b, c, e);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.GetType() == box2d.b2ShapeType.e_chainShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(c.GetType() == box2d.b2ShapeType.e_circleShape)
};
goog.exportProperty(box2d.b2ChainAndCircleContact.prototype, "Reset", box2d.b2ChainAndCircleContact.prototype.Reset);
box2d.b2ChainAndCircleContact.prototype.Evaluate = function(a, b, c) {
    var e = this.m_fixtureA.GetShape(), d = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e instanceof box2d.b2ChainShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(d instanceof box2d.b2CircleShape);
    var f = box2d.b2ChainAndCircleContact.prototype.Evaluate.s_edge;
    (e instanceof box2d.b2ChainShape ? e : null).GetChildEdge(f, this.m_indexA);
    box2d.b2CollideEdgeAndCircle(a, f, b, d instanceof box2d.b2CircleShape ? d : null, c)
};
goog.exportProperty(box2d.b2ChainAndCircleContact.prototype, "Evaluate", box2d.b2ChainAndCircleContact.prototype.Evaluate);
box2d.b2ChainAndCircleContact.prototype.Evaluate.s_edge = new box2d.b2EdgeShape;
box2d.b2EdgeAndCircleContact = function() {
    box2d.b2Contact.call(this)
};
goog.inherits(box2d.b2EdgeAndCircleContact, box2d.b2Contact);
goog.exportSymbol("box2d.b2EdgeAndCircleContact", box2d.b2EdgeAndCircleContact);
box2d.b2EdgeAndCircleContact.Create = function(a) {
    return new box2d.b2EdgeAndCircleContact
};
goog.exportProperty(box2d.b2EdgeAndCircleContact, "Create", box2d.b2EdgeAndCircleContact.Create);
box2d.b2EdgeAndCircleContact.Destroy = function(a, b) {
};
goog.exportProperty(box2d.b2EdgeAndCircleContact, "Destroy", box2d.b2EdgeAndCircleContact.Destroy);
box2d.b2EdgeAndCircleContact.prototype.Reset = function(a, b, c, e) {
    box2d.b2EdgeAndCircleContact.superClass_.Reset.call(this, a, b, c, e);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.GetType() == box2d.b2ShapeType.e_edgeShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(c.GetType() == box2d.b2ShapeType.e_circleShape)
};
goog.exportProperty(box2d.b2EdgeAndCircleContact.prototype, "Reset", box2d.b2EdgeAndCircleContact.prototype.Reset);
box2d.b2EdgeAndCircleContact.prototype.Evaluate = function(a, b, c) {
    var e = this.m_fixtureA.GetShape(), d = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e instanceof box2d.b2EdgeShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(d instanceof box2d.b2CircleShape);
    box2d.b2CollideEdgeAndCircle(a, e instanceof box2d.b2EdgeShape ? e : null, b, d instanceof box2d.b2CircleShape ? d : null, c)
};
goog.exportProperty(box2d.b2EdgeAndCircleContact.prototype, "Evaluate", box2d.b2EdgeAndCircleContact.prototype.Evaluate);
box2d.b2VelocityConstraintPoint = function() {
    this.rA = new box2d.b2Vec2;
    this.rB = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2VelocityConstraintPoint", box2d.b2VelocityConstraintPoint);
box2d.b2VelocityConstraintPoint.prototype.rA = null;
goog.exportProperty(box2d.b2VelocityConstraintPoint.prototype, "rA", box2d.b2VelocityConstraintPoint.prototype.rA);
box2d.b2VelocityConstraintPoint.prototype.rB = null;
goog.exportProperty(box2d.b2VelocityConstraintPoint.prototype, "rB", box2d.b2VelocityConstraintPoint.prototype.rB);
box2d.b2VelocityConstraintPoint.prototype.normalImpulse = 0;
goog.exportProperty(box2d.b2VelocityConstraintPoint.prototype, "normalImpulse", box2d.b2VelocityConstraintPoint.prototype.normalImpulse);
box2d.b2VelocityConstraintPoint.prototype.tangentImpulse = 0;
goog.exportProperty(box2d.b2VelocityConstraintPoint.prototype, "tangentImpulse", box2d.b2VelocityConstraintPoint.prototype.tangentImpulse);
box2d.b2VelocityConstraintPoint.prototype.normalMass = 0;
goog.exportProperty(box2d.b2VelocityConstraintPoint.prototype, "normalMass", box2d.b2VelocityConstraintPoint.prototype.normalMass);
box2d.b2VelocityConstraintPoint.prototype.tangentMass = 0;
goog.exportProperty(box2d.b2VelocityConstraintPoint.prototype, "tangentMass", box2d.b2VelocityConstraintPoint.prototype.tangentMass);
box2d.b2VelocityConstraintPoint.prototype.velocityBias = 0;
goog.exportProperty(box2d.b2VelocityConstraintPoint.prototype, "velocityBias", box2d.b2VelocityConstraintPoint.prototype.velocityBias);
box2d.b2VelocityConstraintPoint.MakeArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return new box2d.b2VelocityConstraintPoint
    })
};
goog.exportProperty(box2d.b2VelocityConstraintPoint, "MakeArray", box2d.b2VelocityConstraintPoint.MakeArray);
box2d.b2ContactVelocityConstraint = function() {
    this.points = box2d.b2VelocityConstraintPoint.MakeArray(box2d.b2_maxManifoldPoints);
    this.normal = new box2d.b2Vec2;
    this.tangent = new box2d.b2Vec2;
    this.normalMass = new box2d.b2Mat22;
    this.K = new box2d.b2Mat22
};
goog.exportSymbol("box2d.b2ContactVelocityConstraint", box2d.b2ContactVelocityConstraint);
box2d.b2ContactVelocityConstraint.prototype.points = null;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "points", box2d.b2ContactVelocityConstraint.prototype.points);
box2d.b2ContactVelocityConstraint.prototype.normal = null;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "normal", box2d.b2ContactVelocityConstraint.prototype.normal);
box2d.b2ContactVelocityConstraint.prototype.tangent = null;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "tangent", box2d.b2ContactVelocityConstraint.prototype.tangent);
box2d.b2ContactVelocityConstraint.prototype.normalMass = null;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "normalMass", box2d.b2ContactVelocityConstraint.prototype.normalMass);
box2d.b2ContactVelocityConstraint.prototype.K = null;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "K", box2d.b2ContactVelocityConstraint.prototype.K);
box2d.b2ContactVelocityConstraint.prototype.indexA = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "indexA", box2d.b2ContactVelocityConstraint.prototype.indexA);
box2d.b2ContactVelocityConstraint.prototype.indexB = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "indexB", box2d.b2ContactVelocityConstraint.prototype.indexB);
box2d.b2ContactVelocityConstraint.prototype.invMassA = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "invMassA", box2d.b2ContactVelocityConstraint.prototype.invMassA);
box2d.b2ContactVelocityConstraint.prototype.invMassB = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "invMassB", box2d.b2ContactVelocityConstraint.prototype.invMassB);
box2d.b2ContactVelocityConstraint.prototype.invIA = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "invIA", box2d.b2ContactVelocityConstraint.prototype.invIA);
box2d.b2ContactVelocityConstraint.prototype.invIB = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "invIB", box2d.b2ContactVelocityConstraint.prototype.invIB);
box2d.b2ContactVelocityConstraint.prototype.friction = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "friction", box2d.b2ContactVelocityConstraint.prototype.friction);
box2d.b2ContactVelocityConstraint.prototype.restitution = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "restitution", box2d.b2ContactVelocityConstraint.prototype.restitution);
box2d.b2ContactVelocityConstraint.prototype.tangentSpeed = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "tangentSpeed", box2d.b2ContactVelocityConstraint.prototype.tangentSpeed);
box2d.b2ContactVelocityConstraint.prototype.pointCount = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "pointCount", box2d.b2ContactVelocityConstraint.prototype.pointCount);
box2d.b2ContactVelocityConstraint.prototype.contactIndex = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "contactIndex", box2d.b2ContactVelocityConstraint.prototype.contactIndex);
box2d.b2ContactVelocityConstraint.MakeArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return new box2d.b2ContactVelocityConstraint
    })
};
goog.exportProperty(box2d.b2ContactVelocityConstraint, "MakeArray", box2d.b2ContactVelocityConstraint.MakeArray);
box2d.b2ContactPositionConstraint = function() {
    this.localPoints = box2d.b2Vec2.MakeArray(box2d.b2_maxManifoldPoints);
    this.localNormal = new box2d.b2Vec2;
    this.localPoint = new box2d.b2Vec2;
    this.localCenterA = new box2d.b2Vec2;
    this.localCenterB = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2ContactPositionConstraint", box2d.b2ContactPositionConstraint);
box2d.b2ContactPositionConstraint.prototype.localPoints = null;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "localPoints", box2d.b2ContactPositionConstraint.prototype.localPoints);
box2d.b2ContactPositionConstraint.prototype.localNormal = null;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "localNormal", box2d.b2ContactPositionConstraint.prototype.localNormal);
box2d.b2ContactPositionConstraint.prototype.localPoint = null;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "localPoint", box2d.b2ContactPositionConstraint.prototype.localPoint);
box2d.b2ContactPositionConstraint.prototype.indexA = 0;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "indexA", box2d.b2ContactPositionConstraint.prototype.indexA);
box2d.b2ContactPositionConstraint.prototype.indexB = 0;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "indexB", box2d.b2ContactPositionConstraint.prototype.indexB);
box2d.b2ContactPositionConstraint.prototype.invMassA = 0;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "invMassA", box2d.b2ContactPositionConstraint.prototype.invMassA);
box2d.b2ContactPositionConstraint.prototype.invMassB = 0;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "invMassB", box2d.b2ContactPositionConstraint.prototype.invMassB);
box2d.b2ContactPositionConstraint.prototype.localCenterA = null;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "localCenterA", box2d.b2ContactPositionConstraint.prototype.localCenterA);
box2d.b2ContactPositionConstraint.prototype.localCenterB = null;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "localCenterB", box2d.b2ContactPositionConstraint.prototype.localCenterB);
box2d.b2ContactPositionConstraint.prototype.invIA = 0;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "invIA", box2d.b2ContactPositionConstraint.prototype.invIA);
box2d.b2ContactPositionConstraint.prototype.invIB = 0;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "invIB", box2d.b2ContactPositionConstraint.prototype.invIB);
box2d.b2ContactPositionConstraint.prototype.type = box2d.b2ManifoldType.e_unknown;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "type", box2d.b2ContactPositionConstraint.prototype.type);
box2d.b2ContactPositionConstraint.prototype.radiusA = 0;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "radiusA", box2d.b2ContactPositionConstraint.prototype.radiusA);
box2d.b2ContactPositionConstraint.prototype.radiusB = 0;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "radiusB", box2d.b2ContactPositionConstraint.prototype.radiusB);
box2d.b2ContactPositionConstraint.prototype.pointCount = 0;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "pointCount", box2d.b2ContactPositionConstraint.prototype.pointCount);
box2d.b2ContactPositionConstraint.MakeArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return new box2d.b2ContactPositionConstraint
    })
};
goog.exportProperty(box2d.b2ContactPositionConstraint, "MakeArray", box2d.b2ContactPositionConstraint.MakeArray);
box2d.b2ContactSolverDef = function() {
    this.step = new box2d.b2TimeStep
};
goog.exportSymbol("box2d.b2ContactSolverDef", box2d.b2ContactSolverDef);
box2d.b2ContactSolverDef.prototype.step = null;
goog.exportProperty(box2d.b2ContactSolverDef.prototype, "step", box2d.b2ContactSolverDef.prototype.step);
box2d.b2ContactSolverDef.prototype.contacts = null;
goog.exportProperty(box2d.b2ContactSolverDef.prototype, "contacts", box2d.b2ContactSolverDef.prototype.contacts);
box2d.b2ContactSolverDef.prototype.count = 0;
goog.exportProperty(box2d.b2ContactSolverDef.prototype, "count", box2d.b2ContactSolverDef.prototype.count);
box2d.b2ContactSolverDef.prototype.positions = null;
goog.exportProperty(box2d.b2ContactSolverDef.prototype, "positions", box2d.b2ContactSolverDef.prototype.positions);
box2d.b2ContactSolverDef.prototype.velocities = null;
goog.exportProperty(box2d.b2ContactSolverDef.prototype, "velocities", box2d.b2ContactSolverDef.prototype.velocities);
box2d.b2ContactSolverDef.prototype.allocator = null;
goog.exportProperty(box2d.b2ContactSolverDef.prototype, "allocator", box2d.b2ContactSolverDef.prototype.allocator);
box2d.b2ContactSolver = function() {
    this.m_step = new box2d.b2TimeStep;
    this.m_positionConstraints = box2d.b2ContactPositionConstraint.MakeArray(1024);
    this.m_velocityConstraints = box2d.b2ContactVelocityConstraint.MakeArray(1024)
};
goog.exportSymbol("box2d.b2ContactSolver", box2d.b2ContactSolver);
box2d.b2ContactSolver.prototype.m_step = null;
goog.exportProperty(box2d.b2ContactSolver.prototype, "m_step", box2d.b2ContactSolver.prototype.m_step);
box2d.b2ContactSolver.prototype.m_positions = null;
goog.exportProperty(box2d.b2ContactSolver.prototype, "m_positions", box2d.b2ContactSolver.prototype.m_positions);
box2d.b2ContactSolver.prototype.m_velocities = null;
goog.exportProperty(box2d.b2ContactSolver.prototype, "m_velocities", box2d.b2ContactSolver.prototype.m_velocities);
box2d.b2ContactSolver.prototype.m_allocator = null;
goog.exportProperty(box2d.b2ContactSolver.prototype, "m_allocator", box2d.b2ContactSolver.prototype.m_allocator);
box2d.b2ContactSolver.prototype.m_positionConstraints = null;
goog.exportProperty(box2d.b2ContactSolver.prototype, "m_positionConstraints", box2d.b2ContactSolver.prototype.m_positionConstraints);
box2d.b2ContactSolver.prototype.m_velocityConstraints = null;
goog.exportProperty(box2d.b2ContactSolver.prototype, "m_velocityConstraints", box2d.b2ContactSolver.prototype.m_velocityConstraints);
box2d.b2ContactSolver.prototype.m_contacts = null;
goog.exportProperty(box2d.b2ContactSolver.prototype, "m_contacts", box2d.b2ContactSolver.prototype.m_contacts);
box2d.b2ContactSolver.prototype.m_count = 0;
goog.exportProperty(box2d.b2ContactSolver.prototype, "m_count", box2d.b2ContactSolver.prototype.m_count);
box2d.b2ContactSolver.prototype.Initialize = function(a) {
    this.m_step.Copy(a.step);
    this.m_allocator = a.allocator;
    this.m_count = a.count;
    if (this.m_positionConstraints.length < this.m_count) {
        var b = box2d.b2Max(2 * this.m_positionConstraints.length, this.m_count);
        for (box2d.DEBUG && window.console.log("box2d.b2ContactSolver.m_positionConstraints: " + b); this.m_positionConstraints.length < b; )
            this.m_positionConstraints[this.m_positionConstraints.length] = new box2d.b2ContactPositionConstraint
    }
    if (this.m_velocityConstraints.length <
            this.m_count)
        for (b = box2d.b2Max(2 * this.m_velocityConstraints.length, this.m_count), box2d.DEBUG && window.console.log("box2d.b2ContactSolver.m_velocityConstraints: " + b); this.m_velocityConstraints.length < b; )
            this.m_velocityConstraints[this.m_velocityConstraints.length] = new box2d.b2ContactVelocityConstraint;
    this.m_positions = a.positions;
    this.m_velocities = a.velocities;
    this.m_contacts = a.contacts;
    var c, e, d, f, g, h, l, k;
    a = 0;
    for (b = this.m_count; a < b; ++a)
        for (d = this.m_contacts[a], f = d.m_fixtureA, g = d.m_fixtureB, c = f.GetShape(),
                e = g.GetShape(), c = c.m_radius, e = e.m_radius, h = f.GetBody(), l = g.GetBody(), g = d.GetManifold(), k = g.pointCount, box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < k), f = this.m_velocityConstraints[a], f.friction = d.m_friction, f.restitution = d.m_restitution, f.tangentSpeed = d.m_tangentSpeed, f.indexA = h.m_islandIndex, f.indexB = l.m_islandIndex, f.invMassA = h.m_invMass, f.invMassB = l.m_invMass, f.invIA = h.m_invI, f.invIB = l.m_invI, f.contactIndex = a, f.pointCount = k, f.K.SetZero(), f.normalMass.SetZero(), d = this.m_positionConstraints[a], d.indexA =
                h.m_islandIndex, d.indexB = l.m_islandIndex, d.invMassA = h.m_invMass, d.invMassB = l.m_invMass, d.localCenterA.Copy(h.m_sweep.localCenter), d.localCenterB.Copy(l.m_sweep.localCenter), d.invIA = h.m_invI, d.invIB = l.m_invI, d.localNormal.Copy(g.localNormal), d.localPoint.Copy(g.localPoint), d.pointCount = k, d.radiusA = c, d.radiusB = e, d.type = g.type, c = 0, e = k; c < e; ++c)
            h = g.points[c], k = f.points[c], this.m_step.warmStarting ? (k.normalImpulse = this.m_step.dtRatio * h.normalImpulse, k.tangentImpulse = this.m_step.dtRatio * h.tangentImpulse) :
                    (k.normalImpulse = 0, k.tangentImpulse = 0), k.rA.SetZero(), k.rB.SetZero(), k.normalMass = 0, k.tangentMass = 0, k.velocityBias = 0, d.localPoints[c].Copy(h.localPoint);
    return this
};
goog.exportProperty(box2d.b2ContactSolver.prototype, "Initialize", box2d.b2ContactSolver.prototype.Initialize);
box2d.b2ContactSolver.prototype.InitializeVelocityConstraints = function() {
    var a, b, c, e, d, f, g, h, l, k, m, n, p, q, r, t, s, u, v, y, D = box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfA, x = box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfB, w = box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_worldManifold;
    a = 0;
    for (b = this.m_count; a < b; ++a) {
        d = this.m_velocityConstraints[a];
        f = this.m_positionConstraints[a];
        c = f.radiusA;
        e = f.radiusB;
        g = this.m_contacts[d.contactIndex].GetManifold();
        h = d.indexA;
        l = d.indexB;
        k = d.invMassA;
        m = d.invMassB;
        n = d.invIA;
        p = d.invIB;
        q = f.localCenterA;
        r = f.localCenterB;
        f = this.m_positions[h].c;
        t = this.m_positions[h].a;
        s = this.m_velocities[h].v;
        h = this.m_velocities[h].w;
        u = this.m_positions[l].c;
        v = this.m_positions[l].a;
        y = this.m_velocities[l].v;
        l = this.m_velocities[l].w;
        box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < g.pointCount);
        D.q.SetAngleRadians(t);
        x.q.SetAngleRadians(v);
        box2d.b2SubVV(f, box2d.b2MulRV(D.q, q, box2d.b2Vec2.s_t0), D.p);
        box2d.b2SubVV(u, box2d.b2MulRV(x.q, r, box2d.b2Vec2.s_t0),
                x.p);
        w.Initialize(g, D, c, x, e);
        d.normal.Copy(w.normal);
        box2d.b2CrossVOne(d.normal, d.tangent);
        e = d.pointCount;
        for (c = 0; c < e; ++c)
            g = d.points[c], box2d.b2SubVV(w.points[c], f, g.rA), box2d.b2SubVV(w.points[c], u, g.rB), q = box2d.b2CrossVV(g.rA, d.normal), r = box2d.b2CrossVV(g.rB, d.normal), q = k + m + n * q * q + p * r * r, g.normalMass = 0 < q ? 1 / q : 0, r = d.tangent, q = box2d.b2CrossVV(g.rA, r), r = box2d.b2CrossVV(g.rB, r), q = k + m + n * q * q + p * r * r, g.tangentMass = 0 < q ? 1 / q : 0, g.velocityBias = 0, q = box2d.b2DotVV(d.normal, box2d.b2SubVV(box2d.b2AddVCrossSV(y, l, g.rB,
                    box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(s, h, g.rA, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t0)), q < -box2d.b2_velocityThreshold && (g.velocityBias += -d.restitution * q);
        2 == d.pointCount && (s = d.points[0], u = d.points[1], f = box2d.b2CrossVV(s.rA, d.normal), s = box2d.b2CrossVV(s.rB, d.normal), h = box2d.b2CrossVV(u.rA, d.normal), l = box2d.b2CrossVV(u.rB, d.normal), u = k + m + n * f * f + p * s * s, y = k + m + n * h * h + p * l * l, k = k + m + n * f * h + p * s * l, u * u < 1E3 * (u * y - k * k) ? (d.K.ex.SetXY(u, k), d.K.ey.SetXY(k, y), d.K.GetInverse(d.normalMass)) : d.pointCount = 1)
    }
};
goog.exportProperty(box2d.b2ContactSolver.prototype, "InitializeVelocityConstraints", box2d.b2ContactSolver.prototype.InitializeVelocityConstraints);
box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfA = new box2d.b2Transform;
box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfB = new box2d.b2Transform;
box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_worldManifold = new box2d.b2WorldManifold;
box2d.b2ContactSolver.prototype.WarmStart = function() {
    var a, b, c, e, d, f, g, h, l, k, m, n, p, q, r, t, s, u, v = box2d.b2ContactSolver.prototype.WarmStart.s_P;
    a = 0;
    for (b = this.m_count; a < b; ++a) {
        d = this.m_velocityConstraints[a];
        f = d.indexA;
        g = d.indexB;
        h = d.invMassA;
        l = d.invIA;
        k = d.invMassB;
        m = d.invIB;
        e = d.pointCount;
        n = this.m_velocities[f].v;
        p = this.m_velocities[f].w;
        q = this.m_velocities[g].v;
        r = this.m_velocities[g].w;
        t = d.normal;
        s = d.tangent;
        for (c = 0; c < e; ++c)
            u = d.points[c], box2d.b2AddVV(box2d.b2MulSV(u.normalImpulse, t, box2d.b2Vec2.s_t0),
                    box2d.b2MulSV(u.tangentImpulse, s, box2d.b2Vec2.s_t1), v), p -= l * box2d.b2CrossVV(u.rA, v), n.SelfMulSub(h, v), r += m * box2d.b2CrossVV(u.rB, v), q.SelfMulAdd(k, v);
        this.m_velocities[f].w = p;
        this.m_velocities[g].w = r
    }
};
goog.exportProperty(box2d.b2ContactSolver.prototype, "WarmStart", box2d.b2ContactSolver.prototype.WarmStart);
box2d.b2ContactSolver.prototype.WarmStart.s_P = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints = function() {
    var a, b, c, e, d, f, g, h, l, k, m, n, p, q, r, t, s, u, v, y = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv, D = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv1, x = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv2, w, C, A = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P, E = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_a, B = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_b, z = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_x,
            G = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_d, F = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1, H = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P2, I = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1P2;
    a = 0;
    for (b = this.m_count; a < b; ++a) {
        d = this.m_velocityConstraints[a];
        f = d.indexA;
        g = d.indexB;
        h = d.invMassA;
        l = d.invIA;
        k = d.invMassB;
        m = d.invIB;
        n = d.pointCount;
        p = this.m_velocities[f].v;
        q = this.m_velocities[f].w;
        r = this.m_velocities[g].v;
        t = this.m_velocities[g].w;
        s = d.normal;
        u = d.tangent;
        v = d.friction;
        box2d.ENABLE_ASSERTS && box2d.b2Assert(1 == n || 2 == n);
        c = 0;
        for (e = n; c < e; ++c)
            n = d.points[c], box2d.b2SubVV(box2d.b2AddVCrossSV(r, t, n.rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(p, q, n.rA, box2d.b2Vec2.s_t1), y), w = box2d.b2DotVV(y, u) - d.tangentSpeed, w = n.tangentMass * -w, C = v * n.normalImpulse, C = box2d.b2Clamp(n.tangentImpulse + w, -C, C), w = C - n.tangentImpulse, n.tangentImpulse = C, box2d.b2MulSV(w, u, A), p.SelfMulSub(h, A), q -= l * box2d.b2CrossVV(n.rA, A), r.SelfMulAdd(k, A), t += m * box2d.b2CrossVV(n.rB, A);
        if (1 == d.pointCount)
            n = d.points[0], box2d.b2SubVV(box2d.b2AddVCrossSV(r, t, n.rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(p, q, n.rA, box2d.b2Vec2.s_t1), y), d = box2d.b2DotVV(y, s), w = -n.normalMass * (d - n.velocityBias), C = box2d.b2Max(n.normalImpulse + w, 0), w = C - n.normalImpulse, n.normalImpulse = C, box2d.b2MulSV(w, s, A), p.SelfMulSub(h, A), q -= l * box2d.b2CrossVV(n.rA, A), r.SelfMulAdd(k, A), t += m * box2d.b2CrossVV(n.rB, A);
        else
            for (c = d.points[0], u = d.points[1], E.SetXY(c.normalImpulse, u.normalImpulse), box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <=
                    E.x && 0 <= E.y), box2d.b2SubVV(box2d.b2AddVCrossSV(r, t, c.rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(p, q, c.rA, box2d.b2Vec2.s_t1), D), box2d.b2SubVV(box2d.b2AddVCrossSV(r, t, u.rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(p, q, u.rA, box2d.b2Vec2.s_t1), x), v = box2d.b2DotVV(D, s), n = box2d.b2DotVV(x, s), B.x = v - c.velocityBias, B.y = n - u.velocityBias, B.SelfSub(box2d.b2MulMV(d.K, E, box2d.b2Vec2.s_t0)); ; ) {
                box2d.b2MulMV(d.normalMass, B, z).SelfNeg();
                if (0 <= z.x && 0 <= z.y) {
                    box2d.b2SubVV(z, E, G);
                    box2d.b2MulSV(G.x, s, F);
                    box2d.b2MulSV(G.y, s,
                            H);
                    box2d.b2AddVV(F, H, I);
                    p.SelfMulSub(h, I);
                    q -= l * (box2d.b2CrossVV(c.rA, F) + box2d.b2CrossVV(u.rA, H));
                    r.SelfMulAdd(k, I);
                    t += m * (box2d.b2CrossVV(c.rB, F) + box2d.b2CrossVV(u.rB, H));
                    c.normalImpulse = z.x;
                    u.normalImpulse = z.y;
                    break
                }
                z.x = -c.normalMass * B.x;
                z.y = 0;
                n = d.K.ex.y * z.x + B.y;
                if (0 <= z.x && 0 <= n) {
                    box2d.b2SubVV(z, E, G);
                    box2d.b2MulSV(G.x, s, F);
                    box2d.b2MulSV(G.y, s, H);
                    box2d.b2AddVV(F, H, I);
                    p.SelfMulSub(h, I);
                    q -= l * (box2d.b2CrossVV(c.rA, F) + box2d.b2CrossVV(u.rA, H));
                    r.SelfMulAdd(k, I);
                    t += m * (box2d.b2CrossVV(c.rB, F) + box2d.b2CrossVV(u.rB,
                            H));
                    c.normalImpulse = z.x;
                    u.normalImpulse = z.y;
                    break
                }
                z.x = 0;
                z.y = -u.normalMass * B.y;
                v = d.K.ey.x * z.y + B.x;
                if (0 <= z.y && 0 <= v) {
                    box2d.b2SubVV(z, E, G);
                    box2d.b2MulSV(G.x, s, F);
                    box2d.b2MulSV(G.y, s, H);
                    box2d.b2AddVV(F, H, I);
                    p.SelfMulSub(h, I);
                    q -= l * (box2d.b2CrossVV(c.rA, F) + box2d.b2CrossVV(u.rA, H));
                    r.SelfMulAdd(k, I);
                    t += m * (box2d.b2CrossVV(c.rB, F) + box2d.b2CrossVV(u.rB, H));
                    c.normalImpulse = z.x;
                    u.normalImpulse = z.y;
                    break
                }
                z.x = 0;
                z.y = 0;
                v = B.x;
                n = B.y;
                if (0 <= v && 0 <= n) {
                    box2d.b2SubVV(z, E, G);
                    box2d.b2MulSV(G.x, s, F);
                    box2d.b2MulSV(G.y, s, H);
                    box2d.b2AddVV(F,
                            H, I);
                    p.SelfMulSub(h, I);
                    q -= l * (box2d.b2CrossVV(c.rA, F) + box2d.b2CrossVV(u.rA, H));
                    r.SelfMulAdd(k, I);
                    t += m * (box2d.b2CrossVV(c.rB, F) + box2d.b2CrossVV(u.rB, H));
                    c.normalImpulse = z.x;
                    u.normalImpulse = z.y;
                    break
                }
                break
            }
        this.m_velocities[f].w = q;
        this.m_velocities[g].w = t
    }
};
goog.exportProperty(box2d.b2ContactSolver.prototype, "SolveVelocityConstraints", box2d.b2ContactSolver.prototype.SolveVelocityConstraints);
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv1 = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv2 = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_a = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_b = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_x = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_d = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1 = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P2 = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1P2 = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.StoreImpulses = function() {
    var a, b, c, e, d, f;
    a = 0;
    for (b = this.m_count; a < b; ++a)
        for (d = this.m_velocityConstraints[a], f = this.m_contacts[d.contactIndex].GetManifold(), c = 0, e = d.pointCount; c < e; ++c)
            f.points[c].normalImpulse = d.points[c].normalImpulse, f.points[c].tangentImpulse = d.points[c].tangentImpulse
};
goog.exportProperty(box2d.b2ContactSolver.prototype, "StoreImpulses", box2d.b2ContactSolver.prototype.StoreImpulses);
box2d.b2PositionSolverManifold = function() {
    this.normal = new box2d.b2Vec2;
    this.point = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2PositionSolverManifold", box2d.b2PositionSolverManifold);
box2d.b2PositionSolverManifold.prototype.normal = null;
goog.exportProperty(box2d.b2PositionSolverManifold.prototype, "normal", box2d.b2PositionSolverManifold.prototype.normal);
box2d.b2PositionSolverManifold.prototype.point = null;
goog.exportProperty(box2d.b2PositionSolverManifold.prototype, "point", box2d.b2PositionSolverManifold.prototype.point);
box2d.b2PositionSolverManifold.prototype.separation = 0;
goog.exportProperty(box2d.b2PositionSolverManifold.prototype, "separation", box2d.b2PositionSolverManifold.prototype.separation);
box2d.b2PositionSolverManifold.prototype.Initialize = function(a, b, c, e) {
    var d = box2d.b2PositionSolverManifold.prototype.Initialize.s_pointA, f = box2d.b2PositionSolverManifold.prototype.Initialize.s_pointB, g = box2d.b2PositionSolverManifold.prototype.Initialize.s_planePoint, h = box2d.b2PositionSolverManifold.prototype.Initialize.s_clipPoint;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < a.pointCount);
    switch (a.type) {
        case box2d.b2ManifoldType.e_circles:
            box2d.b2MulXV(b, a.localPoint, d);
            box2d.b2MulXV(c, a.localPoints[0],
                    f);
            box2d.b2SubVV(f, d, this.normal).SelfNormalize();
            box2d.b2MidVV(d, f, this.point);
            this.separation = box2d.b2DotVV(box2d.b2SubVV(f, d, box2d.b2Vec2.s_t0), this.normal) - a.radiusA - a.radiusB;
            break;
        case box2d.b2ManifoldType.e_faceA:
            box2d.b2MulRV(b.q, a.localNormal, this.normal);
            box2d.b2MulXV(b, a.localPoint, g);
            box2d.b2MulXV(c, a.localPoints[e], h);
            this.separation = box2d.b2DotVV(box2d.b2SubVV(h, g, box2d.b2Vec2.s_t0), this.normal) - a.radiusA - a.radiusB;
            this.point.Copy(h);
            break;
        case box2d.b2ManifoldType.e_faceB:
            box2d.b2MulRV(c.q,
                    a.localNormal, this.normal), box2d.b2MulXV(c, a.localPoint, g), box2d.b2MulXV(b, a.localPoints[e], h), this.separation = box2d.b2DotVV(box2d.b2SubVV(h, g, box2d.b2Vec2.s_t0), this.normal) - a.radiusA - a.radiusB, this.point.Copy(h), this.normal.SelfNeg()
        }
};
goog.exportProperty(box2d.b2PositionSolverManifold.prototype, "Initialize", box2d.b2PositionSolverManifold.prototype.Initialize);
box2d.b2PositionSolverManifold.prototype.Initialize.s_pointA = new box2d.b2Vec2;
box2d.b2PositionSolverManifold.prototype.Initialize.s_pointB = new box2d.b2Vec2;
box2d.b2PositionSolverManifold.prototype.Initialize.s_planePoint = new box2d.b2Vec2;
box2d.b2PositionSolverManifold.prototype.Initialize.s_clipPoint = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolvePositionConstraints = function() {
    var a, b, c, e, d, f, g, h, l, k, m, n, p, q, r, t, s, u = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfA, v = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfB, y = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_psm, D, x, w, C = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rA, A = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rB, E, B = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_P, z =
            0;
    a = 0;
    for (b = this.m_count; a < b; ++a) {
        d = this.m_positionConstraints[a];
        f = d.indexA;
        g = d.indexB;
        h = d.localCenterA;
        l = d.invMassA;
        k = d.invIA;
        m = d.localCenterB;
        n = d.invMassB;
        p = d.invIB;
        e = d.pointCount;
        q = this.m_positions[f].c;
        r = this.m_positions[f].a;
        t = this.m_positions[g].c;
        s = this.m_positions[g].a;
        for (c = 0; c < e; ++c)
            u.q.SetAngleRadians(r), v.q.SetAngleRadians(s), box2d.b2SubVV(q, box2d.b2MulRV(u.q, h, box2d.b2Vec2.s_t0), u.p), box2d.b2SubVV(t, box2d.b2MulRV(v.q, m, box2d.b2Vec2.s_t0), v.p), y.Initialize(d, u, v, c), D = y.normal, x = y.point,
                    w = y.separation, box2d.b2SubVV(x, q, C), box2d.b2SubVV(x, t, A), z = box2d.b2Min(z, w), x = box2d.b2Clamp(box2d.b2_baumgarte * (w + box2d.b2_linearSlop), -box2d.b2_maxLinearCorrection, 0), w = box2d.b2CrossVV(C, D), E = box2d.b2CrossVV(A, D), w = l + n + k * w * w + p * E * E, x = 0 < w ? -x / w : 0, box2d.b2MulSV(x, D, B), q.SelfMulSub(l, B), r -= k * box2d.b2CrossVV(C, B), t.SelfMulAdd(n, B), s += p * box2d.b2CrossVV(A, B);
        this.m_positions[f].a = r;
        this.m_positions[g].a = s
    }
    return z > -3 * box2d.b2_linearSlop
};
goog.exportProperty(box2d.b2ContactSolver.prototype, "SolvePositionConstraints", box2d.b2ContactSolver.prototype.SolvePositionConstraints);
box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfA = new box2d.b2Transform;
box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfB = new box2d.b2Transform;
box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_psm = new box2d.b2PositionSolverManifold;
box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rA = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rB = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints = function(a, b) {
    var c, e, d, f, g, h, l, k, m, n, p, q, r, t, s, u, v, y = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfA, D = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfB, x = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_psm, w, C, A, E = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rA, B = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rB, z, G = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_P,
            F = 0;
    c = 0;
    for (e = this.m_count; c < e; ++c) {
        g = this.m_positionConstraints[c];
        h = g.indexA;
        l = g.indexB;
        k = g.localCenterA;
        m = g.localCenterB;
        f = g.pointCount;
        p = n = 0;
        if (h == a || h == b)
            n = g.invMassA, p = g.invIA;
        r = q = 0;
        if (l == a || l == b)
            q = g.invMassB, r = g.invIB;
        t = this.m_positions[h].c;
        s = this.m_positions[h].a;
        u = this.m_positions[l].c;
        v = this.m_positions[l].a;
        for (d = 0; d < f; ++d)
            y.q.SetAngleRadians(s), D.q.SetAngleRadians(v), box2d.b2SubVV(t, box2d.b2MulRV(y.q, k, box2d.b2Vec2.s_t0), y.p), box2d.b2SubVV(u, box2d.b2MulRV(D.q, m, box2d.b2Vec2.s_t0), D.p),
                    x.Initialize(g, y, D, d), w = x.normal, C = x.point, A = x.separation, box2d.b2SubVV(C, t, E), box2d.b2SubVV(C, u, B), F = box2d.b2Min(F, A), C = box2d.b2Clamp(box2d.b2_toiBaumgarte * (A + box2d.b2_linearSlop), -box2d.b2_maxLinearCorrection, 0), A = box2d.b2CrossVV(E, w), z = box2d.b2CrossVV(B, w), A = n + q + p * A * A + r * z * z, C = 0 < A ? -C / A : 0, box2d.b2MulSV(C, w, G), t.SelfMulSub(n, G), s -= p * box2d.b2CrossVV(E, G), u.SelfMulAdd(q, G), v += r * box2d.b2CrossVV(B, G);
        this.m_positions[h].a = s;
        this.m_positions[l].a = v
    }
    return F >= -1.5 * box2d.b2_linearSlop
};
goog.exportProperty(box2d.b2ContactSolver.prototype, "SolveTOIPositionConstraints", box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints);
box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfA = new box2d.b2Transform;
box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfB = new box2d.b2Transform;
box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_psm = new box2d.b2PositionSolverManifold;
box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rA = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rB = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_P = new box2d.b2Vec2;
box2d.b2WorldCallbacks = {};
box2d.b2DestructionListener = function() {
};
goog.exportSymbol("box2d.b2DestructionListener", box2d.b2DestructionListener);
box2d.b2DestructionListener.prototype.SayGoodbyeJoint = function(a) {
};
goog.exportProperty(box2d.b2DestructionListener.prototype, "SayGoodbyeJoint", box2d.b2DestructionListener.prototype.SayGoodbyeJoint);
box2d.b2DestructionListener.prototype.SayGoodbyeFixture = function(a) {
};
goog.exportProperty(box2d.b2DestructionListener.prototype, "SayGoodbyeFixture", box2d.b2DestructionListener.prototype.SayGoodbyeFixture);
box2d.b2ContactFilter = function() {
};
goog.exportSymbol("box2d.b2ContactFilter", box2d.b2ContactFilter);
box2d.b2ContactFilter.prototype.ShouldCollide = function(a, b) {
    var c = a.GetFilterData(), e = b.GetFilterData();
    return c.groupIndex == e.groupIndex && 0 != c.groupIndex ? 0 < c.groupIndex : 0 != (c.maskBits & e.categoryBits) && 0 != (c.categoryBits & e.maskBits)
};
goog.exportProperty(box2d.b2ContactFilter.prototype, "ShouldCollide", box2d.b2ContactFilter.prototype.ShouldCollide);
box2d.b2ContactFilter.b2_defaultFilter = new box2d.b2ContactFilter;
box2d.b2ContactImpulse = function() {
    this.normalImpulses = box2d.b2MakeNumberArray(box2d.b2_maxManifoldPoints);
    this.tangentImpulses = box2d.b2MakeNumberArray(box2d.b2_maxManifoldPoints)
};
goog.exportSymbol("box2d.b2ContactImpulse", box2d.b2ContactImpulse);
box2d.b2ContactImpulse.prototype.normalImpulses = null;
box2d.b2ContactImpulse.prototype.tangentImpulses = null;
box2d.b2ContactImpulse.prototype.count = 0;
box2d.b2ContactListener = function() {
};
goog.exportSymbol("box2d.b2ContactListener", box2d.b2ContactListener);
box2d.b2ContactListener.prototype.BeginContact = function(a) {
};
goog.exportProperty(box2d.b2ContactListener.prototype, "BeginContact", box2d.b2ContactListener.prototype.BeginContact);
box2d.b2ContactListener.prototype.EndContact = function(a) {
};
goog.exportProperty(box2d.b2ContactListener.prototype, "EndContact", box2d.b2ContactListener.prototype.EndContact);
box2d.b2ContactListener.prototype.PreSolve = function(a, b) {
};
goog.exportProperty(box2d.b2ContactListener.prototype, "PreSolve", box2d.b2ContactListener.prototype.PreSolve);
box2d.b2ContactListener.prototype.PostSolve = function(a, b) {
};
goog.exportProperty(box2d.b2ContactListener.prototype, "PostSolve", box2d.b2ContactListener.prototype.PostSolve);
box2d.b2ContactListener.b2_defaultListener = new box2d.b2ContactListener;
goog.exportProperty(box2d.b2ContactListener, "b2_defaultListener", box2d.b2ContactListener.b2_defaultListener);
box2d.b2QueryCallback = function() {
};
goog.exportSymbol("box2d.b2QueryCallback", box2d.b2QueryCallback);
box2d.b2QueryCallback.prototype.ReportFixture = function(a) {
    return!0
};
goog.exportProperty(box2d.b2QueryCallback.prototype, "ReportFixture", box2d.b2QueryCallback.prototype.ReportFixture);
box2d.b2RayCastCallback = function() {
};
goog.exportSymbol("box2d.b2RayCastCallback", box2d.b2RayCastCallback);
box2d.b2RayCastCallback.prototype.ReportFixture = function(a, b, c, e) {
    return e
};
goog.exportProperty(box2d.b2RayCastCallback.prototype, "ReportFixture", box2d.b2RayCastCallback.prototype.ReportFixture);
box2d.b2Island = function() {
    this.m_bodies = Array(1024);
    this.m_contacts = Array(1024);
    this.m_joints = Array(1024);
    this.m_positions = box2d.b2Position.MakeArray(1024);
    this.m_velocities = box2d.b2Velocity.MakeArray(1024)
};
goog.exportSymbol("box2d.b2Island", box2d.b2Island);
box2d.b2Island.prototype.m_allocator = null;
goog.exportProperty(box2d.b2Island.prototype, "m_allocator", box2d.b2Island.prototype.m_allocator);
box2d.b2Island.prototype.m_listener = null;
goog.exportProperty(box2d.b2Island.prototype, "m_listener", box2d.b2Island.prototype.m_listener);
box2d.b2Island.prototype.m_bodies = null;
goog.exportProperty(box2d.b2Island.prototype, "m_bodies", box2d.b2Island.prototype.m_bodies);
box2d.b2Island.prototype.m_contacts = null;
goog.exportProperty(box2d.b2Island.prototype, "m_contacts", box2d.b2Island.prototype.m_contacts);
box2d.b2Island.prototype.m_joints = null;
goog.exportProperty(box2d.b2Island.prototype, "m_joints", box2d.b2Island.prototype.m_joints);
box2d.b2Island.prototype.m_positions = null;
goog.exportProperty(box2d.b2Island.prototype, "m_positions", box2d.b2Island.prototype.m_positions);
box2d.b2Island.prototype.m_velocities = null;
goog.exportProperty(box2d.b2Island.prototype, "m_velocities", box2d.b2Island.prototype.m_velocities);
box2d.b2Island.prototype.m_bodyCount = 0;
goog.exportProperty(box2d.b2Island.prototype, "m_bodyCount", box2d.b2Island.prototype.m_bodyCount);
box2d.b2Island.prototype.m_jointCount = 0;
goog.exportProperty(box2d.b2Island.prototype, "m_jointCount", box2d.b2Island.prototype.m_jointCount);
box2d.b2Island.prototype.m_contactCount = 0;
goog.exportProperty(box2d.b2Island.prototype, "m_contactCount", box2d.b2Island.prototype.m_contactCount);
box2d.b2Island.prototype.m_bodyCapacity = 0;
goog.exportProperty(box2d.b2Island.prototype, "m_bodyCapacity", box2d.b2Island.prototype.m_bodyCapacity);
box2d.b2Island.prototype.m_contactCapacity = 0;
goog.exportProperty(box2d.b2Island.prototype, "m_contactCapacity", box2d.b2Island.prototype.m_contactCapacity);
box2d.b2Island.prototype.m_jointCapacity = 0;
goog.exportProperty(box2d.b2Island.prototype, "m_jointCapacity", box2d.b2Island.prototype.m_jointCapacity);
box2d.b2Island.prototype.Initialize = function(a, b, c, e, d) {
    this.m_bodyCapacity = a;
    this.m_contactCapacity = b;
    this.m_jointCapacity = c;
    this.m_jointCount = this.m_contactCount = this.m_bodyCount = 0;
    this.m_allocator = e;
    for (this.m_listener = d; this.m_bodies.length < a; )
        this.m_bodies[this.m_bodies.length] = null;
    for (; this.m_contacts.length < b; )
        this.m_contacts[this.m_contacts.length] = null;
    for (; this.m_joints.length < c; )
        this.m_joints[this.m_joints.length] = null;
    if (this.m_positions.length < a)
        for (b = box2d.b2Max(2 * this.m_positions.length,
                a), box2d.DEBUG && window.console.log("box2d.b2Island.m_positions: " + b); this.m_positions.length < b; )
            this.m_positions[this.m_positions.length] = new box2d.b2Position;
    if (this.m_velocities.length < a)
        for (b = box2d.b2Max(2 * this.m_velocities.length, a), box2d.DEBUG && window.console.log("box2d.b2Island.m_velocities: " + b); this.m_velocities.length < b; )
            this.m_velocities[this.m_velocities.length] = new box2d.b2Velocity
};
goog.exportProperty(box2d.b2Island.prototype, "Initialize", box2d.b2Island.prototype.Initialize);
box2d.b2Island.prototype.Clear = function() {
    this.m_jointCount = this.m_contactCount = this.m_bodyCount = 0
};
goog.exportProperty(box2d.b2Island.prototype, "Clear", box2d.b2Island.prototype.Clear);
box2d.b2Island.prototype.AddBody = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_bodyCount < this.m_bodyCapacity);
    a.m_islandIndex = this.m_bodyCount;
    this.m_bodies[this.m_bodyCount++] = a
};
goog.exportProperty(box2d.b2Island.prototype, "AddBody", box2d.b2Island.prototype.AddBody);
box2d.b2Island.prototype.AddContact = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_contactCount < this.m_contactCapacity);
    this.m_contacts[this.m_contactCount++] = a
};
goog.exportProperty(box2d.b2Island.prototype, "AddContact", box2d.b2Island.prototype.AddContact);
box2d.b2Island.prototype.AddJoint = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_jointCount < this.m_jointCapacity);
    this.m_joints[this.m_jointCount++] = a
};
goog.exportProperty(box2d.b2Island.prototype, "AddJoint", box2d.b2Island.prototype.AddJoint);
box2d.b2Island.prototype.Solve = function(a, b, c, e) {
    for (var d = box2d.b2Island.s_timer.Reset(), f = b.dt, g = 0; g < this.m_bodyCount; ++g) {
        var h = this.m_bodies[g], l = this.m_positions[g].c.Copy(h.m_sweep.c), k = h.m_sweep.a, m = this.m_velocities[g].v.Copy(h.m_linearVelocity), n = h.m_angularVelocity;
        h.m_sweep.c0.Copy(h.m_sweep.c);
        h.m_sweep.a0 = h.m_sweep.a;
        h.m_type == box2d.b2BodyType.b2_dynamicBody && (m.x += f * (h.m_gravityScale * c.x + h.m_invMass * h.m_force.x), m.y += f * (h.m_gravityScale * c.y + h.m_invMass * h.m_force.y), n += f * h.m_invI * h.m_torque,
                m.SelfMul(box2d.b2Clamp(1 - f * h.m_linearDamping, 0, 1)), n *= box2d.b2Clamp(1 - f * h.m_angularDamping, 0, 1));
        this.m_positions[g].a = k;
        this.m_velocities[g].w = n
    }
    d.Reset();
    h = box2d.b2Island.s_solverData;
    h.step.Copy(b);
    h.positions = this.m_positions;
    h.velocities = this.m_velocities;
    g = box2d.b2Island.s_contactSolverDef;
    g.step.Copy(b);
    g.contacts = this.m_contacts;
    g.count = this.m_contactCount;
    g.positions = this.m_positions;
    g.velocities = this.m_velocities;
    g.allocator = this.m_allocator;
    c = box2d.b2Island.s_contactSolver.Initialize(g);
    c.InitializeVelocityConstraints();
    b.warmStarting && c.WarmStart();
    for (g = 0; g < this.m_jointCount; ++g)
        this.m_joints[g].InitVelocityConstraints(h);
    a.solveInit = d.GetMilliseconds();
    d.Reset();
    for (g = 0; g < b.velocityIterations; ++g) {
        for (k = 0; k < this.m_jointCount; ++k)
            this.m_joints[k].SolveVelocityConstraints(h);
        c.SolveVelocityConstraints()
    }
    c.StoreImpulses();
    a.solveVelocity = d.GetMilliseconds();
    for (g = 0; g < this.m_bodyCount; ++g) {
        var l = this.m_positions[g].c, k = this.m_positions[g].a, m = this.m_velocities[g].v, n = this.m_velocities[g].w,
                p = box2d.b2MulSV(f, m, box2d.b2Island.s_translation);
        box2d.b2DotVV(p, p) > box2d.b2_maxTranslationSquared && (p = box2d.b2_maxTranslation / p.GetLength(), m.SelfMul(p));
        p = f * n;
        p * p > box2d.b2_maxRotationSquared && (p = box2d.b2_maxRotation / box2d.b2Abs(p), n *= p);
        l.x += f * m.x;
        l.y += f * m.y;
        k += f * n;
        this.m_positions[g].a = k;
        this.m_velocities[g].w = n
    }
    d.Reset();
    l = !1;
    for (g = 0; g < b.positionIterations; ++g) {
        m = c.SolvePositionConstraints();
        n = !0;
        for (k = 0; k < this.m_jointCount; ++k)
            p = this.m_joints[k].SolvePositionConstraints(h), n = n && p;
        if (m && n) {
            l =
                    !0;
            break
        }
    }
    for (g = 0; g < this.m_bodyCount; ++g)
        b = this.m_bodies[g], b.m_sweep.c.Copy(this.m_positions[g].c), b.m_sweep.a = this.m_positions[g].a, b.m_linearVelocity.Copy(this.m_velocities[g].v), b.m_angularVelocity = this.m_velocities[g].w, b.SynchronizeTransform();
    a.solvePosition = d.GetMilliseconds();
    this.Report(c.m_velocityConstraints);
    if (e) {
        a = box2d.b2_maxFloat;
        e = box2d.b2_linearSleepTolerance * box2d.b2_linearSleepTolerance;
        d = box2d.b2_angularSleepTolerance * box2d.b2_angularSleepTolerance;
        for (g = 0; g < this.m_bodyCount; ++g)
            h =
                    this.m_bodies[g], h.GetType() != box2d.b2BodyType.b2_staticBody && (0 == (h.m_flags & box2d.b2BodyFlag.e_autoSleepFlag) || h.m_angularVelocity * h.m_angularVelocity > d || box2d.b2DotVV(h.m_linearVelocity, h.m_linearVelocity) > e ? a = h.m_sleepTime = 0 : (h.m_sleepTime += f, a = box2d.b2Min(a, h.m_sleepTime)));
        if (a >= box2d.b2_timeToSleep && l)
            for (g = 0; g < this.m_bodyCount; ++g)
                h = this.m_bodies[g], h.SetAwake(!1)
    }
};
goog.exportProperty(box2d.b2Island.prototype, "Solve", box2d.b2Island.prototype.Solve);
box2d.b2Island.prototype.SolveTOI = function(a, b, c) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(b < this.m_bodyCount);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(c < this.m_bodyCount);
    for (var e = 0; e < this.m_bodyCount; ++e) {
        var d = this.m_bodies[e];
        this.m_positions[e].c.Copy(d.m_sweep.c);
        this.m_positions[e].a = d.m_sweep.a;
        this.m_velocities[e].v.Copy(d.m_linearVelocity);
        this.m_velocities[e].w = d.m_angularVelocity
    }
    e = box2d.b2Island.s_contactSolverDef;
    e.contacts = this.m_contacts;
    e.count = this.m_contactCount;
    e.allocator = this.m_allocator;
    e.step.Copy(a);
    e.positions = this.m_positions;
    e.velocities = this.m_velocities;
    d = box2d.b2Island.s_contactSolver.Initialize(e);
    for (e = 0; e < a.positionIterations && !d.SolveTOIPositionConstraints(b, c); ++e){};
    this.m_bodies[b].m_sweep.c0.Copy(this.m_positions[b].c);
    this.m_bodies[b].m_sweep.a0 = this.m_positions[b].a;
    this.m_bodies[c].m_sweep.c0.Copy(this.m_positions[c].c);
    this.m_bodies[c].m_sweep.a0 = this.m_positions[c].a;
    d.InitializeVelocityConstraints();
    for (e = 0; e < a.velocityIterations; ++e)
        d.SolveVelocityConstraints();
    a = a.dt;
    for (e = 0; e < this.m_bodyCount; ++e) {
        b = this.m_positions[e].c;
        c = this.m_positions[e].a;
        var f = this.m_velocities[e].v, g = this.m_velocities[e].w, h = box2d.b2MulSV(a, f, box2d.b2Island.s_translation);
        box2d.b2DotVV(h, h) > box2d.b2_maxTranslationSquared && (h = box2d.b2_maxTranslation / h.GetLength(), f.SelfMul(h));
        h = a * g;
        h * h > box2d.b2_maxRotationSquared && (h = box2d.b2_maxRotation / box2d.b2Abs(h), g *= h);
        b.SelfMulAdd(a, f);
        c += a * g;
        this.m_positions[e].a = c;
        this.m_velocities[e].w = g;
        h = this.m_bodies[e];
        h.m_sweep.c.Copy(b);
        h.m_sweep.a =
                c;
        h.m_linearVelocity.Copy(f);
        h.m_angularVelocity = g;
        h.SynchronizeTransform()
    }
    this.Report(d.m_velocityConstraints)
};
goog.exportProperty(box2d.b2Island.prototype, "SolveTOI", box2d.b2Island.prototype.SolveTOI);
box2d.b2Island.prototype.Report = function(a) {
    if (null != this.m_listener)
        for (var b = 0; b < this.m_contactCount; ++b) {
            var c = this.m_contacts[b];
            if (c) {
                var e = a[b], d = box2d.b2Island.s_impulse;
                d.count = e.pointCount;
                for (var f = 0; f < e.pointCount; ++f)
                    d.normalImpulses[f] = e.points[f].normalImpulse, d.tangentImpulses[f] = e.points[f].tangentImpulse;
                this.m_listener.PostSolve(c, d)
            }
        }
};
goog.exportProperty(box2d.b2Island.prototype, "Report", box2d.b2Island.prototype.Report);
box2d.b2Island.s_timer = new box2d.b2Timer;
box2d.b2Island.s_solverData = new box2d.b2SolverData;
box2d.b2Island.s_contactSolverDef = new box2d.b2ContactSolverDef;
box2d.b2Island.s_contactSolver = new box2d.b2ContactSolver;
box2d.b2Island.s_translation = new box2d.b2Vec2;
box2d.b2Island.s_impulse = new box2d.b2ContactImpulse;
box2d.b2ContactRegister = function() {
};
goog.exportSymbol("box2d.b2ContactRegister", box2d.b2ContactRegister);
box2d.b2ContactRegister.prototype.createFcn = null;
box2d.b2ContactRegister.prototype.destroyFcn = null;
box2d.b2ContactRegister.prototype.primary = !1;
box2d.b2ContactFactory = function(a) {
    this.m_allocator = a;
    this.InitializeRegisters()
};
goog.exportSymbol("box2d.b2ContactFactory", box2d.b2ContactFactory);
box2d.b2ContactFactory.prototype.m_allocator = null;
box2d.b2ContactFactory.prototype.AddType = function(a, b, c, e) {
    var d = box2d.b2MakeArray(256, function(b) {
        return a()
    });
    b = function(b) {
        return 0 < d.length ? d.pop() : a(b)
    };
    var f = function(a, b) {
        d.push(a)
    };
    this.m_registers[c][e].pool = d;
    this.m_registers[c][e].createFcn = b;
    this.m_registers[c][e].destroyFcn = f;
    this.m_registers[c][e].primary = !0;
    c != e && (this.m_registers[e][c].pool = d, this.m_registers[e][c].createFcn = b, this.m_registers[e][c].destroyFcn = f, this.m_registers[e][c].primary = !1)
};
goog.exportProperty(box2d.b2ContactFactory.prototype, "AddType", box2d.b2ContactFactory.prototype.AddType);
box2d.b2ContactFactory.prototype.InitializeRegisters = function() {
    this.m_registers = Array(box2d.b2ShapeType.e_shapeTypeCount);
    for (var a = 0; a < box2d.b2ShapeType.e_shapeTypeCount; a++) {
        this.m_registers[a] = Array(box2d.b2ShapeType.e_shapeTypeCount);
        for (var b = 0; b < box2d.b2ShapeType.e_shapeTypeCount; b++)
            this.m_registers[a][b] = new box2d.b2ContactRegister
    }
    this.AddType(box2d.b2CircleContact.Create, box2d.b2CircleContact.Destroy, box2d.b2ShapeType.e_circleShape, box2d.b2ShapeType.e_circleShape);
    this.AddType(box2d.b2PolygonAndCircleContact.Create,
            box2d.b2PolygonAndCircleContact.Destroy, box2d.b2ShapeType.e_polygonShape, box2d.b2ShapeType.e_circleShape);
    this.AddType(box2d.b2PolygonContact.Create, box2d.b2PolygonContact.Destroy, box2d.b2ShapeType.e_polygonShape, box2d.b2ShapeType.e_polygonShape);
    this.AddType(box2d.b2EdgeAndCircleContact.Create, box2d.b2EdgeAndCircleContact.Destroy, box2d.b2ShapeType.e_edgeShape, box2d.b2ShapeType.e_circleShape);
    this.AddType(box2d.b2EdgeAndPolygonContact.Create, box2d.b2EdgeAndPolygonContact.Destroy, box2d.b2ShapeType.e_edgeShape,
            box2d.b2ShapeType.e_polygonShape);
    this.AddType(box2d.b2ChainAndCircleContact.Create, box2d.b2ChainAndCircleContact.Destroy, box2d.b2ShapeType.e_chainShape, box2d.b2ShapeType.e_circleShape);
    this.AddType(box2d.b2ChainAndPolygonContact.Create, box2d.b2ChainAndPolygonContact.Destroy, box2d.b2ShapeType.e_chainShape, box2d.b2ShapeType.e_polygonShape)
};
goog.exportProperty(box2d.b2ContactFactory.prototype, "InitializeRegisters", box2d.b2ContactFactory.prototype.InitializeRegisters);
box2d.b2ContactFactory.prototype.Create = function(a, b, c, e) {
    var d = a.GetType(), f = c.GetType();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= d && d < box2d.b2ShapeType.e_shapeTypeCount);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= f && f < box2d.b2ShapeType.e_shapeTypeCount);
    d = this.m_registers[d][f];
    f = d.createFcn;
    return null != f ? (d.primary ? (d = f(this.m_allocator), d.Reset(a, b, c, e)) : (d = f(this.m_allocator), d.Reset(c, e, a, b)), d) : null
};
goog.exportProperty(box2d.b2ContactFactory.prototype, "Create", box2d.b2ContactFactory.prototype.Create);
box2d.b2ContactFactory.prototype.Destroy = function(a) {
    var b = a.m_fixtureA, c = a.m_fixtureB;
    0 < a.m_manifold.pointCount && (!1 == b.IsSensor() && !1 == c.IsSensor()) && (b.GetBody().SetAwake(!0), c.GetBody().SetAwake(!0));
    b = b.GetType();
    c = c.GetType();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= b && c < box2d.b2ShapeType.e_shapeTypeCount);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= b && c < box2d.b2ShapeType.e_shapeTypeCount);
    c = this.m_registers[b][c].destroyFcn;
    c(a, this.m_allocator)
};
goog.exportProperty(box2d.b2ContactFactory.prototype, "Destroy", box2d.b2ContactFactory.prototype.Destroy);
box2d.b2GrowableStack = function(a) {
    this.m_stack = Array(a)
};
goog.exportSymbol("box2d.b2GrowableStack", box2d.b2GrowableStack);
box2d.b2GrowableStack.prototype.m_stack = null;
goog.exportProperty(box2d.b2GrowableStack.prototype, "m_stack", box2d.b2GrowableStack.prototype.m_stack);
box2d.b2GrowableStack.prototype.m_count = 0;
goog.exportProperty(box2d.b2GrowableStack.prototype, "m_count", box2d.b2GrowableStack.prototype.m_count);
box2d.b2GrowableStack.prototype.Reset = function() {
    this.m_count = 0;
    return this
};
goog.exportProperty(box2d.b2GrowableStack.prototype, "Reset", box2d.b2GrowableStack.prototype.Reset);
box2d.b2GrowableStack.prototype.Push = function(a) {
    this.m_stack[this.m_count] = a;
    ++this.m_count
};
goog.exportProperty(box2d.b2GrowableStack.prototype, "Push", box2d.b2GrowableStack.prototype.Push);
box2d.b2GrowableStack.prototype.Pop = function() {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < this.m_count);
    --this.m_count;
    var a = this.m_stack[this.m_count];
    this.m_stack[this.m_count] = null;
    return a
};
goog.exportProperty(box2d.b2GrowableStack.prototype, "Pop", box2d.b2GrowableStack.prototype.Pop);
box2d.b2GrowableStack.prototype.GetCount = function() {
    return this.m_count
};
goog.exportProperty(box2d.b2GrowableStack.prototype, "GetCount", box2d.b2GrowableStack.prototype.GetCount);
box2d.b2TreeNode = function(a) {
    this.m_id = a || 0;
    this.aabb = new box2d.b2AABB
};
goog.exportSymbol("box2d.b2TreeNode", box2d.b2TreeNode);
box2d.b2TreeNode.prototype.m_id = 0;
goog.exportProperty(box2d.b2TreeNode.prototype, "m_id", box2d.b2TreeNode.prototype.m_id);
box2d.b2TreeNode.prototype.aabb = null;
goog.exportProperty(box2d.b2TreeNode.prototype, "aabb", box2d.b2TreeNode.prototype.aabb);
box2d.b2TreeNode.prototype.userData = null;
goog.exportProperty(box2d.b2TreeNode.prototype, "userData", box2d.b2TreeNode.prototype.userData);
box2d.b2TreeNode.prototype.parent = null;
goog.exportProperty(box2d.b2TreeNode.prototype, "parent", box2d.b2TreeNode.prototype.parent);
box2d.b2TreeNode.prototype.child1 = null;
goog.exportProperty(box2d.b2TreeNode.prototype, "child1", box2d.b2TreeNode.prototype.child1);
box2d.b2TreeNode.prototype.child2 = null;
goog.exportProperty(box2d.b2TreeNode.prototype, "child2", box2d.b2TreeNode.prototype.child2);
box2d.b2TreeNode.prototype.height = 0;
goog.exportProperty(box2d.b2TreeNode.prototype, "height", box2d.b2TreeNode.prototype.height);
box2d.b2TreeNode.prototype.IsLeaf = function() {
    return null == this.child1
};
goog.exportProperty(box2d.b2TreeNode.prototype, "IsLeaf", box2d.b2TreeNode.prototype.IsLeaf);
box2d.b2DynamicTree = function() {
};
goog.exportSymbol("box2d.b2DynamicTree", box2d.b2DynamicTree);
box2d.b2DynamicTree.prototype.m_root = null;
goog.exportProperty(box2d.b2DynamicTree.prototype, "m_root", box2d.b2DynamicTree.prototype.m_root);
box2d.b2DynamicTree.prototype.m_freeList = null;
goog.exportProperty(box2d.b2DynamicTree.prototype, "m_freeList", box2d.b2DynamicTree.prototype.m_freeList);
box2d.b2DynamicTree.prototype.m_path = 0;
goog.exportProperty(box2d.b2DynamicTree.prototype, "m_path", box2d.b2DynamicTree.prototype.m_path);
box2d.b2DynamicTree.prototype.m_insertionCount = 0;
goog.exportProperty(box2d.b2DynamicTree.prototype, "m_insertionCount", box2d.b2DynamicTree.prototype.m_insertionCount);
box2d.b2DynamicTree.s_stack = new box2d.b2GrowableStack(256);
box2d.b2DynamicTree.s_r = new box2d.b2Vec2;
box2d.b2DynamicTree.s_v = new box2d.b2Vec2;
box2d.b2DynamicTree.s_abs_v = new box2d.b2Vec2;
box2d.b2DynamicTree.s_segmentAABB = new box2d.b2AABB;
box2d.b2DynamicTree.s_subInput = new box2d.b2RayCastInput;
box2d.b2DynamicTree.s_combinedAABB = new box2d.b2AABB;
box2d.b2DynamicTree.s_aabb = new box2d.b2AABB;
box2d.b2DynamicTree.prototype.GetUserData = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(null != a);
    return a.userData
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "GetUserData", box2d.b2DynamicTree.prototype.GetUserData);
box2d.b2DynamicTree.prototype.GetFatAABB = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(null != a);
    return a.aabb
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "GetFatAABB", box2d.b2DynamicTree.prototype.GetFatAABB);
box2d.b2DynamicTree.prototype.Query = function(a, b) {
    if (null != this.m_root) {
        var c = box2d.b2DynamicTree.s_stack.Reset();
        for (c.Push(this.m_root); 0 < c.GetCount(); ) {
            var e = c.Pop();
            if (null != e && e.aabb.TestOverlap(b))
                if (e.IsLeaf()) {
                    if (!1 == a(e))
                        break
                } else
                    c.Push(e.child1), c.Push(e.child2)
        }
    }
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "Query", box2d.b2DynamicTree.prototype.Query);
box2d.b2DynamicTree.prototype.RayCast = function(a, b) {
    if (null != this.m_root) {
        var c = b.p1, e = b.p2, d = box2d.b2SubVV(e, c, box2d.b2DynamicTree.s_r);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < d.GetLengthSquared());
        d.Normalize();
        var d = box2d.b2CrossOneV(d, box2d.b2DynamicTree.s_v), f = box2d.b2AbsV(d, box2d.b2DynamicTree.s_abs_v), g = b.maxFraction, h = box2d.b2DynamicTree.s_segmentAABB, l = c.x + g * (e.x - c.x), k = c.y + g * (e.y - c.y);
        h.lowerBound.x = box2d.b2Min(c.x, l);
        h.lowerBound.y = box2d.b2Min(c.y, k);
        h.upperBound.x = box2d.b2Max(c.x, l);
        h.upperBound.y =
                box2d.b2Max(c.y, k);
        var m = box2d.b2DynamicTree.s_stack.Reset();
        for (m.Push(this.m_root); 0 < m.GetCount(); )
            if (l = m.Pop(), null != l && !1 != box2d.b2TestOverlapAABB(l.aabb, h)) {
                var k = l.aabb.GetCenter(), n = l.aabb.GetExtents();
                if (!(0 < box2d.b2Abs(box2d.b2DotVV(d, box2d.b2SubVV(c, k, box2d.b2Vec2.s_t0))) - box2d.b2DotVV(f, n)))
                    if (l.IsLeaf()) {
                        k = box2d.b2DynamicTree.s_subInput;
                        k.p1.Copy(b.p1);
                        k.p2.Copy(b.p2);
                        k.maxFraction = g;
                        l = a(k, l);
                        if (0 == l)
                            break;
                        0 < l && (g = l, l = c.x + g * (e.x - c.x), k = c.y + g * (e.y - c.y), h.lowerBound.x = box2d.b2Min(c.x, l),
                                h.lowerBound.y = box2d.b2Min(c.y, k), h.upperBound.x = box2d.b2Max(c.x, l), h.upperBound.y = box2d.b2Max(c.y, k))
                    } else
                        m.Push(l.child1), m.Push(l.child2)
            }
    }
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "RayCast", box2d.b2DynamicTree.prototype.RayCast);
box2d.b2DynamicTree.prototype.AllocateNode = function() {
    if (this.m_freeList) {
        var a = this.m_freeList;
        this.m_freeList = a.parent;
        a.parent = null;
        a.child1 = null;
        a.child2 = null;
        a.height = 0;
        a.userData = null;
        return a
    }
    return new box2d.b2TreeNode(box2d.b2DynamicTree.prototype.s_node_id++)
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "AllocateNode", box2d.b2DynamicTree.prototype.AllocateNode);
box2d.b2DynamicTree.prototype.s_node_id = 0;
box2d.b2DynamicTree.prototype.FreeNode = function(a) {
    a.parent = this.m_freeList;
    a.height = -1;
    this.m_freeList = a
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "FreeNode", box2d.b2DynamicTree.prototype.FreeNode);
box2d.b2DynamicTree.prototype.CreateProxy = function(a, b) {
    var c = this.AllocateNode(), e = box2d.b2_aabbExtension, d = box2d.b2_aabbExtension;
    c.aabb.lowerBound.x = a.lowerBound.x - e;
    c.aabb.lowerBound.y = a.lowerBound.y - d;
    c.aabb.upperBound.x = a.upperBound.x + e;
    c.aabb.upperBound.y = a.upperBound.y + d;
    c.userData = b;
    c.height = 0;
    this.InsertLeaf(c);
    return c
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "CreateProxy", box2d.b2DynamicTree.prototype.CreateProxy);
box2d.b2DynamicTree.prototype.DestroyProxy = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.IsLeaf());
    this.RemoveLeaf(a);
    this.FreeNode(a)
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "DestroyProxy", box2d.b2DynamicTree.prototype.DestroyProxy);
box2d.b2DynamicTree.prototype.MoveProxy = function(a, b, c) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.IsLeaf());
    if (a.aabb.Contains(b))
        return!1;
    this.RemoveLeaf(a);
    var e = box2d.b2_aabbExtension + box2d.b2_aabbMultiplier * (0 < c.x ? c.x : -c.x);
    c = box2d.b2_aabbExtension + box2d.b2_aabbMultiplier * (0 < c.y ? c.y : -c.y);
    a.aabb.lowerBound.x = b.lowerBound.x - e;
    a.aabb.lowerBound.y = b.lowerBound.y - c;
    a.aabb.upperBound.x = b.upperBound.x + e;
    a.aabb.upperBound.y = b.upperBound.y + c;
    this.InsertLeaf(a);
    return!0
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "MoveProxy", box2d.b2DynamicTree.prototype.MoveProxy);
box2d.b2DynamicTree.prototype.InsertLeaf = function(a) {
    ++this.m_insertionCount;
    if (null == this.m_root)
        this.m_root = a, this.m_root.parent = null;
    else {
        var b = a.aabb;
        b.GetCenter();
        for (var c = this.m_root, e, d; !1 == c.IsLeaf(); ) {
            e = c.child1;
            d = c.child2;
            var f = c.aabb.GetPerimeter(), g = box2d.b2DynamicTree.s_combinedAABB;
            g.Combine2(c.aabb, b);
            var h = g.GetPerimeter(), g = 2 * h, h = 2 * (h - f), l = box2d.b2DynamicTree.s_aabb, k, m;
            e.IsLeaf() ? (l.Combine2(b, e.aabb), f = l.GetPerimeter() + h) : (l.Combine2(b, e.aabb), k = e.aabb.GetPerimeter(), m = l.GetPerimeter(),
                    f = m - k + h);
            d.IsLeaf() ? (l.Combine2(b, d.aabb), h = l.GetPerimeter() + h) : (l.Combine2(b, d.aabb), k = d.aabb.GetPerimeter(), m = l.GetPerimeter(), h = m - k + h);
            if (g < f && g < h)
                break;
            c = f < h ? e : d
        }
        e = c.parent;
        d = this.AllocateNode();
        d.parent = e;
        d.userData = null;
        d.aabb.Combine2(b, c.aabb);
        d.height = c.height + 1;
        e ? (e.child1 == c ? e.child1 = d : e.child2 = d, d.child1 = c, d.child2 = a, c.parent = d, a.parent = d) : (d.child1 = c, d.child2 = a, c.parent = d, this.m_root = a.parent = d);
        for (c = a.parent; null != c; )
            c = this.Balance(c), e = c.child1, d = c.child2, box2d.ENABLE_ASSERTS && box2d.b2Assert(null !=
                    e), box2d.ENABLE_ASSERTS && box2d.b2Assert(null != d), c.height = 1 + box2d.b2Max(e.height, d.height), c.aabb.Combine2(e.aabb, d.aabb), c = c.parent
    }
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "InsertLeaf", box2d.b2DynamicTree.prototype.InsertLeaf);
box2d.b2DynamicTree.prototype.RemoveLeaf = function(a) {
    if (a == this.m_root)
        this.m_root = null;
    else {
        var b = a.parent, c = b.parent;
        a = b.child1 == a ? b.child2 : b.child1;
        if (c)
            for (c.child1 == b?c.child1 = a:c.child2 = a, a.parent = c, this.FreeNode(b), b = c; b; )
                b = this.Balance(b), c = b.child1, a = b.child2, b.aabb.Combine2(c.aabb, a.aabb), b.height = 1 + box2d.b2Max(c.height, a.height), b = b.parent;
        else
            this.m_root = a, a.parent = null, this.FreeNode(b)
    }
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "RemoveLeaf", box2d.b2DynamicTree.prototype.RemoveLeaf);
box2d.b2DynamicTree.prototype.Balance = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(null != a);
    if (a.IsLeaf() || 2 > a.height)
        return a;
    var b = a.child1, c = a.child2, e = c.height - b.height;
    if (1 < e) {
        var e = c.child1, d = c.child2;
        c.child1 = a;
        c.parent = a.parent;
        a.parent = c;
        null != c.parent ? c.parent.child1 == a ? c.parent.child1 = c : (box2d.ENABLE_ASSERTS && box2d.b2Assert(c.parent.child2 == a), c.parent.child2 = c) : this.m_root = c;
        e.height > d.height ? (c.child2 = e, a.child2 = d, d.parent = a, a.aabb.Combine2(b.aabb, d.aabb), c.aabb.Combine2(a.aabb, e.aabb),
                a.height = 1 + box2d.b2Max(b.height, d.height), c.height = 1 + box2d.b2Max(a.height, e.height)) : (c.child2 = d, a.child2 = e, e.parent = a, a.aabb.Combine2(b.aabb, e.aabb), c.aabb.Combine2(a.aabb, d.aabb), a.height = 1 + box2d.b2Max(b.height, e.height), c.height = 1 + box2d.b2Max(a.height, d.height));
        return c
    }
    return-1 > e ? (e = b.child1, d = b.child2, b.child1 = a, b.parent = a.parent, a.parent = b, null != b.parent ? b.parent.child1 == a ? b.parent.child1 = b : (box2d.ENABLE_ASSERTS && box2d.b2Assert(b.parent.child2 == a), b.parent.child2 = b) : this.m_root = b, e.height >
            d.height ? (b.child2 = e, a.child1 = d, d.parent = a, a.aabb.Combine2(c.aabb, d.aabb), b.aabb.Combine2(a.aabb, e.aabb), a.height = 1 + box2d.b2Max(c.height, d.height), b.height = 1 + box2d.b2Max(a.height, e.height)) : (b.child2 = d, a.child1 = e, e.parent = a, a.aabb.Combine2(c.aabb, e.aabb), b.aabb.Combine2(a.aabb, d.aabb), a.height = 1 + box2d.b2Max(c.height, e.height), b.height = 1 + box2d.b2Max(a.height, d.height)), b) : a
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "Balance", box2d.b2DynamicTree.prototype.Balance);
box2d.b2DynamicTree.prototype.GetHeight = function() {
    return null == this.m_root ? 0 : this.m_root.height
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "GetHeight", box2d.b2DynamicTree.prototype.GetHeight);
box2d.b2DynamicTree.prototype.GetAreaRatio = function() {
    if (null == this.m_root)
        return 0;
    var a = this.m_root.aabb.GetPerimeter(), b = function(a) {
        if (null == a || a.IsLeaf())
            return 0;
        var e = a.aabb.GetPerimeter(), e = e + b(a.child1);
        return e += b(a.child2)
    };
    return b(this.m_root) / a
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "GetAreaRatio", box2d.b2DynamicTree.prototype.GetAreaRatio);
box2d.b2DynamicTree.prototype.ComputeHeightNode = function(a) {
    if (a.IsLeaf())
        return 0;
    var b = this.ComputeHeightNode(a.child1);
    a = this.ComputeHeightNode(a.child2);
    return 1 + box2d.b2Max(b, a)
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "ComputeHeightNode", box2d.b2DynamicTree.prototype.ComputeHeightNode);
box2d.b2DynamicTree.prototype.ComputeHeight = function() {
    return this.ComputeHeightNode(this.m_root)
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "ComputeHeight", box2d.b2DynamicTree.prototype.ComputeHeight);
box2d.b2DynamicTree.prototype.ValidateStructure = function(a) {
    if (null != a) {
        a == this.m_root && box2d.ENABLE_ASSERTS && box2d.b2Assert(null == a.parent);
        var b = a.child1, c = a.child2;
        a.IsLeaf() ? (box2d.ENABLE_ASSERTS && box2d.b2Assert(null == b), box2d.ENABLE_ASSERTS && box2d.b2Assert(null == c), box2d.ENABLE_ASSERTS && box2d.b2Assert(0 == a.height)) : (box2d.ENABLE_ASSERTS && box2d.b2Assert(b.parent == a), box2d.ENABLE_ASSERTS && box2d.b2Assert(c.parent == a), this.ValidateStructure(b), this.ValidateStructure(c))
    }
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "ValidateStructure", box2d.b2DynamicTree.prototype.ValidateStructure);
box2d.b2DynamicTree.prototype.ValidateMetrics = function(a) {
    if (null != a) {
        var b = a.child1, c = a.child2;
        if (a.IsLeaf())
            box2d.ENABLE_ASSERTS && box2d.b2Assert(null == b), box2d.ENABLE_ASSERTS && box2d.b2Assert(null == c), box2d.ENABLE_ASSERTS && box2d.b2Assert(0 == a.height);
        else {
            var e;
            e = 1 + box2d.b2Max(b.height, c.height);
            box2d.ENABLE_ASSERTS && box2d.b2Assert(a.height == e);
            e = box2d.b2DynamicTree.s_aabb;
            e.Combine2(b.aabb, c.aabb);
            box2d.ENABLE_ASSERTS && box2d.b2Assert(e.lowerBound == a.aabb.lowerBound);
            box2d.ENABLE_ASSERTS && box2d.b2Assert(e.upperBound ==
                    a.aabb.upperBound);
            this.ValidateMetrics(b);
            this.ValidateMetrics(c)
        }
    }
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "ValidateMetrics", box2d.b2DynamicTree.prototype.ValidateMetrics);
box2d.b2DynamicTree.prototype.Validate = function() {
    this.ValidateStructure(this.m_root);
    this.ValidateMetrics(this.m_root);
    for (var a = 0, b = this.m_freeList; null != b; )
        b = b.parent, ++a;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.GetHeight() == this.ComputeHeight())
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "Validate", box2d.b2DynamicTree.prototype.Validate);
box2d.b2DynamicTree.prototype.GetMaxBalance = function() {
    var a;
    a = this.m_root;
    null == a ? a = 0 : 1 >= a.height ? a = 0 : (box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == a.IsLeaf()), a = box2d.b2Abs(a.child2.height - a.child1.height), a = box2d.b2Max(0, a));
    return a
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "GetMaxBalance", box2d.b2DynamicTree.prototype.GetMaxBalance);
box2d.b2DynamicTree.prototype.RebuildBottomUp = function() {
    this.Validate()
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "RebuildBottomUp", box2d.b2DynamicTree.prototype.RebuildBottomUp);
box2d.b2DynamicTree.prototype.ShiftOrigin = function(a) {
    var b = function(a, e) {
        if (null != a && !(1 >= a.height)) {
            box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == a.IsLeaf());
            var d = a.child2;
            b(a.child1, e);
            b(d, e);
            a.aabb.lowerBound.SelfSub(e);
            a.aabb.upperBound.SelfSub(e)
        }
    };
    b(this.m_root, a)
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "ShiftOrigin", box2d.b2DynamicTree.prototype.ShiftOrigin);
box2d.b2Pair = function() {
};
goog.exportSymbol("box2d.b2Pair", box2d.b2Pair);
box2d.b2Pair.prototype.proxyA = null;
goog.exportProperty(box2d.b2Pair.prototype, "proxyA", box2d.b2Pair.prototype.proxyA);
box2d.b2Pair.prototype.proxyB = null;
goog.exportProperty(box2d.b2Pair.prototype, "proxyB", box2d.b2Pair.prototype.proxyB);
box2d.b2BroadPhase = function() {
    this.m_tree = new box2d.b2DynamicTree;
    this.m_moveBuffer = [];
    this.m_pairBuffer = []
};
goog.exportSymbol("box2d.b2BroadPhase", box2d.b2BroadPhase);
box2d.b2BroadPhase.prototype.m_tree = null;
goog.exportProperty(box2d.b2BroadPhase.prototype, "m_tree", box2d.b2BroadPhase.prototype.m_tree);
box2d.b2BroadPhase.prototype.m_proxyCount = 0;
goog.exportProperty(box2d.b2BroadPhase.prototype, "m_proxyCount", box2d.b2BroadPhase.prototype.m_proxyCount);
box2d.b2BroadPhase.prototype.m_moveCount = 0;
goog.exportProperty(box2d.b2BroadPhase.prototype, "m_moveCount", box2d.b2BroadPhase.prototype.m_moveCount);
box2d.b2BroadPhase.prototype.m_moveBuffer = null;
goog.exportProperty(box2d.b2BroadPhase.prototype, "m_moveBuffer", box2d.b2BroadPhase.prototype.m_moveBuffer);
box2d.b2BroadPhase.prototype.m_pairCount = 0;
goog.exportProperty(box2d.b2BroadPhase.prototype, "m_pairCount", box2d.b2BroadPhase.prototype.m_pairCount);
box2d.b2BroadPhase.prototype.m_pairBuffer = null;
goog.exportProperty(box2d.b2BroadPhase.prototype, "m_pairBuffer", box2d.b2BroadPhase.prototype.m_pairBuffer);
box2d.b2BroadPhase.prototype.CreateProxy = function(a, b) {
    var c = this.m_tree.CreateProxy(a, b);
    ++this.m_proxyCount;
    this.BufferMove(c);
    return c
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "CreateProxy", box2d.b2BroadPhase.prototype.CreateProxy);
box2d.b2BroadPhase.prototype.DestroyProxy = function(a) {
    this.UnBufferMove(a);
    --this.m_proxyCount;
    this.m_tree.DestroyProxy(a)
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "DestroyProxy", box2d.b2BroadPhase.prototype.DestroyProxy);
box2d.b2BroadPhase.prototype.MoveProxy = function(a, b, c) {
    this.m_tree.MoveProxy(a, b, c) && this.BufferMove(a)
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "MoveProxy", box2d.b2BroadPhase.prototype.MoveProxy);
box2d.b2BroadPhase.prototype.TouchProxy = function(a) {
    this.BufferMove(a)
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "TouchProxy", box2d.b2BroadPhase.prototype.TouchProxy);
box2d.b2BroadPhase.prototype.GetFatAABB = function(a) {
    return this.m_tree.GetFatAABB(a)
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "GetFatAABB", box2d.b2BroadPhase.prototype.GetFatAABB);
box2d.b2BroadPhase.prototype.GetUserData = function(a) {
    return this.m_tree.GetUserData(a)
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "GetUserData", box2d.b2BroadPhase.prototype.GetUserData);
box2d.b2BroadPhase.prototype.TestOverlap = function(a, b) {
    var c = this.m_tree.GetFatAABB(a), e = this.m_tree.GetFatAABB(b);
    return box2d.b2TestOverlapAABB(c, e)
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "TestOverlap", box2d.b2BroadPhase.prototype.TestOverlap);
box2d.b2BroadPhase.prototype.GetProxyCount = function() {
    return this.m_proxyCount
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "GetProxyCount", box2d.b2BroadPhase.prototype.GetProxyCount);
box2d.b2BroadPhase.prototype.GetTreeHeight = function() {
    return this.m_tree.GetHeight()
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "GetTreeHeight", box2d.b2BroadPhase.prototype.GetTreeHeight);
box2d.b2BroadPhase.prototype.GetTreeBalance = function() {
    return this.m_tree.GetMaxBalance()
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "GetTreeBalance", box2d.b2BroadPhase.prototype.GetTreeBalance);
box2d.b2BroadPhase.prototype.GetTreeQuality = function() {
    return this.m_tree.GetAreaRatio()
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "GetTreeQuality", box2d.b2BroadPhase.prototype.GetTreeQuality);
box2d.b2BroadPhase.prototype.ShiftOrigin = function(a) {
    this.m_tree.ShiftOrigin(a)
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "ShiftOrigin", box2d.b2BroadPhase.prototype.ShiftOrigin);
box2d.b2BroadPhase.prototype.UpdatePairs = function(a) {
    for (var b = this.m_pairCount = 0; b < this.m_moveCount; ++b) {
        var c = this.m_moveBuffer[b];
        if (null != c) {
            var e = this, d = this.m_tree.GetFatAABB(c);
            this.m_tree.Query(function(a) {
                if (a.m_id == c.m_id)
                    return!0;
                e.m_pairCount == e.m_pairBuffer.length && (e.m_pairBuffer[e.m_pairCount] = new box2d.b2Pair);
                var b = e.m_pairBuffer[e.m_pairCount];
                a.m_id < c.m_id ? (b.proxyA = a, b.proxyB = c) : (b.proxyA = c, b.proxyB = a);
                ++e.m_pairCount;
                return!0
            }, d)
        }
    }
    this.m_moveCount = 0;
    this.m_pairBuffer.length = this.m_pairCount;
    this.m_pairBuffer.sort(box2d.b2PairLessThan);
    for (b = 0; b < this.m_pairCount; ) {
        var d = this.m_pairBuffer[b], f = this.m_tree.GetUserData(d.proxyA), g = this.m_tree.GetUserData(d.proxyB);
        a.AddPair(f, g);
        for (++b; b < this.m_pairCount; ) {
            f = this.m_pairBuffer[b];
            if (f.proxyA.m_id != d.proxyA.m_id || f.proxyB.m_id != d.proxyB.m_id)
                break;
            ++b
        }
    }
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "UpdatePairs", box2d.b2BroadPhase.prototype.UpdatePairs);
box2d.b2BroadPhase.prototype.Query = function(a, b) {
    this.m_tree.Query(a, b)
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "Query", box2d.b2BroadPhase.prototype.Query);
box2d.b2BroadPhase.prototype.RayCast = function(a, b) {
    this.m_tree.RayCast(a, b)
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "RayCast", box2d.b2BroadPhase.prototype.RayCast);
box2d.b2BroadPhase.prototype.BufferMove = function(a) {
    this.m_moveBuffer[this.m_moveCount] = a;
    ++this.m_moveCount
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "BufferMove", box2d.b2BroadPhase.prototype.BufferMove);
box2d.b2BroadPhase.prototype.UnBufferMove = function(a) {
    a = this.m_moveBuffer.indexOf(a);
    this.m_moveBuffer[a] = null
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "UnBufferMove", box2d.b2BroadPhase.prototype.UnBufferMove);
box2d.b2PairLessThan = function(a, b) {
    return a.proxyA.m_id == b.proxyA.m_id ? a.proxyB.m_id - b.proxyB.m_id : a.proxyA.m_id - b.proxyA.m_id
};
box2d.b2ContactManager = function() {
    this.m_broadPhase = new box2d.b2BroadPhase;
    this.m_contactFactory = new box2d.b2ContactFactory(this.m_allocator)
};
box2d.b2ContactManager.prototype.m_broadPhase = null;
goog.exportSymbol("box2d.b2ContactManager.prototype.m_broadPhase", box2d.b2ContactManager.prototype.m_broadPhase);
box2d.b2ContactManager.prototype.m_contactList = null;
goog.exportSymbol("box2d.b2ContactManager.prototype.m_contactList", box2d.b2ContactManager.prototype.m_contactList);
box2d.b2ContactManager.prototype.m_contactCount = 0;
goog.exportSymbol("box2d.b2ContactManager.prototype.m_contactCount", box2d.b2ContactManager.prototype.m_contactCount);
box2d.b2ContactManager.prototype.m_contactFilter = box2d.b2ContactFilter.b2_defaultFilter;
goog.exportSymbol("box2d.b2ContactManager.prototype.m_contactFilter", box2d.b2ContactManager.prototype.m_contactFilter);
box2d.b2ContactManager.prototype.m_contactListener = box2d.b2ContactListener.b2_defaultListener;
goog.exportSymbol("box2d.b2ContactManager.prototype.m_contactListener", box2d.b2ContactManager.prototype.m_contactListener);
box2d.b2ContactManager.prototype.m_allocator = null;
goog.exportSymbol("box2d.b2ContactManager.prototype.m_allocator", box2d.b2ContactManager.prototype.m_allocator);
box2d.b2ContactManager.prototype.m_contactFactory = null;
goog.exportSymbol("box2d.b2ContactManager.prototype.m_contactFactory", box2d.b2ContactManager.prototype.m_contactFactory);
box2d.b2ContactManager.prototype.Destroy = function(a) {
    var b = a.GetFixtureA(), c = a.GetFixtureB(), b = b.GetBody(), c = c.GetBody();
    this.m_contactListener && a.IsTouching() && this.m_contactListener.EndContact(a);
    a.m_prev && (a.m_prev.m_next = a.m_next);
    a.m_next && (a.m_next.m_prev = a.m_prev);
    a == this.m_contactList && (this.m_contactList = a.m_next);
    a.m_nodeA.prev && (a.m_nodeA.prev.next = a.m_nodeA.next);
    a.m_nodeA.next && (a.m_nodeA.next.prev = a.m_nodeA.prev);
    a.m_nodeA == b.m_contactList && (b.m_contactList = a.m_nodeA.next);
    a.m_nodeB.prev &&
            (a.m_nodeB.prev.next = a.m_nodeB.next);
    a.m_nodeB.next && (a.m_nodeB.next.prev = a.m_nodeB.prev);
    a.m_nodeB == c.m_contactList && (c.m_contactList = a.m_nodeB.next);
    this.m_contactFactory.Destroy(a);
    --this.m_contactCount
};
goog.exportSymbol("box2d.b2ContactManager.prototype.Destroy", box2d.b2ContactManager.prototype.Destroy);
box2d.b2ContactManager.prototype.Collide = function() {
    for (var a = this.m_contactList; a; ) {
        var b = a.GetFixtureA(), c = a.GetFixtureB(), e = a.GetChildIndexA(), d = a.GetChildIndexB(), f = b.GetBody(), g = c.GetBody();
        if (a.m_flags & box2d.b2ContactFlag.e_filterFlag) {
            if (!1 == g.ShouldCollide(f)) {
                b = a;
                a = b.m_next;
                this.Destroy(b);
                continue
            }
            if (this.m_contactFilter && !1 == this.m_contactFilter.ShouldCollide(b, c)) {
                b = a;
                a = b.m_next;
                this.Destroy(b);
                continue
            }
            a.m_flags &= ~box2d.b2ContactFlag.e_filterFlag
        }
        f = f.IsAwake() && f.m_type != box2d.b2BodyType.b2_staticBody;
        g = g.IsAwake() && g.m_type != box2d.b2BodyType.b2_staticBody;
        !1 == f && !1 == g ? a = a.m_next : !1 == this.m_broadPhase.TestOverlap(b.m_proxies[e].proxy, c.m_proxies[d].proxy) ? (b = a, a = b.m_next, this.Destroy(b)) : (a.Update(this.m_contactListener), a = a.m_next)
    }
};
goog.exportSymbol("box2d.b2ContactManager.prototype.Collide", box2d.b2ContactManager.prototype.Collide);
box2d.b2ContactManager.prototype.FindNewContacts = function() {
    this.m_broadPhase.UpdatePairs(this)
};
goog.exportSymbol("box2d.b2ContactManager.prototype.FindNewContacts", box2d.b2ContactManager.prototype.FindNewContacts);
box2d.b2ContactManager.prototype.AddPair = function(a, b) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a instanceof box2d.b2FixtureProxy);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(b instanceof box2d.b2FixtureProxy);
    var c = a.fixture, e = b.fixture, d = a.childIndex, f = b.childIndex, g = c.GetBody(), h = e.GetBody();
    if (g != h) {
        for (var l = h.GetContactList(); l; ) {
            if (l.other == g) {
                var k = l.contact.GetFixtureA(), m = l.contact.GetFixtureB(), n = l.contact.GetChildIndexA(), p = l.contact.GetChildIndexB();
                if (k == c && m == e && n == d && p == f || k == e && m == c && n == f &&
                        p == d)
                    return
            }
            l = l.next
        }
        !1 == h.ShouldCollide(g) || this.m_contactFilter && !1 == this.m_contactFilter.ShouldCollide(c, e) || (d = this.m_contactFactory.Create(c, d, e, f), null != d && (c = d.GetFixtureA(), e = d.GetFixtureB(), d.GetChildIndexA(), d.GetChildIndexB(), g = c.m_body, h = e.m_body, d.m_prev = null, d.m_next = this.m_contactList, null !== this.m_contactList && (this.m_contactList.m_prev = d), this.m_contactList = d, d.m_nodeA.contact = d, d.m_nodeA.other = h, d.m_nodeA.prev = null, d.m_nodeA.next = g.m_contactList, null != g.m_contactList && (g.m_contactList.prev =
                d.m_nodeA), g.m_contactList = d.m_nodeA, d.m_nodeB.contact = d, d.m_nodeB.other = g, d.m_nodeB.prev = null, d.m_nodeB.next = h.m_contactList, null != h.m_contactList && (h.m_contactList.prev = d.m_nodeB), h.m_contactList = d.m_nodeB, !1 == c.IsSensor() && !1 == e.IsSensor() && (g.SetAwake(!0), h.SetAwake(!0)), ++this.m_contactCount))
    }
};
goog.exportSymbol("box2d.b2ContactManager.prototype.AddPair", box2d.b2ContactManager.prototype.AddPair);
box2d.b2JointFactory = {};
box2d.b2JointFactory.Create = function(a, b) {
    var c = null;
    switch (a.type) {
        case box2d.b2JointType.e_distanceJoint:
            c = new box2d.b2DistanceJoint(a instanceof box2d.b2DistanceJointDef ? a : null);
            break;
        case box2d.b2JointType.e_mouseJoint:
            c = new box2d.b2MouseJoint(a instanceof box2d.b2MouseJointDef ? a : null);
            break;
        case box2d.b2JointType.e_prismaticJoint:
            c = new box2d.b2PrismaticJoint(a instanceof box2d.b2PrismaticJointDef ? a : null);
            break;
        case box2d.b2JointType.e_revoluteJoint:
            c = new box2d.b2RevoluteJoint(a instanceof box2d.b2RevoluteJointDef ?
                    a : null);
            break;
        case box2d.b2JointType.e_pulleyJoint:
            c = new box2d.b2PulleyJoint(a instanceof box2d.b2PulleyJointDef ? a : null);
            break;
        case box2d.b2JointType.e_gearJoint:
            c = new box2d.b2GearJoint(a instanceof box2d.b2GearJointDef ? a : null);
            break;
        case box2d.b2JointType.e_wheelJoint:
            c = new box2d.b2WheelJoint(a instanceof box2d.b2WheelJointDef ? a : null);
            break;
        case box2d.b2JointType.e_weldJoint:
            c = new box2d.b2WeldJoint(a instanceof box2d.b2WeldJointDef ? a : null);
            break;
        case box2d.b2JointType.e_frictionJoint:
            c = new box2d.b2FrictionJoint(a instanceof
                    box2d.b2FrictionJointDef ? a : null);
            break;
        case box2d.b2JointType.e_ropeJoint:
            c = new box2d.b2RopeJoint(a instanceof box2d.b2RopeJointDef ? a : null);
            break;
        case box2d.b2JointType.e_motorJoint:
            c = new box2d.b2MotorJoint(a instanceof box2d.b2MotorJointDef ? a : null);
            break;
        case box2d.b2JointType.e_areaJoint:
            c = new box2d.b2AreaJoint(a instanceof box2d.b2AreaJointDef ? a : null);
            break;
        default:
            box2d.ENABLE_ASSERTS && box2d.b2Assert(!1)
    }
    return c
};
goog.exportSymbol("box2d.b2JointFactory.Create", box2d.b2JointFactory.Create);
box2d.b2JointFactory.Destroy = function(a, b) {
};
goog.exportSymbol("box2d.b2JointFactory.Destroy", box2d.b2JointFactory.Destroy);
box2d.b2Color = function(a, b, c) {
    this.r = a;
    this.g = b;
    this.b = c
};
goog.exportSymbol("box2d.b2Color", box2d.b2Color);
box2d.b2Color.prototype.r = 0.5;
goog.exportProperty(box2d.b2Color.prototype, "r", box2d.b2Color.prototype.r);
box2d.b2Color.prototype.g = 0.5;
goog.exportProperty(box2d.b2Color.prototype, "g", box2d.b2Color.prototype.g);
box2d.b2Color.prototype.b = 0.5;
goog.exportProperty(box2d.b2Color.prototype, "b", box2d.b2Color.prototype.b);
box2d.b2Color.prototype.SetRGB = function(a, b, c) {
    this.r = a;
    this.g = b;
    this.b = c;
    return this
};
goog.exportProperty(box2d.b2Color.prototype, "SetRGB", box2d.b2Color.prototype.SetRGB);
box2d.b2Color.prototype.MakeStyleString = function(a) {
    var b = Math.round(Math.max(0, Math.min(255, 255 * this.r))), c = Math.round(Math.max(0, Math.min(255, 255 * this.g))), e = Math.round(Math.max(0, Math.min(255, 255 * this.b)));
    a = "undefined" == typeof a ? Math.max(0, Math.min(1, a)) : 1;
    return box2d.b2Color.MakeStyleString(b, c, e, a)
};
goog.exportProperty(box2d.b2Color.prototype, "MakeStyleString", box2d.b2Color.prototype.MakeStyleString);
box2d.b2Color.MakeStyleString = function(a, b, c, e) {
    return 1 > e ? "rgba(" + a + "," + b + "," + c + "," + e + ")" : "rgb(" + a + "," + b + "," + c + ")"
};
goog.exportProperty(box2d.b2Color, "MakeStyleString", box2d.b2Color.MakeStyleString);
box2d.b2Color.RED = new box2d.b2Color(1, 0, 0);
goog.exportProperty(box2d.b2Color, "RED", box2d.b2Color.RED);
box2d.b2Color.GREEN = new box2d.b2Color(0, 1, 0);
goog.exportProperty(box2d.b2Color, "GREEN", box2d.b2Color.GREEN);
box2d.b2Color.BLUE = new box2d.b2Color(0, 0, 1);
goog.exportProperty(box2d.b2Color, "BLUE", box2d.b2Color.BLUE);
box2d.b2DrawFlags = {e_none: 0, e_shapeBit: 1, e_jointBit: 2, e_aabbBit: 4, e_pairBit: 8, e_centerOfMassBit: 16, e_controllerBit: 32, e_all: 63};
goog.exportSymbol("box2d.b2DrawFlags", box2d.b2DrawFlags);
goog.exportProperty(box2d.b2DrawFlags, "e_none", box2d.b2DrawFlags.e_none);
goog.exportProperty(box2d.b2DrawFlags, "e_shapeBit", box2d.b2DrawFlags.e_shapeBit);
goog.exportProperty(box2d.b2DrawFlags, "e_jointBit", box2d.b2DrawFlags.e_jointBit);
goog.exportProperty(box2d.b2DrawFlags, "e_aabbBit", box2d.b2DrawFlags.e_aabbBit);
goog.exportProperty(box2d.b2DrawFlags, "e_pairBit", box2d.b2DrawFlags.e_pairBit);
goog.exportProperty(box2d.b2DrawFlags, "e_centerOfMassBit", box2d.b2DrawFlags.e_centerOfMassBit);
goog.exportProperty(box2d.b2DrawFlags, "e_controllerBit", box2d.b2DrawFlags.e_controllerBit);
goog.exportProperty(box2d.b2DrawFlags, "e_all", box2d.b2DrawFlags.e_all);
box2d.b2Draw = function() {
};
goog.exportSymbol("box2d.b2Draw", box2d.b2Draw);
box2d.b2Draw.prototype.m_drawFlags = box2d.b2DrawFlags.e_none;
goog.exportProperty(box2d.b2Draw.prototype, "m_drawFlags", box2d.b2Draw.prototype.m_drawFlags);
box2d.b2Draw.prototype.SetFlags = function(a) {
    this.m_drawFlags = a
};
goog.exportProperty(box2d.b2Draw.prototype, "SetFlags", box2d.b2Draw.prototype.SetFlags);
box2d.b2Draw.prototype.GetFlags = function() {
    return this.m_drawFlags
};
goog.exportProperty(box2d.b2Draw.prototype, "GetFlags", box2d.b2Draw.prototype.GetFlags);
box2d.b2Draw.prototype.AppendFlags = function(a) {
    this.m_drawFlags |= a
};
goog.exportProperty(box2d.b2Draw.prototype, "AppendFlags", box2d.b2Draw.prototype.AppendFlags);
box2d.b2Draw.prototype.ClearFlags = function(a) {
    this.m_drawFlags &= ~a
};
goog.exportProperty(box2d.b2Draw.prototype, "ClearFlags", box2d.b2Draw.prototype.ClearFlags);
box2d.b2Draw.prototype.PushTransform = function(a) {
};
goog.exportProperty(box2d.b2Draw.prototype, "PushTransform", box2d.b2Draw.prototype.PushTransform);
box2d.b2Draw.prototype.PopTransform = function(a) {
};
goog.exportProperty(box2d.b2Draw.prototype, "PopTransform", box2d.b2Draw.prototype.PopTransform);
box2d.b2Draw.prototype.DrawPolygon = function(a, b, c) {
};
goog.exportProperty(box2d.b2Draw.prototype, "DrawPolygon", box2d.b2Draw.prototype.DrawPolygon);
box2d.b2Draw.prototype.DrawSolidPolygon = function(a, b, c) {
};
goog.exportProperty(box2d.b2Draw.prototype, "DrawSolidPolygon", box2d.b2Draw.prototype.DrawSolidPolygon);
box2d.b2Draw.prototype.DrawCircle = function(a, b, c) {
};
goog.exportProperty(box2d.b2Draw.prototype, "DrawCircle", box2d.b2Draw.prototype.DrawCircle);
box2d.b2Draw.prototype.DrawSolidCircle = function(a, b, c, e) {
};
goog.exportProperty(box2d.b2Draw.prototype, "DrawSolidCircle", box2d.b2Draw.prototype.DrawSolidCircle);
box2d.b2Draw.prototype.DrawSegment = function(a, b, c) {
};
goog.exportProperty(box2d.b2Draw.prototype, "DrawSegment", box2d.b2Draw.prototype.DrawSegment);
box2d.b2Draw.prototype.DrawTransform = function(a) {
};
goog.exportProperty(box2d.b2Draw.prototype, "DrawTransform", box2d.b2Draw.prototype.DrawTransform);
box2d.b2Filter = function() {
};
goog.exportSymbol("box2d.b2Filter", box2d.b2Filter);
box2d.b2Filter.prototype.categoryBits = 1;
goog.exportProperty(box2d.b2Filter.prototype, "categoryBits", box2d.b2Filter.prototype.categoryBits);
box2d.b2Filter.prototype.maskBits = 65535;
goog.exportProperty(box2d.b2Filter.prototype, "maskBits", box2d.b2Filter.prototype.maskBits);
box2d.b2Filter.prototype.groupIndex = 0;
goog.exportProperty(box2d.b2Filter.prototype, "groupIndex", box2d.b2Filter.prototype.groupIndex);
box2d.b2Filter.prototype.Clone = function() {
    return(new box2d.b2Filter).Copy(this)
};
goog.exportProperty(box2d.b2Filter.prototype, "Clone", box2d.b2Filter.prototype.Clone);
box2d.b2Filter.prototype.Copy = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this !== a);
    this.categoryBits = a.categoryBits;
    this.maskBits = a.maskBits;
    this.groupIndex = a.groupIndex;
    return this
};
goog.exportProperty(box2d.b2Filter.prototype, "Copy", box2d.b2Filter.prototype.Copy);
box2d.b2FixtureDef = function() {
    this.filter = new box2d.b2Filter
};
goog.exportSymbol("box2d.b2FixtureDef", box2d.b2FixtureDef);
box2d.b2FixtureDef.prototype.shape = null;
goog.exportProperty(box2d.b2FixtureDef.prototype, "shape", box2d.b2FixtureDef.prototype.shape);
box2d.b2FixtureDef.prototype.userData = null;
goog.exportProperty(box2d.b2FixtureDef.prototype, "userData", box2d.b2FixtureDef.prototype.userData);
box2d.b2FixtureDef.prototype.friction = 0.2;
goog.exportProperty(box2d.b2FixtureDef.prototype, "friction", box2d.b2FixtureDef.prototype.friction);
box2d.b2FixtureDef.prototype.restitution = 0;
goog.exportProperty(box2d.b2FixtureDef.prototype, "restitution", box2d.b2FixtureDef.prototype.restitution);
box2d.b2FixtureDef.prototype.density = 0;
goog.exportProperty(box2d.b2FixtureDef.prototype, "density", box2d.b2FixtureDef.prototype.density);
box2d.b2FixtureDef.prototype.isSensor = !1;
goog.exportProperty(box2d.b2FixtureDef.prototype, "isSensor", box2d.b2FixtureDef.prototype.isSensor);
box2d.b2FixtureDef.prototype.filter = null;
goog.exportProperty(box2d.b2FixtureDef.prototype, "filter", box2d.b2FixtureDef.prototype.filter);
box2d.b2FixtureProxy = function() {
    this.aabb = new box2d.b2AABB
};
goog.exportSymbol("box2d.b2FixtureProxy", box2d.b2FixtureProxy);
box2d.b2FixtureProxy.prototype.aabb = null;
goog.exportProperty(box2d.b2FixtureProxy.prototype, "aabb", box2d.b2FixtureProxy.prototype.aabb);
box2d.b2FixtureProxy.prototype.fixture = null;
goog.exportProperty(box2d.b2FixtureProxy.prototype, "fixture", box2d.b2FixtureProxy.prototype.fixture);
box2d.b2FixtureProxy.prototype.childIndex = 0;
goog.exportProperty(box2d.b2FixtureProxy.prototype, "childIndex", box2d.b2FixtureProxy.prototype.childIndex);
box2d.b2FixtureProxy.prototype.proxy = null;
goog.exportProperty(box2d.b2FixtureProxy.prototype, "proxy", box2d.b2FixtureProxy.prototype.proxy);
box2d.b2FixtureProxy.MakeArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return new box2d.b2FixtureProxy
    })
};
goog.exportProperty(box2d.b2FixtureProxy, "MakeArray", box2d.b2FixtureProxy.MakeArray);
box2d.b2Fixture = function() {
    this.m_proxyCount = 0;
    this.m_filter = new box2d.b2Filter
};
goog.exportSymbol("box2d.b2Fixture", box2d.b2Fixture);
box2d.b2Fixture.prototype.m_density = 0;
goog.exportProperty(box2d.b2Fixture.prototype, "m_density", box2d.b2Fixture.prototype.m_density);
box2d.b2Fixture.prototype.m_next = null;
goog.exportProperty(box2d.b2Fixture.prototype, "m_next", box2d.b2Fixture.prototype.m_next);
box2d.b2Fixture.prototype.m_body = null;
goog.exportProperty(box2d.b2Fixture.prototype, "m_body", box2d.b2Fixture.prototype.m_body);
box2d.b2Fixture.prototype.m_shape = null;
goog.exportProperty(box2d.b2Fixture.prototype, "m_shape", box2d.b2Fixture.prototype.m_shape);
box2d.b2Fixture.prototype.m_friction = 0;
goog.exportProperty(box2d.b2Fixture.prototype, "m_friction", box2d.b2Fixture.prototype.m_friction);
box2d.b2Fixture.prototype.m_restitution = 0;
goog.exportProperty(box2d.b2Fixture.prototype, "m_restitution", box2d.b2Fixture.prototype.m_restitution);
box2d.b2Fixture.prototype.m_proxies = null;
goog.exportProperty(box2d.b2Fixture.prototype, "m_proxies", box2d.b2Fixture.prototype.m_proxies);
box2d.b2Fixture.prototype.m_proxyCount = 0;
goog.exportProperty(box2d.b2Fixture.prototype, "m_proxyCount", box2d.b2Fixture.prototype.m_proxyCount);
box2d.b2Fixture.prototype.m_filter = null;
goog.exportProperty(box2d.b2Fixture.prototype, "m_filter", box2d.b2Fixture.prototype.m_filter);
box2d.b2Fixture.prototype.m_isSensor = !1;
goog.exportProperty(box2d.b2Fixture.prototype, "m_isSensor", box2d.b2Fixture.prototype.m_isSensor);
box2d.b2Fixture.prototype.m_userData = null;
goog.exportProperty(box2d.b2Fixture.prototype, "m_userData", box2d.b2Fixture.prototype.m_userData);
box2d.b2Fixture.prototype.GetType = function() {
    return this.m_shape.GetType()
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetType", box2d.b2Fixture.prototype.GetType);
box2d.b2Fixture.prototype.GetShape = function() {
    return this.m_shape
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetShape", box2d.b2Fixture.prototype.GetShape);
box2d.b2Fixture.prototype.IsSensor = function() {
    return this.m_isSensor
};
goog.exportProperty(box2d.b2Fixture.prototype, "IsSensor", box2d.b2Fixture.prototype.IsSensor);
box2d.b2Fixture.prototype.GetFilterData = function() {
    return this.m_filter
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetFilterData", box2d.b2Fixture.prototype.GetFilterData);
box2d.b2Fixture.prototype.GetUserData = function() {
    return this.m_userData
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetUserData", box2d.b2Fixture.prototype.GetUserData);
box2d.b2Fixture.prototype.SetUserData = function(a) {
    this.m_userData = a
};
goog.exportProperty(box2d.b2Fixture.prototype, "SetUserData", box2d.b2Fixture.prototype.SetUserData);
box2d.b2Fixture.prototype.GetBody = function() {
    return this.m_body
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetBody", box2d.b2Fixture.prototype.GetBody);
box2d.b2Fixture.prototype.GetNext = function() {
    return this.m_next
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetNext", box2d.b2Fixture.prototype.GetNext);
box2d.b2Fixture.prototype.SetDensity = function(a) {
    this.m_density = a
};
goog.exportProperty(box2d.b2Fixture.prototype, "SetDensity", box2d.b2Fixture.prototype.SetDensity);
box2d.b2Fixture.prototype.GetDensity = function() {
    return this.m_density
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetDensity", box2d.b2Fixture.prototype.GetDensity);
box2d.b2Fixture.prototype.GetFriction = function() {
    return this.m_friction
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetFriction", box2d.b2Fixture.prototype.GetFriction);
box2d.b2Fixture.prototype.SetFriction = function(a) {
    this.m_friction = a
};
goog.exportProperty(box2d.b2Fixture.prototype, "SetFriction", box2d.b2Fixture.prototype.SetFriction);
box2d.b2Fixture.prototype.GetRestitution = function() {
    return this.m_restitution
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetRestitution", box2d.b2Fixture.prototype.GetRestitution);
box2d.b2Fixture.prototype.SetRestitution = function(a) {
    this.m_restitution = a
};
goog.exportProperty(box2d.b2Fixture.prototype, "SetRestitution", box2d.b2Fixture.prototype.SetRestitution);
box2d.b2Fixture.prototype.TestPoint = function(a) {
    return this.m_shape.TestPoint(this.m_body.GetTransform(), a)
};
goog.exportProperty(box2d.b2Fixture.prototype, "TestPoint", box2d.b2Fixture.prototype.TestPoint);
box2d.b2Fixture.prototype.RayCast = function(a, b, c) {
    return this.m_shape.RayCast(a, b, this.m_body.GetTransform(), c)
};
goog.exportProperty(box2d.b2Fixture.prototype, "RayCast", box2d.b2Fixture.prototype.RayCast);
box2d.b2Fixture.prototype.GetMassData = function(a) {
    a = a || new box2d.b2MassData;
    this.m_shape.ComputeMass(a, this.m_density);
    return a
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetMassData", box2d.b2Fixture.prototype.GetMassData);
box2d.b2Fixture.prototype.GetAABB = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= a && a < this.m_proxyCount);
    return this.m_proxies[a].aabb
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetAABB", box2d.b2Fixture.prototype.GetAABB);
box2d.b2Fixture.prototype.Create = function(a, b) {
    this.m_userData = b.userData;
    this.m_friction = b.friction;
    this.m_restitution = b.restitution;
    this.m_body = a;
    this.m_next = null;
    this.m_filter.Copy(b.filter);
    this.m_isSensor = b.isSensor;
    this.m_shape = b.shape.Clone();
    this.m_proxies = box2d.b2FixtureProxy.MakeArray(this.m_shape.GetChildCount());
    this.m_proxyCount = 0;
    this.m_density = b.density
};
goog.exportProperty(box2d.b2Fixture.prototype, "Create", box2d.b2Fixture.prototype.Create);
box2d.b2Fixture.prototype.Destroy = function() {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 == this.m_proxyCount);
    this.m_shape = null
};
goog.exportProperty(box2d.b2Fixture.prototype, "Destroy", box2d.b2Fixture.prototype.Destroy);
box2d.b2Fixture.prototype.CreateProxies = function(a, b) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 == this.m_proxyCount);
    this.m_proxyCount = this.m_shape.GetChildCount();
    for (var c = 0; c < this.m_proxyCount; ++c) {
        var e = this.m_proxies[c];
        this.m_shape.ComputeAABB(e.aabb, b, c);
        e.proxy = a.CreateProxy(e.aabb, e);
        e.fixture = this;
        e.childIndex = c
    }
};
goog.exportProperty(box2d.b2Fixture.prototype, "CreateProxies", box2d.b2Fixture.prototype.CreateProxies);
box2d.b2Fixture.prototype.DestroyProxies = function(a) {
    for (var b = 0; b < this.m_proxyCount; ++b) {
        var c = this.m_proxies[b];
        a.DestroyProxy(c.proxy);
        c.proxy = null
    }
    this.m_proxyCount = 0
};
goog.exportProperty(box2d.b2Fixture.prototype, "DestroyProxies", box2d.b2Fixture.prototype.DestroyProxies);
box2d.b2Fixture.prototype.Synchronize = function(a, b, c) {
    if (0 != this.m_proxyCount)
        for (var e = 0; e < this.m_proxyCount; ++e) {
            var d = this.m_proxies[e], f = box2d.b2Fixture.prototype.Synchronize.s_aabb1, g = box2d.b2Fixture.prototype.Synchronize.s_aabb2;
            this.m_shape.ComputeAABB(f, b, e);
            this.m_shape.ComputeAABB(g, c, e);
            d.aabb.Combine2(f, g);
            f = box2d.b2SubVV(c.p, b.p, box2d.b2Fixture.prototype.Synchronize.s_displacement);
            a.MoveProxy(d.proxy, d.aabb, f)
        }
};
goog.exportProperty(box2d.b2Fixture.prototype, "Synchronize", box2d.b2Fixture.prototype.Synchronize);
box2d.b2Fixture.prototype.Synchronize.s_aabb1 = new box2d.b2AABB;
box2d.b2Fixture.prototype.Synchronize.s_aabb2 = new box2d.b2AABB;
box2d.b2Fixture.prototype.Synchronize.s_displacement = new box2d.b2Vec2;
box2d.b2Fixture.prototype.SetFilterData = function(a) {
    this.m_filter.Copy(a);
    this.Refilter()
};
goog.exportProperty(box2d.b2Fixture.prototype, "SetFilterData", box2d.b2Fixture.prototype.SetFilterData);
box2d.b2Fixture.prototype.Refilter = function() {
    if (!this.m_body) {
        for (var a = this.m_body.GetContactList(); a; ) {
            var b = a.contact, c = b.GetFixtureA(), e = b.GetFixtureB();
            c != this && e != this || b.FlagForFiltering();
            a = a.next
        }
        a = this.m_body.GetWorld();
        if (null !== a)
            for (a = a.m_contactManager.m_broadPhase, b = 0; b < this.m_proxyCount; ++b)
                a.TouchProxy(this.m_proxies[b].proxy)
    }
};
goog.exportProperty(box2d.b2Fixture.prototype, "Refilter", box2d.b2Fixture.prototype.Refilter);
box2d.b2Fixture.prototype.SetSensor = function(a) {
    a != this.m_isSensor && (this.m_body.SetAwake(!0), this.m_isSensor = a)
};
goog.exportProperty(box2d.b2Fixture.prototype, "SetSensor", box2d.b2Fixture.prototype.SetSensor);
box2d.b2Fixture.prototype.Dump = function(a) {
    box2d.DEBUG && (box2d.b2Log("    /*box2d.b2FixtureDef*/ var fd = new box2d.b2FixtureDef();\n"), box2d.b2Log("    fd.friction = %.15f;\n", this.m_friction), box2d.b2Log("    fd.restitution = %.15f;\n", this.m_restitution), box2d.b2Log("    fd.density = %.15f;\n", this.m_density), box2d.b2Log("    fd.isSensor = %s;\n", this.m_isSensor ? "true" : "false"), box2d.b2Log("    fd.filter.categoryBits = %d;\n", this.m_filter.categoryBits), box2d.b2Log("    fd.filter.maskBits = %d;\n",
            this.m_filter.maskBits), box2d.b2Log("    fd.filter.groupIndex = %d;\n", this.m_filter.groupIndex), this.m_shape.Dump(), box2d.b2Log("\n"), box2d.b2Log("    fd.shape = shape;\n"), box2d.b2Log("\n"), box2d.b2Log("    bodies[%d].CreateFixture(fd);\n", a))
};
goog.exportProperty(box2d.b2Fixture.prototype, "Dump", box2d.b2Fixture.prototype.Dump);
box2d.b2BodyType = {b2_unknown: -1, b2_staticBody: 0, b2_kinematicBody: 1, b2_dynamicBody: 2, b2_bulletBody: 3};
goog.exportSymbol("box2d.b2BodyType", box2d.b2BodyType);
goog.exportProperty(box2d.b2BodyType, "b2_unknown", box2d.b2BodyType.b2_unknown);
goog.exportProperty(box2d.b2BodyType, "b2_staticBody", box2d.b2BodyType.b2_staticBody);
goog.exportProperty(box2d.b2BodyType, "b2_kinematicBody", box2d.b2BodyType.b2_kinematicBody);
goog.exportProperty(box2d.b2BodyType, "b2_dynamicBody", box2d.b2BodyType.b2_dynamicBody);
goog.exportProperty(box2d.b2BodyType, "b2_bulletBody", box2d.b2BodyType.b2_bulletBody);
box2d.b2BodyDef = function() {
    this.position = new box2d.b2Vec2(0, 0);
    this.linearVelocity = new box2d.b2Vec2(0, 0)
};
goog.exportSymbol("box2d.b2BodyDef", box2d.b2BodyDef);
box2d.b2BodyDef.prototype.type = box2d.b2BodyType.b2_staticBody;
goog.exportProperty(box2d.b2BodyDef.prototype, "type", box2d.b2BodyDef.prototype.type);
box2d.b2BodyDef.prototype.position = null;
goog.exportProperty(box2d.b2BodyDef.prototype, "position", box2d.b2BodyDef.prototype.position);
box2d.b2BodyDef.prototype.angle = 0;
goog.exportProperty(box2d.b2BodyDef.prototype, "angle", box2d.b2BodyDef.prototype.angle);
box2d.b2BodyDef.prototype.linearVelocity = null;
goog.exportProperty(box2d.b2BodyDef.prototype, "linearVelocity", box2d.b2BodyDef.prototype.linearVelocity);
box2d.b2BodyDef.prototype.angularVelocity = 0;
goog.exportProperty(box2d.b2BodyDef.prototype, "angularVelocity", box2d.b2BodyDef.prototype.angularVelocity);
box2d.b2BodyDef.prototype.linearDamping = 0;
goog.exportProperty(box2d.b2BodyDef.prototype, "linearDamping", box2d.b2BodyDef.prototype.linearDamping);
box2d.b2BodyDef.prototype.angularDamping = 0;
goog.exportProperty(box2d.b2BodyDef.prototype, "angularDamping", box2d.b2BodyDef.prototype.angularDamping);
box2d.b2BodyDef.prototype.allowSleep = !0;
goog.exportProperty(box2d.b2BodyDef.prototype, "allowSleep", box2d.b2BodyDef.prototype.allowSleep);
box2d.b2BodyDef.prototype.awake = !0;
goog.exportProperty(box2d.b2BodyDef.prototype, "awake", box2d.b2BodyDef.prototype.awake);
box2d.b2BodyDef.prototype.fixedRotation = !1;
goog.exportProperty(box2d.b2BodyDef.prototype, "fixedRotation", box2d.b2BodyDef.prototype.fixedRotation);
box2d.b2BodyDef.prototype.bullet = !1;
goog.exportProperty(box2d.b2BodyDef.prototype, "bullet", box2d.b2BodyDef.prototype.bullet);
box2d.b2BodyDef.prototype.active = !0;
goog.exportProperty(box2d.b2BodyDef.prototype, "active", box2d.b2BodyDef.prototype.active);
box2d.b2BodyDef.prototype.userData = null;
goog.exportProperty(box2d.b2BodyDef.prototype, "userData", box2d.b2BodyDef.prototype.userData);
box2d.b2BodyDef.prototype.gravityScale = 1;
goog.exportProperty(box2d.b2BodyDef.prototype, "gravityScale", box2d.b2BodyDef.prototype.gravityScale);
box2d.b2BodyFlag = {e_none: 0, e_islandFlag: 1, e_awakeFlag: 2, e_autoSleepFlag: 4, e_bulletFlag: 8, e_fixedRotationFlag: 16, e_activeFlag: 32, e_toiFlag: 64};
goog.exportProperty(box2d.b2BodyFlag, "e_none", box2d.b2BodyFlag.e_none);
goog.exportProperty(box2d.b2BodyFlag, "e_islandFlag", box2d.b2BodyFlag.e_islandFlag);
goog.exportProperty(box2d.b2BodyFlag, "e_awakeFlag", box2d.b2BodyFlag.e_awakeFlag);
goog.exportProperty(box2d.b2BodyFlag, "e_autoSleepFlag", box2d.b2BodyFlag.e_autoSleepFlag);
goog.exportProperty(box2d.b2BodyFlag, "e_bulletFlag", box2d.b2BodyFlag.e_bulletFlag);
goog.exportProperty(box2d.b2BodyFlag, "e_fixedRotationFlag", box2d.b2BodyFlag.e_fixedRotationFlag);
goog.exportProperty(box2d.b2BodyFlag, "e_activeFlag", box2d.b2BodyFlag.e_activeFlag);
goog.exportProperty(box2d.b2BodyFlag, "e_toiFlag", box2d.b2BodyFlag.e_toiFlag);
box2d.b2Body = function(a, b) {
    this.m_xf = new box2d.b2Transform;
    this.m_out_xf = new box2d.b2Transform;
    this.m_sweep = new box2d.b2Sweep;
    this.m_out_sweep = new box2d.b2Sweep;
    this.m_linearVelocity = new box2d.b2Vec2;
    this.m_out_linearVelocity = new box2d.b2Vec2;
    this.m_force = new box2d.b2Vec2;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.position.IsValid());
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.linearVelocity.IsValid());
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a.angle));
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a.angularVelocity));
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a.gravityScale) && 0 <= a.gravityScale);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a.angularDamping) && 0 <= a.angularDamping);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a.linearDamping) && 0 <= a.linearDamping);
    this.m_flags = box2d.b2BodyFlag.e_none;
    a.bullet && (this.m_flags |= box2d.b2BodyFlag.e_bulletFlag);
    a.fixedRotation && (this.m_flags |= box2d.b2BodyFlag.e_fixedRotationFlag);
    a.allowSleep && (this.m_flags |= box2d.b2BodyFlag.e_autoSleepFlag);
    a.awake &&
            (this.m_flags |= box2d.b2BodyFlag.e_awakeFlag);
    a.active && (this.m_flags |= box2d.b2BodyFlag.e_activeFlag);
    this.m_world = b;
    this.m_xf.p.Copy(a.position);
    this.m_xf.q.SetAngleRadians(a.angle);
    this.m_sweep.localCenter.SetZero();
    this.m_sweep.c0.Copy(this.m_xf.p);
    this.m_sweep.c.Copy(this.m_xf.p);
    this.m_sweep.a0 = a.angle;
    this.m_sweep.a = a.angle;
    this.m_sweep.alpha0 = 0;
    this.m_linearVelocity.Copy(a.linearVelocity);
    this.m_angularVelocity = a.angularVelocity;
    this.m_linearDamping = a.linearDamping;
    this.m_angularDamping = a.angularDamping;
    this.m_gravityScale = a.gravityScale;
    this.m_force.SetZero();
    this.m_sleepTime = this.m_torque = 0;
    this.m_type = a.type;
    this.m_invMass = a.type == box2d.b2BodyType.b2_dynamicBody ? this.m_mass = 1 : this.m_mass = 0;
    this.m_invI = this.m_I = 0;
    this.m_userData = a.userData;
    this.m_fixtureList = null;
    this.m_fixtureCount = 0;
    this.m_controllerList = null;
    this.m_controllerCount = 0
};
goog.exportSymbol("box2d.b2Body", box2d.b2Body);
box2d.b2Body.prototype.m_flags = box2d.b2BodyFlag.e_none;
goog.exportProperty(box2d.b2Body.prototype, "m_flags", box2d.b2Body.prototype.m_flags);
box2d.b2Body.prototype.m_islandIndex = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_islandIndex", box2d.b2Body.prototype.m_islandIndex);
box2d.b2Body.prototype.m_world = null;
goog.exportProperty(box2d.b2Body.prototype, "m_world", box2d.b2Body.prototype.m_world);
box2d.b2Body.prototype.m_xf = null;
goog.exportProperty(box2d.b2Body.prototype, "m_xf", box2d.b2Body.prototype.m_xf);
box2d.b2Body.prototype.m_out_xf = null;
goog.exportProperty(box2d.b2Body.prototype, "m_out_xf", box2d.b2Body.prototype.m_out_xf);
box2d.b2Body.prototype.m_sweep = null;
goog.exportProperty(box2d.b2Body.prototype, "m_sweep", box2d.b2Body.prototype.m_sweep);
box2d.b2Body.prototype.m_out_sweep = null;
goog.exportProperty(box2d.b2Body.prototype, "m_out_sweep", box2d.b2Body.prototype.m_out_sweep);
box2d.b2Body.prototype.m_jointList = null;
goog.exportProperty(box2d.b2Body.prototype, "m_jointList", box2d.b2Body.prototype.m_jointList);
box2d.b2Body.prototype.m_contactList = null;
goog.exportProperty(box2d.b2Body.prototype, "m_contactList", box2d.b2Body.prototype.m_contactList);
box2d.b2Body.prototype.m_prev = null;
goog.exportProperty(box2d.b2Body.prototype, "m_prev", box2d.b2Body.prototype.m_prev);
box2d.b2Body.prototype.m_next = null;
goog.exportProperty(box2d.b2Body.prototype, "m_next", box2d.b2Body.prototype.m_next);
box2d.b2Body.prototype.m_linearVelocity = null;
goog.exportProperty(box2d.b2Body.prototype, "m_linearVelocity", box2d.b2Body.prototype.m_linearVelocity);
box2d.b2Body.prototype.m_out_linearVelocity = null;
goog.exportProperty(box2d.b2Body.prototype, "m_out_linearVelocity", box2d.b2Body.prototype.m_out_linearVelocity);
box2d.b2Body.prototype.m_angularVelocity = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_angularVelocity", box2d.b2Body.prototype.m_angularVelocity);
box2d.b2Body.prototype.m_linearDamping = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_linearDamping", box2d.b2Body.prototype.m_linearDamping);
box2d.b2Body.prototype.m_angularDamping = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_angularDamping", box2d.b2Body.prototype.m_angularDamping);
box2d.b2Body.prototype.m_gravityScale = 1;
goog.exportProperty(box2d.b2Body.prototype, "m_gravityScale", box2d.b2Body.prototype.m_gravityScale);
box2d.b2Body.prototype.m_force = null;
goog.exportProperty(box2d.b2Body.prototype, "m_force", box2d.b2Body.prototype.m_force);
box2d.b2Body.prototype.m_torque = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_torque", box2d.b2Body.prototype.m_torque);
box2d.b2Body.prototype.m_sleepTime = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_sleepTime", box2d.b2Body.prototype.m_sleepTime);
box2d.b2Body.prototype.m_type = box2d.b2BodyType.b2_staticBody;
goog.exportProperty(box2d.b2Body.prototype, "m_type", box2d.b2Body.prototype.m_type);
box2d.b2Body.prototype.m_mass = 1;
goog.exportProperty(box2d.b2Body.prototype, "m_mass", box2d.b2Body.prototype.m_mass);
box2d.b2Body.prototype.m_invMass = 1;
goog.exportProperty(box2d.b2Body.prototype, "m_invMass", box2d.b2Body.prototype.m_invMass);
box2d.b2Body.prototype.m_I = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_I", box2d.b2Body.prototype.m_I);
box2d.b2Body.prototype.m_invI = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_invI", box2d.b2Body.prototype.m_invI);
box2d.b2Body.prototype.m_userData = null;
goog.exportProperty(box2d.b2Body.prototype, "m_userData", box2d.b2Body.prototype.m_userData);
box2d.b2Body.prototype.m_fixtureList = null;
goog.exportProperty(box2d.b2Body.prototype, "m_fixtureList", box2d.b2Body.prototype.m_fixtureList);
box2d.b2Body.prototype.m_fixtureCount = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_fixtureCount", box2d.b2Body.prototype.m_fixtureCount);
box2d.b2Body.prototype.m_controllerList = null;
goog.exportProperty(box2d.b2Body.prototype, "m_controllerList", box2d.b2Body.prototype.m_controllerList);
box2d.b2Body.prototype.m_controllerCount = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_controllerCount", box2d.b2Body.prototype.m_controllerCount);
box2d.b2Body.prototype.CreateFixture = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.m_world.IsLocked());
    if (!0 == this.m_world.IsLocked())
        return null;
    var b = new box2d.b2Fixture;
    b.Create(this, a);
    this.m_flags & box2d.b2BodyFlag.e_activeFlag && b.CreateProxies(this.m_world.m_contactManager.m_broadPhase, this.m_xf);
    b.m_next = this.m_fixtureList;
    this.m_fixtureList = b;
    ++this.m_fixtureCount;
    b.m_body = this;
    0 < b.m_density && this.ResetMassData();
    this.m_world.m_flags |= box2d.b2WorldFlag.e_newFixture;
    return b
};
goog.exportProperty(box2d.b2Body.prototype, "CreateFixture", box2d.b2Body.prototype.CreateFixture);
box2d.b2Body.prototype.CreateFixture2 = function(a, b) {
    void 0 === b && (b = 0);
    var c = box2d.b2Body.prototype.CreateFixture2.s_def;
    c.shape = a;
    c.density = b;
    return this.CreateFixture(c)
};
goog.exportProperty(box2d.b2Body.prototype, "CreateFixture2", box2d.b2Body.prototype.CreateFixture2);
box2d.b2Body.prototype.CreateFixture2.s_def = new box2d.b2FixtureDef;
box2d.b2Body.prototype.DestroyFixture = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.m_world.IsLocked());
    if (!0 != this.m_world.IsLocked()) {
        box2d.ENABLE_ASSERTS && box2d.b2Assert(a.m_body == this);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < this.m_fixtureCount);
        for (var b = this.m_fixtureList, c = null, e = !1; null != b; ) {
            if (b == a) {
                c ? c.m_next = a.m_next : this.m_fixtureList = a.m_next;
                e = !0;
                break
            }
            c = b;
            b = b.m_next
        }
        box2d.ENABLE_ASSERTS && box2d.b2Assert(e);
        for (b = this.m_contactList; b; ) {
            var c = b.contact, b = b.next, e = c.GetFixtureA(),
                    d = c.GetFixtureB();
            a != e && a != d || this.m_world.m_contactManager.Destroy(c)
        }
        this.m_flags & box2d.b2BodyFlag.e_activeFlag && a.DestroyProxies(this.m_world.m_contactManager.m_broadPhase);
        a.Destroy();
        a.m_body = null;
        a.m_next = null;
        --this.m_fixtureCount;
        this.ResetMassData()
    }
};
goog.exportProperty(box2d.b2Body.prototype, "DestroyFixture", box2d.b2Body.prototype.DestroyFixture);
box2d.b2Body.prototype.SetTransformVecRadians = function(a, b) {
    this.SetTransformXYRadians(a.x, a.y, b)
};
goog.exportProperty(box2d.b2Body.prototype, "SetTransformVecRadians", box2d.b2Body.prototype.SetTransformVecRadians);
box2d.b2Body.prototype.SetTransformXYRadians = function(a, b, c) {
    if (this.m_xf.p.x != a || this.m_xf.p.y != b || this.m_xf.q.GetAngleRadians() != c)
        if (box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.m_world.IsLocked()), !0 != this.m_world.IsLocked()) {
            this.m_xf.q.SetAngleRadians(c);
            this.m_xf.p.SetXY(a, b);
            box2d.b2MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);
            this.m_sweep.a = c;
            this.m_sweep.c0.Copy(this.m_sweep.c);
            this.m_sweep.a0 = c;
            a = this.m_world.m_contactManager.m_broadPhase;
            for (b = this.m_fixtureList; b; b = b.m_next)
                b.Synchronize(a,
                        this.m_xf, this.m_xf);
            this.m_world.m_contactManager.FindNewContacts()
        }
};
goog.exportProperty(box2d.b2Body.prototype, "SetTransformXYRadians", box2d.b2Body.prototype.SetTransformXYRadians);
box2d.b2Body.prototype.SetTransform = function(a) {
    this.SetTransformVecRadians(a.p, a.GetAngleRadians())
};
goog.exportProperty(box2d.b2Body.prototype, "SetTransform", box2d.b2Body.prototype.SetTransform);
box2d.b2Body.prototype.GetTransform = function(a) {
    a = a || this.m_out_xf;
    return a.Copy(this.m_xf)
};
goog.exportProperty(box2d.b2Body.prototype, "GetTransform", box2d.b2Body.prototype.GetTransform);
box2d.b2Body.prototype.GetPosition = function(a) {
    a = a || this.m_out_xf.p;
    return a.Copy(this.m_xf.p)
};
goog.exportProperty(box2d.b2Body.prototype, "GetPosition", box2d.b2Body.prototype.GetPosition);
box2d.b2Body.prototype.SetPosition = function(a) {
    this.SetTransformVecRadians(a, this.GetAngleRadians())
};
goog.exportProperty(box2d.b2Body.prototype, "SetPosition", box2d.b2Body.prototype.SetPosition);
box2d.b2Body.prototype.SetPositionXY = function(a, b) {
    this.SetTransformXYRadians(a, b, this.GetAngleRadians())
};
goog.exportProperty(box2d.b2Body.prototype, "SetPositionXY", box2d.b2Body.prototype.SetPositionXY);
box2d.b2Body.prototype.GetAngleRadians = function() {
    return this.m_sweep.a
};
goog.exportProperty(box2d.b2Body.prototype, "GetAngleRadians", box2d.b2Body.prototype.GetAngleRadians);
box2d.b2Body.prototype.SetAngleRadians = function(a) {
    this.SetTransformVecRadians(this.GetPosition(), a)
};
goog.exportProperty(box2d.b2Body.prototype, "SetAngleRadians", box2d.b2Body.prototype.SetAngleRadians);
box2d.b2Body.prototype.GetWorldCenter = function(a) {
    a = a || this.m_out_sweep.c;
    return a.Copy(this.m_sweep.c)
};
goog.exportProperty(box2d.b2Body.prototype, "GetWorldCenter", box2d.b2Body.prototype.GetWorldCenter);
box2d.b2Body.prototype.GetLocalCenter = function(a) {
    a = a || this.m_out_sweep.localCenter;
    return a.Copy(this.m_sweep.localCenter)
};
goog.exportProperty(box2d.b2Body.prototype, "GetLocalCenter", box2d.b2Body.prototype.GetLocalCenter);
box2d.b2Body.prototype.SetLinearVelocity = function(a) {
    this.m_type != box2d.b2BodyType.b2_staticBody && (0 < box2d.b2DotVV(a, a) && this.SetAwake(!0), this.m_linearVelocity.Copy(a))
};
goog.exportProperty(box2d.b2Body.prototype, "SetLinearVelocity", box2d.b2Body.prototype.SetLinearVelocity);
box2d.b2Body.prototype.GetLinearVelocity = function(a) {
    a = a || this.m_out_linearVelocity;
    return a.Copy(this.m_linearVelocity)
};
goog.exportProperty(box2d.b2Body.prototype, "GetLinearVelocity", box2d.b2Body.prototype.GetLinearVelocity);
box2d.b2Body.prototype.SetAngularVelocity = function(a) {
    this.m_type != box2d.b2BodyType.b2_staticBody && (0 < a * a && this.SetAwake(!0), this.m_angularVelocity = a)
};
goog.exportProperty(box2d.b2Body.prototype, "SetAngularVelocity", box2d.b2Body.prototype.SetAngularVelocity);
box2d.b2Body.prototype.GetAngularVelocity = function() {
    return this.m_angularVelocity
};
goog.exportProperty(box2d.b2Body.prototype, "GetAngularVelocity", box2d.b2Body.prototype.GetAngularVelocity);
box2d.b2Body.prototype.GetDefinition = function(a) {
    a.type = this.GetType();
    a.allowSleep = (this.m_flags & box2d.b2BodyFlag.e_autoSleepFlag) == box2d.b2BodyFlag.e_autoSleepFlag;
    a.angle = this.GetAngleRadians();
    a.angularDamping = this.m_angularDamping;
    a.gravityScale = this.m_gravityScale;
    a.angularVelocity = this.m_angularVelocity;
    a.fixedRotation = (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) == box2d.b2BodyFlag.e_fixedRotationFlag;
    a.bullet = (this.m_flags & box2d.b2BodyFlag.e_bulletFlag) == box2d.b2BodyFlag.e_bulletFlag;
    a.awake = (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) == box2d.b2BodyFlag.e_awakeFlag;
    a.linearDamping = this.m_linearDamping;
    a.linearVelocity.Copy(this.GetLinearVelocity());
    a.position.Copy(this.GetPosition());
    a.userData = this.GetUserData();
    return a
};
goog.exportProperty(box2d.b2Body.prototype, "GetDefinition", box2d.b2Body.prototype.GetDefinition);
box2d.b2Body.prototype.ApplyForce = function(a, b, c) {
    this.m_type == box2d.b2BodyType.b2_dynamicBody && (0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_force.x += a.x, this.m_force.y += a.y, this.m_torque += (b.x - this.m_sweep.c.x) * a.y - (b.y - this.m_sweep.c.y) * a.x))
};
goog.exportProperty(box2d.b2Body.prototype, "ApplyForce", box2d.b2Body.prototype.ApplyForce);
box2d.b2Body.prototype.ApplyForceToCenter = function(a, b) {
    this.m_type == box2d.b2BodyType.b2_dynamicBody && (0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_force.x += a.x, this.m_force.y += a.y))
};
goog.exportProperty(box2d.b2Body.prototype, "ApplyForceToCenter", box2d.b2Body.prototype.ApplyForceToCenter);
box2d.b2Body.prototype.ApplyTorque = function(a, b) {
    this.m_type == box2d.b2BodyType.b2_dynamicBody && (0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_torque += a))
};
goog.exportProperty(box2d.b2Body.prototype, "ApplyTorque", box2d.b2Body.prototype.ApplyTorque);
box2d.b2Body.prototype.ApplyLinearImpulse = function(a, b, c) {
    this.m_type == box2d.b2BodyType.b2_dynamicBody && (0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_linearVelocity.x += this.m_invMass * a.x, this.m_linearVelocity.y += this.m_invMass * a.y, this.m_angularVelocity += this.m_invI * ((b.x - this.m_sweep.c.x) * a.y - (b.y - this.m_sweep.c.y) * a.x)))
};
goog.exportProperty(box2d.b2Body.prototype, "ApplyLinearImpulse", box2d.b2Body.prototype.ApplyLinearImpulse);
box2d.b2Body.prototype.ApplyAngularImpulse = function(a, b) {
    this.m_type == box2d.b2BodyType.b2_dynamicBody && (0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_angularVelocity += this.m_invI * a))
};
goog.exportProperty(box2d.b2Body.prototype, "ApplyAngularImpulse", box2d.b2Body.prototype.ApplyAngularImpulse);
box2d.b2Body.prototype.GetMass = function() {
    return this.m_mass
};
goog.exportProperty(box2d.b2Body.prototype, "GetMass", box2d.b2Body.prototype.GetMass);
box2d.b2Body.prototype.GetInertia = function() {
    return this.m_I + this.m_mass * box2d.b2DotVV(this.m_sweep.localCenter, this.m_sweep.localCenter)
};
goog.exportProperty(box2d.b2Body.prototype, "GetInertia", box2d.b2Body.prototype.GetInertia);
box2d.b2Body.prototype.GetMassData = function(a) {
    a.mass = this.m_mass;
    a.I = this.m_I + this.m_mass * box2d.b2DotVV(this.m_sweep.localCenter, this.m_sweep.localCenter);
    a.center.Copy(this.m_sweep.localCenter);
    return a
};
goog.exportProperty(box2d.b2Body.prototype, "GetMassData", box2d.b2Body.prototype.GetMassData);
box2d.b2Body.prototype.SetMassData = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.m_world.IsLocked());
    if (!0 != this.m_world.IsLocked() && this.m_type == box2d.b2BodyType.b2_dynamicBody) {
        this.m_invI = this.m_I = this.m_invMass = 0;
        this.m_mass = a.mass;
        0 >= this.m_mass && (this.m_mass = 1);
        this.m_invMass = 1 / this.m_mass;
        0 < a.I && 0 == (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) && (this.m_I = a.I - this.m_mass * box2d.b2DotVV(a.center, a.center), box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < this.m_I), this.m_invI = 1 / this.m_I);
        var b = box2d.b2Body.prototype.SetMassData.s_oldCenter.Copy(this.m_sweep.c);
        this.m_sweep.localCenter.Copy(a.center);
        box2d.b2MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);
        this.m_sweep.c0.Copy(this.m_sweep.c);
        box2d.b2AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, box2d.b2SubVV(this.m_sweep.c, b, box2d.b2Vec2.s_t0), this.m_linearVelocity)
    }
};
goog.exportProperty(box2d.b2Body.prototype, "SetMassData", box2d.b2Body.prototype.SetMassData);
box2d.b2Body.prototype.SetMassData.s_oldCenter = new box2d.b2Vec2;
box2d.b2Body.prototype.ResetMassData = function() {
    this.m_invI = this.m_I = this.m_invMass = this.m_mass = 0;
    this.m_sweep.localCenter.SetZero();
    if (this.m_type == box2d.b2BodyType.b2_staticBody || this.m_type == box2d.b2BodyType.b2_kinematicBody)
        this.m_sweep.c0.Copy(this.m_xf.p), this.m_sweep.c.Copy(this.m_xf.p), this.m_sweep.a0 = this.m_sweep.a;
    else {
        box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_type == box2d.b2BodyType.b2_dynamicBody);
        for (var a = box2d.b2Body.prototype.ResetMassData.s_localCenter.SetZero(), b = this.m_fixtureList; b; b =
                b.m_next)
            if (0 != b.m_density) {
                var c = b.GetMassData(box2d.b2Body.prototype.ResetMassData.s_massData);
                this.m_mass += c.mass;
                a.x += c.center.x * c.mass;
                a.y += c.center.y * c.mass;
                this.m_I += c.I
            }
        0 < this.m_mass ? (this.m_invMass = 1 / this.m_mass, a.x *= this.m_invMass, a.y *= this.m_invMass) : this.m_invMass = this.m_mass = 1;
        0 < this.m_I && 0 == (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) ? (this.m_I -= this.m_mass * box2d.b2DotVV(a, a), box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < this.m_I), this.m_invI = 1 / this.m_I) : this.m_invI = this.m_I = 0;
        b = box2d.b2Body.prototype.ResetMassData.s_oldCenter.Copy(this.m_sweep.c);
        this.m_sweep.localCenter.Copy(a);
        box2d.b2MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);
        this.m_sweep.c0.Copy(this.m_sweep.c);
        box2d.b2AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, box2d.b2SubVV(this.m_sweep.c, b, box2d.b2Vec2.s_t0), this.m_linearVelocity)
    }
};
goog.exportProperty(box2d.b2Body.prototype, "ResetMassData", box2d.b2Body.prototype.ResetMassData);
box2d.b2Body.prototype.ResetMassData.s_localCenter = new box2d.b2Vec2;
box2d.b2Body.prototype.ResetMassData.s_oldCenter = new box2d.b2Vec2;
box2d.b2Body.prototype.ResetMassData.s_massData = new box2d.b2MassData;
box2d.b2Body.prototype.GetWorldPoint = function(a, b) {
    return box2d.b2MulXV(this.m_xf, a, b)
};
goog.exportProperty(box2d.b2Body.prototype, "GetWorldPoint", box2d.b2Body.prototype.GetWorldPoint);
box2d.b2Body.prototype.GetWorldVector = function(a, b) {
    return box2d.b2MulRV(this.m_xf.q, a, b)
};
goog.exportProperty(box2d.b2Body.prototype, "GetWorldVector", box2d.b2Body.prototype.GetWorldVector);
box2d.b2Body.prototype.GetLocalPoint = function(a, b) {
    return box2d.b2MulTXV(this.m_xf, a, b)
};
goog.exportProperty(box2d.b2Body.prototype, "GetLocalPoint", box2d.b2Body.prototype.GetLocalPoint);
box2d.b2Body.prototype.GetLocalVector = function(a, b) {
    return box2d.b2MulTRV(this.m_xf.q, a, b)
};
goog.exportProperty(box2d.b2Body.prototype, "GetLocalVector", box2d.b2Body.prototype.GetLocalVector);
box2d.b2Body.prototype.GetLinearVelocityFromWorldPoint = function(a, b) {
    return box2d.b2AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, box2d.b2SubVV(a, this.m_sweep.c, box2d.b2Vec2.s_t0), b)
};
goog.exportProperty(box2d.b2Body.prototype, "GetLinearVelocityFromWorldPoint", box2d.b2Body.prototype.GetLinearVelocityFromWorldPoint);
box2d.b2Body.prototype.GetLinearVelocityFromLocalPoint = function(a, b) {
    return this.GetLinearVelocityFromWorldPoint(this.GetWorldPoint(a, b), b)
};
goog.exportProperty(box2d.b2Body.prototype, "GetLinearVelocityFromLocalPoint", box2d.b2Body.prototype.GetLinearVelocityFromLocalPoint);
box2d.b2Body.prototype.GetLinearDamping = function() {
    return this.m_linearDamping
};
goog.exportProperty(box2d.b2Body.prototype, "GetLinearDamping", box2d.b2Body.prototype.GetLinearDamping);
box2d.b2Body.prototype.SetLinearDamping = function(a) {
    this.m_linearDamping = a
};
goog.exportProperty(box2d.b2Body.prototype, "SetLinearDamping", box2d.b2Body.prototype.SetLinearDamping);
box2d.b2Body.prototype.GetAngularDamping = function() {
    return this.m_angularDamping
};
goog.exportProperty(box2d.b2Body.prototype, "GetAngularDamping", box2d.b2Body.prototype.GetAngularDamping);
box2d.b2Body.prototype.SetAngularDamping = function(a) {
    this.m_angularDamping = a
};
goog.exportProperty(box2d.b2Body.prototype, "SetAngularDamping", box2d.b2Body.prototype.SetAngularDamping);
box2d.b2Body.prototype.GetGravityScale = function() {
    return this.m_gravityScale
};
goog.exportProperty(box2d.b2Body.prototype, "GetGravityScale", box2d.b2Body.prototype.GetGravityScale);
box2d.b2Body.prototype.SetGravityScale = function(a) {
    this.m_gravityScale = a
};
goog.exportProperty(box2d.b2Body.prototype, "SetGravityScale", box2d.b2Body.prototype.SetGravityScale);
box2d.b2Body.prototype.SetType = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.m_world.IsLocked());
    if (!0 != this.m_world.IsLocked() && this.m_type != a) {
        this.m_type = a;
        this.ResetMassData();
        this.m_type == box2d.b2BodyType.b2_staticBody && (this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0, this.m_sweep.a0 = this.m_sweep.a, this.m_sweep.c0.Copy(this.m_sweep.c), this.SynchronizeFixtures());
        this.SetAwake(!0);
        this.m_force.SetZero();
        this.m_torque = 0;
        for (a = this.m_contactList; a; ) {
            var b = a;
            a = a.next;
            this.m_world.m_contactManager.Destroy(b.contact)
        }
        this.m_contactList =
                null;
        a = this.m_world.m_contactManager.m_broadPhase;
        for (b = this.m_fixtureList; b; b = b.m_next)
            for (var c = b.m_proxyCount, e = 0; e < c; ++e)
                a.TouchProxy(b.m_proxies[e].proxy)
    }
};
goog.exportProperty(box2d.b2Body.prototype, "SetType", box2d.b2Body.prototype.SetType);
box2d.b2Body.prototype.GetType = function() {
    return this.m_type
};
goog.exportProperty(box2d.b2Body.prototype, "GetType", box2d.b2Body.prototype.GetType);
box2d.b2Body.prototype.SetBullet = function(a) {
    this.m_flags = a ? this.m_flags | box2d.b2BodyFlag.e_bulletFlag : this.m_flags & ~box2d.b2BodyFlag.e_bulletFlag
};
goog.exportProperty(box2d.b2Body.prototype, "SetBullet", box2d.b2Body.prototype.SetBullet);
box2d.b2Body.prototype.IsBullet = function() {
    return(this.m_flags & box2d.b2BodyFlag.e_bulletFlag) == box2d.b2BodyFlag.e_bulletFlag
};
goog.exportProperty(box2d.b2Body.prototype, "IsBullet", box2d.b2Body.prototype.IsBullet);
box2d.b2Body.prototype.SetSleepingAllowed = function(a) {
    a ? this.m_flags |= box2d.b2BodyFlag.e_autoSleepFlag : (this.m_flags &= ~box2d.b2BodyFlag.e_autoSleepFlag, this.SetAwake(!0))
};
goog.exportProperty(box2d.b2Body.prototype, "SetSleepingAllowed", box2d.b2Body.prototype.SetSleepingAllowed);
box2d.b2Body.prototype.IsSleepingAllowed = function() {
    return(this.m_flags & box2d.b2BodyFlag.e_autoSleepFlag) == box2d.b2BodyFlag.e_autoSleepFlag
};
goog.exportProperty(box2d.b2Body.prototype, "IsSleepingAllowed", box2d.b2Body.prototype.IsSleepingAllowed);
box2d.b2Body.prototype.SetAwake = function(a) {
    a ? 0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && (this.m_flags |= box2d.b2BodyFlag.e_awakeFlag, this.m_sleepTime = 0) : (this.m_flags &= ~box2d.b2BodyFlag.e_awakeFlag, this.m_sleepTime = 0, this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0, this.m_force.SetZero(), this.m_torque = 0)
};
goog.exportProperty(box2d.b2Body.prototype, "SetAwake", box2d.b2Body.prototype.SetAwake);
box2d.b2Body.prototype.IsAwake = function() {
    return(this.m_flags & box2d.b2BodyFlag.e_awakeFlag) == box2d.b2BodyFlag.e_awakeFlag
};
goog.exportProperty(box2d.b2Body.prototype, "IsAwake", box2d.b2Body.prototype.IsAwake);
box2d.b2Body.prototype.SetActive = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.m_world.IsLocked());
    if (a != this.IsActive())
        if (a) {
            this.m_flags |= box2d.b2BodyFlag.e_activeFlag;
            a = this.m_world.m_contactManager.m_broadPhase;
            for (var b = this.m_fixtureList; b; b = b.m_next)
                b.CreateProxies(a, this.m_xf)
        } else {
            this.m_flags &= ~box2d.b2BodyFlag.e_activeFlag;
            a = this.m_world.m_contactManager.m_broadPhase;
            for (b = this.m_fixtureList; b; b = b.m_next)
                b.DestroyProxies(a);
            for (a = this.m_contactList; a; )
                b = a, a = a.next, this.m_world.m_contactManager.Destroy(b.contact);
            this.m_contactList = null
        }
};
goog.exportProperty(box2d.b2Body.prototype, "SetActive", box2d.b2Body.prototype.SetActive);
box2d.b2Body.prototype.IsActive = function() {
    return(this.m_flags & box2d.b2BodyFlag.e_activeFlag) == box2d.b2BodyFlag.e_activeFlag
};
goog.exportProperty(box2d.b2Body.prototype, "IsActive", box2d.b2Body.prototype.IsActive);
box2d.b2Body.prototype.SetFixedRotation = function(a) {
    (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) == box2d.b2BodyFlag.e_fixedRotationFlag != a && (this.m_flags = a ? this.m_flags | box2d.b2BodyFlag.e_fixedRotationFlag : this.m_flags & ~box2d.b2BodyFlag.e_fixedRotationFlag, this.m_angularVelocity = 0, this.ResetMassData())
};
goog.exportProperty(box2d.b2Body.prototype, "SetFixedRotation", box2d.b2Body.prototype.SetFixedRotation);
box2d.b2Body.prototype.IsFixedRotation = function() {
    return(this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) == box2d.b2BodyFlag.e_fixedRotationFlag
};
goog.exportProperty(box2d.b2Body.prototype, "IsFixedRotation", box2d.b2Body.prototype.IsFixedRotation);
box2d.b2Body.prototype.GetFixtureList = function() {
    return this.m_fixtureList
};
goog.exportProperty(box2d.b2Body.prototype, "GetFixtureList", box2d.b2Body.prototype.GetFixtureList);
box2d.b2Body.prototype.GetJointList = function() {
    return this.m_jointList
};
goog.exportProperty(box2d.b2Body.prototype, "GetJointList", box2d.b2Body.prototype.GetJointList);
box2d.b2Body.prototype.GetContactList = function() {
    return this.m_contactList
};
goog.exportProperty(box2d.b2Body.prototype, "GetContactList", box2d.b2Body.prototype.GetContactList);
box2d.b2Body.prototype.GetNext = function() {
    return this.m_next
};
goog.exportProperty(box2d.b2Body.prototype, "GetNext", box2d.b2Body.prototype.GetNext);
box2d.b2Body.prototype.GetUserData = function() {
    return this.m_userData
};
goog.exportProperty(box2d.b2Body.prototype, "GetUserData", box2d.b2Body.prototype.GetUserData);
box2d.b2Body.prototype.SetUserData = function(a) {
    this.m_userData = a
};
goog.exportProperty(box2d.b2Body.prototype, "SetUserData", box2d.b2Body.prototype.SetUserData);
box2d.b2Body.prototype.GetWorld = function() {
    return this.m_world
};
goog.exportProperty(box2d.b2Body.prototype, "GetWorld", box2d.b2Body.prototype.GetWorld);
box2d.b2Body.prototype.SynchronizeFixtures = function() {
    var a = box2d.b2Body.prototype.SynchronizeFixtures.s_xf1;
    a.q.SetAngleRadians(this.m_sweep.a0);
    box2d.b2MulRV(a.q, this.m_sweep.localCenter, a.p);
    box2d.b2SubVV(this.m_sweep.c0, a.p, a.p);
    for (var b = this.m_world.m_contactManager.m_broadPhase, c = this.m_fixtureList; c; c = c.m_next)
        c.Synchronize(b, a, this.m_xf)
};
goog.exportProperty(box2d.b2Body.prototype, "SynchronizeFixtures", box2d.b2Body.prototype.SynchronizeFixtures);
box2d.b2Body.prototype.SynchronizeFixtures.s_xf1 = new box2d.b2Transform;
box2d.b2Body.prototype.SynchronizeTransform = function() {
    this.m_xf.q.SetAngleRadians(this.m_sweep.a);
    box2d.b2MulRV(this.m_xf.q, this.m_sweep.localCenter, this.m_xf.p);
    box2d.b2SubVV(this.m_sweep.c, this.m_xf.p, this.m_xf.p)
};
goog.exportProperty(box2d.b2Body.prototype, "SynchronizeTransform", box2d.b2Body.prototype.SynchronizeTransform);
box2d.b2Body.prototype.ShouldCollide = function(a) {
    if (this.m_type != box2d.b2BodyType.b2_dynamicBody && a.m_type != box2d.b2BodyType.b2_dynamicBody)
        return!1;
    for (var b = this.m_jointList; b; b = b.next)
        if (b.other == a && !1 == b.joint.m_collideConnected)
            return!1;
    return!0
};
goog.exportProperty(box2d.b2Body.prototype, "ShouldCollide", box2d.b2Body.prototype.ShouldCollide);
box2d.b2Body.prototype.Advance = function(a) {
    this.m_sweep.Advance(a);
    this.m_sweep.c.Copy(this.m_sweep.c0);
    this.m_sweep.a = this.m_sweep.a0;
    this.m_xf.q.SetAngleRadians(this.m_sweep.a);
    box2d.b2MulRV(this.m_xf.q, this.m_sweep.localCenter, this.m_xf.p);
    box2d.b2SubVV(this.m_sweep.c, this.m_xf.p, this.m_xf.p)
};
goog.exportProperty(box2d.b2Body.prototype, "Advance", box2d.b2Body.prototype.Advance);
box2d.b2Body.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_islandIndex;
        box2d.b2Log("if (true)\n");
        box2d.b2Log("{\n");
        box2d.b2Log("  /*box2d.b2BodyDef*/ var bd = new box2d.b2BodyDef();\n");
        var b = "";
        switch (this.m_type) {
            case box2d.b2BodyType.b2_staticBody:
                b = "box2d.b2BodyType.b2_staticBody";
                break;
            case box2d.b2BodyType.b2_kinematicBody:
                b = "box2d.b2BodyType.b2_kinematicBody";
                break;
            case box2d.b2BodyType.b2_dynamicBody:
                b = "box2d.b2BodyType.b2_dynamicBody";
                break;
            default:
                box2d.ENABLE_ASSERTS && box2d.b2Assert(!1)
        }
        box2d.b2Log("  bd.type = %s;\n",
                b);
        box2d.b2Log("  bd.position.SetXY(%.15f, %.15f);\n", this.m_xf.p.x, this.m_xf.p.y);
        box2d.b2Log("  bd.angle = %.15f;\n", this.m_sweep.a);
        box2d.b2Log("  bd.linearVelocity.SetXY(%.15f, %.15f);\n", this.m_linearVelocity.x, this.m_linearVelocity.y);
        box2d.b2Log("  bd.angularVelocity = %.15f;\n", this.m_angularVelocity);
        box2d.b2Log("  bd.linearDamping = %.15f;\n", this.m_linearDamping);
        box2d.b2Log("  bd.angularDamping = %.15f;\n", this.m_angularDamping);
        box2d.b2Log("  bd.allowSleep = %s;\n", this.m_flags & box2d.b2BodyFlag.e_autoSleepFlag ?
                "true" : "false");
        box2d.b2Log("  bd.awake = %s;\n", this.m_flags & box2d.b2BodyFlag.e_awakeFlag ? "true" : "false");
        box2d.b2Log("  bd.fixedRotation = %s;\n", this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag ? "true" : "false");
        box2d.b2Log("  bd.bullet = %s;\n", this.m_flags & box2d.b2BodyFlag.e_bulletFlag ? "true" : "false");
        box2d.b2Log("  bd.active = %s;\n", this.m_flags & box2d.b2BodyFlag.e_activeFlag ? "true" : "false");
        box2d.b2Log("  bd.gravityScale = %.15f;\n", this.m_gravityScale);
        box2d.b2Log("\n");
        box2d.b2Log("  bodies[%d] = this.m_world.CreateBody(bd);\n",
                this.m_islandIndex);
        box2d.b2Log("\n");
        for (b = this.m_fixtureList; b; b = b.m_next)
            box2d.b2Log("  if (true)\n"), box2d.b2Log("  {\n"), b.Dump(a), box2d.b2Log("  }\n");
        box2d.b2Log("}\n")
    }
};
goog.exportProperty(box2d.b2Body.prototype, "Dump", box2d.b2Body.prototype.Dump);
box2d.b2Body.prototype.GetControllerList = function() {
    return this.m_controllerList
};
goog.exportProperty(box2d.b2Body.prototype, "GetControllerList", box2d.b2Body.prototype.GetControllerList);
box2d.b2Body.prototype.GetControllerCount = function() {
    return this.m_controllerCount
};
goog.exportProperty(box2d.b2Body.prototype, "GetControllerCount", box2d.b2Body.prototype.GetControllerCount);
box2d.b2WorldFlag = {e_none: 0, e_newFixture: 1, e_locked: 2, e_clearForces: 4};
goog.exportSymbol("box2d.b2WorldFlag", box2d.b2WorldFlag);
goog.exportProperty(box2d.b2WorldFlag, "e_none", box2d.b2WorldFlag.e_none);
goog.exportProperty(box2d.b2WorldFlag, "e_newFixture", box2d.b2WorldFlag.e_newFixture);
goog.exportProperty(box2d.b2WorldFlag, "e_locked", box2d.b2WorldFlag.e_locked);
goog.exportProperty(box2d.b2WorldFlag, "e_clearForces", box2d.b2WorldFlag.e_clearForces);
box2d.b2World = function(a) {
    this.m_flags = box2d.b2WorldFlag.e_clearForces;
    this.m_contactManager = new box2d.b2ContactManager;
    this.m_gravity = a.Clone();
    this.m_out_gravity = new box2d.b2Vec2;
    this.m_allowSleep = !0;
    this.m_debugDraw = this.m_destructionListener = null;
    this.m_continuousPhysics = this.m_warmStarting = !0;
    this.m_subStepping = !1;
    this.m_stepComplete = !0;
    this.m_profile = new box2d.b2Profile;
    this.m_island = new box2d.b2Island;
    this.s_stack = []
};
goog.exportSymbol("box2d.b2World", box2d.b2World);
box2d.b2World.prototype.m_flags = box2d.b2WorldFlag.e_none;
goog.exportProperty(box2d.b2World.prototype, "m_flags", box2d.b2World.prototype.m_flags);
box2d.b2World.prototype.m_contactManager = null;
goog.exportProperty(box2d.b2World.prototype, "m_contactManager", box2d.b2World.prototype.m_contactManager);
box2d.b2World.prototype.m_bodyList = null;
goog.exportProperty(box2d.b2World.prototype, "m_bodyList", box2d.b2World.prototype.m_bodyList);
box2d.b2World.prototype.m_jointList = null;
goog.exportProperty(box2d.b2World.prototype, "m_jointList", box2d.b2World.prototype.m_jointList);
box2d.b2World.prototype.m_bodyCount = 0;
goog.exportProperty(box2d.b2World.prototype, "m_bodyCount", box2d.b2World.prototype.m_bodyCount);
box2d.b2World.prototype.m_jointCount = 0;
goog.exportProperty(box2d.b2World.prototype, "m_jointCount", box2d.b2World.prototype.m_jointCount);
box2d.b2World.prototype.m_gravity = null;
goog.exportProperty(box2d.b2World.prototype, "m_gravity", box2d.b2World.prototype.m_gravity);
box2d.b2World.prototype.m_out_gravity = null;
goog.exportProperty(box2d.b2World.prototype, "m_out_gravity", box2d.b2World.prototype.m_out_gravity);
box2d.b2World.prototype.m_allowSleep = !0;
goog.exportProperty(box2d.b2World.prototype, "m_allowSleep", box2d.b2World.prototype.m_allowSleep);
box2d.b2World.prototype.m_destructionListener = null;
goog.exportProperty(box2d.b2World.prototype, "m_destructionListener", box2d.b2World.prototype.m_destructionListener);
box2d.b2World.prototype.m_debugDraw = null;
goog.exportProperty(box2d.b2World.prototype, "m_debugDraw", box2d.b2World.prototype.m_debugDraw);
box2d.b2World.prototype.m_inv_dt0 = 0;
goog.exportProperty(box2d.b2World.prototype, "m_inv_dt0", box2d.b2World.prototype.m_inv_dt0);
box2d.b2World.prototype.m_warmStarting = !0;
goog.exportProperty(box2d.b2World.prototype, "m_warmStarting", box2d.b2World.prototype.m_warmStarting);
box2d.b2World.prototype.m_continuousPhysics = !0;
goog.exportProperty(box2d.b2World.prototype, "m_continuousPhysics", box2d.b2World.prototype.m_continuousPhysics);
box2d.b2World.prototype.m_subStepping = !1;
goog.exportProperty(box2d.b2World.prototype, "m_subStepping", box2d.b2World.prototype.m_subStepping);
box2d.b2World.prototype.m_stepComplete = !0;
goog.exportProperty(box2d.b2World.prototype, "m_stepComplete", box2d.b2World.prototype.m_stepComplete);
box2d.b2World.prototype.m_profile = null;
goog.exportProperty(box2d.b2World.prototype, "m_profile", box2d.b2World.prototype.m_profile);
box2d.b2World.prototype.m_island = null;
goog.exportProperty(box2d.b2World.prototype, "m_island", box2d.b2World.prototype.m_island);
box2d.b2World.prototype.s_stack = null;
goog.exportProperty(box2d.b2World.prototype, "s_stack", box2d.b2World.prototype.s_stack);
box2d.b2World.prototype.m_controllerList = null;
goog.exportProperty(box2d.b2World.prototype, "m_controllerList", box2d.b2World.prototype.m_controllerList);
box2d.b2World.prototype.m_controllerCount = 0;
goog.exportProperty(box2d.b2World.prototype, "m_controllerCount", box2d.b2World.prototype.m_controllerCount);
box2d.b2World.prototype.SetAllowSleeping = function(a) {
    if (a != this.m_allowSleep && (this.m_allowSleep = a, !1 == this.m_allowSleep))
        for (a = this.m_bodyList; a; a = a.m_next)
            a.SetAwake(!0)
};
goog.exportProperty(box2d.b2World.prototype, "SetAllowSleeping", box2d.b2World.prototype.SetAllowSleeping);
box2d.b2World.prototype.GetAllowSleeping = function() {
    return this.m_allowSleep
};
goog.exportProperty(box2d.b2World.prototype, "GetAllowSleeping", box2d.b2World.prototype.GetAllowSleeping);
box2d.b2World.prototype.SetWarmStarting = function(a) {
    this.m_warmStarting = a
};
goog.exportProperty(box2d.b2World.prototype, "SetWarmStarting", box2d.b2World.prototype.SetWarmStarting);
box2d.b2World.prototype.GetWarmStarting = function() {
    return this.m_warmStarting
};
goog.exportProperty(box2d.b2World.prototype, "GetWarmStarting", box2d.b2World.prototype.GetWarmStarting);
box2d.b2World.prototype.SetContinuousPhysics = function(a) {
    this.m_continuousPhysics = a
};
goog.exportProperty(box2d.b2World.prototype, "SetContinuousPhysics", box2d.b2World.prototype.SetContinuousPhysics);
box2d.b2World.prototype.GetContinuousPhysics = function() {
    return this.m_continuousPhysics
};
goog.exportProperty(box2d.b2World.prototype, "GetContinuousPhysics", box2d.b2World.prototype.GetContinuousPhysics);
box2d.b2World.prototype.SetSubStepping = function(a) {
    this.m_subStepping = a
};
goog.exportProperty(box2d.b2World.prototype, "SetSubStepping", box2d.b2World.prototype.SetSubStepping);
box2d.b2World.prototype.GetSubStepping = function() {
    return this.m_subStepping
};
goog.exportProperty(box2d.b2World.prototype, "GetSubStepping", box2d.b2World.prototype.GetSubStepping);
box2d.b2World.prototype.GetBodyList = function() {
    return this.m_bodyList
};
goog.exportProperty(box2d.b2World.prototype, "GetBodyList", box2d.b2World.prototype.GetBodyList);
box2d.b2World.prototype.GetJointList = function() {
    return this.m_jointList
};
goog.exportProperty(box2d.b2World.prototype, "GetJointList", box2d.b2World.prototype.GetJointList);
box2d.b2World.prototype.GetContactList = function() {
    return this.m_contactManager.m_contactList
};
goog.exportProperty(box2d.b2World.prototype, "GetContactList", box2d.b2World.prototype.GetContactList);
box2d.b2World.prototype.GetBodyCount = function() {
    return this.m_bodyCount
};
goog.exportProperty(box2d.b2World.prototype, "GetBodyCount", box2d.b2World.prototype.GetBodyCount);
box2d.b2World.prototype.GetJointCount = function() {
    return this.m_jointCount
};
goog.exportProperty(box2d.b2World.prototype, "GetJointCount", box2d.b2World.prototype.GetJointCount);
box2d.b2World.prototype.GetContactCount = function() {
    return this.m_contactManager.m_contactCount
};
goog.exportProperty(box2d.b2World.prototype, "GetContactCount", box2d.b2World.prototype.GetContactCount);
box2d.b2World.prototype.SetGravity = function(a, b) {
    b = b || !0;
    if (this.m_gravity.x !== a.x || this.m_gravity.y !== a.y)
        if (this.m_gravity.Copy(a), b)
            for (var c = this.m_bodyList; c; c = c.m_next)
                c.SetAwake(!0)
};
goog.exportProperty(box2d.b2World.prototype, "SetGravity", box2d.b2World.prototype.SetGravity);
box2d.b2World.prototype.GetGravity = function(a) {
    a = a || this.m_out_gravity;
    return a.Copy(this.m_gravity)
};
goog.exportProperty(box2d.b2World.prototype, "GetGravity", box2d.b2World.prototype.GetGravity);
box2d.b2World.prototype.IsLocked = function() {
    return 0 < (this.m_flags & box2d.b2WorldFlag.e_locked)
};
goog.exportProperty(box2d.b2World.prototype, "IsLocked", box2d.b2World.prototype.IsLocked);
box2d.b2World.prototype.SetAutoClearForces = function(a) {
    this.m_flags = a ? this.m_flags | box2d.b2WorldFlag.e_clearForces : this.m_flags & ~box2d.b2WorldFlag.e_clearForces
};
goog.exportProperty(box2d.b2World.prototype, "SetAutoClearForces", box2d.b2World.prototype.SetAutoClearForces);
box2d.b2World.prototype.GetAutoClearForces = function() {
    return(this.m_flags & box2d.b2WorldFlag.e_clearForces) == box2d.b2WorldFlag.e_clearForces
};
goog.exportProperty(box2d.b2World.prototype, "GetAutoClearForces", box2d.b2World.prototype.GetAutoClearForces);
box2d.b2World.prototype.GetContactManager = function() {
    return this.m_contactManager
};
goog.exportProperty(box2d.b2World.prototype, "GetContactManager", box2d.b2World.prototype.GetContactManager);
box2d.b2World.prototype.GetProfile = function() {
    return this.m_profile
};
goog.exportProperty(box2d.b2World.prototype, "GetProfile", box2d.b2World.prototype.GetProfile);
box2d.b2World.prototype.SetDestructionListener = function(a) {
    this.m_destructionListener = a
};
goog.exportProperty(box2d.b2World.prototype, "SetDestructionListener", box2d.b2World.prototype.SetDestructionListener);
box2d.b2World.prototype.SetContactFilter = function(a) {
    this.m_contactManager.m_contactFilter = a
};
goog.exportProperty(box2d.b2World.prototype, "SetContactFilter", box2d.b2World.prototype.SetContactFilter);
box2d.b2World.prototype.SetContactListener = function(a) {
    this.m_contactManager.m_contactListener = a
};
goog.exportProperty(box2d.b2World.prototype, "SetContactListener", box2d.b2World.prototype.SetContactListener);
box2d.b2World.prototype.SetDebugDraw = function(a) {
    this.m_debugDraw = a
};
goog.exportProperty(box2d.b2World.prototype, "SetDebugDraw", box2d.b2World.prototype.SetDebugDraw);
box2d.b2World.prototype.CreateBody = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.IsLocked());
    if (this.IsLocked())
        return null;
    a = new box2d.b2Body(a, this);
    a.m_prev = null;
    if (a.m_next = this.m_bodyList)
        this.m_bodyList.m_prev = a;
    this.m_bodyList = a;
    ++this.m_bodyCount;
    return a
};
goog.exportProperty(box2d.b2World.prototype, "CreateBody", box2d.b2World.prototype.CreateBody);
box2d.b2World.prototype.DestroyBody = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < this.m_bodyCount);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.IsLocked());
    if (!this.IsLocked()) {
        for (var b = a.m_jointList; b; ) {
            var c = b, b = b.next;
            this.m_destructionListener && this.m_destructionListener.SayGoodbyeJoint(c.joint);
            this.DestroyJoint(c.joint);
            a.m_jointList = b
        }
        a.m_jointList = null;
        for (b = a.m_controllerList; b; )
            c = b, b = b.nextController, c.controller.RemoveBody(a);
        for (b = a.m_contactList; b; )
            c = b, b = b.next, this.m_contactManager.Destroy(c.contact);
        a.m_contactList = null;
        for (b = a.m_fixtureList; b; )
            c = b, b = b.m_next, this.m_destructionListener && this.m_destructionListener.SayGoodbyeFixture(c), c.DestroyProxies(this.m_contactManager.m_broadPhase), c.Destroy(), a.m_fixtureList = b, a.m_fixtureCount -= 1;
        a.m_fixtureList = null;
        a.m_fixtureCount = 0;
        a.m_prev && (a.m_prev.m_next = a.m_next);
        a.m_next && (a.m_next.m_prev = a.m_prev);
        a == this.m_bodyList && (this.m_bodyList = a.m_next);
        --this.m_bodyCount
    }
};
goog.exportProperty(box2d.b2World.prototype, "DestroyBody", box2d.b2World.prototype.DestroyBody);
box2d.b2World.prototype.CreateJoint = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.IsLocked());
    if (this.IsLocked())
        return null;
    var b = box2d.b2JointFactory.Create(a, null);
    b.m_prev = null;
    if (b.m_next = this.m_jointList)
        this.m_jointList.m_prev = b;
    this.m_jointList = b;
    ++this.m_jointCount;
    b.m_edgeA.joint = b;
    b.m_edgeA.other = b.m_bodyB;
    b.m_edgeA.prev = null;
    if (b.m_edgeA.next = b.m_bodyA.m_jointList)
        b.m_bodyA.m_jointList.prev = b.m_edgeA;
    b.m_bodyA.m_jointList = b.m_edgeA;
    b.m_edgeB.joint = b;
    b.m_edgeB.other = b.m_bodyA;
    b.m_edgeB.prev = null;
    if (b.m_edgeB.next = b.m_bodyB.m_jointList)
        b.m_bodyB.m_jointList.prev = b.m_edgeB;
    b.m_bodyB.m_jointList = b.m_edgeB;
    var c = a.bodyA, e = a.bodyB;
    if (!1 == a.collideConnected)
        for (a = e.GetContactList(); a; )
            a.other == c && a.contact.FlagForFiltering(), a = a.next;
    return b
};
goog.exportProperty(box2d.b2World.prototype, "CreateJoint", box2d.b2World.prototype.CreateJoint);
box2d.b2World.prototype.DestroyJoint = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.IsLocked());
    if (!this.IsLocked()) {
        var b = a.m_collideConnected;
        a.m_prev && (a.m_prev.m_next = a.m_next);
        a.m_next && (a.m_next.m_prev = a.m_prev);
        a == this.m_jointList && (this.m_jointList = a.m_next);
        var c = a.m_bodyA, e = a.m_bodyB;
        c.SetAwake(!0);
        e.SetAwake(!0);
        a.m_edgeA.prev && (a.m_edgeA.prev.next = a.m_edgeA.next);
        a.m_edgeA.next && (a.m_edgeA.next.prev = a.m_edgeA.prev);
        a.m_edgeA == c.m_jointList && (c.m_jointList = a.m_edgeA.next);
        a.m_edgeA.prev =
                null;
        a.m_edgeA.next = null;
        a.m_edgeB.prev && (a.m_edgeB.prev.next = a.m_edgeB.next);
        a.m_edgeB.next && (a.m_edgeB.next.prev = a.m_edgeB.prev);
        a.m_edgeB == e.m_jointList && (e.m_jointList = a.m_edgeB.next);
        a.m_edgeB.prev = null;
        a.m_edgeB.next = null;
        box2d.b2JointFactory.Destroy(a, null);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < this.m_jointCount);
        --this.m_jointCount;
        if (!1 == b)
            for (a = e.GetContactList(); a; )
                a.other == c && a.contact.FlagForFiltering(), a = a.next
    }
};
goog.exportProperty(box2d.b2World.prototype, "DestroyJoint", box2d.b2World.prototype.DestroyJoint);
box2d.b2World.prototype.Solve = function(a) {
    for (var b = this.m_controllerList; b; b = b.m_next)
        b.Step(a);
    this.m_profile.solveInit = 0;
    this.m_profile.solveVelocity = 0;
    this.m_profile.solvePosition = 0;
    b = this.m_island;
    b.Initialize(this.m_bodyCount, this.m_contactManager.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener);
    for (var c = this.m_bodyList; c; c = c.m_next)
        c.m_flags &= ~box2d.b2BodyFlag.e_islandFlag;
    for (var e = this.m_contactManager.m_contactList; e; e = e.m_next)
        e.m_flags &= ~box2d.b2ContactFlag.e_islandFlag;
    for (e = this.m_jointList; e; e = e.m_next)
        e.m_islandFlag = !1;
    for (var e = this.m_bodyCount, d = this.s_stack, f = this.m_bodyList; f; f = f.m_next)
        if (!(f.m_flags & box2d.b2BodyFlag.e_islandFlag) && !1 != f.IsAwake() && !1 != f.IsActive() && f.GetType() != box2d.b2BodyType.b2_staticBody) {
            b.Clear();
            var g = 0;
            d[g++] = f;
            for (f.m_flags |= box2d.b2BodyFlag.e_islandFlag; 0 < g; )
                if (c = d[--g], box2d.ENABLE_ASSERTS && box2d.b2Assert(!0 == c.IsActive()), b.AddBody(c), c.SetAwake(!0), c.GetType() != box2d.b2BodyType.b2_staticBody) {
                    for (var h = c.m_contactList; h; h =
                            h.next) {
                        var l = h.contact;
                        if (!(l.m_flags & box2d.b2ContactFlag.e_islandFlag) && !1 != l.IsEnabled() && !1 != l.IsTouching()) {
                            var k = l.m_fixtureB.m_isSensor;
                            l.m_fixtureA.m_isSensor || k || (b.AddContact(l), l.m_flags |= box2d.b2ContactFlag.e_islandFlag, l = h.other, l.m_flags & box2d.b2BodyFlag.e_islandFlag || (box2d.ENABLE_ASSERTS && box2d.b2Assert(g < e), d[g++] = l, l.m_flags |= box2d.b2BodyFlag.e_islandFlag))
                        }
                    }
                    for (c = c.m_jointList; c; c = c.next)
                        !0 != c.joint.m_islandFlag && (l = c.other, !1 != l.IsActive() && (b.AddJoint(c.joint), c.joint.m_islandFlag =
                                !0, l.m_flags & box2d.b2BodyFlag.e_islandFlag || (box2d.ENABLE_ASSERTS && box2d.b2Assert(g < e), d[g++] = l, l.m_flags |= box2d.b2BodyFlag.e_islandFlag)))
                }
            c = new box2d.b2Profile;
            b.Solve(c, a, this.m_gravity, this.m_allowSleep);
            this.m_profile.solveInit += c.solveInit;
            this.m_profile.solveVelocity += c.solveVelocity;
            this.m_profile.solvePosition += c.solvePosition;
            for (g = 0; g < b.m_bodyCount; ++g)
                c = b.m_bodies[g], c.GetType() == box2d.b2BodyType.b2_staticBody && (c.m_flags &= ~box2d.b2BodyFlag.e_islandFlag)
        }
    for (g = 0; g < d.length && d[g]; ++g)
        d[g] =
                null;
    a = new box2d.b2Timer;
    for (c = this.m_bodyList; c; c = c.m_next)
        0 != (c.m_flags & box2d.b2BodyFlag.e_islandFlag) && c.GetType() != box2d.b2BodyType.b2_staticBody && c.SynchronizeFixtures();
    this.m_contactManager.FindNewContacts();
    this.m_profile.broadphase = a.GetMilliseconds()
};
goog.exportProperty(box2d.b2World.prototype, "Solve", box2d.b2World.prototype.Solve);
box2d.b2World.prototype.SolveTOI = function(a) {
    var b = this.m_island;
    b.Initialize(2 * box2d.b2_maxTOIContacts, box2d.b2_maxTOIContacts, 0, null, this.m_contactManager.m_contactListener);
    if (this.m_stepComplete) {
        for (var c = this.m_bodyList; c; c = c.m_next)
            c.m_flags &= ~box2d.b2BodyFlag.e_islandFlag, c.m_sweep.alpha0 = 0;
        for (var e = this.m_contactManager.m_contactList; e; e = e.m_next)
            e.m_flags &= ~(box2d.b2ContactFlag.e_toiFlag | box2d.b2ContactFlag.e_islandFlag), e.m_toiCount = 0, e.m_toi = 1
    }
    for (; ; ) {
        for (var d = null, c = 1, e = this.m_contactManager.m_contactList; e; e =
                e.m_next)
            if (!1 != e.IsEnabled() && !(e.m_toiCount > box2d.b2_maxSubSteps)) {
                var f = 1;
                if (e.m_flags & box2d.b2ContactFlag.e_toiFlag)
                    f = e.m_toi;
                else {
                    var g = e.GetFixtureA(), h = e.GetFixtureB();
                    if (g.IsSensor() || h.IsSensor())
                        continue;
                    var f = g.GetBody(), l = h.GetBody(), k = f.m_type, m = l.m_type;
                    box2d.ENABLE_ASSERTS && box2d.b2Assert(k == box2d.b2BodyType.b2_dynamicBody || m == box2d.b2BodyType.b2_dynamicBody);
                    var n = f.IsAwake() && k != box2d.b2BodyType.b2_staticBody, p = l.IsAwake() && m != box2d.b2BodyType.b2_staticBody;
                    if (!1 == n && !1 == p)
                        continue;
                    k = f.IsBullet() || k != box2d.b2BodyType.b2_dynamicBody;
                    m = l.IsBullet() || m != box2d.b2BodyType.b2_dynamicBody;
                    if (!1 == k && !1 == m)
                        continue;
                    m = f.m_sweep.alpha0;
                    f.m_sweep.alpha0 < l.m_sweep.alpha0 ? (m = l.m_sweep.alpha0, f.m_sweep.Advance(m)) : l.m_sweep.alpha0 < f.m_sweep.alpha0 && (m = f.m_sweep.alpha0, l.m_sweep.Advance(m));
                    box2d.ENABLE_ASSERTS && box2d.b2Assert(1 > m);
                    n = e.GetChildIndexA();
                    p = e.GetChildIndexB();
                    k = box2d.b2World.prototype.SolveTOI.s_toi_input;
                    k.proxyA.SetShape(g.GetShape(), n);
                    k.proxyB.SetShape(h.GetShape(), p);
                    k.sweepA.Copy(f.m_sweep);
                    k.sweepB.Copy(l.m_sweep);
                    k.tMax = 1;
                    f = box2d.b2World.prototype.SolveTOI.s_toi_output;
                    box2d.b2TimeOfImpact(f, k);
                    l = f.t;
                    f = f.state == box2d.b2TOIOutputState.e_touching ? box2d.b2Min(m + (1 - m) * l, 1) : 1;
                    e.m_toi = f;
                    e.m_flags |= box2d.b2ContactFlag.e_toiFlag
                }
                f < c && (d = e, c = f)
            }
        if (null == d || 1 - 10 * box2d.b2_epsilon < c) {
            this.m_stepComplete = !0;
            break
        }
        g = d.GetFixtureA();
        h = d.GetFixtureB();
        f = g.GetBody();
        l = h.GetBody();
        e = box2d.b2World.prototype.SolveTOI.s_backup1.Copy(f.m_sweep);
        g = box2d.b2World.prototype.SolveTOI.s_backup2.Copy(l.m_sweep);
        f.Advance(c);
        l.Advance(c);
        d.Update(this.m_contactManager.m_contactListener);
        d.m_flags &= ~box2d.b2ContactFlag.e_toiFlag;
        ++d.m_toiCount;
        if (!1 == d.IsEnabled() || !1 == d.IsTouching())
            d.SetEnabled(!1), f.m_sweep.Copy(e), l.m_sweep.Copy(g), f.SynchronizeTransform(), l.SynchronizeTransform();
        else {
            f.SetAwake(!0);
            l.SetAwake(!0);
            b.Clear();
            b.AddBody(f);
            b.AddBody(l);
            b.AddContact(d);
            f.m_flags |= box2d.b2BodyFlag.e_islandFlag;
            l.m_flags |= box2d.b2BodyFlag.e_islandFlag;
            d.m_flags |= box2d.b2ContactFlag.e_islandFlag;
            for (d = 0; 2 > d; ++d)
                if (e =
                        0 == d ? f : l, e.m_type == box2d.b2BodyType.b2_dynamicBody)
                    for (g = e.m_contactList; g && b.m_bodyCount != b.m_bodyCapacity && b.m_contactCount != b.m_contactCapacity; g = g.next)
                        h = g.contact, h.m_flags & box2d.b2ContactFlag.e_islandFlag || (m = g.other, m.m_type == box2d.b2BodyType.b2_dynamicBody && !1 == e.IsBullet() && !1 == m.IsBullet()) || (k = h.m_fixtureB.m_isSensor, h.m_fixtureA.m_isSensor || k || (k = box2d.b2World.prototype.SolveTOI.s_backup.Copy(m.m_sweep), 0 == (m.m_flags & box2d.b2BodyFlag.e_islandFlag) && m.Advance(c), h.Update(this.m_contactManager.m_contactListener),
                                !1 == h.IsEnabled() ? (m.m_sweep.Copy(k), m.SynchronizeTransform()) : !1 == h.IsTouching() ? (m.m_sweep.Copy(k), m.SynchronizeTransform()) : (h.m_flags |= box2d.b2ContactFlag.e_islandFlag, b.AddContact(h), m.m_flags & box2d.b2BodyFlag.e_islandFlag || (m.m_flags |= box2d.b2BodyFlag.e_islandFlag, m.m_type != box2d.b2BodyType.b2_staticBody && m.SetAwake(!0), b.AddBody(m)))));
            d = box2d.b2World.prototype.SolveTOI.s_subStep;
            d.dt = (1 - c) * a.dt;
            d.inv_dt = 1 / d.dt;
            d.dtRatio = 1;
            d.positionIterations = 20;
            d.velocityIterations = a.velocityIterations;
            d.warmStarting =
                    !1;
            b.SolveTOI(d, f.m_islandIndex, l.m_islandIndex);
            for (d = 0; d < b.m_bodyCount; ++d)
                if (e = b.m_bodies[d], e.m_flags &= ~box2d.b2BodyFlag.e_islandFlag, e.m_type == box2d.b2BodyType.b2_dynamicBody)
                    for (e.SynchronizeFixtures(), g = e.m_contactList; g; g = g.next)
                        g.contact.m_flags &= ~(box2d.b2ContactFlag.e_toiFlag | box2d.b2ContactFlag.e_islandFlag);
            this.m_contactManager.FindNewContacts();
            if (this.m_subStepping) {
                this.m_stepComplete = !1;
                break
            }
        }
    }
};
goog.exportProperty(box2d.b2World.prototype, "SolveTOI", box2d.b2World.prototype.SolveTOI);
box2d.b2World.prototype.SolveTOI.s_subStep = new box2d.b2TimeStep;
box2d.b2World.prototype.SolveTOI.s_backup = new box2d.b2Sweep;
box2d.b2World.prototype.SolveTOI.s_backup1 = new box2d.b2Sweep;
box2d.b2World.prototype.SolveTOI.s_backup2 = new box2d.b2Sweep;
box2d.b2World.prototype.SolveTOI.s_toi_input = new box2d.b2TOIInput;
box2d.b2World.prototype.SolveTOI.s_toi_output = new box2d.b2TOIOutput;
box2d.b2World.prototype.Step = function(a, b, c) {
    var e = new box2d.b2Timer;
    this.m_flags & box2d.b2WorldFlag.e_newFixture && (this.m_contactManager.FindNewContacts(), this.m_flags &= ~box2d.b2WorldFlag.e_newFixture);
    this.m_flags |= box2d.b2WorldFlag.e_locked;
    var d = box2d.b2World.prototype.Step.s_step;
    d.dt = a;
    d.velocityIterations = b;
    d.positionIterations = c;
    d.inv_dt = 0 < a ? 1 / a : 0;
    d.dtRatio = this.m_inv_dt0 * a;
    d.warmStarting = this.m_warmStarting;
    a = new box2d.b2Timer;
    this.m_contactManager.Collide();
    this.m_profile.collide = a.GetMilliseconds();
    this.m_stepComplete && 0 < d.dt && (a = new box2d.b2Timer, this.Solve(d), this.m_profile.solve = a.GetMilliseconds());
    this.m_continuousPhysics && 0 < d.dt && (a = new box2d.b2Timer, this.SolveTOI(d), this.m_profile.solveTOI = a.GetMilliseconds());
    0 < d.dt && (this.m_inv_dt0 = d.inv_dt);
    this.m_flags & box2d.b2WorldFlag.e_clearForces && this.ClearForces();
    this.m_flags &= ~box2d.b2WorldFlag.e_locked;
    this.m_profile.step = e.GetMilliseconds()
};
goog.exportProperty(box2d.b2World.prototype, "Step", box2d.b2World.prototype.Step);
box2d.b2World.prototype.Step.s_step = new box2d.b2TimeStep;
box2d.b2World.prototype.ClearForces = function() {
    for (var a = this.m_bodyList; a; a = a.m_next)
        a.m_force.SetZero(), a.m_torque = 0
};
goog.exportProperty(box2d.b2World.prototype, "ClearForces", box2d.b2World.prototype.ClearForces);
box2d.b2World.prototype.QueryAABB = function(a, b) {
    var c = this.m_contactManager.m_broadPhase;
    c.Query(function(b) {
        b = c.GetUserData(b);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(b instanceof box2d.b2FixtureProxy);
        b = b.fixture;
        return a instanceof box2d.b2QueryCallback ? a.ReportFixture(b) : a(b)
    }, b)
};
goog.exportProperty(box2d.b2World.prototype, "QueryAABB", box2d.b2World.prototype.QueryAABB);
box2d.b2World.prototype.QueryShape = function(a, b, c) {
    var e = this.m_contactManager.m_broadPhase, d = box2d.b2World.prototype.QueryShape.s_aabb;
    b.ComputeAABB(d, c, 0);
    e.Query(function(d) {
        d = e.GetUserData(d);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(d instanceof box2d.b2FixtureProxy);
        d = d.fixture;
        return box2d.b2TestOverlapShape(b, 0, d.GetShape(), 0, c, d.GetBody().GetTransform()) ? a instanceof box2d.b2QueryCallback ? a.ReportFixture(d) : a(d) : !0
    }, d)
};
goog.exportProperty(box2d.b2World.prototype, "QueryShape", box2d.b2World.prototype.QueryShape);
box2d.b2World.prototype.QueryShape.s_aabb = new box2d.b2AABB;
box2d.b2World.prototype.QueryPoint = function(a, b) {
    var c = this.m_contactManager.m_broadPhase, e = box2d.b2World.prototype.QueryPoint.s_aabb;
    e.lowerBound.SetXY(b.x - box2d.b2_linearSlop, b.y - box2d.b2_linearSlop);
    e.upperBound.SetXY(b.x + box2d.b2_linearSlop, b.y + box2d.b2_linearSlop);
    c.Query(function(d) {
        d = c.GetUserData(d);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(d instanceof box2d.b2FixtureProxy);
        d = d.fixture;
        return d.TestPoint(b) ? a instanceof box2d.b2QueryCallback ? a.ReportFixture(d) : a(d) : !0
    }, e)
};
goog.exportProperty(box2d.b2World.prototype, "QueryPoint", box2d.b2World.prototype.QueryPoint);
box2d.b2World.prototype.QueryPoint.s_aabb = new box2d.b2AABB;
box2d.b2World.prototype.RayCast = function(a, b, c) {
    var e = this.m_contactManager.m_broadPhase, d = box2d.b2World.prototype.RayCast.s_input;
    d.maxFraction = 1;
    d.p1.Copy(b);
    d.p2.Copy(c);
    e.RayCast(function(d, g) {
        var h = e.GetUserData(g);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(h instanceof box2d.b2FixtureProxy);
        var l = h.fixture, k = box2d.b2World.prototype.RayCast.s_output;
        if (l.RayCast(k, d, h.childIndex)) {
            var h = k.fraction, m = box2d.b2World.prototype.RayCast.s_point;
            m.SetXY((1 - h) * b.x + h * c.x, (1 - h) * b.y + h * c.y);
            return a instanceof
                    box2d.b2RayCastCallback ? a.ReportFixture(l, m, k.normal, h) : a(l, m, k.normal, h)
        }
        return d.maxFraction
    }, d)
};
goog.exportProperty(box2d.b2World.prototype, "RayCast", box2d.b2World.prototype.RayCast);
box2d.b2World.prototype.RayCast.s_input = new box2d.b2RayCastInput;
box2d.b2World.prototype.RayCast.s_output = new box2d.b2RayCastOutput;
box2d.b2World.prototype.RayCast.s_point = new box2d.b2Vec2;
box2d.b2World.prototype.RayCastOne = function(a, b) {
    var c = null, e = 1;
    this.RayCast(function(a, b, g, h) {
        h < e && (e = h, c = a);
        return e
    }, a, b);
    return c
};
goog.exportProperty(box2d.b2World.prototype, "RayCastOne", box2d.b2World.prototype.RayCastOne);
box2d.b2World.prototype.RayCastAll = function(a, b, c) {
    c.length = 0;
    this.RayCast(function(a, b, f, g) {
        c.push(a);
        return 1
    }, a, b);
    return c
};
goog.exportProperty(box2d.b2World.prototype, "RayCastAll", box2d.b2World.prototype.RayCastAll);
box2d.b2World.prototype.DrawShape = function(a, b) {
    var c = a.GetShape();
    switch (c.m_type) {
        case box2d.b2ShapeType.e_circleShape:
            c = c instanceof box2d.b2CircleShape ? c : null;
            this.m_debugDraw.DrawSolidCircle(c.m_p, c.m_radius, box2d.b2Vec2.UNITX, b);
            break;
        case box2d.b2ShapeType.e_edgeShape:
            var e = c instanceof box2d.b2EdgeShape ? c : null, c = e.m_vertex1, d = e.m_vertex2;
            this.m_debugDraw.DrawSegment(c, d, b);
            break;
        case box2d.b2ShapeType.e_chainShape:
            var c = c instanceof box2d.b2ChainShape ? c : null, e = c.m_count, f = c.m_vertices, c = f[0];
            this.m_debugDraw.DrawCircle(c, 0.05, b);
            for (var g = 1; g < e; ++g)
                d = f[g], this.m_debugDraw.DrawSegment(c, d, b), this.m_debugDraw.DrawCircle(d, 0.05, b), c = d;
            break;
        case box2d.b2ShapeType.e_polygonShape:
            e = c instanceof box2d.b2PolygonShape ? c : null, c = e.m_count, f = e.m_vertices, this.m_debugDraw.DrawSolidPolygon(f, c, b)
        }
};
goog.exportProperty(box2d.b2World.prototype, "DrawShape", box2d.b2World.prototype.DrawShape);
box2d.b2World.prototype.DrawJoint = function(a) {
    var b = a.GetBodyA(), c = a.GetBodyB(), e = b.m_xf.p, d = c.m_xf.p, c = a.GetAnchorA(box2d.b2World.prototype.DrawJoint.s_p1), b = a.GetAnchorB(box2d.b2World.prototype.DrawJoint.s_p2), f = box2d.b2World.prototype.DrawJoint.s_color.SetRGB(0.5, 0.8, 0.8);
    switch (a.m_type) {
        case box2d.b2JointType.e_distanceJoint:
            this.m_debugDraw.DrawSegment(c, b, f);
            break;
        case box2d.b2JointType.e_pulleyJoint:
            e = a instanceof box2d.b2PulleyJoint ? a : null;
            a = e.GetGroundAnchorA(box2d.b2World.prototype.DrawJoint.s_s1);
            e = e.GetGroundAnchorB(box2d.b2World.prototype.DrawJoint.s_s2);
            this.m_debugDraw.DrawSegment(a, c, f);
            this.m_debugDraw.DrawSegment(e, b, f);
            this.m_debugDraw.DrawSegment(a, e, f);
            break;
        case box2d.b2JointType.e_mouseJoint:
            this.m_debugDraw.DrawSegment(c, b, f);
            break;
        default:
            this.m_debugDraw.DrawSegment(e, c, f), this.m_debugDraw.DrawSegment(c, b, f), this.m_debugDraw.DrawSegment(d, b, f)
        }
};
goog.exportProperty(box2d.b2World.prototype, "DrawJoint", box2d.b2World.prototype.DrawJoint);
box2d.b2World.prototype.DrawJoint.s_p1 = new box2d.b2Vec2;
box2d.b2World.prototype.DrawJoint.s_p2 = new box2d.b2Vec2;
box2d.b2World.prototype.DrawJoint.s_color = new box2d.b2Color(0.5, 0.8, 0.8);
box2d.b2World.prototype.DrawJoint.s_s1 = new box2d.b2Vec2;
box2d.b2World.prototype.DrawJoint.s_s2 = new box2d.b2Vec2;
box2d.b2World.prototype.DrawDebugData = function() {
    if (null != this.m_debugDraw) {
        var a = this.m_debugDraw.GetFlags(), b = box2d.b2World.prototype.DrawDebugData.s_color.SetRGB(0, 0, 0);
        if (a & box2d.b2DrawFlags.e_shapeBit)
            for (var c = this.m_bodyList; c; c = c.m_next) {
                var e = c.m_xf;
                this.m_debugDraw.PushTransform(e);
                for (var d = c.GetFixtureList(); d; d = d.m_next)
                    !1 == c.IsActive() ? b.SetRGB(0.5, 0.5, 0.3) : c.GetType() == box2d.b2BodyType.b2_staticBody ? b.SetRGB(0.5, 0.9, 0.5) : c.GetType() == box2d.b2BodyType.b2_kinematicBody ? b.SetRGB(0.5, 0.5,
                            0.9) : !1 == c.IsAwake() ? b.SetRGB(0.6, 0.6, 0.6) : b.SetRGB(0.9, 0.7, 0.7), this.DrawShape(d, b);
                this.m_debugDraw.PopTransform(e)
            }
        if (a & box2d.b2DrawFlags.e_jointBit)
            for (c = this.m_jointList; c; c = c.m_next)
                this.DrawJoint(c);
        if (a & box2d.b2DrawFlags.e_aabbBit) {
            b.SetRGB(0.9, 0.3, 0.9);
            for (var e = this.m_contactManager.m_broadPhase, f = box2d.b2World.prototype.DrawDebugData.s_vs, c = this.m_bodyList; c; c = c.m_next)
                if (!1 != c.IsActive())
                    for (d = c.GetFixtureList(); d; d = d.m_next)
                        for (var g = 0; g < d.m_proxyCount; ++g) {
                            var h = e.GetFatAABB(d.m_proxies[g].proxy);
                            f[0].SetXY(h.lowerBound.x, h.lowerBound.y);
                            f[1].SetXY(h.upperBound.x, h.lowerBound.y);
                            f[2].SetXY(h.upperBound.x, h.upperBound.y);
                            f[3].SetXY(h.lowerBound.x, h.upperBound.y);
                            this.m_debugDraw.DrawPolygon(f, 4, b)
                        }
        }
        if (a & box2d.b2DrawFlags.e_centerOfMassBit)
            for (c = this.m_bodyList; c; c = c.m_next)
                e = box2d.b2World.prototype.DrawDebugData.s_xf, e.q.Copy(c.m_xf.q), e.p.Copy(c.GetWorldCenter()), this.m_debugDraw.DrawTransform(e);
        if (a & box2d.b2DrawFlags.e_controllerBit)
            for (a = this.m_controllerList; a; a = a.m_next)
                a.Draw(this.m_debugDraw)
    }
};
goog.exportProperty(box2d.b2World.prototype, "DrawDebugData", box2d.b2World.prototype.DrawDebugData);
box2d.b2World.prototype.DrawDebugData.s_color = new box2d.b2Color(0, 0, 0);
box2d.b2World.prototype.DrawDebugData.s_vs = box2d.b2Vec2.MakeArray(4);
box2d.b2World.prototype.DrawDebugData.s_xf = new box2d.b2Transform;
box2d.b2World.prototype.SetBroadPhase = function(a) {
    var b = this.m_contactManager.m_broadPhase;
    this.m_contactManager.m_broadPhase = a;
    for (var c = this.m_bodyList; c; c = c.m_next)
        for (var e = c.m_fixtureList; e; e = e.m_next)
            e.m_proxy = a.CreateProxy(b.GetFatAABB(e.m_proxy), e)
};
goog.exportProperty(box2d.b2World.prototype, "SetBroadPhase", box2d.b2World.prototype.SetBroadPhase);
box2d.b2World.prototype.GetProxyCount = function() {
    return this.m_contactManager.m_broadPhase.GetProxyCount()
};
goog.exportProperty(box2d.b2World.prototype, "GetProxyCount", box2d.b2World.prototype.GetProxyCount);
box2d.b2World.prototype.GetTreeHeight = function() {
    return this.m_contactManager.m_broadPhase.GetTreeHeight()
};
goog.exportProperty(box2d.b2World.prototype, "GetTreeHeight", box2d.b2World.prototype.GetTreeHeight);
box2d.b2World.prototype.GetTreeBalance = function() {
    return this.m_contactManager.m_broadPhase.GetTreeBalance()
};
goog.exportProperty(box2d.b2World.prototype, "GetTreeBalance", box2d.b2World.prototype.GetTreeBalance);
box2d.b2World.prototype.GetTreeQuality = function() {
    return this.m_contactManager.m_broadPhase.GetTreeQuality()
};
goog.exportProperty(box2d.b2World.prototype, "GetTreeQuality", box2d.b2World.prototype.GetTreeQuality);
box2d.b2World.prototype.ShiftOrigin = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.IsLocked());
    if (!this.IsLocked()) {
        for (var b = this.m_bodyList; b; b = b.m_next)
            b.m_xf.p.SelfSub(a), b.m_sweep.c0.SelfSub(a), b.m_sweep.c.SelfSub(a);
        for (b = this.m_jointList; b; b = b.m_next)
            b.ShiftOrigin(a);
        this.m_contactManager.m_broadPhase.ShiftOrigin(a)
    }
};
goog.exportProperty(box2d.b2World.prototype, "ShiftOrigin", box2d.b2World.prototype.ShiftOrigin);
box2d.b2World.prototype.Dump = function() {
    if (box2d.DEBUG && (this.m_flags & box2d.b2WorldFlag.e_locked) != box2d.b2WorldFlag.e_locked) {
        box2d.b2Log("/** @type {box2d.b2Vec2} */ var g = new box2d.b2Vec2(%.15f, %.15f);\n", this.m_gravity.x, this.m_gravity.y);
        box2d.b2Log("this.m_world.SetGravity(g);\n");
        box2d.b2Log("/** @type {Array.<box2d.b2Body>} */ var bodies = new Array(%d);\n", this.m_bodyCount);
        box2d.b2Log("/** @type {Array.<box2d.b2Joint>} */ var joints = new Array(%d);\n", this.m_jointCount);
        for (var a = 0,
                b = this.m_bodyList; b; b = b.m_next)
            b.m_islandIndex = a, b.Dump(), ++a;
        a = 0;
        for (b = this.m_jointList; b; b = b.m_next)
            b.m_index = a, ++a;
        for (b = this.m_jointList; b; b = b.m_next)
            b.m_type != box2d.b2JointType.e_gearJoint && (box2d.b2Log("if (true)\n"), box2d.b2Log("{\n"), b.Dump(), box2d.b2Log("}\n"));
        for (b = this.m_jointList; b; b = b.m_next)
            b.m_type == box2d.b2JointType.e_gearJoint && (box2d.b2Log("if (true)\n"), box2d.b2Log("{\n"), b.Dump(), box2d.b2Log("}\n"))
    }
};
goog.exportProperty(box2d.b2World.prototype, "Dump", box2d.b2World.prototype.Dump);
box2d.b2World.prototype.AddController = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(null === a.m_world, "Controller can only be a member of one world");
    a.m_world = this;
    a.m_next = this.m_controllerList;
    a.m_prev = null;
    this.m_controllerList && (this.m_controllerList.m_prev = a);
    this.m_controllerList = a;
    ++this.m_controllerCount;
    return a
};
goog.exportProperty(box2d.b2World.prototype, "AddController", box2d.b2World.prototype.AddController);
box2d.b2World.prototype.RemoveController = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.m_world === this, "Controller is not a member of this world");
    a.m_prev && (a.m_prev.m_next = a.m_next);
    a.m_next && (a.m_next.m_prev = a.m_prev);
    this.m_controllerList == a && (this.m_controllerList = a.m_next);
    --this.m_controllerCount;
    a.m_prev = null;
    a.m_next = null;
    a.m_world = null
};
goog.exportProperty(box2d.b2World.prototype, "RemoveController", box2d.b2World.prototype.RemoveController);
box2d.b2AreaJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_areaJoint);
    this.bodies = []
};
goog.inherits(box2d.b2AreaJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2AreaJointDef", box2d.b2AreaJointDef);
box2d.b2AreaJointDef.prototype.world = null;
goog.exportProperty(box2d.b2AreaJointDef.prototype, "world", box2d.b2AreaJointDef.prototype.world);
box2d.b2AreaJointDef.prototype.bodies = null;
goog.exportProperty(box2d.b2AreaJointDef.prototype, "bodies", box2d.b2AreaJointDef.prototype.bodies);
box2d.b2AreaJointDef.prototype.frequencyHz = 0;
goog.exportProperty(box2d.b2AreaJointDef.prototype, "frequencyHz", box2d.b2AreaJointDef.prototype.frequencyHz);
box2d.b2AreaJointDef.prototype.dampingRatio = 0;
goog.exportProperty(box2d.b2AreaJointDef.prototype, "dampingRatio", box2d.b2AreaJointDef.prototype.dampingRatio);
box2d.b2AreaJointDef.prototype.AddBody = function(a) {
    this.bodies.push(a);
    1 == this.bodies.length ? this.bodyA = a : 2 == this.bodies.length && (this.bodyB = a)
};
goog.exportProperty(box2d.b2AreaJointDef.prototype, "AddBody", box2d.b2AreaJointDef.prototype.AddBody);
box2d.b2AreaJoint = function(a) {
    box2d.b2Joint.call(this, a);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(3 <= a.bodies.length, "You cannot create an area joint with less than three bodies.");
    this.m_bodies = a.bodies;
    this.m_frequencyHz = a.frequencyHz;
    this.m_dampingRatio = a.dampingRatio;
    this.m_targetLengths = box2d.b2MakeNumberArray(a.bodies.length);
    this.m_normals = box2d.b2Vec2.MakeArray(a.bodies.length);
    this.m_joints = Array(a.bodies.length);
    this.m_deltas = box2d.b2Vec2.MakeArray(a.bodies.length);
    this.m_delta = new box2d.b2Vec2;
    var b = new box2d.b2DistanceJointDef;
    b.frequencyHz = a.frequencyHz;
    b.dampingRatio = a.dampingRatio;
    for (var c = this.m_targetArea = 0, e = this.m_bodies.length; c < e; ++c) {
        var d = this.m_bodies[c], f = this.m_bodies[(c + 1) % e], g = d.GetWorldCenter(), h = f.GetWorldCenter();
        this.m_targetLengths[c] = box2d.b2DistanceVV(g, h);
        this.m_targetArea += box2d.b2CrossVV(g, h);
        b.Initialize(d, f, g, h);
        this.m_joints[c] = a.world.CreateJoint(b)
    }
    this.m_targetArea *= 0.5
};
goog.inherits(box2d.b2AreaJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2AreaJoint", box2d.b2AreaJoint);
box2d.b2AreaJoint.prototype.m_bodies = null;
goog.exportProperty(box2d.b2AreaJoint.prototype, "m_bodies", box2d.b2AreaJoint.prototype.m_bodies);
box2d.b2AreaJoint.prototype.m_frequencyHz = 0;
goog.exportProperty(box2d.b2AreaJoint.prototype, "m_frequencyHz", box2d.b2AreaJoint.prototype.m_frequencyHz);
box2d.b2AreaJoint.prototype.m_dampingRatio = 0;
goog.exportProperty(box2d.b2AreaJoint.prototype, "m_dampingRatio", box2d.b2AreaJoint.prototype.m_dampingRatio);
box2d.b2AreaJoint.prototype.m_impulse = 0;
goog.exportProperty(box2d.b2AreaJoint.prototype, "m_impulse", box2d.b2AreaJoint.prototype.m_impulse);
box2d.b2AreaJoint.prototype.m_targetLengths = null;
box2d.b2AreaJoint.prototype.m_targetArea = 0;
box2d.b2AreaJoint.prototype.m_normals = null;
box2d.b2AreaJoint.prototype.m_joints = null;
box2d.b2AreaJoint.prototype.m_deltas = null;
box2d.b2AreaJoint.prototype.m_delta = null;
box2d.b2AreaJoint.prototype.GetAnchorA = function(a) {
    return a.SetZero()
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "GetAnchorA", box2d.b2AreaJoint.prototype.GetAnchorA);
box2d.b2AreaJoint.prototype.GetAnchorB = function(a) {
    return a.SetZero()
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "GetAnchorB", box2d.b2AreaJoint.prototype.GetAnchorB);
box2d.b2AreaJoint.prototype.GetReactionForce = function(a, b) {
    return b.SetZero()
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "GetReactionForce", box2d.b2AreaJoint.prototype.GetReactionForce);
box2d.b2AreaJoint.prototype.GetReactionTorque = function(a) {
    return 0
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "GetReactionTorque", box2d.b2AreaJoint.prototype.GetReactionTorque);
box2d.b2AreaJoint.prototype.SetFrequency = function(a) {
    this.m_frequencyHz = a;
    for (var b = 0, c = this.m_joints.length; b < c; ++b)
        this.m_joints[b].SetFrequency(a)
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "SetFrequency", box2d.b2AreaJoint.prototype.SetFrequency);
box2d.b2AreaJoint.prototype.GetFrequency = function() {
    return this.m_frequencyHz
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "GetFrequency", box2d.b2AreaJoint.prototype.GetFrequency);
box2d.b2AreaJoint.prototype.SetDampingRatio = function(a) {
    this.m_dampingRatio = a;
    for (var b = 0, c = this.m_joints.length; b < c; ++b)
        this.m_joints[b].SetDampingRatio(a)
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "SetDampingRatio", box2d.b2AreaJoint.prototype.SetDampingRatio);
box2d.b2AreaJoint.prototype.GetDampingRatio = function() {
    return this.m_dampingRatio
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "GetDampingRatio", box2d.b2AreaJoint.prototype.GetDampingRatio);
box2d.b2AreaJoint.prototype.Dump = function() {
    box2d.DEBUG && box2d.b2Log("Area joint dumping is not supported.\n")
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "Dump", box2d.b2AreaJoint.prototype.Dump);
box2d.b2AreaJoint.prototype.InitVelocityConstraints = function(a) {
    for (var b = 0, c = this.m_bodies.length; b < c; ++b) {
        var e = this.m_deltas[b];
        box2d.b2SubVV(a.positions[this.m_bodies[(b + 1) % c].m_islandIndex].c, a.positions[this.m_bodies[(b + c - 1) % c].m_islandIndex].c, e)
    }
    if (a.step.warmStarting)
        for (this.m_impulse *= a.step.dtRatio, b = 0, c = this.m_bodies.length; b < c; ++b) {
            var d = this.m_bodies[b], f = a.velocities[d.m_islandIndex].v, e = this.m_deltas[b];
            f.x += 0.5 * (d.m_invMass * e.y) * this.m_impulse;
            f.y += 0.5 * (d.m_invMass * -e.x) * this.m_impulse
        }
    else
        this.m_impulse =
        0
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "InitVelocityConstraints", box2d.b2AreaJoint.prototype.InitVelocityConstraints);
box2d.b2AreaJoint.prototype.SolveVelocityConstraints = function(a) {
    for (var b = 0, c = 0, e = 0, d = this.m_bodies.length; e < d; ++e)
        var f = this.m_bodies[e], g = a.velocities[f.m_islandIndex].v, h = this.m_deltas[e], b = b + h.GetLengthSquared() / f.GetMass(), c = c + box2d.b2CrossVV(g, h);
    b = -2 * c / b;
    this.m_impulse += b;
    e = 0;
    for (d = this.m_bodies.length; e < d; ++e)
        f = this.m_bodies[e], g = a.velocities[f.m_islandIndex].v, h = this.m_deltas[e], g.x += 0.5 * (f.m_invMass * h.y) * b, g.y += 0.5 * (f.m_invMass * -h.x) * b
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "SolveVelocityConstraints", box2d.b2AreaJoint.prototype.SolveVelocityConstraints);
box2d.b2AreaJoint.prototype.SolvePositionConstraints = function(a) {
    for (var b = 0, c = 0, e = 0, d = this.m_bodies.length; e < d; ++e) {
        var f = this.m_bodies[e], f = a.positions[f.m_islandIndex].c, g = a.positions[this.m_bodies[(e + 1) % d].m_islandIndex].c, h = box2d.b2SubVV(g, f, this.m_delta), l = h.GetLength();
        l < box2d.b2_epsilon && (l = 1);
        this.m_normals[e].x = h.y / l;
        this.m_normals[e].y = -h.x / l;
        b += l;
        c += box2d.b2CrossVV(f, g)
    }
    b = 0.5 * (this.m_targetArea - 0.5 * c) / b;
    c = !0;
    e = 0;
    for (d = this.m_bodies.length; e < d; ++e)
        f = this.m_bodies[e], f = a.positions[f.m_islandIndex].c,
                h = box2d.b2AddVV(this.m_normals[e], this.m_normals[(e + 1) % d], this.m_delta), h.SelfMul(b), g = h.GetLengthSquared(), g > box2d.b2Sq(box2d.b2_maxLinearCorrection) && h.SelfMul(box2d.b2_maxLinearCorrection / box2d.b2Sqrt(g)), g > box2d.b2Sq(box2d.b2_linearSlop) && (c = !1), f.x += h.x, f.y += h.y;
    return c
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "SolvePositionConstraints", box2d.b2AreaJoint.prototype.SolvePositionConstraints);
box2d.b2BuoyancyController = function() {
    box2d.b2Controller.call(this);
    this.normal = new box2d.b2Vec2(0, 1);
    this.velocity = new box2d.b2Vec2(0, 0);
    this.gravity = new box2d.b2Vec2(0, 0)
};
goog.inherits(box2d.b2BuoyancyController, box2d.b2Controller);
goog.exportSymbol("box2d.b2BuoyancyController", box2d.b2BuoyancyController);
box2d.b2BuoyancyController.prototype.normal = null;
goog.exportProperty(box2d.b2BuoyancyController.prototype, "normal", box2d.b2BuoyancyController.prototype.normal);
box2d.b2BuoyancyController.prototype.offset = 0;
goog.exportProperty(box2d.b2BuoyancyController.prototype, "offset", box2d.b2BuoyancyController.prototype.offset);
box2d.b2BuoyancyController.prototype.density = 0;
goog.exportProperty(box2d.b2BuoyancyController.prototype, "density", box2d.b2BuoyancyController.prototype.density);
box2d.b2BuoyancyController.prototype.velocity = null;
goog.exportProperty(box2d.b2BuoyancyController.prototype, "velocity", box2d.b2BuoyancyController.prototype.velocity);
box2d.b2BuoyancyController.prototype.linearDrag = 0;
goog.exportProperty(box2d.b2BuoyancyController.prototype, "linearDrag", box2d.b2BuoyancyController.prototype.linearDrag);
box2d.b2BuoyancyController.prototype.angularDrag = 0;
goog.exportProperty(box2d.b2BuoyancyController.prototype, "angularDrag", box2d.b2BuoyancyController.prototype.angularDrag);
box2d.b2BuoyancyController.prototype.useDensity = !1;
goog.exportProperty(box2d.b2BuoyancyController.prototype, "useDensity", box2d.b2BuoyancyController.prototype.useDensity);
box2d.b2BuoyancyController.prototype.useWorldGravity = !0;
goog.exportProperty(box2d.b2BuoyancyController.prototype, "useWorldGravity", box2d.b2BuoyancyController.prototype.useWorldGravity);
box2d.b2BuoyancyController.prototype.gravity = null;
goog.exportProperty(box2d.b2BuoyancyController.prototype, "gravity", box2d.b2BuoyancyController.prototype.gravity);
box2d.b2BuoyancyController.prototype.Step = function(a) {
    if (this.m_bodyList)
        for (this.useWorldGravity && this.gravity.Copy(this.GetWorld().GetGravity()), a = this.m_bodyList; a; a = a.nextBody) {
            var b = a.body;
            if (!1 != b.IsAwake()) {
                for (var c = new box2d.b2Vec2, e = new box2d.b2Vec2, d = 0, f = 0, g = b.GetFixtureList(); g; g = g.m_next) {
                    var h = new box2d.b2Vec2, l = g.GetShape().ComputeSubmergedArea(this.normal, this.offset, b.GetTransform(), h), d = d + l;
                    c.x += l * h.x;
                    c.y += l * h.y;
                    var k = 0, k = this.useDensity ? g.GetDensity() : 1, f = f + l * k;
                    e.x += l * h.x * k;
                    e.y +=
                            l * h.y * k
                }
                c.x /= d;
                c.y /= d;
                e.x /= f;
                e.y /= f;
                d < box2d.b2_epsilon || (f = box2d.b2NegV(this.gravity, new box2d.b2Vec2), f.SelfMul(this.density * d), b.ApplyForce(f, e), e = b.GetLinearVelocityFromWorldPoint(c, new box2d.b2Vec2), e.SelfSub(this.velocity), e.SelfMul(-this.linearDrag * d), b.ApplyForce(e, c), b.ApplyTorque(-b.GetInertia() / b.GetMass() * d * b.GetAngularVelocity() * this.angularDrag))
            }
        }
};
goog.exportProperty(box2d.b2BuoyancyController.prototype, "Step", box2d.b2BuoyancyController.prototype.Step);
box2d.b2BuoyancyController.prototype.Draw = function(a) {
    var b = new box2d.b2Vec2, c = new box2d.b2Vec2;
    b.x = this.normal.x * this.offset + 100 * this.normal.y;
    b.y = this.normal.y * this.offset - 100 * this.normal.x;
    c.x = this.normal.x * this.offset - 100 * this.normal.y;
    c.y = this.normal.y * this.offset + 100 * this.normal.x;
    var e = new box2d.b2Color(0, 0, 0.8);
    a.DrawSegment(b, c, e)
};
goog.exportProperty(box2d.b2BuoyancyController.prototype, "Draw", box2d.b2BuoyancyController.prototype.Draw);
box2d.b2TensorDampingController = function() {
    box2d.b2Controller.call(this);
    this.T = new box2d.b2Mat22;
    this.maxTimestep = 0
};
goog.inherits(box2d.b2TensorDampingController, box2d.b2Controller);
goog.exportSymbol("box2d.b2TensorDampingController", box2d.b2TensorDampingController);
box2d.b2TensorDampingController.prototype.T = new box2d.b2Mat22;
goog.exportProperty(box2d.b2TensorDampingController.prototype, "T", box2d.b2TensorDampingController.prototype.T);
box2d.b2TensorDampingController.prototype.maxTimestep = 0;
goog.exportProperty(box2d.b2TensorDampingController.prototype, "maxTimestep", box2d.b2TensorDampingController.prototype.maxTimestep);
box2d.b2TensorDampingController.prototype.Step = function(a) {
    a = a.dt;
    if (!(a <= box2d.b2_epsilon)) {
        a > this.maxTimestep && 0 < this.maxTimestep && (a = this.maxTimestep);
        for (var b = this.m_bodyList; b; b = b.nextBody) {
            var c = b.body;
            if (c.IsAwake()) {
                var e = c.GetWorldVector(box2d.b2MulMV(this.T, c.GetLocalVector(c.GetLinearVelocity(), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t1), box2d.b2TensorDampingController.prototype.Step.s_damping);
                c.SetLinearVelocity(box2d.b2AddVV(c.GetLinearVelocity(), box2d.b2MulSV(a, e, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t1))
            }
        }
    }
};
box2d.b2TensorDampingController.prototype.Step.s_damping = new box2d.b2Vec2;
box2d.b2TensorDampingController.prototype.SetAxisAligned = function(a, b) {
    this.T.ex.x = -a;
    this.T.ex.y = 0;
    this.T.ey.x = 0;
    this.T.ey.y = -b;
    this.maxTimestep = 0 < a || 0 < b ? 1 / box2d.b2Max(a, b) : 0
};
box2d.b2DistanceJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_distanceJoint);
    this.localAnchorA = new box2d.b2Vec2;
    this.localAnchorB = new box2d.b2Vec2
};
goog.inherits(box2d.b2DistanceJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2DistanceJointDef", box2d.b2DistanceJointDef);
box2d.b2DistanceJointDef.prototype.localAnchorA = null;
goog.exportProperty(box2d.b2DistanceJointDef.prototype, "localAnchorA", box2d.b2DistanceJointDef.prototype.localAnchorA);
box2d.b2DistanceJointDef.prototype.localAnchorB = null;
goog.exportProperty(box2d.b2DistanceJointDef.prototype, "localAnchorB", box2d.b2DistanceJointDef.prototype.localAnchorB);
box2d.b2DistanceJointDef.prototype.length = 1;
goog.exportProperty(box2d.b2DistanceJointDef.prototype, "length", box2d.b2DistanceJointDef.prototype.length);
box2d.b2DistanceJointDef.prototype.frequencyHz = 0;
goog.exportProperty(box2d.b2DistanceJointDef.prototype, "frequencyHz", box2d.b2DistanceJointDef.prototype.frequencyHz);
box2d.b2DistanceJointDef.prototype.dampingRatio = 0;
goog.exportProperty(box2d.b2DistanceJointDef.prototype, "dampingRatio", box2d.b2DistanceJointDef.prototype.dampingRatio);
box2d.b2DistanceJointDef.prototype.Initialize = function(a, b, c, e) {
    this.bodyA = a;
    this.bodyB = b;
    this.bodyA.GetLocalPoint(c, this.localAnchorA);
    this.bodyB.GetLocalPoint(e, this.localAnchorB);
    this.length = box2d.b2DistanceVV(c, e);
    this.dampingRatio = this.frequencyHz = 0
};
goog.exportProperty(box2d.b2DistanceJointDef.prototype, "Initialize", box2d.b2DistanceJointDef.prototype.Initialize);
box2d.b2DistanceJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_u = new box2d.b2Vec2;
    this.m_rA = new box2d.b2Vec2;
    this.m_rB = new box2d.b2Vec2;
    this.m_localCenterA = new box2d.b2Vec2;
    this.m_localCenterB = new box2d.b2Vec2;
    this.m_qA = new box2d.b2Rot;
    this.m_qB = new box2d.b2Rot;
    this.m_lalcA = new box2d.b2Vec2;
    this.m_lalcB = new box2d.b2Vec2;
    this.m_frequencyHz = a.frequencyHz;
    this.m_dampingRatio = a.dampingRatio;
    this.m_localAnchorA = a.localAnchorA.Clone();
    this.m_localAnchorB = a.localAnchorB.Clone();
    this.m_length = a.length
};
goog.inherits(box2d.b2DistanceJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2DistanceJoint", box2d.b2DistanceJoint);
box2d.b2DistanceJoint.prototype.m_frequencyHz = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_frequencyHz", box2d.b2DistanceJoint.prototype.m_frequencyHz);
box2d.b2DistanceJoint.prototype.m_dampingRatio = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_dampingRatio", box2d.b2DistanceJoint.prototype.m_dampingRatio);
box2d.b2DistanceJoint.prototype.m_bias = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_bias", box2d.b2DistanceJoint.prototype.m_bias);
box2d.b2DistanceJoint.prototype.m_localAnchorA = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_localAnchorA", box2d.b2DistanceJoint.prototype.m_localAnchorA);
box2d.b2DistanceJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_localAnchorB", box2d.b2DistanceJoint.prototype.m_localAnchorB);
box2d.b2DistanceJoint.prototype.m_gamma = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_gamma", box2d.b2DistanceJoint.prototype.m_gamma);
box2d.b2DistanceJoint.prototype.m_impulse = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_impulse", box2d.b2DistanceJoint.prototype.m_impulse);
box2d.b2DistanceJoint.prototype.m_length = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_length", box2d.b2DistanceJoint.prototype.m_length);
box2d.b2DistanceJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_indexA", box2d.b2DistanceJoint.prototype.m_indexA);
box2d.b2DistanceJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_indexB", box2d.b2DistanceJoint.prototype.m_indexB);
box2d.b2DistanceJoint.prototype.m_u = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_u", box2d.b2DistanceJoint.prototype.m_u);
box2d.b2DistanceJoint.prototype.m_rA = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_rA", box2d.b2DistanceJoint.prototype.m_rA);
box2d.b2DistanceJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_rB", box2d.b2DistanceJoint.prototype.m_rB);
box2d.b2DistanceJoint.prototype.m_localCenterA = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_localCenterA", box2d.b2DistanceJoint.prototype.m_localCenterA);
box2d.b2DistanceJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_localCenterB", box2d.b2DistanceJoint.prototype.m_localCenterB);
box2d.b2DistanceJoint.prototype.m_invMassA = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_invMassA", box2d.b2DistanceJoint.prototype.m_invMassA);
box2d.b2DistanceJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_invMassB", box2d.b2DistanceJoint.prototype.m_invMassB);
box2d.b2DistanceJoint.prototype.m_invIA = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_invIA", box2d.b2DistanceJoint.prototype.m_invIA);
box2d.b2DistanceJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_invIB", box2d.b2DistanceJoint.prototype.m_invIB);
box2d.b2DistanceJoint.prototype.m_mass = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_mass", box2d.b2DistanceJoint.prototype.m_mass);
box2d.b2DistanceJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_qA", box2d.b2DistanceJoint.prototype.m_qA);
box2d.b2DistanceJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_qB", box2d.b2DistanceJoint.prototype.m_qB);
box2d.b2DistanceJoint.prototype.m_lalcA = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_lalcA", box2d.b2DistanceJoint.prototype.m_lalcA);
box2d.b2DistanceJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_lalcB", box2d.b2DistanceJoint.prototype.m_lalcB);
box2d.b2DistanceJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, a)
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "GetAnchorA", box2d.b2DistanceJoint.prototype.GetAnchorA);
box2d.b2DistanceJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "GetAnchorB", box2d.b2DistanceJoint.prototype.GetAnchorB);
box2d.b2DistanceJoint.prototype.GetReactionForce = function(a, b) {
    return b.SetXY(a * this.m_impulse * this.m_u.x, a * this.m_impulse * this.m_u.y)
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "GetReactionForce", box2d.b2DistanceJoint.prototype.GetReactionForce);
box2d.b2DistanceJoint.prototype.GetReactionTorque = function(a) {
    return 0
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "GetReactionTorque", box2d.b2DistanceJoint.prototype.GetReactionTorque);
box2d.b2DistanceJoint.prototype.GetLocalAnchorA = function(a) {
    return a.Copy(this.m_localAnchorA)
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "GetLocalAnchorA", box2d.b2DistanceJoint.prototype.GetLocalAnchorA);
box2d.b2DistanceJoint.prototype.GetLocalAnchorB = function(a) {
    return a.Copy(this.m_localAnchorB)
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "GetLocalAnchorB", box2d.b2DistanceJoint.prototype.GetLocalAnchorB);
box2d.b2DistanceJoint.prototype.SetLength = function(a) {
    this.m_length = a
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "SetLength", box2d.b2DistanceJoint.prototype.SetLength);
box2d.b2DistanceJoint.prototype.GetLength = function() {
    return this.m_length
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "GetLength", box2d.b2DistanceJoint.prototype.GetLength);
box2d.b2DistanceJoint.prototype.SetFrequency = function(a) {
    this.m_frequencyHz = a
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "SetFrequency", box2d.b2DistanceJoint.prototype.SetFrequency);
box2d.b2DistanceJoint.prototype.GetFrequency = function() {
    return this.m_frequencyHz
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "GetFrequency", box2d.b2DistanceJoint.prototype.GetFrequency);
box2d.b2DistanceJoint.prototype.SetDampingRatio = function(a) {
    this.m_dampingRatio = a
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "SetDampingRatio", box2d.b2DistanceJoint.prototype.SetDampingRatio);
box2d.b2DistanceJoint.prototype.GetDampingRatio = function() {
    return this.m_dampingRatio
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "GetDampingRatio", box2d.b2DistanceJoint.prototype.GetDampingRatio);
box2d.b2DistanceJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2DistanceJointDef*/ var jd = new box2d.b2DistanceJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
        box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n",
                this.m_localAnchorB.x, this.m_localAnchorB.y);
        box2d.b2Log("  jd.length = %.15f;\n", this.m_length);
        box2d.b2Log("  jd.frequencyHz = %.15f;\n", this.m_frequencyHz);
        box2d.b2Log("  jd.dampingRatio = %.15f;\n", this.m_dampingRatio);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "Dump", box2d.b2DistanceJoint.prototype.Dump);
box2d.b2DistanceJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassA = this.m_bodyA.m_invMass;
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIA = this.m_bodyA.m_invI;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = a.positions[this.m_indexA].c, c = a.velocities[this.m_indexA].v, e = a.velocities[this.m_indexA].w,
            d = a.positions[this.m_indexB].c, f = a.positions[this.m_indexB].a, g = a.velocities[this.m_indexB].v, h = a.velocities[this.m_indexB].w, l = this.m_qA.SetAngleRadians(a.positions[this.m_indexA].a), f = this.m_qB.SetAngleRadians(f);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    box2d.b2MulRV(l, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    box2d.b2MulRV(f, this.m_lalcB, this.m_rB);
    this.m_u.x = d.x + this.m_rB.x - b.x - this.m_rA.x;
    this.m_u.y = d.y + this.m_rB.y -
            b.y - this.m_rA.y;
    d = this.m_u.GetLength();
    d > box2d.b2_linearSlop ? this.m_u.SelfMul(1 / d) : this.m_u.SetZero();
    b = box2d.b2CrossVV(this.m_rA, this.m_u);
    l = box2d.b2CrossVV(this.m_rB, this.m_u);
    b = this.m_invMassA + this.m_invIA * b * b + this.m_invMassB + this.m_invIB * l * l;
    this.m_mass = 0 != b ? 1 / b : 0;
    if (0 < this.m_frequencyHz) {
        var d = d - this.m_length, l = 2 * box2d.b2_pi * this.m_frequencyHz, f = this.m_mass * l * l, k = a.step.dt;
        this.m_gamma = k * (2 * this.m_mass * this.m_dampingRatio * l + k * f);
        this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma : 0;
        this.m_bias = d * k * f *
                this.m_gamma;
        b += this.m_gamma;
        this.m_mass = 0 != b ? 1 / b : 0
    } else
        this.m_bias = this.m_gamma = 0;
    a.step.warmStarting ? (this.m_impulse *= a.step.dtRatio, b = box2d.b2MulSV(this.m_impulse, this.m_u, box2d.b2DistanceJoint.prototype.InitVelocityConstraints.s_P), c.SelfMulSub(this.m_invMassA, b), e -= this.m_invIA * box2d.b2CrossVV(this.m_rA, b), g.SelfMulAdd(this.m_invMassB, b), h += this.m_invIB * box2d.b2CrossVV(this.m_rB, b)) : this.m_impulse = 0;
    a.velocities[this.m_indexA].w = e;
    a.velocities[this.m_indexB].w = h
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "InitVelocityConstraints", box2d.b2DistanceJoint.prototype.InitVelocityConstraints);
box2d.b2DistanceJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2DistanceJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.velocities[this.m_indexB].v, d = a.velocities[this.m_indexB].w, f = box2d.b2AddVCrossSV(b, c, this.m_rA, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpA), g = box2d.b2AddVCrossSV(e, d, this.m_rB, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpB), f = box2d.b2DotVV(this.m_u, box2d.b2SubVV(g, f, box2d.b2Vec2.s_t0)), f = -this.m_mass * (f + this.m_bias + this.m_gamma *
            this.m_impulse);
    this.m_impulse += f;
    f = box2d.b2MulSV(f, this.m_u, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_P);
    b.SelfMulSub(this.m_invMassA, f);
    c -= this.m_invIA * box2d.b2CrossVV(this.m_rA, f);
    e.SelfMulAdd(this.m_invMassB, f);
    d += this.m_invIB * box2d.b2CrossVV(this.m_rB, f);
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = d
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "SolveVelocityConstraints", box2d.b2DistanceJoint.prototype.SolveVelocityConstraints);
box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpA = new box2d.b2Vec2;
box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpB = new box2d.b2Vec2;
box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2DistanceJoint.prototype.SolvePositionConstraints = function(a) {
    if (0 < this.m_frequencyHz)
        return!0;
    var b = a.positions[this.m_indexA].c, c = a.positions[this.m_indexA].a, e = a.positions[this.m_indexB].c, d = a.positions[this.m_indexB].a;
    this.m_qA.SetAngleRadians(c);
    this.m_qB.SetAngleRadians(d);
    var f = box2d.b2MulRV(this.m_qA, this.m_lalcA, this.m_rA), g = box2d.b2MulRV(this.m_qB, this.m_lalcB, this.m_rB), h = this.m_u;
    h.x = e.x + g.x - b.x - f.x;
    h.y = e.y + g.y - b.y - f.y;
    var l = this.m_u.Normalize() - this.m_length, l = box2d.b2Clamp(l,
            -box2d.b2_maxLinearCorrection, box2d.b2_maxLinearCorrection), h = box2d.b2MulSV(-this.m_mass * l, h, box2d.b2DistanceJoint.prototype.SolvePositionConstraints.s_P);
    b.SelfMulSub(this.m_invMassA, h);
    c -= this.m_invIA * box2d.b2CrossVV(f, h);
    e.SelfMulAdd(this.m_invMassB, h);
    d += this.m_invIB * box2d.b2CrossVV(g, h);
    a.positions[this.m_indexA].a = c;
    a.positions[this.m_indexB].a = d;
    return box2d.b2Abs(l) < box2d.b2_linearSlop
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "SolvePositionConstraints", box2d.b2DistanceJoint.prototype.SolvePositionConstraints);
box2d.b2DistanceJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2;
box2d.b2FrictionJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_frictionJoint);
    this.localAnchorA = new box2d.b2Vec2;
    this.localAnchorB = new box2d.b2Vec2
};
goog.inherits(box2d.b2FrictionJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2FrictionJointDef", box2d.b2FrictionJointDef);
box2d.b2FrictionJointDef.prototype.localAnchorA = null;
goog.exportProperty(box2d.b2FrictionJointDef.prototype, "localAnchorA", box2d.b2FrictionJointDef.prototype.localAnchorA);
box2d.b2FrictionJointDef.prototype.localAnchorB = null;
goog.exportProperty(box2d.b2FrictionJointDef.prototype, "localAnchorB", box2d.b2FrictionJointDef.prototype.localAnchorB);
box2d.b2FrictionJointDef.prototype.maxForce = 0;
goog.exportProperty(box2d.b2FrictionJointDef.prototype, "maxForce", box2d.b2FrictionJointDef.prototype.maxForce);
box2d.b2FrictionJointDef.prototype.maxTorque = 0;
goog.exportProperty(box2d.b2FrictionJointDef.prototype, "maxTorque", box2d.b2FrictionJointDef.prototype.maxTorque);
box2d.b2FrictionJointDef.prototype.Initialize = function(a, b, c) {
    this.bodyA = a;
    this.bodyB = b;
    this.bodyA.GetLocalPoint(c, this.localAnchorA);
    this.bodyB.GetLocalPoint(c, this.localAnchorB)
};
goog.exportProperty(box2d.b2FrictionJointDef.prototype, "Initialize", box2d.b2FrictionJointDef.prototype.Initialize);
box2d.b2FrictionJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_localAnchorA = a.localAnchorA.Clone();
    this.m_localAnchorB = a.localAnchorB.Clone();
    this.m_linearImpulse = (new box2d.b2Vec2).SetZero();
    this.m_maxForce = a.maxForce;
    this.m_maxTorque = a.maxTorque;
    this.m_rA = new box2d.b2Vec2;
    this.m_rB = new box2d.b2Vec2;
    this.m_localCenterA = new box2d.b2Vec2;
    this.m_localCenterB = new box2d.b2Vec2;
    this.m_linearMass = (new box2d.b2Mat22).SetZero();
    this.m_qA = new box2d.b2Rot;
    this.m_qB = new box2d.b2Rot;
    this.m_lalcA = new box2d.b2Vec2;
    this.m_lalcB = new box2d.b2Vec2;
    this.m_K = new box2d.b2Mat22
};
goog.inherits(box2d.b2FrictionJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2FrictionJoint", box2d.b2FrictionJoint);
box2d.b2FrictionJoint.prototype.m_localAnchorA = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_localAnchorA", box2d.b2FrictionJoint.prototype.m_localAnchorA);
box2d.b2FrictionJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_localAnchorB", box2d.b2FrictionJoint.prototype.m_localAnchorB);
box2d.b2FrictionJoint.prototype.m_linearImpulse = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_linearImpulse", box2d.b2FrictionJoint.prototype.m_linearImpulse);
box2d.b2FrictionJoint.prototype.m_angularImpulse = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_angularImpulse", box2d.b2FrictionJoint.prototype.m_angularImpulse);
box2d.b2FrictionJoint.prototype.m_maxForce = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_maxForce", box2d.b2FrictionJoint.prototype.m_maxForce);
box2d.b2FrictionJoint.prototype.m_maxTorque = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_maxTorque", box2d.b2FrictionJoint.prototype.m_maxTorque);
box2d.b2FrictionJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_indexA", box2d.b2FrictionJoint.prototype.m_indexA);
box2d.b2FrictionJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_indexB", box2d.b2FrictionJoint.prototype.m_indexB);
box2d.b2FrictionJoint.prototype.m_rA = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_rA", box2d.b2FrictionJoint.prototype.m_rA);
box2d.b2FrictionJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_rB", box2d.b2FrictionJoint.prototype.m_rB);
box2d.b2FrictionJoint.prototype.m_localCenterA = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_localCenterA", box2d.b2FrictionJoint.prototype.m_localCenterA);
box2d.b2FrictionJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_localCenterB", box2d.b2FrictionJoint.prototype.m_localCenterB);
box2d.b2FrictionJoint.prototype.m_invMassA = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_invMassA", box2d.b2FrictionJoint.prototype.m_invMassA);
box2d.b2FrictionJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_invMassB", box2d.b2FrictionJoint.prototype.m_invMassB);
box2d.b2FrictionJoint.prototype.m_invIA = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_invIA", box2d.b2FrictionJoint.prototype.m_invIA);
box2d.b2FrictionJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_invIB", box2d.b2FrictionJoint.prototype.m_invIB);
box2d.b2FrictionJoint.prototype.m_linearMass = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_linearMass", box2d.b2FrictionJoint.prototype.m_linearMass);
box2d.b2FrictionJoint.prototype.m_angularMass = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_angularMass", box2d.b2FrictionJoint.prototype.m_angularMass);
box2d.b2FrictionJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_qA", box2d.b2FrictionJoint.prototype.m_qA);
box2d.b2FrictionJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_qB", box2d.b2FrictionJoint.prototype.m_qB);
box2d.b2FrictionJoint.prototype.m_lalcA = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_lalcA", box2d.b2FrictionJoint.prototype.m_lalcA);
box2d.b2FrictionJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_lalcB", box2d.b2FrictionJoint.prototype.m_lalcB);
box2d.b2FrictionJoint.prototype.m_K = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_K", box2d.b2FrictionJoint.prototype.m_K);
box2d.b2FrictionJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassA = this.m_bodyA.m_invMass;
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIA = this.m_bodyA.m_invI;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.positions[this.m_indexB].a,
            d = a.velocities[this.m_indexB].v, f = a.velocities[this.m_indexB].w, g = this.m_qA.SetAngleRadians(a.positions[this.m_indexA].a), e = this.m_qB.SetAngleRadians(e);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    g = box2d.b2MulRV(g, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var h = box2d.b2MulRV(e, this.m_lalcB, this.m_rB), e = this.m_invMassA, l = this.m_invMassB, k = this.m_invIA, m = this.m_invIB, n = this.m_K;
    n.ex.x = e + l + k * g.y * g.y + m * h.y * h.y;
    n.ex.y = -k * g.x * g.y -
            m * h.x * h.y;
    n.ey.x = n.ex.y;
    n.ey.y = e + l + k * g.x * g.x + m * h.x * h.x;
    n.GetInverse(this.m_linearMass);
    this.m_angularMass = k + m;
    0 < this.m_angularMass && (this.m_angularMass = 1 / this.m_angularMass);
    a.step.warmStarting ? (this.m_linearImpulse.SelfMul(a.step.dtRatio), this.m_angularImpulse *= a.step.dtRatio, g = this.m_linearImpulse, b.SelfMulSub(e, g), c -= k * (box2d.b2CrossVV(this.m_rA, g) + this.m_angularImpulse), d.SelfMulAdd(l, g), f += m * (box2d.b2CrossVV(this.m_rB, g) + this.m_angularImpulse)) : (this.m_linearImpulse.SetZero(), this.m_angularImpulse =
            0);
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = f
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "InitVelocityConstraints", box2d.b2FrictionJoint.prototype.InitVelocityConstraints);
box2d.b2FrictionJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.velocities[this.m_indexB].v, d = a.velocities[this.m_indexB].w, f = this.m_invMassA, g = this.m_invMassB, h = this.m_invIA, l = this.m_invIB, k = a.step.dt, m, n = -this.m_angularMass * (d - c), p = this.m_angularImpulse;
    m = k * this.m_maxTorque;
    this.m_angularImpulse = box2d.b2Clamp(this.m_angularImpulse + n, -m, m);
    n = this.m_angularImpulse - p;
    c -= h * n;
    d += l * n;
    m = box2d.b2SubVV(box2d.b2AddVCrossSV(e, d, this.m_rB,
            box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(b, c, this.m_rA, box2d.b2Vec2.s_t1), box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_Cdot);
    n = box2d.b2MulMV(this.m_linearMass, m, box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_impulseV).SelfNeg();
    p = box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_oldImpulseV.Copy(this.m_linearImpulse);
    this.m_linearImpulse.SelfAdd(n);
    m = k * this.m_maxForce;
    this.m_linearImpulse.GetLengthSquared() > m * m && (this.m_linearImpulse.Normalize(), this.m_linearImpulse.SelfMul(m));
    box2d.b2SubVV(this.m_linearImpulse, p, n);
    b.SelfMulSub(f, n);
    c -= h * box2d.b2CrossVV(this.m_rA, n);
    e.SelfMulAdd(g, n);
    d += l * box2d.b2CrossVV(this.m_rB, n);
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = d
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "SolveVelocityConstraints", box2d.b2FrictionJoint.prototype.SolveVelocityConstraints);
box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2;
box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_impulseV = new box2d.b2Vec2;
box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_oldImpulseV = new box2d.b2Vec2;
box2d.b2FrictionJoint.prototype.SolvePositionConstraints = function(a) {
    return!0
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "SolvePositionConstraints", box2d.b2FrictionJoint.prototype.SolvePositionConstraints);
box2d.b2FrictionJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, a)
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "GetAnchorA", box2d.b2FrictionJoint.prototype.GetAnchorA);
box2d.b2FrictionJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "GetAnchorB", box2d.b2FrictionJoint.prototype.GetAnchorB);
box2d.b2FrictionJoint.prototype.GetReactionForce = function(a, b) {
    return b.SetXY(a * this.m_linearImpulse.x, a * this.m_linearImpulse.y)
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "GetReactionForce", box2d.b2FrictionJoint.prototype.GetReactionForce);
box2d.b2FrictionJoint.prototype.GetReactionTorque = function(a) {
    return a * this.m_angularImpulse
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "GetReactionTorque", box2d.b2FrictionJoint.prototype.GetReactionTorque);
box2d.b2FrictionJoint.prototype.GetLocalAnchorA = function(a) {
    return a.Copy(this.m_localAnchorA)
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "GetLocalAnchorA", box2d.b2FrictionJoint.prototype.GetLocalAnchorA);
box2d.b2FrictionJoint.prototype.GetLocalAnchorB = function(a) {
    return a.Copy(this.m_localAnchorB)
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "GetLocalAnchorB", box2d.b2FrictionJoint.prototype.GetLocalAnchorB);
box2d.b2FrictionJoint.prototype.SetMaxForce = function(a) {
    this.m_maxForce = a
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "SetMaxForce", box2d.b2FrictionJoint.prototype.SetMaxForce);
box2d.b2FrictionJoint.prototype.GetMaxForce = function() {
    return this.m_maxForce
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "GetMaxForce", box2d.b2FrictionJoint.prototype.GetMaxForce);
box2d.b2FrictionJoint.prototype.SetMaxTorque = function(a) {
    this.m_maxTorque = a
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "SetMaxTorque", box2d.b2FrictionJoint.prototype.SetMaxTorque);
box2d.b2FrictionJoint.prototype.GetMaxTorque = function() {
    return this.m_maxTorque
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "GetMaxTorque", box2d.b2FrictionJoint.prototype.GetMaxTorque);
box2d.b2FrictionJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2FrictionJointDef*/ var jd = new box2d.b2FrictionJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
        box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n",
                this.m_localAnchorB.x, this.m_localAnchorB.y);
        box2d.b2Log("  jd.maxForce = %.15f;\n", this.m_maxForce);
        box2d.b2Log("  jd.maxTorque = %.15f;\n", this.m_maxTorque);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "Dump", box2d.b2FrictionJoint.prototype.Dump);
box2d.b2MouseJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_mouseJoint);
    this.target = new box2d.b2Vec2
};
goog.inherits(box2d.b2MouseJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2MouseJointDef", box2d.b2MouseJointDef);
box2d.b2MouseJointDef.prototype.target = null;
goog.exportProperty(box2d.b2MouseJointDef.prototype, "target", box2d.b2MouseJointDef.prototype.target);
box2d.b2MouseJointDef.prototype.maxForce = 0;
goog.exportProperty(box2d.b2MouseJointDef.prototype, "maxForce", box2d.b2MouseJointDef.prototype.maxForce);
box2d.b2MouseJointDef.prototype.frequencyHz = 5;
goog.exportProperty(box2d.b2MouseJointDef.prototype, "frequencyHz", box2d.b2MouseJointDef.prototype.frequencyHz);
box2d.b2MouseJointDef.prototype.dampingRatio = 0.7;
goog.exportProperty(box2d.b2MouseJointDef.prototype, "dampingRatio", box2d.b2MouseJointDef.prototype.dampingRatio);
box2d.b2MouseJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_localAnchorB = new box2d.b2Vec2;
    this.m_targetA = new box2d.b2Vec2;
    this.m_impulse = new box2d.b2Vec2;
    this.m_rB = new box2d.b2Vec2;
    this.m_localCenterB = new box2d.b2Vec2;
    this.m_mass = new box2d.b2Mat22;
    this.m_C = new box2d.b2Vec2;
    this.m_qB = new box2d.b2Rot;
    this.m_lalcB = new box2d.b2Vec2;
    this.m_K = new box2d.b2Mat22;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.target.IsValid());
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a.maxForce) && 0 <= a.maxForce);
    box2d.ENABLE_ASSERTS &&
            box2d.b2Assert(box2d.b2IsValid(a.frequencyHz) && 0 <= a.frequencyHz);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a.dampingRatio) && 0 <= a.dampingRatio);
    this.m_targetA.Copy(a.target);
    box2d.b2MulTXV(this.m_bodyB.GetTransform(), this.m_targetA, this.m_localAnchorB);
    this.m_maxForce = a.maxForce;
    this.m_impulse.SetZero();
    this.m_frequencyHz = a.frequencyHz;
    this.m_dampingRatio = a.dampingRatio;
    this.m_gamma = this.m_beta = 0
};
goog.inherits(box2d.b2MouseJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2MouseJoint", box2d.b2MouseJoint);
box2d.b2MouseJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_localAnchorB", box2d.b2MouseJoint.prototype.m_localAnchorB);
box2d.b2MouseJoint.prototype.m_targetA = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_targetA", box2d.b2MouseJoint.prototype.m_targetA);
box2d.b2MouseJoint.prototype.m_frequencyHz = 0;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_frequencyHz", box2d.b2MouseJoint.prototype.m_frequencyHz);
box2d.b2MouseJoint.prototype.m_dampingRatio = 0;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_dampingRatio", box2d.b2MouseJoint.prototype.m_dampingRatio);
box2d.b2MouseJoint.prototype.m_beta = 0;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_beta", box2d.b2MouseJoint.prototype.m_beta);
box2d.b2MouseJoint.prototype.m_impulse = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_impulse", box2d.b2MouseJoint.prototype.m_impulse);
box2d.b2MouseJoint.prototype.m_maxForce = 0;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_maxForce", box2d.b2MouseJoint.prototype.m_maxForce);
box2d.b2MouseJoint.prototype.m_gamma = 0;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_gamma", box2d.b2MouseJoint.prototype.m_gamma);
box2d.b2MouseJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_indexA", box2d.b2MouseJoint.prototype.m_indexA);
box2d.b2MouseJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_indexB", box2d.b2MouseJoint.prototype.m_indexB);
box2d.b2MouseJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_rB", box2d.b2MouseJoint.prototype.m_rB);
box2d.b2MouseJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_localCenterB", box2d.b2MouseJoint.prototype.m_localCenterB);
box2d.b2MouseJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_invMassB", box2d.b2MouseJoint.prototype.m_invMassB);
box2d.b2MouseJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_invIB", box2d.b2MouseJoint.prototype.m_invIB);
box2d.b2MouseJoint.prototype.m_mass = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_mass", box2d.b2MouseJoint.prototype.m_mass);
box2d.b2MouseJoint.prototype.m_C = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_C", box2d.b2MouseJoint.prototype.m_C);
box2d.b2MouseJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_qB", box2d.b2MouseJoint.prototype.m_qB);
box2d.b2MouseJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_lalcB", box2d.b2MouseJoint.prototype.m_lalcB);
box2d.b2MouseJoint.prototype.m_K = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_K", box2d.b2MouseJoint.prototype.m_K);
box2d.b2MouseJoint.prototype.SetTarget = function(a) {
    !1 == this.m_bodyB.IsAwake() && this.m_bodyB.SetAwake(!0);
    this.m_targetA.Copy(a)
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "SetTarget", box2d.b2MouseJoint.prototype.SetTarget);
box2d.b2MouseJoint.prototype.GetTarget = function(a) {
    return a.Copy(this.m_targetA)
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "GetTarget", box2d.b2MouseJoint.prototype.GetTarget);
box2d.b2MouseJoint.prototype.SetMaxForce = function(a) {
    this.m_maxForce = a
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "SetMaxForce", box2d.b2MouseJoint.prototype.SetMaxForce);
box2d.b2MouseJoint.prototype.GetMaxForce = function() {
    return this.m_maxForce
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "GetMaxForce", box2d.b2MouseJoint.prototype.GetMaxForce);
box2d.b2MouseJoint.prototype.SetFrequency = function(a) {
    this.m_frequencyHz = a
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "SetFrequency", box2d.b2MouseJoint.prototype.SetFrequency);
box2d.b2MouseJoint.prototype.GetFrequency = function() {
    return this.m_frequencyHz
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "GetFrequency", box2d.b2MouseJoint.prototype.GetFrequency);
box2d.b2MouseJoint.prototype.SetDampingRatio = function(a) {
    this.m_dampingRatio = a
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "SetDampingRatio", box2d.b2MouseJoint.prototype.SetDampingRatio);
box2d.b2MouseJoint.prototype.GetDampingRatio = function() {
    return this.m_dampingRatio
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "GetDampingRatio", box2d.b2MouseJoint.prototype.GetDampingRatio);
box2d.b2MouseJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = a.positions[this.m_indexB].c, c = a.velocities[this.m_indexB].v, e = a.velocities[this.m_indexB].w, d = this.m_qB.SetAngleRadians(a.positions[this.m_indexB].a), f = this.m_bodyB.GetMass(), g = 2 * box2d.b2_pi * this.m_frequencyHz, h = 2 * f * this.m_dampingRatio * g, f = f * g * g, g = a.step.dt;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(h + g * f > box2d.b2_epsilon);
    this.m_gamma = g * (h + g * f);
    0 != this.m_gamma && (this.m_gamma = 1 / this.m_gamma);
    this.m_beta = g * f * this.m_gamma;
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    box2d.b2MulRV(d, this.m_lalcB, this.m_rB);
    d = this.m_K;
    d.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y + this.m_gamma;
    d.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y;
    d.ey.x = d.ex.y;
    d.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x + this.m_gamma;
    d.GetInverse(this.m_mass);
    this.m_C.x = b.x + this.m_rB.x - this.m_targetA.x;
    this.m_C.y = b.y + this.m_rB.y - this.m_targetA.y;
    this.m_C.SelfMul(this.m_beta);
    e *= 0.98;
    a.step.warmStarting ? (this.m_impulse.SelfMul(a.step.dtRatio), c.x += this.m_invMassB * this.m_impulse.x, c.y += this.m_invMassB * this.m_impulse.y, e += this.m_invIB * box2d.b2CrossVV(this.m_rB, this.m_impulse)) : this.m_impulse.SetZero();
    a.velocities[this.m_indexB].w = e
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "InitVelocityConstraints", box2d.b2MouseJoint.prototype.InitVelocityConstraints);
box2d.b2MouseJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexB].v, c = a.velocities[this.m_indexB].w, e = box2d.b2AddVCrossSV(b, c, this.m_rB, box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_Cdot), e = box2d.b2MulMV(this.m_mass, box2d.b2AddVV(e, box2d.b2AddVV(this.m_C, box2d.b2MulSV(this.m_gamma, this.m_impulse, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0).SelfNeg(), box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_impulse), d = box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_oldImpulse.Copy(this.m_impulse);
    this.m_impulse.SelfAdd(e);
    var f = a.step.dt * this.m_maxForce;
    this.m_impulse.GetLengthSquared() > f * f && this.m_impulse.SelfMul(f / this.m_impulse.GetLength());
    box2d.b2SubVV(this.m_impulse, d, e);
    b.SelfMulAdd(this.m_invMassB, e);
    c += this.m_invIB * box2d.b2CrossVV(this.m_rB, e);
    a.velocities[this.m_indexB].w = c
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "SolveVelocityConstraints", box2d.b2MouseJoint.prototype.SolveVelocityConstraints);
box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2;
box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_impulse = new box2d.b2Vec2;
box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_oldImpulse = new box2d.b2Vec2;
box2d.b2MouseJoint.prototype.SolvePositionConstraints = function(a) {
    return!0
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "SolvePositionConstraints", box2d.b2MouseJoint.prototype.SolvePositionConstraints);
box2d.b2MouseJoint.prototype.GetAnchorA = function(a) {
    return a.Copy(this.m_targetA)
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "GetAnchorA", box2d.b2MouseJoint.prototype.GetAnchorA);
box2d.b2MouseJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "GetAnchorB", box2d.b2MouseJoint.prototype.GetAnchorB);
box2d.b2MouseJoint.prototype.GetReactionForce = function(a, b) {
    return box2d.b2MulSV(a, this.m_impulse, b)
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "GetReactionForce", box2d.b2MouseJoint.prototype.GetReactionForce);
box2d.b2MouseJoint.prototype.GetReactionTorque = function(a) {
    return 0
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "GetReactionTorque", box2d.b2MouseJoint.prototype.GetReactionTorque);
box2d.b2MouseJoint.prototype.Dump = function() {
    box2d.DEBUG && box2d.b2Log("Mouse joint dumping is not supported.\n")
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "Dump", box2d.b2MouseJoint.prototype.Dump);
box2d.b2MouseJoint.prototype.ShiftOrigin = function(a) {
    this.m_targetA.SelfSub(a)
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "ShiftOrigin", box2d.b2MouseJoint.prototype.ShiftOrigin);
box2d.b2ConstantForceController = function() {
    box2d.b2Controller.call(this);
    this.F = new box2d.b2Vec2(0, 0)
};
goog.inherits(box2d.b2ConstantForceController, box2d.b2Controller);
goog.exportSymbol("box2d.b2ConstantForceController", box2d.b2ConstantForceController);
box2d.b2ConstantAccelController.prototype.F = null;
goog.exportProperty(box2d.b2ConstantAccelController.prototype, "F", box2d.b2ConstantAccelController.prototype.F);
box2d.b2ConstantForceController.prototype.Step = function(a) {
    for (a = this.m_bodyList; a; a = a.nextBody) {
        var b = a.body;
        b.IsAwake() && b.ApplyForce(this.F, b.GetWorldCenter())
    }
};
goog.exportProperty(box2d.b2ConstantForceController.prototype, "Step", box2d.b2ConstantForceController.prototype.Step);
box2d.b2_minPulleyLength = 2;
goog.exportSymbol("box2d.b2_minPulleyLength", box2d.b2_minPulleyLength);
box2d.b2PulleyJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_pulleyJoint);
    this.collideConnected = !0;
    this.groundAnchorA = new box2d.b2Vec2(-1, 1);
    this.groundAnchorB = new box2d.b2Vec2(1, 1);
    this.localAnchorA = new box2d.b2Vec2(-1, 0);
    this.localAnchorB = new box2d.b2Vec2(1, 0)
};
goog.inherits(box2d.b2PulleyJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2PulleyJointDef", box2d.b2PulleyJointDef);
box2d.b2PulleyJointDef.prototype.groundAnchorA = null;
goog.exportProperty(box2d.b2PulleyJointDef.prototype, "groundAnchorA", box2d.b2PulleyJointDef.prototype.groundAnchorA);
box2d.b2PulleyJointDef.prototype.groundAnchorB = null;
goog.exportProperty(box2d.b2PulleyJointDef.prototype, "groundAnchorB", box2d.b2PulleyJointDef.prototype.groundAnchorB);
box2d.b2PulleyJointDef.prototype.localAnchorA = null;
goog.exportProperty(box2d.b2PulleyJointDef.prototype, "localAnchorA", box2d.b2PulleyJointDef.prototype.localAnchorA);
box2d.b2PulleyJointDef.prototype.localAnchorB = null;
goog.exportProperty(box2d.b2PulleyJointDef.prototype, "localAnchorB", box2d.b2PulleyJointDef.prototype.localAnchorB);
box2d.b2PulleyJointDef.prototype.lengthA = 0;
goog.exportProperty(box2d.b2PulleyJointDef.prototype, "lengthA", box2d.b2PulleyJointDef.prototype.lengthA);
box2d.b2PulleyJointDef.prototype.lengthB = 0;
goog.exportProperty(box2d.b2PulleyJointDef.prototype, "lengthB", box2d.b2PulleyJointDef.prototype.lengthB);
box2d.b2PulleyJointDef.prototype.ratio = 1;
goog.exportProperty(box2d.b2PulleyJointDef.prototype, "ratio", box2d.b2PulleyJointDef.prototype.ratio);
box2d.b2PulleyJointDef.prototype.Initialize = function(a, b, c, e, d, f, g) {
    this.bodyA = a;
    this.bodyB = b;
    this.groundAnchorA.Copy(c);
    this.groundAnchorB.Copy(e);
    this.bodyA.GetLocalPoint(d, this.localAnchorA);
    this.bodyB.GetLocalPoint(f, this.localAnchorB);
    this.lengthA = box2d.b2DistanceVV(d, c);
    this.lengthB = box2d.b2DistanceVV(f, e);
    this.ratio = g;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.ratio > box2d.b2_epsilon)
};
goog.exportProperty(box2d.b2PulleyJointDef.prototype, "Initialize", box2d.b2PulleyJointDef.prototype.Initialize);
box2d.b2PulleyJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_groundAnchorA = new box2d.b2Vec2;
    this.m_groundAnchorB = new box2d.b2Vec2;
    this.m_localAnchorA = new box2d.b2Vec2;
    this.m_localAnchorB = new box2d.b2Vec2;
    this.m_uA = new box2d.b2Vec2;
    this.m_uB = new box2d.b2Vec2;
    this.m_rA = new box2d.b2Vec2;
    this.m_rB = new box2d.b2Vec2;
    this.m_localCenterA = new box2d.b2Vec2;
    this.m_localCenterB = new box2d.b2Vec2;
    this.m_qA = new box2d.b2Rot;
    this.m_qB = new box2d.b2Rot;
    this.m_lalcA = new box2d.b2Vec2;
    this.m_lalcB = new box2d.b2Vec2;
    this.m_groundAnchorA.Copy(a.groundAnchorA);
    this.m_groundAnchorB.Copy(a.groundAnchorB);
    this.m_localAnchorA.Copy(a.localAnchorA);
    this.m_localAnchorB.Copy(a.localAnchorB);
    this.m_lengthA = a.lengthA;
    this.m_lengthB = a.lengthB;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 != a.ratio);
    this.m_ratio = a.ratio;
    this.m_constant = a.lengthA + this.m_ratio * a.lengthB;
    this.m_impulse = 0
};
goog.inherits(box2d.b2PulleyJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2PulleyJoint", box2d.b2PulleyJoint);
box2d.b2PulleyJoint.prototype.m_groundAnchorA = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_groundAnchorA", box2d.b2PulleyJoint.prototype.m_groundAnchorA);
box2d.b2PulleyJoint.prototype.m_groundAnchorB = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_groundAnchorB", box2d.b2PulleyJoint.prototype.m_groundAnchorB);
box2d.b2PulleyJoint.prototype.m_lengthA = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_lengthA", box2d.b2PulleyJoint.prototype.m_lengthA);
box2d.b2PulleyJoint.prototype.m_lengthB = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_lengthB", box2d.b2PulleyJoint.prototype.m_lengthB);
box2d.b2PulleyJoint.prototype.m_localAnchorA = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_localAnchorA", box2d.b2PulleyJoint.prototype.m_localAnchorA);
box2d.b2PulleyJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_localAnchorB", box2d.b2PulleyJoint.prototype.m_localAnchorB);
box2d.b2PulleyJoint.prototype.m_constant = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_constant", box2d.b2PulleyJoint.prototype.m_constant);
box2d.b2PulleyJoint.prototype.m_ratio = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_ratio", box2d.b2PulleyJoint.prototype.m_ratio);
box2d.b2PulleyJoint.prototype.m_impulse = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_impulse", box2d.b2PulleyJoint.prototype.m_impulse);
box2d.b2PulleyJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_indexA", box2d.b2PulleyJoint.prototype.m_indexA);
box2d.b2PulleyJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_indexB", box2d.b2PulleyJoint.prototype.m_indexB);
box2d.b2PulleyJoint.prototype.m_uA = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_uA", box2d.b2PulleyJoint.prototype.m_uA);
box2d.b2PulleyJoint.prototype.m_uB = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_uB", box2d.b2PulleyJoint.prototype.m_uB);
box2d.b2PulleyJoint.prototype.m_rA = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_rA", box2d.b2PulleyJoint.prototype.m_rA);
box2d.b2PulleyJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_rB", box2d.b2PulleyJoint.prototype.m_rB);
box2d.b2PulleyJoint.prototype.m_localCenterA = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_localCenterA", box2d.b2PulleyJoint.prototype.m_localCenterA);
box2d.b2PulleyJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_localCenterB", box2d.b2PulleyJoint.prototype.m_localCenterB);
box2d.b2PulleyJoint.prototype.m_invMassA = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_invMassA", box2d.b2PulleyJoint.prototype.m_invMassA);
box2d.b2PulleyJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_invMassB", box2d.b2PulleyJoint.prototype.m_invMassB);
box2d.b2PulleyJoint.prototype.m_invIA = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_invIA", box2d.b2PulleyJoint.prototype.m_invIA);
box2d.b2PulleyJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_invIB", box2d.b2PulleyJoint.prototype.m_invIB);
box2d.b2PulleyJoint.prototype.m_mass = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_mass", box2d.b2PulleyJoint.prototype.m_mass);
box2d.b2PulleyJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_qA", box2d.b2PulleyJoint.prototype.m_qA);
box2d.b2PulleyJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_qB", box2d.b2PulleyJoint.prototype.m_qB);
box2d.b2PulleyJoint.prototype.m_lalcA = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_lalcA", box2d.b2PulleyJoint.prototype.m_lalcA);
box2d.b2PulleyJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_lalcB", box2d.b2PulleyJoint.prototype.m_lalcB);
box2d.b2PulleyJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassA = this.m_bodyA.m_invMass;
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIA = this.m_bodyA.m_invI;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = a.positions[this.m_indexA].c, c = a.velocities[this.m_indexA].v, e = a.velocities[this.m_indexA].w,
            d = a.positions[this.m_indexB].c, f = a.positions[this.m_indexB].a, g = a.velocities[this.m_indexB].v, h = a.velocities[this.m_indexB].w, l = this.m_qA.SetAngleRadians(a.positions[this.m_indexA].a), f = this.m_qB.SetAngleRadians(f);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    box2d.b2MulRV(l, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    box2d.b2MulRV(f, this.m_lalcB, this.m_rB);
    this.m_uA.Copy(b).SelfAdd(this.m_rA).SelfSub(this.m_groundAnchorA);
    this.m_uB.Copy(d).SelfAdd(this.m_rB).SelfSub(this.m_groundAnchorB);
    b = this.m_uA.GetLength();
    d = this.m_uB.GetLength();
    b > 10 * box2d.b2_linearSlop ? this.m_uA.SelfMul(1 / b) : this.m_uA.SetZero();
    d > 10 * box2d.b2_linearSlop ? this.m_uB.SelfMul(1 / d) : this.m_uB.SetZero();
    b = box2d.b2CrossVV(this.m_rA, this.m_uA);
    d = box2d.b2CrossVV(this.m_rB, this.m_uB);
    this.m_mass = this.m_invMassA + this.m_invIA * b * b + this.m_ratio * this.m_ratio * (this.m_invMassB + this.m_invIB * d * d);
    0 < this.m_mass && (this.m_mass = 1 / this.m_mass);
    a.step.warmStarting ? (this.m_impulse *= a.step.dtRatio, b = box2d.b2MulSV(-this.m_impulse, this.m_uA,
            box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PA), d = box2d.b2MulSV(-this.m_ratio * this.m_impulse, this.m_uB, box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PB), c.SelfMulAdd(this.m_invMassA, b), e += this.m_invIA * box2d.b2CrossVV(this.m_rA, b), g.SelfMulAdd(this.m_invMassB, d), h += this.m_invIB * box2d.b2CrossVV(this.m_rB, d)) : this.m_impulse = 0;
    a.velocities[this.m_indexA].w = e;
    a.velocities[this.m_indexB].w = h
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "InitVelocityConstraints", box2d.b2PulleyJoint.prototype.InitVelocityConstraints);
box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PA = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PB = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.velocities[this.m_indexB].v, d = a.velocities[this.m_indexB].w, f = box2d.b2AddVCrossSV(b, c, this.m_rA, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpA), g = box2d.b2AddVCrossSV(e, d, this.m_rB, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpB), f = -box2d.b2DotVV(this.m_uA, f) - this.m_ratio * box2d.b2DotVV(this.m_uB, g), g = -this.m_mass * f;
    this.m_impulse += g;
    f =
            box2d.b2MulSV(-g, this.m_uA, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PA);
    g = box2d.b2MulSV(-this.m_ratio * g, this.m_uB, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PB);
    b.SelfMulAdd(this.m_invMassA, f);
    c += this.m_invIA * box2d.b2CrossVV(this.m_rA, f);
    e.SelfMulAdd(this.m_invMassB, g);
    d += this.m_invIB * box2d.b2CrossVV(this.m_rB, g);
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = d
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "SolveVelocityConstraints", box2d.b2PulleyJoint.prototype.SolveVelocityConstraints);
box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpA = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpB = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PA = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PB = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.SolvePositionConstraints = function(a) {
    var b = a.positions[this.m_indexA].c, c = a.positions[this.m_indexA].a, e = a.positions[this.m_indexB].c, d = a.positions[this.m_indexB].a, f = this.m_qA.SetAngleRadians(c), g = this.m_qB.SetAngleRadians(d);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    f = box2d.b2MulRV(f, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var g = box2d.b2MulRV(g, this.m_lalcB, this.m_rB), h = this.m_uA.Copy(b).SelfAdd(f).SelfSub(this.m_groundAnchorA),
            l = this.m_uB.Copy(e).SelfAdd(g).SelfSub(this.m_groundAnchorB), k = h.GetLength(), m = l.GetLength();
    k > 10 * box2d.b2_linearSlop ? h.SelfMul(1 / k) : h.SetZero();
    m > 10 * box2d.b2_linearSlop ? l.SelfMul(1 / m) : l.SetZero();
    var n = box2d.b2CrossVV(f, h), p = box2d.b2CrossVV(g, l), n = this.m_invMassA + this.m_invIA * n * n + this.m_ratio * this.m_ratio * (this.m_invMassB + this.m_invIB * p * p);
    0 < n && (n = 1 / n);
    m = this.m_constant - k - this.m_ratio * m;
    k = box2d.b2Abs(m);
    m *= -n;
    h = box2d.b2MulSV(-m, h, box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PA);
    l = box2d.b2MulSV(-this.m_ratio *
            m, l, box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PB);
    b.SelfMulAdd(this.m_invMassA, h);
    c += this.m_invIA * box2d.b2CrossVV(f, h);
    e.SelfMulAdd(this.m_invMassB, l);
    d += this.m_invIB * box2d.b2CrossVV(g, l);
    a.positions[this.m_indexA].a = c;
    a.positions[this.m_indexB].a = d;
    return k < box2d.b2_linearSlop
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "SolvePositionConstraints", box2d.b2PulleyJoint.prototype.SolvePositionConstraints);
box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PA = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PB = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, a)
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetAnchorA", box2d.b2PulleyJoint.prototype.GetAnchorA);
box2d.b2PulleyJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetAnchorB", box2d.b2PulleyJoint.prototype.GetAnchorB);
box2d.b2PulleyJoint.prototype.GetReactionForce = function(a, b) {
    return b.SetXY(a * this.m_impulse * this.m_uB.x, a * this.m_impulse * this.m_uB.y)
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetReactionForce", box2d.b2PulleyJoint.prototype.GetReactionForce);
box2d.b2PulleyJoint.prototype.GetReactionTorque = function(a) {
    return 0
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetReactionTorque", box2d.b2PulleyJoint.prototype.GetReactionTorque);
box2d.b2PulleyJoint.prototype.GetGroundAnchorA = function(a) {
    return a.Copy(this.m_groundAnchorA)
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetGroundAnchorA", box2d.b2PulleyJoint.prototype.GetGroundAnchorA);
box2d.b2PulleyJoint.prototype.GetGroundAnchorB = function(a) {
    return a.Copy(this.m_groundAnchorB)
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetGroundAnchorB", box2d.b2PulleyJoint.prototype.GetGroundAnchorB);
box2d.b2PulleyJoint.prototype.GetLengthA = function() {
    return this.m_lengthA
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetLengthA", box2d.b2PulleyJoint.prototype.GetLengthA);
box2d.b2PulleyJoint.prototype.GetLengthB = function() {
    return this.m_lengthB
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetLengthB", box2d.b2PulleyJoint.prototype.GetLengthB);
box2d.b2PulleyJoint.prototype.GetRatio = function() {
    return this.m_ratio
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetRatio", box2d.b2PulleyJoint.prototype.GetRatio);
box2d.b2PulleyJoint.prototype.GetCurrentLengthA = function() {
    var a = this.m_bodyA.GetWorldPoint(this.m_localAnchorA, box2d.b2PulleyJoint.prototype.GetCurrentLengthA.s_p);
    return box2d.b2DistanceVV(a, this.m_groundAnchorA)
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetCurrentLengthA", box2d.b2PulleyJoint.prototype.GetCurrentLengthA);
box2d.b2PulleyJoint.prototype.GetCurrentLengthA.s_p = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.GetCurrentLengthB = function() {
    var a = this.m_bodyB.GetWorldPoint(this.m_localAnchorB, box2d.b2PulleyJoint.prototype.GetCurrentLengthB.s_p);
    return box2d.b2DistanceVV(a, this.m_groundAnchorB)
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetCurrentLengthB", box2d.b2PulleyJoint.prototype.GetCurrentLengthB);
box2d.b2PulleyJoint.prototype.GetCurrentLengthB.s_p = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2PulleyJointDef*/ var jd = new box2d.b2PulleyJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.groundAnchorA.SetXY(%.15f, %.15f);\n", this.m_groundAnchorA.x, this.m_groundAnchorA.y);
        box2d.b2Log("  jd.groundAnchorB.SetXY(%.15f, %.15f);\n",
                this.m_groundAnchorB.x, this.m_groundAnchorB.y);
        box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
        box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y);
        box2d.b2Log("  jd.lengthA = %.15f;\n", this.m_lengthA);
        box2d.b2Log("  jd.lengthB = %.15f;\n", this.m_lengthB);
        box2d.b2Log("  jd.ratio = %.15f;\n", this.m_ratio);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "Dump", box2d.b2PulleyJoint.prototype.Dump);
box2d.b2PulleyJoint.prototype.ShiftOrigin = function(a) {
    this.m_groundAnchorA.SelfSub(a);
    this.m_groundAnchorB.SelfSub(a)
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "ShiftOrigin", box2d.b2PulleyJoint.prototype.ShiftOrigin);
box2d.b2CircleShape = function(a) {
    box2d.b2Shape.call(this, box2d.b2ShapeType.e_circleShape, a || 0);
    this.m_p = new box2d.b2Vec2
};
goog.inherits(box2d.b2CircleShape, box2d.b2Shape);
goog.exportSymbol("box2d.b2CircleShape", box2d.b2CircleShape);
box2d.b2CircleShape.prototype.m_p = null;
goog.exportProperty(box2d.b2CircleShape.prototype, "m_p", box2d.b2CircleShape.prototype.m_p);
box2d.b2CircleShape.prototype.Clone = function() {
    return(new box2d.b2CircleShape).Copy(this)
};
goog.exportProperty(box2d.b2CircleShape.prototype, "Clone", box2d.b2CircleShape.prototype.Clone);
box2d.b2CircleShape.prototype.Copy = function(a) {
    box2d.b2CircleShape.superClass_.Copy.call(this, a);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a instanceof box2d.b2CircleShape);
    this.m_p.Copy(a.m_p);
    return this
};
goog.exportProperty(box2d.b2CircleShape.prototype, "Copy", box2d.b2CircleShape.prototype.Copy);
box2d.b2CircleShape.prototype.GetChildCount = function() {
    return 1
};
goog.exportProperty(box2d.b2CircleShape.prototype, "GetChildCount", box2d.b2CircleShape.prototype.GetChildCount);
box2d.b2CircleShape.prototype.TestPoint = function(a, b) {
    var c = box2d.b2MulXV(a, this.m_p, box2d.b2CircleShape.prototype.TestPoint.s_center), c = box2d.b2SubVV(b, c, box2d.b2CircleShape.prototype.TestPoint.s_d);
    return box2d.b2DotVV(c, c) <= box2d.b2Sq(this.m_radius)
};
goog.exportProperty(box2d.b2CircleShape.prototype, "TestPoint", box2d.b2CircleShape.prototype.TestPoint);
box2d.b2CircleShape.prototype.TestPoint.s_center = new box2d.b2Vec2;
box2d.b2CircleShape.prototype.TestPoint.s_d = new box2d.b2Vec2;
box2d.b2CircleShape.prototype.RayCast = function(a, b, c, e) {
    c = box2d.b2MulXV(c, this.m_p, box2d.b2CircleShape.prototype.RayCast.s_position);
    c = box2d.b2SubVV(b.p1, c, box2d.b2CircleShape.prototype.RayCast.s_s);
    var d = box2d.b2DotVV(c, c) - box2d.b2Sq(this.m_radius);
    e = box2d.b2SubVV(b.p2, b.p1, box2d.b2CircleShape.prototype.RayCast.s_r);
    var f = box2d.b2DotVV(c, e), g = box2d.b2DotVV(e, e), d = f * f - g * d;
    if (0 > d || g < box2d.b2_epsilon)
        return!1;
    f = -(f + box2d.b2Sqrt(d));
    return 0 <= f && f <= b.maxFraction * g ? (f /= g, a.fraction = f, box2d.b2AddVMulSV(c,
            f, e, a.normal).SelfNormalize(), !0) : !1
};
goog.exportProperty(box2d.b2CircleShape.prototype, "RayCast", box2d.b2CircleShape.prototype.RayCast);
box2d.b2CircleShape.prototype.RayCast.s_position = new box2d.b2Vec2;
box2d.b2CircleShape.prototype.RayCast.s_s = new box2d.b2Vec2;
box2d.b2CircleShape.prototype.RayCast.s_r = new box2d.b2Vec2;
box2d.b2CircleShape.prototype.ComputeAABB = function(a, b, c) {
    b = box2d.b2MulXV(b, this.m_p, box2d.b2CircleShape.prototype.ComputeAABB.s_p);
    a.lowerBound.SetXY(b.x - this.m_radius, b.y - this.m_radius);
    a.upperBound.SetXY(b.x + this.m_radius, b.y + this.m_radius)
};
goog.exportProperty(box2d.b2CircleShape.prototype, "ComputeAABB", box2d.b2CircleShape.prototype.ComputeAABB);
box2d.b2CircleShape.prototype.ComputeAABB.s_p = new box2d.b2Vec2;
box2d.b2CircleShape.prototype.ComputeMass = function(a, b) {
    var c = box2d.b2Sq(this.m_radius);
    a.mass = b * box2d.b2_pi * c;
    a.center.Copy(this.m_p);
    a.I = a.mass * (0.5 * c + box2d.b2DotVV(this.m_p, this.m_p))
};
goog.exportProperty(box2d.b2CircleShape.prototype, "ComputeMass", box2d.b2CircleShape.prototype.ComputeMass);
box2d.b2CircleShape.prototype.SetupDistanceProxy = function(a, b) {
    a.m_vertices = [1, !0];
    a.m_vertices[0] = this.m_p;
    a.m_count = 1;
    a.m_radius = this.m_radius
};
box2d.b2CircleShape.prototype.ComputeSubmergedArea = function(a, b, c, e) {
    c = box2d.b2MulXV(c, this.m_p, new box2d.b2Vec2);
    var d = -(box2d.b2DotVV(a, c) - b);
    if (d < -this.m_radius + box2d.b2_epsilon)
        return 0;
    if (d > this.m_radius)
        return e.Copy(c), box2d.b2_pi * this.m_radius * this.m_radius;
    b = this.m_radius * this.m_radius;
    var f = d * d, d = b * (box2d.b2Asin(d / this.m_radius) + box2d.b2_pi / 2) + d * box2d.b2Sqrt(b - f);
    b = -2 / 3 * box2d.b2Pow(b - f, 1.5) / d;
    e.x = c.x + a.x * b;
    e.y = c.y + a.y * b;
    return d
};
goog.exportProperty(box2d.b2CircleShape.prototype, "ComputeSubmergedArea", box2d.b2CircleShape.prototype.ComputeSubmergedArea);
box2d.b2CircleShape.prototype.Dump = function() {
    box2d.b2Log("    /*box2d.b2CircleShape*/ var shape = new box2d.b2CircleShape();\n");
    box2d.b2Log("    shape.m_radius = %.15f;\n", this.m_radius);
    box2d.b2Log("    shape.m_p.SetXY(%.15f, %.15f);\n", this.m_p.x, this.m_p.y)
};
goog.exportProperty(box2d.b2CircleShape.prototype, "Dump", box2d.b2CircleShape.prototype.Dump);
box2d.b2RopeDef = function() {
    this.vertices = [];
    this.masses = [];
    this.gravity = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2RopeDef", box2d.b2RopeDef);
box2d.b2RopeDef.prototype.vertices = null;
box2d.b2RopeDef.prototype.count = 0;
box2d.b2RopeDef.prototype.masses = null;
box2d.b2RopeDef.prototype.gravity = null;
box2d.b2RopeDef.prototype.damping = 0.1;
box2d.b2RopeDef.prototype.k2 = 0.9;
box2d.b2RopeDef.prototype.k3 = 0.1;
box2d.b2Rope = function() {
    this.m_gravity = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2Rope", box2d.b2Rope);
box2d.b2Rope.prototype.m_count = 0;
box2d.b2Rope.prototype.m_ps = null;
box2d.b2Rope.prototype.m_p0s = null;
box2d.b2Rope.prototype.m_vs = null;
box2d.b2Rope.prototype.m_ims = null;
box2d.b2Rope.prototype.m_Ls = null;
box2d.b2Rope.prototype.m_as = null;
box2d.b2Rope.prototype.m_gravity = null;
box2d.b2Rope.prototype.m_damping = 0;
box2d.b2Rope.prototype.m_k2 = 1;
box2d.b2Rope.prototype.m_k3 = 0.1;
box2d.b2Rope.prototype.GetVertexCount = function() {
    return this.m_count
};
goog.exportProperty(box2d.b2Rope.prototype, "GetVertexCount", box2d.b2Rope.prototype.GetVertexCount);
box2d.b2Rope.prototype.GetVertices = function() {
    return this.m_ps
};
goog.exportProperty(box2d.b2Rope.prototype, "GetVertices", box2d.b2Rope.prototype.GetVertices);
box2d.b2Rope.prototype.Initialize = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(3 <= a.count);
    this.m_count = a.count;
    this.m_ps = box2d.b2Vec2.MakeArray(this.m_count);
    this.m_p0s = box2d.b2Vec2.MakeArray(this.m_count);
    this.m_vs = box2d.b2Vec2.MakeArray(this.m_count);
    this.m_ims = box2d.b2MakeNumberArray(this.m_count);
    for (var b = 0; b < this.m_count; ++b) {
        this.m_ps[b].Copy(a.vertices[b]);
        this.m_p0s[b].Copy(a.vertices[b]);
        this.m_vs[b].SetZero();
        var c = a.masses[b];
        this.m_ims[b] = 0 < c ? 1 / c : 0
    }
    var e = this.m_count - 1, c = this.m_count -
            2;
    this.m_Ls = box2d.b2MakeNumberArray(e);
    this.m_as = box2d.b2MakeNumberArray(c);
    for (b = 0; b < e; ++b) {
        var d = this.m_ps[b], f = this.m_ps[b + 1];
        this.m_Ls[b] = box2d.b2DistanceVV(d, f)
    }
    for (b = 0; b < c; ++b)
        d = this.m_ps[b], f = this.m_ps[b + 1], e = this.m_ps[b + 2], d = box2d.b2SubVV(f, d, box2d.b2Vec2.s_t0), e = box2d.b2SubVV(e, f, box2d.b2Vec2.s_t1), f = box2d.b2CrossVV(d, e), d = box2d.b2DotVV(d, e), this.m_as[b] = box2d.b2Atan2(f, d);
    this.m_gravity.Copy(a.gravity);
    this.m_damping = a.damping;
    this.m_k2 = a.k2;
    this.m_k3 = a.k3
};
goog.exportProperty(box2d.b2Rope.prototype, "Initialize", box2d.b2Rope.prototype.Initialize);
box2d.b2Rope.prototype.Step = function(a, b) {
    if (0 != a) {
        for (var c = Math.exp(-a * this.m_damping), e = 0; e < this.m_count; ++e)
            this.m_p0s[e].Copy(this.m_ps[e]), 0 < this.m_ims[e] && this.m_vs[e].SelfMulAdd(a, this.m_gravity), this.m_vs[e].SelfMul(c), this.m_ps[e].SelfMulAdd(a, this.m_vs[e]);
        for (e = 0; e < b; ++e)
            this.SolveC2(), this.SolveC3(), this.SolveC2();
        c = 1 / a;
        for (e = 0; e < this.m_count; ++e)
            box2d.b2MulSV(c, box2d.b2SubVV(this.m_ps[e], this.m_p0s[e], box2d.b2Vec2.s_t0), this.m_vs[e])
    }
};
goog.exportProperty(box2d.b2Rope.prototype, "Step", box2d.b2Rope.prototype.Step);
box2d.b2Rope.prototype.SolveC2 = function() {
    for (var a = this.m_count - 1, b = 0; b < a; ++b) {
        var c = this.m_ps[b], e = this.m_ps[b + 1], d = box2d.b2SubVV(e, c, box2d.b2Rope.s_d), f = d.Normalize(), g = this.m_ims[b], h = this.m_ims[b + 1];
        if (0 != g + h) {
            var l = h / (g + h);
            c.SelfMulSub(this.m_k2 * (g / (g + h)) * (this.m_Ls[b] - f), d);
            e.SelfMulAdd(this.m_k2 * l * (this.m_Ls[b] - f), d)
        }
    }
};
goog.exportProperty(box2d.b2Rope.prototype, "SolveC2", box2d.b2Rope.prototype.SolveC2);
box2d.b2Rope.s_d = new box2d.b2Vec2;
box2d.b2Rope.prototype.SetAngleRadians = function(a) {
    for (var b = this.m_count - 2, c = 0; c < b; ++c)
        this.m_as[c] = a
};
goog.exportProperty(box2d.b2Rope.prototype, "SetAngleRadians", box2d.b2Rope.prototype.SetAngleRadians);
box2d.b2Rope.prototype.SolveC3 = function() {
    for (var a = this.m_count - 2, b = 0; b < a; ++b) {
        var c = this.m_ps[b], e = this.m_ps[b + 1], d = this.m_ps[b + 2], f = this.m_ims[b], g = this.m_ims[b + 1], h = this.m_ims[b + 2], l = box2d.b2SubVV(e, c, box2d.b2Rope.s_d1), k = box2d.b2SubVV(d, e, box2d.b2Rope.s_d2), m = l.GetLengthSquared(), n = k.GetLengthSquared();
        if (0 != m * n) {
            var p = box2d.b2CrossVV(l, k), q = box2d.b2DotVV(l, k), p = box2d.b2Atan2(p, q), l = box2d.b2MulSV(-1 / m, l.SelfSkew(), box2d.b2Rope.s_Jd1), m = box2d.b2MulSV(1 / n, k.SelfSkew(), box2d.b2Rope.s_Jd2), k = box2d.b2NegV(l,
                    box2d.b2Rope.s_J1), n = box2d.b2SubVV(l, m, box2d.b2Rope.s_J2), l = m, m = f * box2d.b2DotVV(k, k) + g * box2d.b2DotVV(n, n) + h * box2d.b2DotVV(l, l);
            if (0 != m) {
                m = 1 / m;
                for (q = p - this.m_as[b]; q > box2d.b2_pi; )
                    p -= 2 * box2d.b2_pi, q = p - this.m_as[b];
                for (; q < - box2d.b2_pi; )
                    p += 2 * box2d.b2_pi, q = p - this.m_as[b];
                p = -this.m_k3 * m * q;
                c.SelfMulAdd(f * p, k);
                e.SelfMulAdd(g * p, n);
                d.SelfMulAdd(h * p, l)
            }
        }
    }
};
goog.exportProperty(box2d.b2Rope.prototype, "SolveC3", box2d.b2Rope.prototype.SolveC3);
box2d.b2Rope.s_d1 = new box2d.b2Vec2;
box2d.b2Rope.s_d2 = new box2d.b2Vec2;
box2d.b2Rope.s_Jd1 = new box2d.b2Vec2;
box2d.b2Rope.s_Jd2 = new box2d.b2Vec2;
box2d.b2Rope.s_J1 = new box2d.b2Vec2;
box2d.b2Rope.s_J2 = new box2d.b2Vec2;
box2d.b2Rope.prototype.Draw = function(a) {
    for (var b = new box2d.b2Color(0.4, 0.5, 0.7), c = 0; c < this.m_count - 1; ++c)
        a.DrawSegment(this.m_ps[c], this.m_ps[c + 1], b)
};
goog.exportProperty(box2d.b2Rope.prototype, "Draw", box2d.b2Rope.prototype.Draw);
box2d.b2WheelJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_wheelJoint);
    this.localAnchorA = new box2d.b2Vec2(0, 0);
    this.localAnchorB = new box2d.b2Vec2(0, 0);
    this.localAxisA = new box2d.b2Vec2(1, 0)
};
goog.inherits(box2d.b2WheelJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2WheelJointDef", box2d.b2WheelJointDef);
box2d.b2WheelJointDef.prototype.localAnchorA = null;
goog.exportProperty(box2d.b2WheelJointDef.prototype, "localAnchorA", box2d.b2WheelJointDef.prototype.localAnchorA);
box2d.b2WheelJointDef.prototype.localAnchorB = null;
goog.exportProperty(box2d.b2WheelJointDef.prototype, "localAnchorB", box2d.b2WheelJointDef.prototype.localAnchorB);
box2d.b2WheelJointDef.prototype.localAxisA = null;
goog.exportProperty(box2d.b2WheelJointDef.prototype, "localAxisA", box2d.b2WheelJointDef.prototype.localAxisA);
box2d.b2WheelJointDef.prototype.enableMotor = !1;
goog.exportProperty(box2d.b2WheelJointDef.prototype, "enableMotor", box2d.b2WheelJointDef.prototype.enableMotor);
box2d.b2WheelJointDef.prototype.maxMotorTorque = 0;
goog.exportProperty(box2d.b2WheelJointDef.prototype, "maxMotorTorque", box2d.b2WheelJointDef.prototype.maxMotorTorque);
box2d.b2WheelJointDef.prototype.motorSpeed = 0;
goog.exportProperty(box2d.b2WheelJointDef.prototype, "motorSpeed", box2d.b2WheelJointDef.prototype.motorSpeed);
box2d.b2WheelJointDef.prototype.frequencyHz = 2;
goog.exportProperty(box2d.b2WheelJointDef.prototype, "frequencyHz", box2d.b2WheelJointDef.prototype.frequencyHz);
box2d.b2WheelJointDef.prototype.dampingRatio = 0.7;
goog.exportProperty(box2d.b2WheelJointDef.prototype, "dampingRatio", box2d.b2WheelJointDef.prototype.dampingRatio);
box2d.b2WheelJointDef.prototype.Initialize = function(a, b, c, e) {
    this.bodyA = a;
    this.bodyB = b;
    this.bodyA.GetLocalPoint(c, this.localAnchorA);
    this.bodyB.GetLocalPoint(c, this.localAnchorB);
    this.bodyA.GetLocalVector(e, this.localAxisA)
};
goog.exportProperty(box2d.b2WheelJointDef.prototype, "Initialize", box2d.b2WheelJointDef.prototype.Initialize);
box2d.b2WheelJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_frequencyHz = a.frequencyHz;
    this.m_dampingRatio = a.dampingRatio;
    this.m_localAnchorA = a.localAnchorA.Clone();
    this.m_localAnchorB = a.localAnchorB.Clone();
    this.m_localXAxisA = a.localAxisA.Clone();
    this.m_localYAxisA = box2d.b2CrossOneV(this.m_localXAxisA, new box2d.b2Vec2);
    this.m_maxMotorTorque = a.maxMotorTorque;
    this.m_motorSpeed = a.motorSpeed;
    this.m_enableMotor = a.enableMotor;
    this.m_localCenterA = new box2d.b2Vec2;
    this.m_localCenterB = new box2d.b2Vec2;
    this.m_ax = new box2d.b2Vec2;
    this.m_ay = new box2d.b2Vec2;
    this.m_qA = new box2d.b2Rot;
    this.m_qB = new box2d.b2Rot;
    this.m_lalcA = new box2d.b2Vec2;
    this.m_lalcB = new box2d.b2Vec2;
    this.m_rA = new box2d.b2Vec2;
    this.m_rB = new box2d.b2Vec2;
    this.m_ax.SetZero();
    this.m_ay.SetZero()
};
goog.inherits(box2d.b2WheelJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2WheelJoint", box2d.b2WheelJoint);
box2d.b2WheelJoint.prototype.m_frequencyHz = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_frequencyHz", box2d.b2WheelJoint.prototype.m_frequencyHz);
box2d.b2WheelJoint.prototype.m_dampingRatio = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_dampingRatio", box2d.b2WheelJoint.prototype.m_dampingRatio);
box2d.b2WheelJoint.prototype.m_localAnchorA = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_localAnchorA", box2d.b2WheelJoint.prototype.m_localAnchorA);
box2d.b2WheelJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_localAnchorB", box2d.b2WheelJoint.prototype.m_localAnchorB);
box2d.b2WheelJoint.prototype.m_localXAxisA = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_localXAxisA", box2d.b2WheelJoint.prototype.m_localXAxisA);
box2d.b2WheelJoint.prototype.m_localYAxisA = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_localYAxisA", box2d.b2WheelJoint.prototype.m_localYAxisA);
box2d.b2WheelJoint.prototype.m_impulse = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_impulse", box2d.b2WheelJoint.prototype.m_impulse);
box2d.b2WheelJoint.prototype.m_motorImpulse = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_motorImpulse", box2d.b2WheelJoint.prototype.m_motorImpulse);
box2d.b2WheelJoint.prototype.m_springImpulse = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_springImpulse", box2d.b2WheelJoint.prototype.m_springImpulse);
box2d.b2WheelJoint.prototype.m_maxMotorTorque = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_maxMotorTorque", box2d.b2WheelJoint.prototype.m_maxMotorTorque);
box2d.b2WheelJoint.prototype.m_motorSpeed = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_motorSpeed", box2d.b2WheelJoint.prototype.m_motorSpeed);
box2d.b2WheelJoint.prototype.m_enableMotor = !1;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_enableMotor", box2d.b2WheelJoint.prototype.m_enableMotor);
box2d.b2WheelJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_indexA", box2d.b2WheelJoint.prototype.m_indexA);
box2d.b2WheelJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_indexB", box2d.b2WheelJoint.prototype.m_indexB);
box2d.b2WheelJoint.prototype.m_localCenterA = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_localCenterA", box2d.b2WheelJoint.prototype.m_localCenterA);
box2d.b2WheelJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_localCenterB", box2d.b2WheelJoint.prototype.m_localCenterB);
box2d.b2WheelJoint.prototype.m_invMassA = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_invMassA", box2d.b2WheelJoint.prototype.m_invMassA);
box2d.b2WheelJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_invMassB", box2d.b2WheelJoint.prototype.m_invMassB);
box2d.b2WheelJoint.prototype.m_invIA = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_invIA", box2d.b2WheelJoint.prototype.m_invIA);
box2d.b2WheelJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_invIB", box2d.b2WheelJoint.prototype.m_invIB);
box2d.b2WheelJoint.prototype.m_ax = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_ax", box2d.b2WheelJoint.prototype.m_ax);
box2d.b2WheelJoint.prototype.m_ay = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_ay", box2d.b2WheelJoint.prototype.m_ay);
box2d.b2WheelJoint.prototype.m_sAx = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_sAx", box2d.b2WheelJoint.prototype.m_sAx);
box2d.b2WheelJoint.prototype.m_sBx = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_sBx", box2d.b2WheelJoint.prototype.m_sBx);
box2d.b2WheelJoint.prototype.m_sAy = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_sAy", box2d.b2WheelJoint.prototype.m_sAy);
box2d.b2WheelJoint.prototype.m_sBy = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_sBy", box2d.b2WheelJoint.prototype.m_sBy);
box2d.b2WheelJoint.prototype.m_mass = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_mass", box2d.b2WheelJoint.prototype.m_mass);
box2d.b2WheelJoint.prototype.m_motorMass = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_motorMass", box2d.b2WheelJoint.prototype.m_motorMass);
box2d.b2WheelJoint.prototype.m_springMass = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_springMass", box2d.b2WheelJoint.prototype.m_springMass);
box2d.b2WheelJoint.prototype.m_bias = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_bias", box2d.b2WheelJoint.prototype.m_bias);
box2d.b2WheelJoint.prototype.m_gamma = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_gamma", box2d.b2WheelJoint.prototype.m_gamma);
box2d.b2WheelJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_qA", box2d.b2WheelJoint.prototype.m_qA);
box2d.b2WheelJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_qB", box2d.b2WheelJoint.prototype.m_qB);
box2d.b2WheelJoint.prototype.m_lalcA = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_lalcA", box2d.b2WheelJoint.prototype.m_lalcA);
box2d.b2WheelJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_lalcB", box2d.b2WheelJoint.prototype.m_lalcB);
box2d.b2WheelJoint.prototype.m_rA = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_rA", box2d.b2WheelJoint.prototype.m_rA);
box2d.b2WheelJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_rB", box2d.b2WheelJoint.prototype.m_rB);
box2d.b2WheelJoint.prototype.GetMotorSpeed = function() {
    return this.m_motorSpeed
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetMotorSpeed", box2d.b2WheelJoint.prototype.GetMotorSpeed);
box2d.b2WheelJoint.prototype.GetMaxMotorTorque = function() {
    return this.m_maxMotorTorque
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetMaxMotorTorque", box2d.b2WheelJoint.prototype.GetMaxMotorTorque);
box2d.b2WheelJoint.prototype.SetSpringFrequencyHz = function(a) {
    this.m_frequencyHz = a
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "SetSpringFrequencyHz", box2d.b2WheelJoint.prototype.SetSpringFrequencyHz);
box2d.b2WheelJoint.prototype.GetSpringFrequencyHz = function() {
    return this.m_frequencyHz
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetSpringFrequencyHz", box2d.b2WheelJoint.prototype.GetSpringFrequencyHz);
box2d.b2WheelJoint.prototype.SetSpringDampingRatio = function(a) {
    this.m_dampingRatio = a
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "SetSpringDampingRatio", box2d.b2WheelJoint.prototype.SetSpringDampingRatio);
box2d.b2WheelJoint.prototype.GetSpringDampingRatio = function() {
    return this.m_dampingRatio
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetSpringDampingRatio", box2d.b2WheelJoint.prototype.GetSpringDampingRatio);
box2d.b2WheelJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassA = this.m_bodyA.m_invMass;
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIA = this.m_bodyA.m_invI;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = this.m_invMassA, c = this.m_invMassB, e = this.m_invIA, d = this.m_invIB, f = a.positions[this.m_indexA].c,
            g = a.velocities[this.m_indexA].v, h = a.velocities[this.m_indexA].w, l = a.positions[this.m_indexB].c, k = a.positions[this.m_indexB].a, m = a.velocities[this.m_indexB].v, n = a.velocities[this.m_indexB].w, p = this.m_qA.SetAngleRadians(a.positions[this.m_indexA].a), q = this.m_qB.SetAngleRadians(k);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    k = box2d.b2MulRV(p, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    q = box2d.b2MulRV(q, this.m_lalcB, this.m_rB);
    f =
            box2d.b2SubVV(box2d.b2AddVV(l, q, box2d.b2Vec2.s_t0), box2d.b2AddVV(f, k, box2d.b2Vec2.s_t1), box2d.b2WheelJoint.prototype.InitVelocityConstraints.s_d);
    box2d.b2MulRV(p, this.m_localYAxisA, this.m_ay);
    this.m_sAy = box2d.b2CrossVV(box2d.b2AddVV(f, k, box2d.b2Vec2.s_t0), this.m_ay);
    this.m_sBy = box2d.b2CrossVV(q, this.m_ay);
    this.m_mass = b + c + e * this.m_sAy * this.m_sAy + d * this.m_sBy * this.m_sBy;
    0 < this.m_mass && (this.m_mass = 1 / this.m_mass);
    this.m_gamma = this.m_bias = this.m_springMass = 0;
    0 < this.m_frequencyHz ? (box2d.b2MulRV(p, this.m_localXAxisA,
            this.m_ax), this.m_sAx = box2d.b2CrossVV(box2d.b2AddVV(f, k, box2d.b2Vec2.s_t0), this.m_ax), this.m_sBx = box2d.b2CrossVV(q, this.m_ax), b = b + c + e * this.m_sAx * this.m_sAx + d * this.m_sBx * this.m_sBx, 0 < b && (this.m_springMass = 1 / b, c = box2d.b2DotVV(f, this.m_ax), p = 2 * box2d.b2_pi * this.m_frequencyHz, f = this.m_springMass * p * p, l = a.step.dt, this.m_gamma = l * (2 * this.m_springMass * this.m_dampingRatio * p + l * f), 0 < this.m_gamma && (this.m_gamma = 1 / this.m_gamma), this.m_bias = c * l * f * this.m_gamma, this.m_springMass = b + this.m_gamma, 0 < this.m_springMass &&
            (this.m_springMass = 1 / this.m_springMass))) : this.m_springImpulse = 0;
    this.m_enableMotor ? (this.m_motorMass = e + d, 0 < this.m_motorMass && (this.m_motorMass = 1 / this.m_motorMass)) : this.m_motorImpulse = this.m_motorMass = 0;
    a.step.warmStarting ? (this.m_impulse *= a.step.dtRatio, this.m_springImpulse *= a.step.dtRatio, this.m_motorImpulse *= a.step.dtRatio, e = box2d.b2AddVV(box2d.b2MulSV(this.m_impulse, this.m_ay, box2d.b2Vec2.s_t0), box2d.b2MulSV(this.m_springImpulse, this.m_ax, box2d.b2Vec2.s_t1), box2d.b2WheelJoint.prototype.InitVelocityConstraints.s_P),
            d = this.m_impulse * this.m_sAy + this.m_springImpulse * this.m_sAx + this.m_motorImpulse, b = this.m_impulse * this.m_sBy + this.m_springImpulse * this.m_sBx + this.m_motorImpulse, g.SelfMulSub(this.m_invMassA, e), h -= this.m_invIA * d, m.SelfMulAdd(this.m_invMassB, e), n += this.m_invIB * b) : this.m_motorImpulse = this.m_springImpulse = this.m_impulse = 0;
    a.velocities[this.m_indexA].w = h;
    a.velocities[this.m_indexB].w = n
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "InitVelocityConstraints", box2d.b2WheelJoint.prototype.InitVelocityConstraints);
box2d.b2WheelJoint.prototype.InitVelocityConstraints.s_d = new box2d.b2Vec2;
box2d.b2WheelJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2WheelJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = this.m_invMassA, c = this.m_invMassB, e = this.m_invIA, d = this.m_invIB, f = a.velocities[this.m_indexA].v, g = a.velocities[this.m_indexA].w, h = a.velocities[this.m_indexB].v, l = a.velocities[this.m_indexB].w, k = box2d.b2DotVV(this.m_ax, box2d.b2SubVV(h, f, box2d.b2Vec2.s_t0)) + this.m_sBx * l - this.m_sAx * g, k = -this.m_springMass * (k + this.m_bias + this.m_gamma * this.m_springImpulse);
    this.m_springImpulse += k;
    var m = box2d.b2MulSV(k, this.m_ax, box2d.b2WheelJoint.prototype.SolveVelocityConstraints.s_P),
            n = k * this.m_sAx, k = k * this.m_sBx;
    f.SelfMulSub(b, m);
    g -= e * n;
    h.SelfMulAdd(c, m);
    l += d * k;
    k = l - g - this.m_motorSpeed;
    k *= -this.m_motorMass;
    m = this.m_motorImpulse;
    n = a.step.dt * this.m_maxMotorTorque;
    this.m_motorImpulse = box2d.b2Clamp(this.m_motorImpulse + k, -n, n);
    k = this.m_motorImpulse - m;
    g -= e * k;
    l += d * k;
    k = box2d.b2DotVV(this.m_ay, box2d.b2SubVV(h, f, box2d.b2Vec2.s_t0)) + this.m_sBy * l - this.m_sAy * g;
    k *= -this.m_mass;
    this.m_impulse += k;
    m = box2d.b2MulSV(k, this.m_ay, box2d.b2WheelJoint.prototype.SolveVelocityConstraints.s_P);
    n = k * this.m_sAy;
    k *= this.m_sBy;
    f.SelfMulSub(b, m);
    g -= e * n;
    h.SelfMulAdd(c, m);
    a.velocities[this.m_indexA].w = g;
    a.velocities[this.m_indexB].w = l + d * k
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "SolveVelocityConstraints", box2d.b2WheelJoint.prototype.SolveVelocityConstraints);
box2d.b2WheelJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2WheelJoint.prototype.SolvePositionConstraints = function(a) {
    var b = a.positions[this.m_indexA].c, c = a.positions[this.m_indexA].a, e = a.positions[this.m_indexB].c, d = a.positions[this.m_indexB].a, f = this.m_qA.SetAngleRadians(c), g = this.m_qB.SetAngleRadians(d);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    var h = box2d.b2MulRV(f, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var g = box2d.b2MulRV(g, this.m_lalcB, this.m_rB), l = box2d.b2AddVV(box2d.b2SubVV(e,
            b, box2d.b2Vec2.s_t0), box2d.b2SubVV(g, h, box2d.b2Vec2.s_t1), box2d.b2WheelJoint.prototype.SolvePositionConstraints.s_d), f = box2d.b2MulRV(f, this.m_localYAxisA, this.m_ay), h = box2d.b2CrossVV(box2d.b2AddVV(l, h, box2d.b2Vec2.s_t0), f), g = box2d.b2CrossVV(g, f), l = box2d.b2DotVV(l, this.m_ay), k = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy, k = 0 != k ? -l / k : 0, f = box2d.b2MulSV(k, f, box2d.b2WheelJoint.prototype.SolvePositionConstraints.s_P), h = k * h, g = k * g;
    b.SelfMulSub(this.m_invMassA,
            f);
    c -= this.m_invIA * h;
    e.SelfMulAdd(this.m_invMassB, f);
    d += this.m_invIB * g;
    a.positions[this.m_indexA].a = c;
    a.positions[this.m_indexB].a = d;
    return box2d.b2Abs(l) <= box2d.b2_linearSlop
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "SolvePositionConstraints", box2d.b2WheelJoint.prototype.SolvePositionConstraints);
box2d.b2WheelJoint.prototype.SolvePositionConstraints.s_d = new box2d.b2Vec2;
box2d.b2WheelJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2;
box2d.b2WheelJoint.prototype.GetDefinition = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1);
    return a
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetDefinition", box2d.b2WheelJoint.prototype.GetDefinition);
box2d.b2WheelJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, a)
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetAnchorA", box2d.b2WheelJoint.prototype.GetAnchorA);
box2d.b2WheelJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetAnchorB", box2d.b2WheelJoint.prototype.GetAnchorB);
box2d.b2WheelJoint.prototype.GetReactionForce = function(a, b) {
    b.x = a * (this.m_impulse * this.m_ay.x + this.m_springImpulse * this.m_ax.x);
    b.y = a * (this.m_impulse * this.m_ay.y + this.m_springImpulse * this.m_ax.y);
    return b
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetReactionForce", box2d.b2WheelJoint.prototype.GetReactionForce);
box2d.b2WheelJoint.prototype.GetReactionTorque = function(a) {
    return a * this.m_motorImpulse
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetReactionTorque", box2d.b2WheelJoint.prototype.GetReactionTorque);
box2d.b2WheelJoint.prototype.GetLocalAnchorA = function(a) {
    return a.Copy(this.m_localAnchorA)
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetLocalAnchorA", box2d.b2WheelJoint.prototype.GetLocalAnchorA);
box2d.b2WheelJoint.prototype.GetLocalAnchorB = function(a) {
    return a.Copy(this.m_localAnchorB)
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetLocalAnchorB", box2d.b2WheelJoint.prototype.GetLocalAnchorB);
box2d.b2WheelJoint.prototype.GetLocalAxisA = function(a) {
    return a.Copy(this.m_localXAxisA)
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetLocalAxisA", box2d.b2WheelJoint.prototype.GetLocalAxisA);
box2d.b2WheelJoint.prototype.GetJointTranslation = function() {
    var a = this.m_bodyA, b = this.m_bodyB, c = a.GetWorldPoint(this.m_localAnchorA, new box2d.b2Vec2), b = b.GetWorldPoint(this.m_localAnchorB, new box2d.b2Vec2), c = box2d.b2SubVV(b, c, new box2d.b2Vec2), a = a.GetWorldVector(this.m_localXAxisA, new box2d.b2Vec2);
    return box2d.b2DotVV(c, a)
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetJointTranslation", box2d.b2WheelJoint.prototype.GetJointTranslation);
box2d.b2WheelJoint.prototype.GetJointSpeed = function() {
    return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetJointSpeed", box2d.b2WheelJoint.prototype.GetJointSpeed);
box2d.b2WheelJoint.prototype.IsMotorEnabled = function() {
    return this.m_enableMotor
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "IsMotorEnabled", box2d.b2WheelJoint.prototype.IsMotorEnabled);
box2d.b2WheelJoint.prototype.EnableMotor = function(a) {
    this.m_bodyA.SetAwake(!0);
    this.m_bodyB.SetAwake(!0);
    this.m_enableMotor = a
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "EnableMotor", box2d.b2WheelJoint.prototype.EnableMotor);
box2d.b2WheelJoint.prototype.SetMotorSpeed = function(a) {
    this.m_bodyA.SetAwake(!0);
    this.m_bodyB.SetAwake(!0);
    this.m_motorSpeed = a
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "SetMotorSpeed", box2d.b2WheelJoint.prototype.SetMotorSpeed);
box2d.b2WheelJoint.prototype.SetMaxMotorTorque = function(a) {
    this.m_bodyA.SetAwake(!0);
    this.m_bodyB.SetAwake(!0);
    this.m_maxMotorTorque = a
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "SetMaxMotorTorque", box2d.b2WheelJoint.prototype.SetMaxMotorTorque);
box2d.b2WheelJoint.prototype.GetMotorTorque = function(a) {
    return a * this.m_motorImpulse
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetMotorTorque", box2d.b2WheelJoint.prototype.GetMotorTorque);
box2d.b2WheelJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2WheelJointDef*/ var jd = new box2d.b2WheelJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
        box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n",
                this.m_localAnchorB.x, this.m_localAnchorB.y);
        box2d.b2Log("  jd.localAxisA.Set(%.15f, %.15f);\n", this.m_localXAxisA.x, this.m_localXAxisA.y);
        box2d.b2Log("  jd.enableMotor = %s;\n", this.m_enableMotor ? "true" : "false");
        box2d.b2Log("  jd.motorSpeed = %.15f;\n", this.m_motorSpeed);
        box2d.b2Log("  jd.maxMotorTorque = %.15f;\n", this.m_maxMotorTorque);
        box2d.b2Log("  jd.frequencyHz = %.15f;\n", this.m_frequencyHz);
        box2d.b2Log("  jd.dampingRatio = %.15f;\n", this.m_dampingRatio);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n",
                this.m_index)
    }
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "Dump", box2d.b2WheelJoint.prototype.Dump);
box2d.b2MotorJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_motorJoint);
    this.linearOffset = new box2d.b2Vec2(0, 0)
};
goog.inherits(box2d.b2MotorJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2MotorJointDef", box2d.b2MotorJointDef);
box2d.b2MotorJointDef.prototype.linearOffset = null;
goog.exportProperty(box2d.b2MotorJointDef.prototype, "linearOffset", box2d.b2MotorJointDef.prototype.linearOffset);
box2d.b2MotorJointDef.prototype.angularOffset = 0;
goog.exportProperty(box2d.b2MotorJointDef.prototype, "angularOffset", box2d.b2MotorJointDef.prototype.angularOffset);
box2d.b2MotorJointDef.prototype.maxForce = 1;
goog.exportProperty(box2d.b2MotorJointDef.prototype, "maxForce", box2d.b2MotorJointDef.prototype.maxForce);
box2d.b2MotorJointDef.prototype.maxTorque = 1;
goog.exportProperty(box2d.b2MotorJointDef.prototype, "maxTorque", box2d.b2MotorJointDef.prototype.maxTorque);
box2d.b2MotorJointDef.prototype.correctionFactor = 0.3;
goog.exportProperty(box2d.b2MotorJointDef.prototype, "correctionFactor", box2d.b2MotorJointDef.prototype.correctionFactor);
box2d.b2MotorJointDef.prototype.Initialize = function(a, b) {
    this.bodyA = a;
    this.bodyB = b;
    this.bodyA.GetLocalPoint(this.bodyB.GetPosition(), this.linearOffset);
    var c = this.bodyA.GetAngleRadians();
    this.angularOffset = this.bodyB.GetAngleRadians() - c
};
goog.exportProperty(box2d.b2MotorJointDef.prototype, "Initialize", box2d.b2MotorJointDef.prototype.Initialize);
box2d.b2MotorJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_linearOffset = a.linearOffset.Clone();
    this.m_linearImpulse = new box2d.b2Vec2(0, 0);
    this.m_maxForce = a.maxForce;
    this.m_maxTorque = a.maxTorque;
    this.m_correctionFactor = a.correctionFactor;
    this.m_rA = new box2d.b2Vec2(0, 0);
    this.m_rB = new box2d.b2Vec2(0, 0);
    this.m_localCenterA = new box2d.b2Vec2(0, 0);
    this.m_localCenterB = new box2d.b2Vec2(0, 0);
    this.m_linearError = new box2d.b2Vec2(0, 0);
    this.m_linearMass = new box2d.b2Mat22;
    this.m_qA = new box2d.b2Rot;
    this.m_qB =
            new box2d.b2Rot;
    this.m_K = new box2d.b2Mat22
};
goog.inherits(box2d.b2MotorJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2MotorJoint", box2d.b2MotorJoint);
box2d.b2MotorJoint.prototype.m_linearOffset = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_linearOffset", box2d.b2MotorJoint.prototype.m_linearOffset);
box2d.b2MotorJoint.prototype.m_angularOffset = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_angularOffset", box2d.b2MotorJoint.prototype.m_angularOffset);
box2d.b2MotorJoint.prototype.m_linearImpulse = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_linearImpulse", box2d.b2MotorJoint.prototype.m_linearImpulse);
box2d.b2MotorJoint.prototype.m_angularImpulse = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_angularImpulse", box2d.b2MotorJoint.prototype.m_angularImpulse);
box2d.b2MotorJoint.prototype.m_maxForce = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_maxForce", box2d.b2MotorJoint.prototype.m_maxForce);
box2d.b2MotorJoint.prototype.m_maxTorque = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_maxTorque", box2d.b2MotorJoint.prototype.m_maxTorque);
box2d.b2MotorJoint.prototype.m_correctionFactor = 0.3;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_correctionFactor", box2d.b2MotorJoint.prototype.m_correctionFactor);
box2d.b2MotorJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_indexA", box2d.b2MotorJoint.prototype.m_indexA);
box2d.b2MotorJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_indexB", box2d.b2MotorJoint.prototype.m_indexB);
box2d.b2MotorJoint.prototype.m_rA = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_rA", box2d.b2MotorJoint.prototype.m_rA);
box2d.b2MotorJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_rB", box2d.b2MotorJoint.prototype.m_rB);
box2d.b2MotorJoint.prototype.m_localCenterA = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_localCenterA", box2d.b2MotorJoint.prototype.m_localCenterA);
box2d.b2MotorJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_localCenterB", box2d.b2MotorJoint.prototype.m_localCenterB);
box2d.b2MotorJoint.prototype.m_linearError = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_linearError", box2d.b2MotorJoint.prototype.m_linearError);
box2d.b2MotorJoint.prototype.m_angularError = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_angularError", box2d.b2MotorJoint.prototype.m_angularError);
box2d.b2MotorJoint.prototype.m_invMassA = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_invMassA", box2d.b2MotorJoint.prototype.m_invMassA);
box2d.b2MotorJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_invMassB", box2d.b2MotorJoint.prototype.m_invMassB);
box2d.b2MotorJoint.prototype.m_invIA = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_invIA", box2d.b2MotorJoint.prototype.m_invIA);
box2d.b2MotorJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_invIB", box2d.b2MotorJoint.prototype.m_invIB);
box2d.b2MotorJoint.prototype.m_linearMass = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_linearMass", box2d.b2MotorJoint.prototype.m_linearMass);
box2d.b2MotorJoint.prototype.m_angularMass = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_angularMass", box2d.b2MotorJoint.prototype.m_angularMass);
box2d.b2MotorJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_qA", box2d.b2MotorJoint.prototype.m_qA);
box2d.b2MotorJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_qB", box2d.b2MotorJoint.prototype.m_qB);
box2d.b2MotorJoint.prototype.m_K = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_K", box2d.b2MotorJoint.prototype.m_K);
box2d.b2MotorJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetPosition(a)
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "GetAnchorA", box2d.b2MotorJoint.prototype.GetAnchorA);
box2d.b2MotorJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetPosition(a)
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "GetAnchorB", box2d.b2MotorJoint.prototype.GetAnchorB);
box2d.b2MotorJoint.prototype.GetReactionForce = function(a, b) {
    return box2d.b2MulSV(a, this.m_linearImpulse, b)
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "GetReactionForce", box2d.b2MotorJoint.prototype.GetReactionForce);
box2d.b2MotorJoint.prototype.GetReactionTorque = function(a) {
    return a * this.m_angularImpulse
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "GetReactionTorque", box2d.b2MotorJoint.prototype.GetReactionTorque);
box2d.b2MotorJoint.prototype.SetLinearOffset = function(a) {
    box2d.b2IsEqualToV(a, this.m_linearOffset) || (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_linearOffset.Copy(a))
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "SetLinearOffset", box2d.b2MotorJoint.prototype.SetLinearOffset);
box2d.b2MotorJoint.prototype.GetLinearOffset = function(a) {
    return a.Copy(this.m_linearOffset)
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "GetLinearOffset", box2d.b2MotorJoint.prototype.GetLinearOffset);
box2d.b2MotorJoint.prototype.SetAngularOffset = function(a) {
    a != this.m_angularOffset && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_angularOffset = a)
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "SetAngularOffset", box2d.b2MotorJoint.prototype.SetAngularOffset);
box2d.b2MotorJoint.prototype.GetAngularOffset = function() {
    return this.m_angularOffset
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "GetAngularOffset", box2d.b2MotorJoint.prototype.GetAngularOffset);
box2d.b2MotorJoint.prototype.SetMaxForce = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a) && 0 <= a);
    this.m_maxForce = a
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "SetMaxForce", box2d.b2MotorJoint.prototype.SetMaxForce);
box2d.b2MotorJoint.prototype.GetMaxForce = function() {
    return this.m_maxForce
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "GetMaxForce", box2d.b2MotorJoint.prototype.GetMaxForce);
box2d.b2MotorJoint.prototype.SetMaxTorque = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a) && 0 <= a);
    this.m_maxTorque = a
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "SetMaxTorque", box2d.b2MotorJoint.prototype.SetMaxTorque);
box2d.b2MotorJoint.prototype.GetMaxTorque = function() {
    return this.m_maxTorque
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "GetMaxTorque", box2d.b2MotorJoint.prototype.GetMaxTorque);
box2d.b2MotorJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassA = this.m_bodyA.m_invMass;
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIA = this.m_bodyA.m_invI;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = a.positions[this.m_indexA].c, c = a.positions[this.m_indexA].a, e = a.velocities[this.m_indexA].v,
            d = a.velocities[this.m_indexA].w, f = a.positions[this.m_indexB].c, g = a.positions[this.m_indexB].a, h = a.velocities[this.m_indexB].v, l = a.velocities[this.m_indexB].w, k = this.m_qA.SetAngleRadians(c), m = this.m_qB.SetAngleRadians(g), n = box2d.b2MulRV(k, box2d.b2NegV(this.m_localCenterA, box2d.b2Vec2.s_t0), this.m_rA), m = box2d.b2MulRV(m, box2d.b2NegV(this.m_localCenterB, box2d.b2Vec2.s_t0), this.m_rB), p = this.m_invMassA, q = this.m_invMassB, r = this.m_invIA, t = this.m_invIB, s = this.m_K;
    s.ex.x = p + q + r * n.y * n.y + t * m.y * m.y;
    s.ex.y = -r * n.x *
            n.y - t * m.x * m.y;
    s.ey.x = s.ex.y;
    s.ey.y = p + q + r * n.x * n.x + t * m.x * m.x;
    s.GetInverse(this.m_linearMass);
    this.m_angularMass = r + t;
    0 < this.m_angularMass && (this.m_angularMass = 1 / this.m_angularMass);
    box2d.b2SubVV(box2d.b2SubVV(box2d.b2AddVV(f, m, box2d.b2Vec2.s_t0), box2d.b2AddVV(b, n, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t2), box2d.b2MulRV(k, this.m_linearOffset, box2d.b2Vec2.s_t3), this.m_linearError);
    this.m_angularError = g - c - this.m_angularOffset;
    a.step.warmStarting ? (this.m_linearImpulse.SelfMul(a.step.dtRatio), this.m_angularImpulse *=
            a.step.dtRatio, b = this.m_linearImpulse, e.SelfMulSub(p, b), d -= r * (box2d.b2CrossVV(n, b) + this.m_angularImpulse), h.SelfMulAdd(q, b), l += t * (box2d.b2CrossVV(m, b) + this.m_angularImpulse)) : (this.m_linearImpulse.SetZero(), this.m_angularImpulse = 0);
    a.velocities[this.m_indexA].w = d;
    a.velocities[this.m_indexB].w = l
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "InitVelocityConstraints", box2d.b2MotorJoint.prototype.InitVelocityConstraints);
box2d.b2MotorJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.velocities[this.m_indexB].v, d = a.velocities[this.m_indexB].w, f = this.m_invMassA, g = this.m_invMassB, h = this.m_invIA, l = this.m_invIB, k = a.step.dt, m = a.step.inv_dt, n = d - c + m * this.m_correctionFactor * this.m_angularError, n = -this.m_angularMass * n, p = this.m_angularImpulse, q = k * this.m_maxTorque;
    this.m_angularImpulse = box2d.b2Clamp(this.m_angularImpulse + n, -q, q);
    var n = this.m_angularImpulse -
            p, c = c - h * n, d = d + l * n, r = this.m_rA, t = this.m_rB, n = box2d.b2AddVV(box2d.b2SubVV(box2d.b2AddVV(e, box2d.b2CrossSV(d, t, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), box2d.b2AddVV(b, box2d.b2CrossSV(c, r, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t2), box2d.b2MulSV(m * this.m_correctionFactor, this.m_linearError, box2d.b2Vec2.s_t3), box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_Cdot), n = box2d.b2MulMV(this.m_linearMass, n, box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_impulse).SelfNeg(), p = box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_oldImpulse.Copy(this.m_linearImpulse);
    this.m_linearImpulse.SelfAdd(n);
    q = k * this.m_maxForce;
    this.m_linearImpulse.GetLengthSquared() > q * q && (this.m_linearImpulse.Normalize(), this.m_linearImpulse.SelfMul(q));
    box2d.b2SubVV(this.m_linearImpulse, p, n);
    b.SelfMulSub(f, n);
    c -= h * box2d.b2CrossVV(r, n);
    e.SelfMulAdd(g, n);
    d += l * box2d.b2CrossVV(t, n);
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = d
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "SolveVelocityConstraints", box2d.b2MotorJoint.prototype.SolveVelocityConstraints);
box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2;
box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_impulse = new box2d.b2Vec2;
box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_oldImpulse = new box2d.b2Vec2;
box2d.b2MotorJoint.prototype.SolvePositionConstraints = function(a) {
    return!0
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "SolvePositionConstraints", box2d.b2MotorJoint.prototype.SolvePositionConstraints);
box2d.b2MotorJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2MotorJointDef*/ var jd = new box2d.b2MotorJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.linearOffset.SetXY(%.15f, %.15f);\n", this.m_linearOffset.x, this.m_linearOffset.y);
        box2d.b2Log("  jd.angularOffset = %.15f;\n",
                this.m_angularOffset);
        box2d.b2Log("  jd.maxForce = %.15f;\n", this.m_maxForce);
        box2d.b2Log("  jd.maxTorque = %.15f;\n", this.m_maxTorque);
        box2d.b2Log("  jd.correctionFactor = %.15f;\n", this.m_correctionFactor);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "Dump", box2d.b2MotorJoint.prototype.Dump);
/*
* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.Render');

//goog.require('box2d');

//goog.require('goog.string.format');

/** 
 * This class implements debug drawing callbacks that are 
 * invoked inside b2World::Step. 
 * @export 
 * @constructor
 * @extends {box2d.b2Draw} 
 * @param {object} opts
 */
box2d.b2DebugDraw = function (opts)
{
	goog.base(this);

    this.scale = opts.scale
	this.m_canvas = opts.canvas || false
	this.m_ctx = opts.ctx ||¬†false
    this.m_settings = opts.flags || box2d.b2DrawFlags.e_shapeBit
    this.alpha = opts.alpha || 0.5
}

goog.inherits(box2d.b2DebugDraw, box2d.b2Draw);

/**
 * @export 
 * @type {HTMLCanvasElement} 
 */
box2d.b2DebugDraw.prototype.m_canvas = null;
/**
 * @export 
 * @type {CanvasRenderingContext2D} 
 */
box2d.b2DebugDraw.prototype.m_ctx = null;
/**
 * @export 
 * @type {box2d.Settings} 
 */
box2d.b2DebugDraw.prototype.m_settings = null;

box2d.b2DebugDraw.prototype.scale = 40;
box2d.b2DebugDraw.prototype.alpha = 0.5;


/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Transform} xf 
 */
box2d.b2DebugDraw.prototype.PushTransform = function (xf)
{
	var ctx = this.m_ctx;
	ctx.save();
    ctx.globalAlpha = this.alpha
	ctx.translate(xf.p.x * this.scale, xf.p.y * this.scale);
	ctx.rotate(xf.q.GetAngleRadians());
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Transform} xf 
 */
box2d.b2DebugDraw.prototype.PopTransform = function (xf)
{
	var ctx = this.m_ctx;
	ctx.restore();
}

/**
 * @export 
 * @return {void} 
 * @param {Array.<box2d.b2Vec2>} vertices 
 * @param {number} vertexCount 
 * @param {box2d.b2Color} color 
 */
box2d.b2DebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color)
{
	if (!vertexCount) return;

	var ctx = this.m_ctx;

	ctx.beginPath();
	ctx.moveTo(vertices[0].x, vertices[0].y);
	for (var i = 1; i < vertexCount; i++)
	{
		ctx.lineTo(vertices[i].x * this.scale, vertices[i].y * this.scale);
	}
	ctx.closePath();
	ctx.strokeStyle = color.MakeStyleString(1);
	ctx.stroke();
};

/**
 * @export 
 * @return {void} 
 * @param {Array.<box2d.b2Vec2>} vertices 
 * @param {number} vertexCount 
 * @param {box2d.b2Color} color 
 */
box2d.b2DebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color)
{
    if (!vertexCount) return;

	var ctx = this.m_ctx;

	ctx.beginPath();
	ctx.moveTo(vertices[0].x * this.scale, vertices[0].y * this.scale);
	for (var i = 1; i < vertexCount; i++)
	{
		ctx.lineTo(vertices[i].x * this.scale, vertices[i].y * this.scale);
	}
	ctx.closePath();
	ctx.fillStyle = color.MakeStyleString(0.5);
	ctx.fill();
	ctx.strokeStyle = color.MakeStyleString(1);
	ctx.stroke();
};

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} center 
 * @param {number} radius 
 * @param {box2d.b2Color} color 
 */
box2d.b2DebugDraw.prototype.DrawCircle = function (center, radius, color)
{
    if (!radius) return;

	var ctx = this.m_ctx;

	ctx.beginPath();
	ctx.arc(center.x * this.scale, center.y * this.scale, radius * this.scale, 0, box2d.b2_pi * 2, true);
	ctx.strokeStyle = color.MakeStyleString(1);
	ctx.stroke();
};

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} center 
 * @param {number} radius 
 * @param {box2d.b2Vec2} axis 
 * @param {box2d.b2Color} color 
 */
box2d.b2DebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color)
{
	if (!radius) return;

	var ctx = this.m_ctx;

	var cx = center.x * this.scale;
	var cy = center.y * this.scale;
	ctx.beginPath();
	ctx.arc(cx, cy, radius, 0, box2d.b2_pi * 2, true);
	ctx.moveTo(cx, cy);
	ctx.lineTo((cx + axis.x * this.scale * radius), (cy + axis.y * this.scale * radius));
	ctx.fillStyle = color.MakeStyleString(0.5);
	ctx.fill();
	ctx.strokeStyle = color.MakeStyleString(1);
	ctx.stroke();
};

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} p1 
 * @param {box2d.b2Vec2} p2 
 * @param {box2d.b2Color} color 
 */
box2d.b2DebugDraw.prototype.DrawSegment = function (p1, p2, color)
{
	var ctx = this.m_ctx;

	ctx.beginPath();
	ctx.moveTo(p1.x * this.scale, p1.y * this.scale);
	ctx.lineTo(p2.x * this.scale, p2.y * this.scale);
	ctx.strokeStyle = color.MakeStyleString(1);
	ctx.stroke();
};

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Transform} xf 
 */
box2d.b2DebugDraw.prototype.DrawTransform = function (xf)
{
	var ctx = this.m_ctx;

	this.PushTransform(xf);

	ctx.beginPath();
	ctx.moveTo(0, 0);
	ctx.lineTo(1, 0);
	ctx.strokeStyle = box2d.b2Color.RED.MakeStyleString(1);
	ctx.stroke();

	ctx.beginPath();
	ctx.moveTo(0, 0);
	ctx.lineTo(0, 1);
	ctx.strokeStyle = box2d.b2Color.GREEN.MakeStyleString(1);
	ctx.stroke();

	this.PopTransform(xf);
};

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} p 
 * @param {number} size 
 * @param {box2d.b2Color} color 
 */
box2d.b2DebugDraw.prototype.DrawPoint = function (p, size, color)
{
	var ctx = this.m_ctx;

	ctx.fillStyle = color.MakeStyleString();
	size /= this.m_settings.viewZoom;
	size /= this.m_settings.canvasScale;
	var hsize = size / 2;
	ctx.fillRect(p.x * this.scale - hsize, p.y * this.scale - hsize, size, size);
}

/**
 * @export 
 * @param {number} x 
 * @param {number} y 
 * @param {string} format
 * @param {...string|number} var_args 
 */
box2d.b2DebugDraw.prototype.DrawString = function (x, y, format, var_args)
{
	var ctx = this.m_ctx;

	var args = Array.prototype.slice.call(arguments);
	var string = goog.string.format.apply(null, args.slice(2));

	ctx.save();
		ctx.setTransform(1, 0, 0, 1, 0, 0);
		ctx.font = '18pt helvetica';//'9pt lucida console';
		var color = box2d.b2DebugDraw.prototype.DrawString.s_color;
		ctx.fillStyle = color.MakeStyleString();
		ctx.fillText(string, x * this.scale, y * this.scale);
	ctx.restore();
}
box2d.b2DebugDraw.prototype.DrawString.s_color = new box2d.b2Color(0.9, 0.6, 0.6);

/**
 * @export 
 * @param {number} x 
 * @param {number} y 
 * @param {string} format
 * @param {...string|number} var_args 
 */
box2d.b2DebugDraw.prototype.DrawStringWorld = function (x, y, format, var_args)
{
	var p = box2d.b2DebugDraw.prototype.DrawStringWorld.s_p.SetXY(x, y);

	// world -> viewport
	var vt = this.m_settings.viewCenter;
	box2d.b2SubVV(p, vt, p);
	var vr = this.m_settings.viewRotation;
	box2d.b2MulTRV(vr, p, p);
	var vs = this.m_settings.viewZoom;
	box2d.b2MulSV(vs, p, p);

	// viewport -> canvas
	var cs = this.m_settings.canvasScale;
	box2d.b2MulSV(cs, p, p);
	p.y *= -1;
	var cc = box2d.b2DebugDraw.prototype.DrawStringWorld.s_cc.SetXY(0.5 * this.m_canvas.width, 0.5 * this.m_canvas.height);
	box2d.b2AddVV(p, cc, p);

	var ctx = this.m_ctx;

	var args = Array.prototype.slice.call(arguments);
	var string = goog.string.format.apply(null, args.slice(2));

	ctx.save();
		ctx.setTransform(1, 0, 0, 1, 0, 0);
		ctx.font = '18pt helvetica';//'9pt lucida console';
		var color = box2d.b2DebugDraw.prototype.DrawStringWorld.s_color;
		ctx.fillStyle = color.MakeStyleString();
		ctx.fillText(string, p.x * this.scale, p.y * this.scale);
	ctx.restore();
}
box2d.b2DebugDraw.prototype.DrawStringWorld.s_p = new box2d.b2Vec2();
box2d.b2DebugDraw.prototype.DrawStringWorld.s_cc = new box2d.b2Vec2();
box2d.b2DebugDraw.prototype.DrawStringWorld.s_color = new box2d.b2Color(0.5, 0.9, 0.5);

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2AABB} aabb 
 * @param {box2d.b2Color} color 
 */
box2d.b2DebugDraw.prototype.DrawAABB = function (aabb, color)
{
	var ctx = this.m_ctx;

	ctx.strokeStyle = color.MakeStyleString();
	var x = aabb.lowerBound.x;
	var y = aabb.lowerBound.y;
	var w = aabb.upperBound.x - aabb.lowerBound.x;
	var h = aabb.upperBound.y - aabb.lowerBound.y;
	ctx.strokeRect(x * this.scale, y * this.scale, w * this.scale, h * this.scale);
}

box2d.b2DebugDraw.prototype.SetFlags = function (flags) {
    this.m_settings = flags
}

box2d.b2DebugDraw.prototype.GetFlags = function () {
    return this.m_settings
}
//'remove' namespace for less code writing ;o)
var b2AABB = box2d.b2AABB,
    b2Body = box2d.b2Body,
    b2BodyDef = box2d.b2BodyDef,
    b2ChainShape = box2d.b2ChainShape,
    b2CircleShape = box2d.b2CircleShape,
    b2ContactListener = box2d.b2ContactListener,
    b2DebugDraw = box2d.b2DebugDraw,
    b2EdgeChainDef = box2d.b2EdgeChainDef,
    b2EdgeShape = box2d.b2EdgeShape,
    b2Fixture = box2d.b2Fixture,
    b2FixtureDef = box2d.b2FixtureDef,
    b2Joint = box2d.b2Joint,
    b2MassData = box2d.b2MassData,
    b2Mat22 = box2d.b2Mat22,
    b2MouseJointDef = box2d.b2MouseJointDef,
    b2PolygonShape = box2d.b2PolygonShape,
    b2PrismaticJointDef = box2d.b2PrismaticJointDef,
    b2RevoluteJointDef = box2d.b2RevoluteJointDef,
    b2Settings = box2d.b2Settings,
    b2Shape = box2d.b2Shape,
    b2World = box2d.b2World,
    b2WorldManifold = box2d.b2WorldManifold,
    b2Vec2 = box2d.b2Vec2/**
 *  ¬© 2012 by Christian Sonntag <info@motions-media.de>
 *  simple experimental Canvas Game JavaScript Framework
 */


/**
 * @description
 *
 * B2DEntity is the base class with properties for all B2D objects.
 * This class handles also the drawings for all classes.
 *
 * @class CG.B2DEntity
 * @extends CG.Entity
 */

CG.Entity.extend('B2DEntity', {
    /**
     * @method init
     * @constructor
     * @param name      {String}      id or name to identify
     * @param image     {mixed}       path to image, image or atlasimage from asset
     * @param world     {object}      reference to world of B2DWorld
     * @param x         {Number}     the x position
     * @param y         {Number}     the y position
     * @param scale     {Number}     the world scale of B2DWorld
     * @return {*}
     */

    init:function (name, image, world, x, y, scale) {
        this._super()
        this.setImage(image)
        /**
         * @property body
         * @type {b2Body}
         */
        this.body = {}
        /**
         * @property x
         * @type {Number}
         */
        this.x = x
        /**
         * @property y
         * @type {Number}
         */
        this.y = y
        /**
         * @property scale
         * @type {Number}
         */
        this.scale = scale
        /**
         * @property id
         * @type {Object}
         */
        this.id = {name:name, uid:0}
        /**
         * @property world
         * @type {b2World}
         */
        this.world = world
        /**
         * @property xhandle
         * @type {Number}
         */
        this.xhandle = (this.width / 2)
        /**
         * @property yhandle
         * @type {Number}
         */
        this.yhandle = (this.height / 2)
        if(!this.bodyDef){
            /**
             * @property bodyDef
             * @type {b2BodyDef}
             */
            this.bodyDef = new b2BodyDef
            /**
             * @property bodyDef.alowSleep
             * @type {Boolean}
             */
            this.bodyDef.allowSleep = true
            /**
             * @property bodyDef.awake
             * @type {Boolean}
             */
            this.bodyDef.awake = true
        }

        if(!this.fixDef) {
            /**
             * @property fixDef
             * @type {b2FixtureDef}
             */
            this.fixDef = new b2FixtureDef
            /**
             * @property fixDef.density
             * @type {Number}
             */
            this.fixDef.density = 1.0
            /**
             * @property fixDef.friction
             * @type {Number}
             */
            this.fixDef.friction = 0.5
            /**
             * @property fixDef.restitution
             * @type {Number}
             */
            this.fixDef.restitution = 0.5
        }
        /**
         * @property isHit
         * @type {Boolean}
         */
        this.isHit = false;
        /**
         * @property strength
         * @type {Number}
         */
        this.strength = 100;
        /**
         * @property dead
         * @type {Boolean}
         */
        this.dead = false;

        return this
    },
    /**
     * @method hit
     * @param impulse
     * @param source
     */
    hit:function (impulse, source) {
        this.isHit = true;
        if (this.strength) {
            this.strength -= impulse;
            if (this.strength <= 0) {
                this.dead = true
            }
        }
    },
    update:function () {
    },
    draw:function () {
        Game.b_ctx.save()
        Game.b_ctx.globalAlpha = this.alpha
        Game.b_ctx.translate(this.body.GetPosition().x * this.scale, this.body.GetPosition().y * this.scale)
        if (this.atlasimage) {
            Game.b_ctx.rotate((this.body.GetAngleRadians() - this.imagerotation)) // * CG.Const_PI_180)
            Game.b_ctx.drawImage(this.image, this.xoffset, this.yoffset, this.cutwidth, this.cutheight, 0 - this.xhandle, 0 - this.yhandle, this.cutwidth, this.cutheight)
        } else {
            Game.b_ctx.rotate(this.body.GetAngleRadians()) // * CG.Const_PI_180)
            Game.b_ctx.drawImage(this.image, 0 - this.xhandle, 0 - this.yhandle, this.image.width, this.image.height)
        }
        Game.b_ctx.restore()
    }
})


/**
 *  ¬© 2012 by Christian Sonntag <info@motions-media.de>
 *  simple experimental Canvas Game JavaScript Framework
 */


/**
 * @description
 *
 * B2DCircle is a simple b2CircleShape wrapper element with basic physics properties.
 *
 * @class CG.B2DCirlce
 * @extends CG.B2DEntity
 */

CG.B2DEntity.extend('B2DCircle', {
    /**
     * @method init
     * @constructor
     * @param world     {Object}      reference to world of B2DWorld
     * @param name      {String}      id or name to identify
     * @param image     {mixed}       path to image, image or atlasimage from asset
     * @param radius    {Number}     json file from PhysicsEditor from asset
     * @param x         {Number}     the x position
     * @param y         {Number}     the y position
     * @param scale     {Number}     the world scale of B2DWorld
     * @param b2BodyType      {box2d.b2BodyType}     Box2D bodytype constant
     * @return {*}
     */
    init:function (world, name, image, radius, x, y, scale, b2BodyType) {
        this._super(name, image, world, x, y, scale)
        /**
         * @property radius
         * @type {Number}
         */
        this.radius = this.width / 2
        /**
         * @property bodyDef.type
         * @type {box2d.b2BodyType.b2_staticBody/box2d.b2BodyType.b2_dynamicBody/box2d.b2BodyType.b2_kinematicBody/box2d.b2BodyType.b2_bulletBody}
         */
        this.bodyDef.type = b2BodyType || box2d.b2BodyType.b2_staticBody

        /**
         * @property bodyDef.position.x
         * @type {Number}
         */
        this.bodyDef.position.x = this.x / this.scale
        /**
         * @property bodyDef.position.y
         * @type {Number}
         */
        this.bodyDef.position.y = this.y / this.scale
        /**
         * @property bdyDef.userData
         * @type {*}
         */
        this.bodyDef.userData = this.id
        /**
         * @property fixDef.shape
         * @type {b2CircleShape}
         */
        this.fixDef.shape = new b2CircleShape(this.radius / this.scale)

        /**
         * @property body
         * @type {b2Body}
         */
        this.body = this.world.CreateBody(this.bodyDef)
        this.body.CreateFixture(this.fixDef)

        return this

    }
})


/**
 *  ¬© 2012 by Christian Sonntag <info@motions-media.de>
 *  simple experimental Canvas Game JavaScript Framework
 */


/**
 * @description
 *
 * B2DLine is a simple b2PolygonShape wrapper. There is no visible drawing
 * now in the canvas for now. It can be used to build walls, ground,. ,.
 *
 * @class CG.B2DLine
 * @extends CG.B2DEntity
 */

CG.B2DEntity.extend('B2DLine', {
    /**
     * @method init
     * @constructor
     * @param world     {Object}      reference to world of B2DWorld
     * @param name      {String}      id or name to identify
     * @param start     {b2Vec2}      start of line
     * @param end       {b2Vec2}      end of line
     * @param scale     {Number}     the world scale of B2DWorld
     * @return {*}
     */
    init:function (world, name, start, end, scale) {
        this._super(name, false, world, 0, 0, scale) //TODO clean arguments?
        /**
         * @property start
         * @type {b2Vec2}
         */
        this.start = start
        /**
         * @property end
         * @type {b2Vec2}
         */
        this.end = end
        /**
         * @property xhandle
         * @type {Number}
         */
        this.xhandle = 0
        /**
         * @property yhandle
         * @type {Number}
         */
        this.yhandle = 0
        /**
         * @property fixDef.shape
         * @type {b2PolygonShape}
         */
        this.fixDef.shape = new b2EdgeShape()
        this.fixDef.shape.Set(this.start, this.end)
        /**
         * @property bodyDef.type
         * @type {Number}
         */
        this.bodyDef.type = box2d.b2BodyType.b2_staticBody
        /**
         * @property bodyDef.position
         */
        this.bodyDef.position.SetXY(0 / this.scale, 0 / this.scale)
        /**
         * @property bodyDef.userData
         * @type {*}
         */
        this.bodyDef.userData = this.id
        /**
         * @property body
         * @type {b2Body}
         */
        this.body = this.world.CreateBody(this.bodyDef)
        this.body.CreateFixture(this.fixDef)

        return this
    },
    update:function () {

    },
    draw:function () {

    }
})


/**
 *  ¬© 2012 by Christian Sonntag <info@motions-media.de>
 *  simple experimental Canvas Game JavaScript Framework
 */


/**
 * @description
 *
 * B2DRectangle is a simple b2PolygonShape wrapper element with basic physics properties.
 *
 * @class CG.B2DRectangle
 * @extends CG.B2DEntity
 */

CG.B2DEntity.extend('B2DRectangle', {
    /**
     * @method init
     * @constructor
     * @param world     {Object}      reference to world of B2DWorld
     * @param name      {String}      id or name to identify
     * @param image     {mixed}     path to image, image or atlasimage from asset
     * @param x         {Number}     the x position
     * @param y         {Number}     the y position
     * @param scale     {Number}     the world scale of B2DWorld
     * @param b2BodyType      {box2d.b2BodyType}     Box2D bodytype constant
     * @return {*}
     */
    init:function (world, name, image, x, y, scale, b2BodyType) {
        this._super(name, image, world, x, y, scale)

        /**
         * @property bodyDef.stat
         * @type {box2d.b2BodyType.b2_staticBody/box2d.b2BodyType.b2_dynamicBody/box2d.b2BodyType.b2_kinematicBody/box2d.b2BodyType.b2_bulletBody}
         */
        this.bodyDef.type = b2BodyType || box2d.b2BodyType.b2_staticBody

        /**
         * @property fixDef.shape
         * @type {b2PolygonShape}
         */
        this.fixDef.shape = new b2PolygonShape
        this.fixDef.shape.SetAsBox(this.width / scale * 0.5, this.height / scale * 0.5)
        /**
         * @property bodyDef.position.x
         * @type {Number}
         */
        this.bodyDef.position.x = this.x / this.scale
        /**
         * @property bodyDef.position.y
         * @type {Number}
         */
        this.bodyDef.position.y = this.y / this.scale
        /**
         * @property bodyDef.userData
         * @type {*}
         */
        this.bodyDef.userData = this.id
        /**
         * @property body
         * @type {b2Body}
         */
        this.body = this.world.CreateBody(this.bodyDef)
        this.body.CreateFixture(this.fixDef)

        return this
    }
})


/**
 *  ¬© 2012 by Christian Sonntag <info@motions-media.de>
 *  simple experimental Canvas Game JavaScript Framework
 */


/**
 * @description
 *
 * B2DPolygon  is a simple b2PolygonShape wrapper element with basic physics properties.
 * It uses PhysicsEditor json files, use export Lime + Corona (json).
 * Supported options for now are friction, density and bounce and would be set to B2DPolygon.
 *
 * @class CG.B2DPolygon
 * @extends CG.B2DEntity
 */

CG.B2DEntity.extend('B2DPolygon', {
    /**
     * @method init
     * @constructor
     * @param world     {Object}      reference to world of B2DWorld
     * @param name      {String}      id or name to identify
     * @param image     {mixed}       path to image, image or atlasimage from asset
     * @param jsonpoly  {string}      json file from PhysicsEditor from asset
     * @param x         {Number}     the x position
     * @param y         {Number}     the y position
     * @param scale     {Number}     the world scale of B2DWorld
     * @param b2BodyType      {box2d.b2BodyType}     Box2D bodytype constant
     * @param bullet    {Boolean}     bullet option
     * @return {*}
     */
    init:function (world, name, image, jsonpoly, x, y, scale, b2BodyType, bullet) {
        this._super(name, image, world, x, y, scale)
        /**
         * @property polys
         * @type {Array}
         */
        this.polys = new Array()
        /**
         * @property jsondata
         * @type {*}
         */
//        this.jsondata = jsonpoly.data[jsonpoly.name]
        this.jsondata = jsonpoly.data[name]
        /**
         * @property xhandle
          * @type {Number}
         */
        this.xhandle = 0
        /**
         * @property yhandle
         * @type {Number}
         */
        this.yhandle = 0
        /**
         * @property vecs
         * @type {Array}
         */
        this.vecs = new Array()
        this.vecs = this.getPolysFromJson(jsonpoly) // build grouped b2vecs from physicseditor

        /**
         * @property bodyDef.type
         * @type {box2d.b2BodyType.b2_staticBody/box2d.b2BodyType.b2_dynamicBody/box2d.b2BodyType.b2_kinematicBody/box2d.b2BodyType.b2_bulletBody}
         */
        this.bodyDef.type = b2BodyType || box2d.b2BodyType.b2_staticBody

        /**
         * @property bodyDef.position
         */
        this.bodyDef.position.SetXY(this.x / this.scale, this.y / this.scale)
        /**
         * @property bodyDef.userData
         * @type {*}
         */
        this.bodyDef.userData = this.id
        /**
         * @property bullet
         * @type {*}
         */
        this.bullet = bullet || false
        /**
         * @property bodyDef.bullet
         * @type {*}
         */
        this.bodyDef.bullet = this.bullet

        //this.bodyDef.linearDamping = options.linearDamping
        //this.bodyDef.angularDamping = options.angularDamping
        //this.bodyDef.fixedRotation = true

        /**
         * @property body
         * @type {b2Body}
         */
        this.body = this.world.CreateBody(this.bodyDef)

        for (var i = 0, l = this.vecs.length; i < l; i++) {
            this.bodyShapePoly = new b2PolygonShape
            this.bodyShapePoly.bounce = this.jsondata[i].restitution        //value from physics editor
            this.bodyShapePoly.SetAsArray(this.vecs[i], this.vecs[i].length)
            this.fixDef.density = this.jsondata[i].density                  //value from physics editor
            this.fixDef.friction = this.jsondata[i].friction                //value from physics editor
            //this.fixDef.restitution = 0
            //this.fixDef.density = 10

            this.fixDef.shape = this.bodyShapePoly
            this.body.CreateFixture(this.fixDef)
        }
        return this

    },
    /**
     * @description extract the polygons out of the PhysicsEditor json file and collect them into an array
     *
     * @method getPolysFromJson
     * @return {Array}
     */
    getPolysFromJson:function () {
        var vecs = []
        for (var i = 0, l = this.jsondata.length; i < l; i++) {
            poly = this.jsondata[i].shape
            var temp = []
            for (var i2 = 0, l2 = poly.length; i2 < l2; i2 = i2 + 2) {
                vec = new b2Vec2(poly[i2] / this.scale, poly[i2 + 1] / this.scale)
                temp.push(vec)
            }
            vecs.push(temp)
        }
        return vecs
    }
})


/**
 *  ¬© 2012 by Christian Sonntag <info@motions-media.de>
 *  simple experimental Canvas Game JavaScript Framework
 */


/**
 * @description
 *
 * B2DTerrain
 *
 * @class CG.B2DPolygon
 * @extends CG.B2DEntity
 */


//@TODO code cleanup and description
//@TODO comment to polygon winding order for clipper (outer == CW; holes == CCW)

CG.B2DEntity.extend('B2DTerrain', {
    /**
     * @method init
     * @constructor
     * @param world     {Object}      reference to world of B2DWorld
     * @param name      {String}      id or name to identify
     * @param image     {mixed}       path to image, image or atlasimage from asset
     * @param terrainPoly  {array}      array of vertices to start terrain building
     * @param x         {Number}     the x position
     * @param y         {Number}     the y position
     * @param scale     {Number}     the world scale of B2DWorld
     * @param b2BodyType      {box2d.b2BodyType}     Box2D bodytype constant
     * @param bullet    {Boolean}     bullet option
     * @return {*}
     */
    init: function (world, name, image, terrainPoly, x, y, scale, b2BodyType, bullet) {
        this._super(name, image, world, x, y, scale)
        /**
         * @property polys
         * @type {Array}
         */
        this.polys = new Array()
        /**
         * @property terrainpoly
         * @type {*}
         */
        this.terrainPoly = terrainPoly

        this.terrainTriangles = []

        /**
         * @property holes
         * @type {Array}
         */
        this.holes = []
        /**
         * @property xhandle
         * @type {Number}
         */
        this.xhandle = 0
        /**
         * @property yhandle
         * @type {Number}
         */
        this.yhandle = 0

        /**
         * @property bodyDef.type
         * @type {box2d.b2BodyType.b2_staticBody/box2d.b2BodyType.b2_dynamicBody/box2d.b2BodyType.b2_kinematicBody/box2d.b2BodyType.b2_bulletBody}
         */
        this.bodyDef.type = b2BodyType || box2d.b2BodyType.b2_staticBody
        /**
         * @property bodyDef.position
         */
        this.bodyDef.position.SetXY(this.x / this.scale, this.y / this.scale)
        /**
         * @property bodyDef.userData
         * @type {*}
         */
        this.bodyDef.userData = this.id
        /**
         * @property bullet
         * @type {*}
         */
        this.bullet = bullet || false
        /**
         * @property bodyDef.bullet
         * @type {*}
         */
        this.bodyDef.bullet = this.bullet

        this.createTerrain()

        return this

    },
    createTerrain: function () {
        this.body = this.world.CreateBody(this.bodyDef)

        for (var part = 0, len = this.terrainPoly.length; part < len; part++) {
            try {
                var swctx = new poly2tri.SweepContext(this.terrainPoly[part].outer, {cloneArrays: true})

                if (this.terrainPoly[part].holes.length > 0) {
                    for (var i = 0, l = this.terrainPoly[part].holes.length; i < l; i++) {
                        swctx.addHole(this.terrainPoly[part].holes[i])
                    }
                }

                swctx.triangulate();

                this.terrainTriangles = this.terrainTriangles.concat(swctx.getTriangles() || [])
            } catch (e) {
                console.log(e)
            }
        }

        for (var i = 0, l = this.terrainTriangles.length; i < l; i++) {
            this.bodyShapePoly = new b2PolygonShape
            this.bodyShapePoly.bounce = 0.5
            this.bodyShapePoly.SetAsArray(this.getPolysFromTriangulation(this.terrainTriangles[i].points_), this.terrainTriangles[i].points_.length)
            this.fixDef.density = 0.5
            this.fixDef.friction = 0.5
            //this.fixDef.restitution = 0
            //this.fixDef.density = 10

            this.fixDef.shape = this.bodyShapePoly
            this.body.CreateFixture(this.fixDef)
        }
    },
    deleteTerrain: function () {
        //remove triangles
        this.terrainTriangles = []
        //remove body from b2world
        this.world.DestroyBody(this.body)
    },
    clippTerrain: function (opt) {
        var newhole = this.createCircle(opt)

        //add new hole to all contour terrainPolys
        for (var part = 0, len = this.terrainPoly.length; part < len; part++) {
            this.terrainPoly[part].holes.push(newhole)
        }

        //use clipper to calculate new terrainPolys
        var tempPolys = []
        var subj_polygons = []
        var clip_polygons = []
        for (var part = 0, len = this.terrainPoly.length; part < len; part++) {
            subj_polygons = [this.terrainPoly[part].outer]
            clip_polygons = []
            if (this.terrainPoly[part].holes.length > 0) {
                for (var i = 0, l = this.terrainPoly[part].holes.length; i < l; i++) {
                    clip_polygons.push(this.terrainPoly[part].holes[i])
                }
            }
            var cpr = new ClipperLib.Clipper()
            cpr.AddPolygons(subj_polygons, ClipperLib.PolyType.ptSubject)
            cpr.AddPolygons(clip_polygons, ClipperLib.PolyType.ptClip)

            var solution_polygons = new ClipperLib.ExPolygons()
            cpr.Execute(ClipperLib.ClipType.ctDifference, solution_polygons, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero)
            if (solution_polygons.length > 0) {
                for (var spoly = 0, slen = solution_polygons.length; spoly < slen; spoly++) {
                    tempPolys.push(solution_polygons[spoly])
                }
            }
        }
        this.terrainPoly = tempPolys
        this.lightenTerrain()
//        this.cleanTerrain()
        this.deleteTerrain()
        this.createTerrain()
    },
    /**
     * @description this method uses the Clipper Lighten mehtod to reduces vertices for better triangulation
     * @method lightenTerrain
     */
    lightenTerrain: function () {
        //use clipper to eliminate to much vertices
        var tolerance = 0.015

        for (var part = 0, len = this.terrainPoly.length; part < len; part++) {
            var temp = ClipperLib.Lighten(this.terrainPoly[part].outer, tolerance * this.scale)
            this.terrainPoly[part].outer = temp[0]
            if (this.terrainPoly[part].holes.length > 0) {
                for (var i = 0, l = this.terrainPoly[part].holes.length; i < l; i++) {
                    var temp = ClipperLib.Lighten(this.terrainPoly[part].holes[i], tolerance * this.scale)
                    this.terrainPoly[part].holes[i] = temp[0]
                }
            }
        }
    },
    /**
     * experimental not working yet
     */
    cleanTerrain: function () {
        //use clipper to eliminate to much vertices
        var tolerance = 0.015

        for (var part = 0, len = this.terrainPoly.length; part < len; part++) {
            var temp = ClipperLib.Clean(this.terrainPoly[part].outer, tolerance * this.scale)
            this.terrainPoly[part].outer = temp[0]
            if (this.terrainPoly[part].holes.length > 0) {
                for (var i = 0, l = this.terrainPoly[part].holes.length; i < l; i++) {
                    var temp = ClipperLib.Clean(this.terrainPoly[part].holes[i], tolerance * this.scale)
                    this.terrainPoly[part].holes[i] = temp[0]
                }
            }
        }
    },
    /**
     * @description extract the triangles out of poly2tri array
     *
     * @method getPolysFromJson
     * @return {Array}
     */
    getPolysFromTriangulation: function (pointsArray) {
        var vecs = []
        for (var i = 0, l = pointsArray.length; i < l; i++) {
            var poly = pointsArray[i]
            vecs.push(new b2Vec2(poly.x / this.scale, poly.y / this.scale))
        }
        return vecs
    },
    /**
     * @description creates a ccw wise circle vertices array for clipping
     *
     * @method createCircle
     * @param {object} opts example {points: 16, radius: 30, x: 320, y: 240}
     * @returns {Array}
     */
    createCircle: function (opts) {
        var angle = 2 * Math.PI / opts.points
        var circleArray = []
        for (var i = 0; i < opts.points; i++) {
            circleArray.push({x: opts.x + opts.radius * Math.cos(angle * i), y: opts.y + opts.radius * Math.sin(angle * i)})
        }
        return circleArray.reverse()
    },
    update: function () {

    },
    draw: function () {

    }
})


/**
 *  ¬© 2012 by Christian Sonntag <info@motions-media.de>
 *  simple experimental Canvas Game JavaScript Framework
 */


/**
 * @description
 *
 * B2DChainShape
 *
 * @class CG.B2DChainShape
 * @extends CG.B2DEntity
 */

CG.B2DEntity.extend('B2DChainShape', {
    /**
     * @method init
     * @constructor
     * @param world     {Object}      reference to world of B2DWorld
     * @param name      {String}      id or name to identify
     * @param vertices  {array}      vertices for chainshape CG.Point array
     * @param x         {Number}     the x position
     * @param y         {Number}     the y position
     * @param scale     {Number}     the world scale of B2DWorld
     * @param b2BodyType      {box2d.b2BodyType}     Box2D bodytype constant
     * @return {*}
     */
    init:function (world, name, vertices, x, y, scale, b2BodyType) {
        this._super(name, false, world, x, y, scale)
        /**
         * @property polys
         * @type {Array}
         */
        this.vertices = this.convertRealWorldPointToBox2DVec2(vertices)
        /**
         * @property xhandle
          * @type {Number}
         */
        this.xhandle = 0
        /**
         * @property yhandle
         * @type {Number}
         */
        this.yhandle = 0
        /**
         * @property bodyDef.type
         * @type {box2d.b2BodyType.b2_staticBody/box2d.b2BodyType.b2_dynamicBody/box2d.b2BodyType.b2_kinematicBody/box2d.b2BodyType.b2_bulletBody}
         */
        this.bodyDef.type = b2BodyType || box2d.b2BodyType.b2_staticBody
        /**
         * @property bodyDef.position
         */
        this.bodyDef.position.SetXY(this.x / this.scale, this.y / this.scale)
        /**
         * @property bodyDef.userData
         * @type {*}
         */
        this.bodyDef.userData = this.id
        /**
         * @property body
         * @type {b2Body}
         */
        /**
         * @property fixDef.shape
         * @type {b2CircleShape}
         */
        this.fixDef.shape = new b2ChainShape()
        this.fixDef.shape.CreateChain(this.vertices, this.vertices.length)

        /**
         * @property body
         * @type {b2Body}
         */
        this.body = this.world.CreateBody(this.bodyDef)
        this.body.CreateFixture(this.fixDef)

        return this

    },
    /**
     * @description
     *
     * convertRealWorldPointToBox2DVec2 converts real world vectors to box2d world vecs depending on scale
     *
     * @method convertRealWorldPointToBox2DVec2
     * @param {Array} vertices CG.Point array
     * @return {Array} vecs b2Vec2  with box2d world scale
     */
    convertRealWorldPointToBox2DVec2:function (vertices) {
        var vecs = []
        for (var i = 0, l = vertices.length; i < l; i++) {
            var vec = new b2Vec2(vertices[i].x / this.scale, vertices[i].y / this.scale)
            vecs.push(vec)
        }
        return vecs
    },
    update:function () {

    },
    draw:function () {

    }

})


/**
 *  ¬© 2012 by Christian Sonntag <info@motions-media.de>
 *  simple experimental Canvas Game JavaScript Framework
 */


/**
 * @description
 *
 * B2DRope is a simple wrapper that creates a rope with segments.
 * Just play with the params to get a good result.
 *
 * @class CG.B2DRope
 * @extends CG.B2DEntity
 */

CG.B2DEntity.extend('B2DRope', {
    /**
     * @method init
     * @constructor
     * @param world         {Object}      reference to world of B2DWorld
     * @param name          {String}      id or name to identify
     * @param image         {mixed}       path to image, image or atlasimage from asset
     * @param x             {Number}     the x position
     * @param y             {Number}     the y position
     * @param length        {Number}     the length/width of the bridge
     * @param segments      {Number}     segments of the bridge
     * @param segmentWidth  {Number}     width of a segment
     * @param scale         {Number}     the world scale of B2DWorld
     * @return {*}
     */
    init:function (world, name, image, x, y, length, segments, segmentWidth, scale) {
        this._super(name, image, world, x, y, scale)
        /**
         * @property length
         * @type {Number}
         */
        this.length = length
        /**
         * @property segments
         * @type {Number}
         */
        this.segments = segments
        /**
         * @property segmentHeight
         * @type {Number}
         */
        this.segmentHeight = ((this.length - this.y) / this.segments) / 2
        /**
         * @property segmentWidth
         * @type {*}
         */
        this.segmentWidth = segmentWidth
        /**
         * @property anchor
         * @type {b2Vec2}
         */
        this.anchor = new b2Vec2()
        /**
         * @property prevBody
         * @type {Object}
         */
        this.prevBody = {}
        /**
         * @property bodyGroup
         * @type {Array}
         */
        this.bodyGroup = []
        /**
         * @property bodyCount
         * @type {Number}
         */
        this.bodyCount = 0

        // RopeStart
        this.fixtureDef = new b2FixtureDef()
        this.bodyShapeCircle = new b2CircleShape()
        this.bodyDef = new b2BodyDef()
        this.bodyDef.userData = this.id
        this.bodyShapeCircle.m_radius = this.segmentWidth / this.scale
        this.fixtureDef.density = 1.0
        this.fixtureDef.restitution = 0.2
        this.fixtureDef.friction = 0.2
        this.fixtureDef.shape = this.bodyShapeCircle
        this.bodyDef.position.SetXY(this.x / this.scale, this.y / this.scale)
        this.body = this.bodyGroup[0] = this.world.CreateBody(this.bodyDef)
        this.bodyGroup[0].CreateFixture(this.fixtureDef)
        this.prevBody = this.bodyGroup[0]

        // RopeSegments
        this.fixtureDef = new b2FixtureDef()
        this.bodyShapePoly = new b2PolygonShape()
        this.bodyDef = new b2BodyDef()
        this.bodyDef.userData = this.id
        this.bodyShapePoly.SetAsBox(this.segmentWidth / this.scale, this.segmentHeight / this.scale)
        this.bodyDef.type = box2d.b2BodyType.b2_dynamicBody
        this.fixtureDef.shape = this.bodyShapePoly
        this.fixtureDef.density = 20.0
        this.fixtureDef.restitution = 0.2
        this.fixtureDef.friction = 0.2
        this.jointDef = new b2RevoluteJointDef()
        this.jointDef.lowerAngle = -25 / (180 / Math.PI)
        this.jointDef.upperAngle = 25 / (180 / Math.PI)
        this.jointDef.enableLimit = true


        for (var i = 0, l = this.segments; i < l; i++) {
            this.bodyDef.position.SetXY(this.x / this.scale, ((this.y + this.segmentHeight) + (this.segmentHeight * 2) * i) / this.scale)
            this.bodyGroup[i + 1] = this.world.CreateBody(this.bodyDef)
            this.bodyGroup[i + 1].CreateFixture(this.fixtureDef)
            this.anchor.SetXY(this.x / this.scale, (this.y + (this.segmentHeight * 2) * i) / this.scale)
            this.jointDef.Initialize(this.prevBody, this.bodyGroup[i + 1], this.anchor)
            this.world.CreateJoint(this.jointDef)
            this.prevBody = this.bodyGroup[i + 1]
            this.bodyCount = i + 1
        }

        return this

    },

    draw:function () {
        for (var i = 1; i <= this.bodyCount; i++) {
            var x = this.bodyGroup[i].GetPosition().x
            var y = this.bodyGroup[i].GetPosition().y
            var r = this.bodyGroup[i].GetAngleRadians()
            Game.b_ctx.save()
            Game.b_ctx.globalAlpha = this.alpha
            Game.b_ctx.translate(x * this.scale, y * this.scale)
            if (this.atlasimage) {
                Game.b_ctx.rotate(r - this.imagerotation) // * CG.Const_PI_180)
                Game.b_ctx.drawImage(this.image, this.xoffset, this.yoffset, this.cutwidth, this.cutheight, 0 - this.xhandle, 0 - this.yhandle, this.cutwidth, this.cutheight)
            } else {
                Game.b_ctx.rotate(r) // * CG.Const_PI_180)
                Game.b_ctx.drawImage(this.image, 0 - this.xhandle, 0 - this.yhandle, this.image.width, this.image.height)
            }
            Game.b_ctx.restore()
        }
    }
})


/**
 *  ¬© 2012 by Christian Sonntag <info@motions-media.de>
 *  simple experimental Canvas Game JavaScript Framework
 */


/**
 * @description
 *
 * B2DBridge is a simple wrapper that creates a bridge with segments.
 * Just play with the params to get a good result.
 *
 * @class CG.B2DBridge
 * @extends CG.B2DEntity
 */

CG.B2DEntity.extend('B2DBridge', {
    /**
     * @method init
     * @constructor
     * @param world         {Object}      reference to world of B2DWorld
     * @param name          {String}      id or name to identify
     * @param image         {mixed}       path to image, image or atlasimage from asset
     * @param x             {Number}     the x position
     * @param y             {Number}     the y position
     * @param length        {Number}     the length/width of the bridge
     * @param segments      {Number}     segments of the bridge
     * @param segmentHeight {Number}     height of a segment
     * @param scale         {Number}     the world scale of B2DWorld
     * @return {*}
     */
    init: function (world, name, image, x, y, length, segments, segmentHeight, scale) {
        this._super(name, image, world, x, y, scale)
        /**
         * @property length
         * @type {Number}
         */
        this.length = length
        /**
         * @property segments
         * @type {Number}
         */
        this.segments = segments
        /**
         * @property segmentHeight
         * @type {Number}
         */
        this.segmentHeight = segmentHeight
        /**
         * @property segmentWidth
         * @type {Number}
         */
        this.segmentWidth = ((this.length - this.x) / this.segments) / 2
        /**
         * @property anchor
         * @type {b2Vec2}
         */
        this.anchor = new b2Vec2()
        /**
         * @property prevBodf
         * @type {Object}
         */
        this.prevBody = {}
        /**
         * @property bodyGroup
         * @type {Array}
         */
        this.bodyGroup = []
        /**
         * @property bodyCount
         * @type {Number}
         */
        this.bodyCount = 0

        // BridgeStart

        this.fixtureDef = new b2FixtureDef()
        this.bodyShapeCircle = new b2CircleShape()
        this.bodyDef = new b2BodyDef()
        this.bodyDef.userData = this.id
        this.bodyShapeCircle.m_radius = this.segmentHeight / this.scale
        this.fixtureDef.density = 20.0
        this.fixtureDef.restitution = 0.2
        this.fixtureDef.friction = 0.2
        this.fixtureDef.shape = this.bodyShapeCircle
        this.bodyDef.position.SetXY(this.x / this.scale, this.y / this.scale)
        this.body = this.bodyGroup[0] = this.world.CreateBody(this.bodyDef)
        this.bodyGroup[0].CreateFixture(this.fixtureDef)
        this.prevBody = this.bodyGroup[0]

        // BridgeEnd
        this.bodyDef.position.SetXY(this.length / this.scale, this.y / this.scale)
        this.bodyDef.userData = this.id
        this.bodyGroup[1] = this.world.CreateBody(this.bodyDef)
        this.bodyGroup[1].CreateFixture(this.fixtureDef)

        // bridge elements
        this.fixtureDef = new b2FixtureDef()
        this.bodyShapePoly = new b2PolygonShape()
        this.bodyDef = new b2BodyDef()
        this.bodyDef.userData = this.id
        this.bodyShapePoly.SetAsBox(this.segmentWidth / this.scale, this.segmentHeight / this.scale)
        this.bodyDef.type = box2d.b2BodyType.b2_dynamicBody
        this.fixtureDef.shape = this.bodyShapePoly
        this.fixtureDef.density = 20.0
        this.fixtureDef.restitution = 0.2
        this.fixtureDef.friction = 0.2
        this.jointDef = new b2RevoluteJointDef()
        this.jointDef.lowerAngle = -25 / (180 / Math.PI)
        this.jointDef.upperAngle = 25 / (180 / Math.PI)
        this.jointDef.enableLimit = true

        for (var i = 0, l = this.segments; i < l; i++) {
            this.bodyDef.position.SetXY(((this.x + this.segmentWidth) + (this.segmentWidth * 2) * i) / this.scale, this.y / this.scale)
            this.bodyGroup[i + 2] = this.world.CreateBody(this.bodyDef)
            this.bodyGroup[i + 2].CreateFixture(this.fixtureDef)
            this.anchor.SetXY((this.x + (this.segmentWidth * 2) * i) / this.scale, this.y / this.scale)
            this.jointDef.Initialize(this.prevBody, this.bodyGroup[i + 2], this.anchor)
            this.world.CreateJoint(this.jointDef)
            this.prevBody = this.bodyGroup[i + 2]
            this.bodyCount = i + 2
        }

        this.anchor.SetXY((this.x + (this.segmentWidth * 2) * this.segments - 1) / this.scale, this.y / this.scale)
        this.jointDef.Initialize(this.prevBody, this.bodyGroup[1], this.anchor)
        this.world.CreateJoint(this.jointDef)

        return this
    },
    draw: function () {
        for (var i = 2; i <= this.bodyCount; i++) {
            var x = this.bodyGroup[i].GetPosition().x
            var y = this.bodyGroup[i].GetPosition().y
            var r = this.bodyGroup[i].GetAngleRadians()
            Game.b_ctx.save()
            Game.b_ctx.globalAlpha = this.alpha
            Game.b_ctx.translate(x * this.scale, y * this.scale)
            if (this.atlasimage) {
                Game.b_ctx.rotate(r - this.imagerotation) // * CG.Const_PI_180)
                Game.b_ctx.drawImage(this.image, this.xoffset, this.yoffset, this.cutwidth, this.cutheight, 0 - this.xhandle, 0 - this.yhandle, this.cutwidth, this.cutheight)
            } else {
                Game.b_ctx.rotate(r) // * CG.Const_PI_180)
                Game.b_ctx.drawImage(this.image, 0 - this.xhandle, 0 - this.yhandle, this.image.width, this.image.height)
            }
            Game.b_ctx.restore()
        }
    }
})


/**
 *  ¬© 2012 by Christian Sonntag <info@motions-media.de>
 *  simple experimental Canvas Game JavaScript Framework
 */


/**
 * @description
 *
 * B2DWorld is a Box2dWeb wrapper with basic and easy methods for creating Box2d Objects like
 * lines, circles, rectangles, polybodies, ropes and bridges. Custom B2D Objects that extends
 * one of the basic B2D objects can added to the B2DWorld with the addCustom method.
 * The CG.B2DWorld can attached to an CG.Screen object as layer. The B2DWorld will handle
 * all physics and drawings.
 *
 * @class CG.B2DWorld
 * @xtend CG.Layer
 */

CG.Layer.extend('B2DWorld', {
    /**
     * @method init
     * @constructor
     * @param name {String} name of the b2dworld
     * @param opt {object} additional options
     */
    init: function (name, opt) {

        this.framerate = 1 / 30

        /**
         * @property opt
         * @type {object}
         */
        this.opt = opt || {}

        /**
         * @property name
         * @type {String}
         */
        this.name = name || ''
        /**
         * @property debug
         * @type {Boolean}
         */
        this.debug = false
        /**
         * @property x
         * @type {Number}
         */
        this.x = 0
        /**
         * @property y
         * @type {Number}
         */
        this.y = 0
        /**
         * @property elements
         * @type {Array}
         */
        this.elements = []

        /**
         * @property world
         * @type {b2World}
         */
        this.world = new b2World(
            new b2Vec2(0, 10), //gravity
            this.opt.sleep || true        //allow sleep
        )
        /**
         * @property uid
         * @type {Number}
         */
        this.uid = 0 //uid counter for elements
        /**
         * @property scale
         * @type {Number}
         */
        this.scale = 40

        /**
         * add m_groundBody for use with b2MouseJoint
         */
        this.world.m_groundBody = this.world.CreateBody(new b2BodyDef());


        //setup debug draw
        var debugDraw = new b2DebugDraw({
            scale: this.scale,
            canvas: Game.b_canvas,
            ctx: Game.b_ctx,
            flags: box2d.b2DrawFlags.e_shapeBit | box2d.b2DrawFlags.e_jointBit
        })
        this.world.SetDebugDraw(debugDraw)

    },
    update: function () {

        this.world.Step(
            this.framerate   //frame-rate
            , 10       //velocity iterations
            , 10       //position iterations
        )

        if (CG.mousedown) {
            this.mouseDownAt(mousex, mousey);
        } else if (this.isMouseDown()) {
            this.mouseUp();
        }

        for (var i = 0, l = this.elements.length; i < l; i++) {
            this.elements[i].update()
        }


    },
    draw: function () {
        Game.b_ctx.save()
        Game.b_ctx.translate(this.x, this.y)

        //TODO ? place for CanvasRenderer ?

        for (var i = 0, l = this.elements.length; i < l; i++) {
            this.elements[i].draw()
        }

        if (this.debug) {
            this.world.DrawDebugData()
            this.world.ClearForces()
        }

        Game.b_ctx.restore()
    },
    /**
     * @description
     *
     * Custom extended objects can be added to the B2DWork with this method.
     *
     * @method addCustom
     * @param obj      object    custom B2D object
     */
    addCustom: function (obj) {
        this.uid = this.uid + 1
        obj.id.uid = this.uid
        this.elements.push(obj)
    },
    /**
     * @description
     *
     * createBox creates a basic Box2D rectangle with some default settings.
     *
     * @method createBox
     * @param id      {String}      id or name to identify
     * @param image   {mixed}       path to image, image or atlasimage from asset
     * @param x       {Number}     the x position
     * @param y       {Number}     the y position
     * @param stat    {Boolean}     is the body static or dynamic
     */
    createBox: function (id, image, x, y, stat) {
        this.uid = this.uid + 1
        var entity = new CG.B2DRectangle(this.world, id, image, x, y, this.scale, stat)
        entity.id.uid = this.uid
        this.elements.push(entity)
        return entity
    },
    /**
     * @description
     *
     * createLine creates a basic Box2D line with some default settings.
     *
     * @method createLine
     * @param id      {String}    id or name to identify
     * @param start   {CG.Point}  start o fline
     * @param end     {CG.Point}  end of line
     */
    createLine: function (id, start, end) {
        this.uid = this.uid + 1
        var entity = new CG.B2DLine(this.world, id, new b2Vec2(start.x / this.scale, start.y / this.scale), new b2Vec2(end.x / this.scale, end.y / this.scale), this.scale)
        entity.id.uid = this.uid
        this.elements.push(entity)
        return entity
    },
    /**
     * @description
     *
     * createCircle creates a basic Box2D circle with some default settings
     *
     * @method createCircle
     * @param id      {String}      id or name to identify
     * @param image   {mixed}       path to image, image or atlasimage from asset
     * @param radius  {Number}     the radius
     * @param x       {Number}     the x position
     * @param y       {Number}     the y position
     * @param stat    {Boolean}     is the body static or dynamic
     */
    createCircle: function (id, image, radius, x, y, stat) {
        this.uid = this.uid + 1
        var entity = new CG.B2DCircle(this.world, id, image, radius, x, y, this.scale, stat)
        entity.id.uid = this.uid
        this.elements.push(entity)
        return entity
    },
    /**
     * @description
     *
     * createPolyBody creates a Box2D polybody. A PhysicsEditor json (Lime + Corona JSON Exporter) file is needed for this
     * Box2D object. The polygonshape and some settings like density, bounce and friction are
     * taken from the json file at the moment.
     *
     * @method createPolyBody
     * @param id        {String}      id or name to identify
     * @param image     {mixed}       path to image, image or atlasimage from asset
     * @param jsonpoly  {String}      json file from PhysicsEditor from asset
     * @param x         {Number}     the x position
     * @param y         {Number}     the y position
     * @param stat      {Boolean}     is the body static or dynamic
     * @param bullet    {Boolean}     bullet option
     */
    createPolyBody: function (id, image, jsonpoly, x, y, stat, bullet) {
        this.uid = this.uid + 1
        var entity = new CG.B2DPolygon(this.world, id, image, jsonpoly, x, y, this.scale, stat, bullet)
        entity.id.uid = this.uid
        this.elements.push(entity)
        return entity
    },
    /**
     * @description
     *
     * createTerrain
     *
     * @method createPolyBody
     * @param id        {String}      id or name to identify
     * @param image     {mixed}       path to image, image or atlasimage from asset
     * @param terrainpoly  {Array}      array of vertices to start terrain building
     * @param x         {Number}     the x position
     * @param y         {Number}     the y position
     * @param stat      {Boolean}     is the body static or dynamic
     * @param bullet    {Boolean}     bullet option
     */
    createTerrain: function (id, image, terrainpoly, x, y, stat, bullet) {
        this.uid = this.uid + 1
        var entity = new CG.B2DTerrain(this.world, id, image, terrainpoly, x, y, this.scale, stat, bullet)
        entity.id.uid = this.uid
        this.elements.push(entity)
        return entity
    },
    /**
     * @description
     *
     * createChainShape
     *
     * @method createChainShape
     * @param id        {String}      id or name to identify
     * @param vertices  {array}      vertices for chainshape CG.Point array
     * @param x         {Number}     the x position
     * @param y         {Number}     the y position
     */
    createChainShape: function (id, vertices, x, y, stat) {
        this.uid = this.uid + 1
        var entity = new CG.B2DChainShape(this.world, id, vertices, x, y, this.scale, stat)
        entity.id.uid = this.uid
        this.elements.push(entity)
        return entity
    },
    /**
     * @description
     *
     * This method creates a B2D bridge. Just play with the params to get a good result!
     *
     * @method createBridge
     * @param id          {String}      id or name to identify
     * @param image         {mixed}       path to image, image or atlasimage from asset
     * @param x             {Number}     the x position
     * @param y             {Number}     the y position
     * @param length        {Number}     the length/width of the bridge
     * @param segments      {Number}     segments of the bridge
     * @param segmentHeight {Number}     height of a segment
     * @return {*}
     */
    createBridge: function (id, image, x, y, length, segments, segmentHeight) {
        this.uid = this.uid + 1
        var entity = new CG.B2DBridge(this.world, id, image, x, y, length, segments, segmentHeight, this.scale)
        entity.id.uid = this.uid
        this.elements.push(entity)
        return entity
    },
    /**
     * @description
     *
     * This method creates a B2D rope. Just play with the params to get a good result!
     *
     * @method createRope
     * @param id            {String}      id or name to identify
     * @param image         {mixed}       path to image, image or atlasimage from asset
     * @param x             {Number}     the x position
     * @param y             {Number}     the y position
     * @param length        {Number}     the length/width of the bridge
     * @param segments      {Number}     segments of the bridge
     * @param segmentHeight {Number}     height of a segment
     * @return {*}
     */
    createRope: function (id, image, x, y, length, segments, segmentHeight) {
        this.uid = this.uid + 1
        var entity = new CG.B2DRope(this.world, id, image, x, y, length, segments, segmentHeight, this.scale)
        entity.id.uid = this.uid
        this.elements.push(entity)
        return entity
    },
    /**
     * @description
     *
     * Enables dragging B2D objects with the mouse.
     *
     * @method mouseDownAt
     * @param x {Number}
     * @param y {Number}
     */
    mouseDownAt: function (x, y) {
        if (!this.mouseJoint) {
            var body = this.getBodyAt(x, y)
            console.log(body)
            if (body) {
                var md = new b2MouseJointDef()
                md.bodyA = this.world.m_groundBody
                md.bodyB = body
                md.target.SetXY((x - this.x) / this.scale, (y - this.y) / this.scale)
                md.collideConnected = true
                md.maxForce = 300.0 * body.GetMass()
                this.mouseJoint = this.world.CreateJoint(md)
                body.SetAwake(true);
            }
        } else {
            this.mouseJoint.SetTarget(new b2Vec2((x - this.x) / this.scale, (y - this.y) / this.scale))
        }
    },
    /**
     * @method mouseUp
     */
    mouseUp: function () {
        this.world.DestroyJoint(this.mouseJoint);
        this.mouseJoint = null;
    },
    /**
     * @description
     *
     * Get a B2D body at the give x, y position.
     *
     * @method getBodyAt
     * @param x {Number}
     * @param y {Number}
     * @return {*}
     */
    getBodyAt: function (x, y) {
        var worldx = (x - this.x) / this.scale;
        var worldy = (y - this.y) / this.scale

        var mousePVec = new b2Vec2(worldx, worldy)  //b2world offset for x and y!!!
        var aabb = new b2AABB()
        aabb.lowerBound.SetXY(worldx - 0.001, worldy - 0.001)
        aabb.upperBound.SetXY(worldx + 0.001, worldy + 0.001)

        // Query the world for overlapping shapes.

        var selectedBody = null;
        this.world.QueryAABB(function (fixture) {
            if (fixture.GetBody().GetType() != b2Body.b2_staticBody) {
                if (fixture.GetShape().TestPoint(fixture.GetBody().GetTransform(), mousePVec)) {
                    selectedBody = fixture.GetBody();
                    return false;
                }
            }
            return true;
        }, aabb);
        return selectedBody;
    },
    /**
     * @description
     *
     * Deletes a B2D body at the given x, y position
     *
     * @method deleteBodyAt
     * @param x {Number}
     * @param y (Number)
     * @return {Boolean}
     */
    deleteBodyAt: function (x, y) {
        body = this.getBodyAt(x, y)
        if (body) {
            for (var i = 0, l = this.elements.length; i < l; i++) {
                //if b2entity found delete entity and b2body
                if (this.elements[i].body.m_userData.uid == body.m_userData.uid) {
                    this.removeElementByIndex(i)
                    this.world.DestroyBody(body)
                    return true
                }
            }
        }
        return false
    },
    /**
     * @method isMouseDown
     * @return {Boolean}
     */
    isMouseDown: function () {
        return (this.mouseJoint != null);
    },
    /**
     * @method removeElementByIndex
     * @param index
     */
    removeElementByIndex: function (index) {
        this.elements.splice(index, 1);
    },
    /**
     * @method removeElementByUid
     * @param uid
     */
    removeElementByUid: function (uid) {
        for (var i = 0, l = this.elements.length; i < l; i++) {
            if (typeof this.elements[i].id !== 'undefined') {
                if(this.elements[i].id.uid === uid) {
                    this.elements.splice(i, 1);
                }
            }
        }
    },
    /**
     * @method applyImpulse
     * @param body
     * @param degrees
     * @param power
     */
    applyImpulse: function (body, degrees, power) {
        if (body) {
            body.ApplyLinearImpulse(new b2Vec2(Math.cos(degrees * (Math.PI / 180)) * power,
                Math.sin(degrees * (Math.PI / 180)) * power),
                body.GetWorldCenter());
        }
    },
    /**
     * @method addContactListener
     * @param callbacks
     */
    addContactListener: function (callbacks) {
        var listener = new box2d.b2ContactListener;
        if (callbacks.BeginContact) listener.BeginContact = function (contact) {
            callbacks.BeginContact(contact.GetFixtureA().GetBody(),
                contact.GetFixtureB().GetBody());
        }
        if (callbacks.EndContact) listener.EndContact = function (contact) {
            callbacks.EndContact(contact.GetFixtureA().GetBody(),
                contact.GetFixtureB().GetBody());
        }
        if (callbacks.PostSolve) listener.PostSolve = function (contact, impulse) {
            callbacks.PostSolve(contact.GetFixtureA().GetBody(),
                contact.GetFixtureB().GetBody(),
                impulse.normalImpulses[0]);
        }
        if (callbacks.PreSolve) listener.PreSolve = function (contact, oldManifold) {
            callbacks.PreSolve(contact, oldManifold);
        }
        this.world.SetContactListener(listener);
    },
    /**
     * @method getBodySpec
     * @param b
     * @return {Object}
     */
    getBodySpec: function (b) {
        return {x: b.GetPosition().x, y: b.GetPosition().y, a: b.GetAngle(), c: {x: b.GetWorldCenter().x, y: b.GetWorldCenter().y}};
    }

})


// ----------------------------------------------------------------------------
// Buzz, a Javascript HTML5 Audio library
// v 1.0.6
// Licensed under the MIT license.
// http://buzz.jaysalvat.com/
// ----------------------------------------------------------------------------
// Copyright (C) 2013 Jay Salvat
// http://jaysalvat.com/
// ----------------------------------------------------------------------------
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files ( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
// ----------------------------------------------------------------------------

var buzz = {
    defaults: {
        autoplay: false,
        duration: 5000,
        formats: [],
        loop: false,
        placeholder: '--',
        preload: 'metadata',
        volume: 80
    },
    types: {
        'mp3': 'audio/mpeg',
        'ogg': 'audio/ogg',
        'wav': 'audio/wav',
        'aac': 'audio/aac',
        'm4a': 'audio/x-m4a'
    },
    sounds: [],
    el: document.createElement( 'audio' ),

    sound: function( src, options ) {
        options = options || {};

        var pid = 0,
            events = [],
            eventsOnce = {},
            supported = buzz.isSupported();

        // publics
        this.load = function() {
            if ( !supported ) {
              return this;
            }

            this.sound.load();
            return this;
        };

        this.play = function() {
            if ( !supported ) {
              return this;
            }

            this.sound.play();
            return this;
        };

        this.togglePlay = function() {
            if ( !supported ) {
              return this;
            }

            if ( this.sound.paused ) {
                this.sound.play();
            } else {
                this.sound.pause();
            }
            return this;
        };

        this.pause = function() {
            if ( !supported ) {
              return this;
            }

            this.sound.pause();
            return this;
        };

        this.isPaused = function() {
            if ( !supported ) {
              return null;
            }

            return this.sound.paused;
        };

        this.stop = function() {
            if ( !supported  ) {
              return this;
            }

            this.setTime( 0 );
            this.sound.pause();
            return this;
        };

        this.isEnded = function() {
            if ( !supported ) {
              return null;
            }

            return this.sound.ended;
        };

        this.loop = function() {
            if ( !supported ) {
              return this;
            }

            this.sound.loop = 'loop';
            this.bind( 'ended.buzzloop', function() {
                this.currentTime = 0;
                this.play();
            });
            return this;
        };

        this.unloop = function() {
            if ( !supported ) {
              return this;
            }

            this.sound.removeAttribute( 'loop' );
            this.unbind( 'ended.buzzloop' );
            return this;
        };

        this.mute = function() {
            if ( !supported ) {
              return this;
            }

            this.sound.muted = true;
            return this;
        };

        this.unmute = function() {
            if ( !supported ) {
              return this;
            }

            this.sound.muted = false;
            return this;
        };

        this.toggleMute = function() {
            if ( !supported ) {
              return this;
            }

            this.sound.muted = !this.sound.muted;
            return this;
        };

        this.isMuted = function() {
            if ( !supported ) {
              return null;
            }

            return this.sound.muted;
        };

        this.setVolume = function( volume ) {
            if ( !supported ) {
              return this;
            }

            if ( volume < 0 ) {
              volume = 0;
            }
            if ( volume > 100 ) {
              volume = 100;
            }
          
            this.volume = volume;
            this.sound.volume = volume / 100;
            return this;
        };
      
        this.getVolume = function() {
            if ( !supported ) {
              return this;
            }

            return this.volume;
        };

        this.increaseVolume = function( value ) {
            return this.setVolume( this.volume + ( value || 1 ) );
        };

        this.decreaseVolume = function( value ) {
            return this.setVolume( this.volume - ( value || 1 ) );
        };

        this.setTime = function( time ) {
            if ( !supported ) {
              return this;
            }

            this.whenReady( function() {
                this.sound.currentTime = time;
            });
            return this;
        };

        this.getTime = function() {
            if ( !supported ) {
              return null;
            }

            var time = Math.round( this.sound.currentTime * 100 ) / 100;
            return isNaN( time ) ? buzz.defaults.placeholder : time;
        };

        this.setPercent = function( percent ) {
            if ( !supported ) {
              return this;
            }

            return this.setTime( buzz.fromPercent( percent, this.sound.duration ) );
        };

        this.getPercent = function() {
            if ( !supported ) {
              return null;
            }

			var percent = Math.round( buzz.toPercent( this.sound.currentTime, this.sound.duration ) );
            return isNaN( percent ) ? buzz.defaults.placeholder : percent;
        };

        this.setSpeed = function( duration ) {
			if ( !supported ) {
              return this;
            }

            this.sound.playbackRate = duration;
        };

        this.getSpeed = function() {
			if ( !supported ) {
              return null;
            }

            return this.sound.playbackRate;
        };

        this.getDuration = function() {
            if ( !supported ) {
              return null;
            }

            var duration = Math.round( this.sound.duration * 100 ) / 100;
            return isNaN( duration ) ? buzz.defaults.placeholder : duration;
        };

        this.getPlayed = function() {
			if ( !supported ) {
              return null;
            }

            return timerangeToArray( this.sound.played );
        };

        this.getBuffered = function() {
			if ( !supported ) {
              return null;
            }

            return timerangeToArray( this.sound.buffered );
        };

        this.getSeekable = function() {
			if ( !supported ) {
              return null;
            }

            return timerangeToArray( this.sound.seekable );
        };

        this.getErrorCode = function() {
            if ( supported && this.sound.error ) {
                return this.sound.error.code;
            }
            return 0;
        };

        this.getErrorMessage = function() {
			if ( !supported ) {
              return null;
            }

            switch( this.getErrorCode() ) {
                case 1:
                    return 'MEDIA_ERR_ABORTED';
                case 2:
                    return 'MEDIA_ERR_NETWORK';
                case 3:
                    return 'MEDIA_ERR_DECODE';
                case 4:
                    return 'MEDIA_ERR_SRC_NOT_SUPPORTED';
                default:
                    return null;
            }
        };

        this.getStateCode = function() {
			if ( !supported ) {
              return null;
            }

            return this.sound.readyState;
        };

        this.getStateMessage = function() {
			if ( !supported ) {
              return null;
            }

            switch( this.getStateCode() ) {
                case 0:
                    return 'HAVE_NOTHING';
                case 1:
                    return 'HAVE_METADATA';
                case 2:
                    return 'HAVE_CURRENT_DATA';
                case 3:
                    return 'HAVE_FUTURE_DATA';
                case 4:
                    return 'HAVE_ENOUGH_DATA';
                default:
                    return null;
            }
        };

        this.getNetworkStateCode = function() {
			if ( !supported ) {
              return null;
            }

            return this.sound.networkState;
        };

        this.getNetworkStateMessage = function() {
			if ( !supported ) {
              return null;
            }

            switch( this.getNetworkStateCode() ) {
                case 0:
                    return 'NETWORK_EMPTY';
                case 1:
                    return 'NETWORK_IDLE';
                case 2:
                    return 'NETWORK_LOADING';
                case 3:
                    return 'NETWORK_NO_SOURCE';
                default:
                    return null;
            }
        };

        this.set = function( key, value ) {
            if ( !supported ) {
              return this;
            }

            this.sound[ key ] = value;
            return this;
        };

        this.get = function( key ) {
            if ( !supported ) {
              return null;
            }

            return key ? this.sound[ key ] : this.sound;
        };

        this.bind = function( types, func ) {
            if ( !supported ) {
              return this;
            }

            types = types.split( ' ' );

            var that = this,
				efunc = function( e ) { func.call( that, e ); };

            for( var t = 0; t < types.length; t++ ) {
                var type = types[ t ],
                    idx = type;
                    type = idx.split( '.' )[ 0 ];

                    events.push( { idx: idx, func: efunc } );
                    this.sound.addEventListener( type, efunc, true );
            }
            return this;
        };

        this.unbind = function( types ) {
            if ( !supported ) {
              return this;
            }

            types = types.split( ' ' );

            for( var t = 0; t < types.length; t++ ) {
                var idx = types[ t ],
                    type = idx.split( '.' )[ 0 ];

                for( var i = 0; i < events.length; i++ ) {
                    var namespace = events[ i ].idx.split( '.' );
                    if ( events[ i ].idx == idx || ( namespace[ 1 ] && namespace[ 1 ] == idx.replace( '.', '' ) ) ) {
                        this.sound.removeEventListener( type, events[ i ].func, true );
                        // remove event
                        events.splice(i, 1);
                    }
                }
            }
            return this;
        };

        this.bindOnce = function( type, func ) {
            if ( !supported ) {
              return this;
            }

            var that = this;

            eventsOnce[ pid++ ] = false;
            this.bind( type + '.' + pid, function() {
               if ( !eventsOnce[ pid ] ) {
                   eventsOnce[ pid ] = true;
                   func.call( that );
               }
               that.unbind( type + '.' + pid );
            });
        };

        this.trigger = function( types ) {
            if ( !supported ) {
              return this;
            }

            types = types.split( ' ' );

            for( var t = 0; t < types.length; t++ ) {
                var idx = types[ t ];

                for( var i = 0; i < events.length; i++ ) {
                    var eventType = events[ i ].idx.split( '.' );
                    if ( events[ i ].idx == idx || ( eventType[ 0 ] && eventType[ 0 ] == idx.replace( '.', '' ) ) ) {
                        var evt = document.createEvent('HTMLEvents');
                        evt.initEvent( eventType[ 0 ], false, true );
                        this.sound.dispatchEvent( evt );
                    }
                }
            }
            return this;
        };

        this.fadeTo = function( to, duration, callback ) {
			if ( !supported ) {
              return this;
            }

            if ( duration instanceof Function ) {
                callback = duration;
                duration = buzz.defaults.duration;
            } else {
                duration = duration || buzz.defaults.duration;
            }

            var from = this.volume,
				delay = duration / Math.abs( from - to ),
                that = this;
            this.play();

            function doFade() {
                setTimeout( function() {
                    if ( from < to && that.volume < to ) {
                        that.setVolume( that.volume += 1 );
                        doFade();
                    } else if ( from > to && that.volume > to ) {
                        that.setVolume( that.volume -= 1 );
                        doFade();
                    } else if ( callback instanceof Function ) {
                        callback.apply( that );
                    }
                }, delay );
            }
            this.whenReady( function() {
                doFade();
            });

            return this;
        };

        this.fadeIn = function( duration, callback ) {
            if ( !supported ) {
              return this;
            }

            return this.setVolume(0).fadeTo( 100, duration, callback );
        };

        this.fadeOut = function( duration, callback ) {
			if ( !supported ) {
              return this;
            }

            return this.fadeTo( 0, duration, callback );
        };

        this.fadeWith = function( sound, duration ) {
            if ( !supported ) {
              return this;
            }

            this.fadeOut( duration, function() {
                this.stop();
            });

            sound.play().fadeIn( duration );

            return this;
        };

        this.whenReady = function( func ) {
            if ( !supported ) {
              return null;
            }

            var that = this;
            if ( this.sound.readyState === 0 ) {
                this.bind( 'canplay.buzzwhenready', function() {
                    func.call( that );
                });
            } else {
                func.call( that );
            }
        };

        // privates
        function timerangeToArray( timeRange ) {
            var array = [],
                length = timeRange.length - 1;

            for( var i = 0; i <= length; i++ ) {
                array.push({
                    start: timeRange.start( length ),
                    end: timeRange.end( length )
                });
            }
            return array;
        }

        function getExt( filename ) {
            return filename.split('.').pop();
        }
        
        function addSource( sound, src ) {
            var source = document.createElement( 'source' );
            source.src = src;
            if ( buzz.types[ getExt( src ) ] ) {
                source.type = buzz.types[ getExt( src ) ];
            }
            sound.appendChild( source );
        }

        // init
        if ( supported && src ) {
          
            for(var i in buzz.defaults ) {
              if(buzz.defaults.hasOwnProperty(i)) {
                options[ i ] = options[ i ] || buzz.defaults[ i ];
              }
            }

            this.sound = document.createElement( 'audio' );

            if ( src instanceof Array ) {
                for( var j in src ) {
                  if(src.hasOwnProperty(j)) {
                    addSource( this.sound, src[ j ] );
                  }
                }
            } else if ( options.formats.length ) {
                for( var k in options.formats ) {
                  if(options.formats.hasOwnProperty(k)) {
                    addSource( this.sound, src + '.' + options.formats[ k ] );
                  }
                }
            } else {
                addSource( this.sound, src );
            }

            if ( options.loop ) {
                this.loop();
            }

            if ( options.autoplay ) {
                this.sound.autoplay = 'autoplay';
            }

            if ( options.preload === true ) {
                this.sound.preload = 'auto';
            } else if ( options.preload === false ) {
                this.sound.preload = 'none';
            } else {
                this.sound.preload = options.preload;
            }

            this.setVolume( options.volume );

            buzz.sounds.push( this );
        }
    },

    group: function( sounds ) {
        sounds = argsToArray( sounds, arguments );

        // publics
        this.getSounds = function() {
            return sounds;
        };

        this.add = function( soundArray ) {
            soundArray = argsToArray( soundArray, arguments );
            for( var a = 0; a < soundArray.length; a++ ) {
                sounds.push( soundArray[ a ] );
            }
        };

        this.remove = function( soundArray ) {
            soundArray = argsToArray( soundArray, arguments );
            for( var a = 0; a < soundArray.length; a++ ) {
                for( var i = 0; i < sounds.length; i++ ) {
                    if ( sounds[ i ] == soundArray[ a ] ) {
                        sounds.splice(i, 1);
                        break;
                    }
                }
            }
        };

        this.load = function() {
            fn( 'load' );
            return this;
        };

        this.play = function() {
            fn( 'play' );
            return this;
        };

        this.togglePlay = function( ) {
            fn( 'togglePlay' );
            return this;
        };

        this.pause = function( time ) {
            fn( 'pause', time );
            return this;
        };

        this.stop = function() {
            fn( 'stop' );
            return this;
        };

        this.mute = function() {
            fn( 'mute' );
            return this;
        };

        this.unmute = function() {
            fn( 'unmute' );
            return this;
        };

        this.toggleMute = function() {
            fn( 'toggleMute' );
            return this;
        };

        this.setVolume = function( volume ) {
            fn( 'setVolume', volume );
            return this;
        };

        this.increaseVolume = function( value ) {
            fn( 'increaseVolume', value );
            return this;
        };

        this.decreaseVolume = function( value ) {
            fn( 'decreaseVolume', value );
            return this;
        };

        this.loop = function() {
            fn( 'loop' );
            return this;
        };

        this.unloop = function() {
            fn( 'unloop' );
            return this;
        };

        this.setTime = function( time ) {
            fn( 'setTime', time );
            return this;
        };

        this.set = function( key, value ) {
            fn( 'set', key, value );
            return this;
        };

        this.bind = function( type, func ) {
            fn( 'bind', type, func );
            return this;
        };

        this.unbind = function( type ) {
            fn( 'unbind', type );
            return this;
        };

        this.bindOnce = function( type, func ) {
            fn( 'bindOnce', type, func );
            return this;
        };

        this.trigger = function( type ) {
            fn( 'trigger', type );
            return this;
        };

        this.fade = function( from, to, duration, callback ) {
            fn( 'fade', from, to, duration, callback );
            return this;
        };

        this.fadeIn = function( duration, callback ) {
            fn( 'fadeIn', duration, callback );
            return this;
        };

        this.fadeOut = function( duration, callback ) {
            fn( 'fadeOut', duration, callback );
            return this;
        };

        // privates
        function fn() {
            var args = argsToArray( null, arguments ),
                func = args.shift();

            for( var i = 0; i < sounds.length; i++ ) {
                sounds[ i ][ func ].apply( sounds[ i ], args );
            }
        }

        function argsToArray( array, args ) {
            return ( array instanceof Array ) ? array : Array.prototype.slice.call( args );
        }
    },

    all: function() {
      return new buzz.group( buzz.sounds );
    },

    isSupported: function() {
        return !!buzz.el.canPlayType;
    },

    isOGGSupported: function() {
        return !!buzz.el.canPlayType && buzz.el.canPlayType( 'audio/ogg; codecs="vorbis"' );
    },

    isWAVSupported: function() {
        return !!buzz.el.canPlayType && buzz.el.canPlayType( 'audio/wav; codecs="1"' );
    },

    isMP3Supported: function() {
        return !!buzz.el.canPlayType && buzz.el.canPlayType( 'audio/mpeg;' );
    },

    isAACSupported: function() {
        return !!buzz.el.canPlayType && ( buzz.el.canPlayType( 'audio/x-m4a;' ) || buzz.el.canPlayType( 'audio/aac;' ) );
    },

    toTimer: function( time, withHours ) {
        var h, m, s;
        h = Math.floor( time / 3600 );
        h = isNaN( h ) ? '--' : ( h >= 10 ) ? h : '0' + h;
        m = withHours ? Math.floor( time / 60 % 60 ) : Math.floor( time / 60 );
        m = isNaN( m ) ? '--' : ( m >= 10 ) ? m : '0' + m;
        s = Math.floor( time % 60 );
        s = isNaN( s ) ? '--' : ( s >= 10 ) ? s : '0' + s;
        return withHours ? h + ':' + m + ':' + s : m + ':' + s;
    },

    fromTimer: function( time ) {
        var splits = time.toString().split( ':' );
        if ( splits && splits.length == 3 ) {
            time = ( parseInt( splits[ 0 ], 10 ) * 3600 ) + ( parseInt(splits[ 1 ], 10 ) * 60 ) + parseInt( splits[ 2 ], 10 );
        }
        if ( splits && splits.length == 2 ) {
            time = ( parseInt( splits[ 0 ], 10 ) * 60 ) + parseInt( splits[ 1 ], 10 );
        }
        return time;
    },

    toPercent: function( value, total, decimal ) {
		var r = Math.pow( 10, decimal || 0 );

		return Math.round( ( ( value * 100 ) / total ) * r ) / r;
    },

    fromPercent: function( percent, total, decimal ) {
		var r = Math.pow( 10, decimal || 0 );

        return  Math.round( ( ( total / 100 ) * percent ) * r ) / r;
    }
};
/*! Hammer.JS - v1.0.5 - 2013-04-07
 * http://eightmedia.github.com/hammer.js
 *
 * Copyright (c) 2013 Jorik Tangelder <j.tangelder@gmail.com>;
 * Licensed under the MIT license */

(function(window, undefined) {
    'use strict';

/**
 * Hammer
 * use this to create instances
 * @param   {HTMLElement}   element
 * @param   {Object}        options
 * @returns {Hammer.Instance}
 * @constructor
 */
var Hammer = function(element, options) {
    return new Hammer.Instance(element, options || {});
};

// default settings
Hammer.defaults = {
    // add styles and attributes to the element to prevent the browser from doing
    // its native behavior. this doesnt prevent the scrolling, but cancels
    // the contextmenu, tap highlighting etc
    // set to false to disable this
    stop_browser_behavior: {
		// this also triggers onselectstart=false for IE
        userSelect: 'none',
		// this makes the element blocking in IE10 >, you could experiment with the value
		// see for more options this issue; https://github.com/EightMedia/hammer.js/issues/241
        touchAction: 'none',
		touchCallout: 'none',
        contentZooming: 'none',
        userDrag: 'none',
        tapHighlightColor: 'rgba(0,0,0,0)'
    }

    // more settings are defined per gesture at gestures.js
};

// detect touchevents
Hammer.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;
Hammer.HAS_TOUCHEVENTS = ('ontouchstart' in window);

// dont use mouseevents on mobile devices
Hammer.MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
Hammer.NO_MOUSEEVENTS = Hammer.HAS_TOUCHEVENTS && navigator.userAgent.match(Hammer.MOBILE_REGEX);

// eventtypes per touchevent (start, move, end)
// are filled by Hammer.event.determineEventTypes on setup
Hammer.EVENT_TYPES = {};

// direction defines
Hammer.DIRECTION_DOWN = 'down';
Hammer.DIRECTION_LEFT = 'left';
Hammer.DIRECTION_UP = 'up';
Hammer.DIRECTION_RIGHT = 'right';

// pointer type
Hammer.POINTER_MOUSE = 'mouse';
Hammer.POINTER_TOUCH = 'touch';
Hammer.POINTER_PEN = 'pen';

// touch event defines
Hammer.EVENT_START = 'start';
Hammer.EVENT_MOVE = 'move';
Hammer.EVENT_END = 'end';

// hammer document where the base events are added at
Hammer.DOCUMENT = document;

// plugins namespace
Hammer.plugins = {};

// if the window events are set...
Hammer.READY = false;

/**
 * setup events to detect gestures on the document
 */
function setup() {
    if(Hammer.READY) {
        return;
    }

    // find what eventtypes we add listeners to
    Hammer.event.determineEventTypes();

    // Register all gestures inside Hammer.gestures
    for(var name in Hammer.gestures) {
        if(Hammer.gestures.hasOwnProperty(name)) {
            Hammer.detection.register(Hammer.gestures[name]);
        }
    }

    // Add touch events on the document
    Hammer.event.onTouch(Hammer.DOCUMENT, Hammer.EVENT_MOVE, Hammer.detection.detect);
    Hammer.event.onTouch(Hammer.DOCUMENT, Hammer.EVENT_END, Hammer.detection.detect);

    // Hammer is ready...!
    Hammer.READY = true;
}

/**
 * create new hammer instance
 * all methods should return the instance itself, so it is chainable.
 * @param   {HTMLElement}       element
 * @param   {Object}            [options={}]
 * @returns {Hammer.Instance}
 * @constructor
 */
Hammer.Instance = function(element, options) {
    var self = this;

    // setup HammerJS window events and register all gestures
    // this also sets up the default options
    setup();

    this.element = element;

    // start/stop detection option
    this.enabled = true;

    // merge options
    this.options = Hammer.utils.extend(
        Hammer.utils.extend({}, Hammer.defaults),
        options || {});

    // add some css to the element to prevent the browser from doing its native behavoir
    if(this.options.stop_browser_behavior) {
        Hammer.utils.stopDefaultBrowserBehavior(this.element, this.options.stop_browser_behavior);
    }

    // start detection on touchstart
    Hammer.event.onTouch(element, Hammer.EVENT_START, function(ev) {
        if(self.enabled) {
            Hammer.detection.startDetect(self, ev);
        }
    });

    // return instance
    return this;
};


Hammer.Instance.prototype = {
    /**
     * bind events to the instance
     * @param   {String}      gesture
     * @param   {Function}    handler
     * @returns {Hammer.Instance}
     */
    on: function onEvent(gesture, handler){
        var gestures = gesture.split(' ');
        for(var t=0; t<gestures.length; t++) {
            this.element.addEventListener(gestures[t], handler, false);
        }
        return this;
    },


    /**
     * unbind events to the instance
     * @param   {String}      gesture
     * @param   {Function}    handler
     * @returns {Hammer.Instance}
     */
    off: function offEvent(gesture, handler){
        var gestures = gesture.split(' ');
        for(var t=0; t<gestures.length; t++) {
            this.element.removeEventListener(gestures[t], handler, false);
        }
        return this;
    },


    /**
     * trigger gesture event
     * @param   {String}      gesture
     * @param   {Object}      eventData
     * @returns {Hammer.Instance}
     */
    trigger: function triggerEvent(gesture, eventData){
        // create DOM event
        var event = Hammer.DOCUMENT.createEvent('Event');
		event.initEvent(gesture, true, true);
		event.gesture = eventData;

        // trigger on the target if it is in the instance element,
        // this is for event delegation tricks
        var element = this.element;
        if(Hammer.utils.hasParent(eventData.target, element)) {
            element = eventData.target;
        }

        element.dispatchEvent(event);
        return this;
    },


    /**
     * enable of disable hammer.js detection
     * @param   {Boolean}   state
     * @returns {Hammer.Instance}
     */
    enable: function enable(state) {
        this.enabled = state;
        return this;
    }
};

/**
 * this holds the last move event,
 * used to fix empty touchend issue
 * see the onTouch event for an explanation
 * @type {Object}
 */
var last_move_event = null;


/**
 * when the mouse is hold down, this is true
 * @type {Boolean}
 */
var enable_detect = false;


/**
 * when touch events have been fired, this is true
 * @type {Boolean}
 */
var touch_triggered = false;


Hammer.event = {
    /**
     * simple addEventListener
     * @param   {HTMLElement}   element
     * @param   {String}        type
     * @param   {Function}      handler
     */
    bindDom: function(element, type, handler) {
        var types = type.split(' ');
        for(var t=0; t<types.length; t++) {
            element.addEventListener(types[t], handler, false);
        }
    },


    /**
     * touch events with mouse fallback
     * @param   {HTMLElement}   element
     * @param   {String}        eventType        like Hammer.EVENT_MOVE
     * @param   {Function}      handler
     */
    onTouch: function onTouch(element, eventType, handler) {
		var self = this;

        this.bindDom(element, Hammer.EVENT_TYPES[eventType], function bindDomOnTouch(ev) {
            var sourceEventType = ev.type.toLowerCase();

            // onmouseup, but when touchend has been fired we do nothing.
            // this is for touchdevices which also fire a mouseup on touchend
            if(sourceEventType.match(/mouse/) && touch_triggered) {
                return;
            }

            // mousebutton must be down or a touch event
            else if( sourceEventType.match(/touch/) ||   // touch events are always on screen
                sourceEventType.match(/pointerdown/) || // pointerevents touch
                (sourceEventType.match(/mouse/) && ev.which === 1)   // mouse is pressed
            ){
                enable_detect = true;
            }

            // we are in a touch event, set the touch triggered bool to true,
            // this for the conflicts that may occur on ios and android
            if(sourceEventType.match(/touch|pointer/)) {
                touch_triggered = true;
            }

            // count the total touches on the screen
            var count_touches = 0;

            // when touch has been triggered in this detection session
            // and we are now handling a mouse event, we stop that to prevent conflicts
            if(enable_detect) {
                // update pointerevent
                if(Hammer.HAS_POINTEREVENTS && eventType != Hammer.EVENT_END) {
                    count_touches = Hammer.PointerEvent.updatePointer(eventType, ev);
                }
                // touch
                else if(sourceEventType.match(/touch/)) {
                    count_touches = ev.touches.length;
                }
                // mouse
                else if(!touch_triggered) {
                    count_touches = sourceEventType.match(/up/) ? 0 : 1;
                }

                // if we are in a end event, but when we remove one touch and
                // we still have enough, set eventType to move
                if(count_touches > 0 && eventType == Hammer.EVENT_END) {
                    eventType = Hammer.EVENT_MOVE;
                }
                // no touches, force the end event
                else if(!count_touches) {
                    eventType = Hammer.EVENT_END;
                }

                // because touchend has no touches, and we often want to use these in our gestures,
                // we send the last move event as our eventData in touchend
                if(!count_touches && last_move_event !== null) {
                    ev = last_move_event;
                }
                // store the last move event
                else {
                    last_move_event = ev;
                }

                // trigger the handler
                handler.call(Hammer.detection, self.collectEventData(element, eventType, ev));

                // remove pointerevent from list
                if(Hammer.HAS_POINTEREVENTS && eventType == Hammer.EVENT_END) {
                    count_touches = Hammer.PointerEvent.updatePointer(eventType, ev);
                }
            }

            //debug(sourceEventType +" "+ eventType);

            // on the end we reset everything
            if(!count_touches) {
                last_move_event = null;
                enable_detect = false;
                touch_triggered = false;
                Hammer.PointerEvent.reset();
            }
        });
    },


    /**
     * we have different events for each device/browser
     * determine what we need and set them in the Hammer.EVENT_TYPES constant
     */
    determineEventTypes: function determineEventTypes() {
        // determine the eventtype we want to set
        var types;

        // pointerEvents magic
        if(Hammer.HAS_POINTEREVENTS) {
            types = Hammer.PointerEvent.getEvents();
        }
        // on Android, iOS, blackberry, windows mobile we dont want any mouseevents
        else if(Hammer.NO_MOUSEEVENTS) {
            types = [
                'touchstart',
                'touchmove',
                'touchend touchcancel'];
        }
        // for non pointer events browsers and mixed browsers,
        // like chrome on windows8 touch laptop
        else {
            types = [
                'touchstart mousedown',
                'touchmove mousemove',
                'touchend touchcancel mouseup'];
        }

        Hammer.EVENT_TYPES[Hammer.EVENT_START]  = types[0];
        Hammer.EVENT_TYPES[Hammer.EVENT_MOVE]   = types[1];
        Hammer.EVENT_TYPES[Hammer.EVENT_END]    = types[2];
    },


    /**
     * create touchlist depending on the event
     * @param   {Object}    ev
     * @param   {String}    eventType   used by the fakemultitouch plugin
     */
    getTouchList: function getTouchList(ev/*, eventType*/) {
        // get the fake pointerEvent touchlist
        if(Hammer.HAS_POINTEREVENTS) {
            return Hammer.PointerEvent.getTouchList();
        }
        // get the touchlist
        else if(ev.touches) {
            return ev.touches;
        }
        // make fake touchlist from mouse position
        else {
            return [{
                identifier: 1,
                pageX: ev.pageX,
                pageY: ev.pageY,
                target: ev.target
            }];
        }
    },


    /**
     * collect event data for Hammer js
     * @param   {HTMLElement}   element
     * @param   {String}        eventType        like Hammer.EVENT_MOVE
     * @param   {Object}        eventData
     */
    collectEventData: function collectEventData(element, eventType, ev) {
        var touches = this.getTouchList(ev, eventType);

        // find out pointerType
        var pointerType = Hammer.POINTER_TOUCH;
        if(ev.type.match(/mouse/) || Hammer.PointerEvent.matchType(Hammer.POINTER_MOUSE, ev)) {
            pointerType = Hammer.POINTER_MOUSE;
        }

        return {
            center      : Hammer.utils.getCenter(touches),
            timeStamp   : new Date().getTime(),
            target      : ev.target,
            touches     : touches,
            eventType   : eventType,
            pointerType : pointerType,
            srcEvent    : ev,

            /**
             * prevent the browser default actions
             * mostly used to disable scrolling of the browser
             */
            preventDefault: function() {
                if(this.srcEvent.preventManipulation) {
                    this.srcEvent.preventManipulation();
                }

                if(this.srcEvent.preventDefault) {
                    this.srcEvent.preventDefault();
                }
            },

            /**
             * stop bubbling the event up to its parents
             */
            stopPropagation: function() {
                this.srcEvent.stopPropagation();
            },

            /**
             * immediately stop gesture detection
             * might be useful after a swipe was detected
             * @return {*}
             */
            stopDetect: function() {
                return Hammer.detection.stopDetect();
            }
        };
    }
};

Hammer.PointerEvent = {
    /**
     * holds all pointers
     * @type {Object}
     */
    pointers: {},

    /**
     * get a list of pointers
     * @returns {Array}     touchlist
     */
    getTouchList: function() {
        var self = this;
        var touchlist = [];

        // we can use forEach since pointerEvents only is in IE10
        Object.keys(self.pointers).sort().forEach(function(id) {
            touchlist.push(self.pointers[id]);
        });
        return touchlist;
    },

    /**
     * update the position of a pointer
     * @param   {String}   type             Hammer.EVENT_END
     * @param   {Object}   pointerEvent
     */
    updatePointer: function(type, pointerEvent) {
        if(type == Hammer.EVENT_END) {
            this.pointers = {};
        }
        else {
            pointerEvent.identifier = pointerEvent.pointerId;
            this.pointers[pointerEvent.pointerId] = pointerEvent;
        }

        return Object.keys(this.pointers).length;
    },

    /**
     * check if ev matches pointertype
     * @param   {String}        pointerType     Hammer.POINTER_MOUSE
     * @param   {PointerEvent}  ev
     */
    matchType: function(pointerType, ev) {
        if(!ev.pointerType) {
            return false;
        }

        var types = {};
        types[Hammer.POINTER_MOUSE] = (ev.pointerType == ev.MSPOINTER_TYPE_MOUSE || ev.pointerType == Hammer.POINTER_MOUSE);
        types[Hammer.POINTER_TOUCH] = (ev.pointerType == ev.MSPOINTER_TYPE_TOUCH || ev.pointerType == Hammer.POINTER_TOUCH);
        types[Hammer.POINTER_PEN] = (ev.pointerType == ev.MSPOINTER_TYPE_PEN || ev.pointerType == Hammer.POINTER_PEN);
        return types[pointerType];
    },


    /**
     * get events
     */
    getEvents: function() {
        return [
            'pointerdown MSPointerDown',
            'pointermove MSPointerMove',
            'pointerup pointercancel MSPointerUp MSPointerCancel'
        ];
    },

    /**
     * reset the list
     */
    reset: function() {
        this.pointers = {};
    }
};


Hammer.utils = {
    /**
     * extend method,
     * also used for cloning when dest is an empty object
     * @param   {Object}    dest
     * @param   {Object}    src
	 * @parm	{Boolean}	merge		do a merge
     * @returns {Object}    dest
     */
    extend: function extend(dest, src, merge) {
        for (var key in src) {
			if(dest[key] !== undefined && merge) {
				continue;
			}
            dest[key] = src[key];
        }
        return dest;
    },


    /**
     * find if a node is in the given parent
     * used for event delegation tricks
     * @param   {HTMLElement}   node
     * @param   {HTMLElement}   parent
     * @returns {boolean}       has_parent
     */
    hasParent: function(node, parent) {
        while(node){
            if(node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    },


    /**
     * get the center of all the touches
     * @param   {Array}     touches
     * @returns {Object}    center
     */
    getCenter: function getCenter(touches) {
        var valuesX = [], valuesY = [];

        for(var t= 0,len=touches.length; t<len; t++) {
            valuesX.push(touches[t].pageX);
            valuesY.push(touches[t].pageY);
        }

        return {
            pageX: ((Math.min.apply(Math, valuesX) + Math.max.apply(Math, valuesX)) / 2),
            pageY: ((Math.min.apply(Math, valuesY) + Math.max.apply(Math, valuesY)) / 2)
        };
    },


    /**
     * calculate the velocity between two points
     * @param   {Number}    delta_time
     * @param   {Number}    delta_x
     * @param   {Number}    delta_y
     * @returns {Object}    velocity
     */
    getVelocity: function getVelocity(delta_time, delta_x, delta_y) {
        return {
            x: Math.abs(delta_x / delta_time) || 0,
            y: Math.abs(delta_y / delta_time) || 0
        };
    },


    /**
     * calculate the angle between two coordinates
     * @param   {Touch}     touch1
     * @param   {Touch}     touch2
     * @returns {Number}    angle
     */
    getAngle: function getAngle(touch1, touch2) {
        var y = touch2.pageY - touch1.pageY,
            x = touch2.pageX - touch1.pageX;
        return Math.atan2(y, x) * 180 / Math.PI;
    },


    /**
     * angle to direction define
     * @param   {Touch}     touch1
     * @param   {Touch}     touch2
     * @returns {String}    direction constant, like Hammer.DIRECTION_LEFT
     */
    getDirection: function getDirection(touch1, touch2) {
        var x = Math.abs(touch1.pageX - touch2.pageX),
            y = Math.abs(touch1.pageY - touch2.pageY);

        if(x >= y) {
            return touch1.pageX - touch2.pageX > 0 ? Hammer.DIRECTION_LEFT : Hammer.DIRECTION_RIGHT;
        }
        else {
            return touch1.pageY - touch2.pageY > 0 ? Hammer.DIRECTION_UP : Hammer.DIRECTION_DOWN;
        }
    },


    /**
     * calculate the distance between two touches
     * @param   {Touch}     touch1
     * @param   {Touch}     touch2
     * @returns {Number}    distance
     */
    getDistance: function getDistance(touch1, touch2) {
        var x = touch2.pageX - touch1.pageX,
            y = touch2.pageY - touch1.pageY;
        return Math.sqrt((x*x) + (y*y));
    },


    /**
     * calculate the scale factor between two touchLists (fingers)
     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
     * @param   {Array}     start
     * @param   {Array}     end
     * @returns {Number}    scale
     */
    getScale: function getScale(start, end) {
        // need two fingers...
        if(start.length >= 2 && end.length >= 2) {
            return this.getDistance(end[0], end[1]) /
                this.getDistance(start[0], start[1]);
        }
        return 1;
    },


    /**
     * calculate the rotation degrees between two touchLists (fingers)
     * @param   {Array}     start
     * @param   {Array}     end
     * @returns {Number}    rotation
     */
    getRotation: function getRotation(start, end) {
        // need two fingers
        if(start.length >= 2 && end.length >= 2) {
            return this.getAngle(end[1], end[0]) -
                this.getAngle(start[1], start[0]);
        }
        return 0;
    },


    /**
     * boolean if the direction is vertical
     * @param    {String}    direction
     * @returns  {Boolean}   is_vertical
     */
    isVertical: function isVertical(direction) {
        return (direction == Hammer.DIRECTION_UP || direction == Hammer.DIRECTION_DOWN);
    },


    /**
     * stop browser default behavior with css props
     * @param   {HtmlElement}   element
     * @param   {Object}        css_props
     */
    stopDefaultBrowserBehavior: function stopDefaultBrowserBehavior(element, css_props) {
        var prop,
            vendors = ['webkit','khtml','moz','ms','o',''];

        if(!css_props || !element.style) {
            return;
        }

        // with css properties for modern browsers
        for(var i = 0; i < vendors.length; i++) {
            for(var p in css_props) {
                if(css_props.hasOwnProperty(p)) {
                    prop = p;

                    // vender prefix at the property
                    if(vendors[i]) {
                        prop = vendors[i] + prop.substring(0, 1).toUpperCase() + prop.substring(1);
                    }

                    // set the style
                    element.style[prop] = css_props[p];
                }
            }
        }

        // also the disable onselectstart
        if(css_props.userSelect == 'none') {
            element.onselectstart = function() {
                return false;
            };
        }
    }
};

Hammer.detection = {
    // contains all registred Hammer.gestures in the correct order
    gestures: [],

    // data of the current Hammer.gesture detection session
    current: null,

    // the previous Hammer.gesture session data
    // is a full clone of the previous gesture.current object
    previous: null,

    // when this becomes true, no gestures are fired
    stopped: false,


    /**
     * start Hammer.gesture detection
     * @param   {Hammer.Instance}   inst
     * @param   {Object}            eventData
     */
    startDetect: function startDetect(inst, eventData) {
        // already busy with a Hammer.gesture detection on an element
        if(this.current) {
            return;
        }

        this.stopped = false;

        this.current = {
            inst        : inst, // reference to HammerInstance we're working for
            startEvent  : Hammer.utils.extend({}, eventData), // start eventData for distances, timing etc
            lastEvent   : false, // last eventData
            name        : '' // current gesture we're in/detected, can be 'tap', 'hold' etc
        };

        this.detect(eventData);
    },


    /**
     * Hammer.gesture detection
     * @param   {Object}    eventData
     * @param   {Object}    eventData
     */
    detect: function detect(eventData) {
        if(!this.current || this.stopped) {
            return;
        }

        // extend event data with calculations about scale, distance etc
        eventData = this.extendEventData(eventData);

        // instance options
        var inst_options = this.current.inst.options;

        // call Hammer.gesture handlers
        for(var g=0,len=this.gestures.length; g<len; g++) {
            var gesture = this.gestures[g];

            // only when the instance options have enabled this gesture
            if(!this.stopped && inst_options[gesture.name] !== false) {
                // if a handler returns false, we stop with the detection
                if(gesture.handler.call(gesture, eventData, this.current.inst) === false) {
                    this.stopDetect();
                    break;
                }
            }
        }

        // store as previous event event
        if(this.current) {
            this.current.lastEvent = eventData;
        }

        // endevent, but not the last touch, so dont stop
        if(eventData.eventType == Hammer.EVENT_END && !eventData.touches.length-1) {
            this.stopDetect();
        }

        return eventData;
    },


    /**
     * clear the Hammer.gesture vars
     * this is called on endDetect, but can also be used when a final Hammer.gesture has been detected
     * to stop other Hammer.gestures from being fired
     */
    stopDetect: function stopDetect() {
        // clone current data to the store as the previous gesture
        // used for the double tap gesture, since this is an other gesture detect session
        this.previous = Hammer.utils.extend({}, this.current);

        // reset the current
        this.current = null;

        // stopped!
        this.stopped = true;
    },


    /**
     * extend eventData for Hammer.gestures
     * @param   {Object}   ev
     * @returns {Object}   ev
     */
    extendEventData: function extendEventData(ev) {
        var startEv = this.current.startEvent;

        // if the touches change, set the new touches over the startEvent touches
        // this because touchevents don't have all the touches on touchstart, or the
        // user must place his fingers at the EXACT same time on the screen, which is not realistic
        // but, sometimes it happens that both fingers are touching at the EXACT same time
        if(startEv && (ev.touches.length != startEv.touches.length || ev.touches === startEv.touches)) {
            // extend 1 level deep to get the touchlist with the touch objects
            startEv.touches = [];
            for(var i=0,len=ev.touches.length; i<len; i++) {
                startEv.touches.push(Hammer.utils.extend({}, ev.touches[i]));
            }
        }

        var delta_time = ev.timeStamp - startEv.timeStamp,
            delta_x = ev.center.pageX - startEv.center.pageX,
            delta_y = ev.center.pageY - startEv.center.pageY,
            velocity = Hammer.utils.getVelocity(delta_time, delta_x, delta_y);

        Hammer.utils.extend(ev, {
            deltaTime   : delta_time,

            deltaX      : delta_x,
            deltaY      : delta_y,

            velocityX   : velocity.x,
            velocityY   : velocity.y,

            distance    : Hammer.utils.getDistance(startEv.center, ev.center),
            angle       : Hammer.utils.getAngle(startEv.center, ev.center),
            direction   : Hammer.utils.getDirection(startEv.center, ev.center),

            scale       : Hammer.utils.getScale(startEv.touches, ev.touches),
            rotation    : Hammer.utils.getRotation(startEv.touches, ev.touches),

            startEvent  : startEv
        });

        return ev;
    },


    /**
     * register new gesture
     * @param   {Object}    gesture object, see gestures.js for documentation
     * @returns {Array}     gestures
     */
    register: function register(gesture) {
        // add an enable gesture options if there is no given
        var options = gesture.defaults || {};
        if(options[gesture.name] === undefined) {
            options[gesture.name] = true;
        }

        // extend Hammer default options with the Hammer.gesture options
        Hammer.utils.extend(Hammer.defaults, options, true);

        // set its index
        gesture.index = gesture.index || 1000;

        // add Hammer.gesture to the list
        this.gestures.push(gesture);

        // sort the list by index
        this.gestures.sort(function(a, b) {
            if (a.index < b.index) {
                return -1;
            }
            if (a.index > b.index) {
                return 1;
            }
            return 0;
        });

        return this.gestures;
    }
};


Hammer.gestures = Hammer.gestures || {};

/**
 * Custom gestures
 * ==============================
 *
 * Gesture object
 * --------------------
 * The object structure of a gesture:
 *
 * { name: 'mygesture',
 *   index: 1337,
 *   defaults: {
 *     mygesture_option: true
 *   }
 *   handler: function(type, ev, inst) {
 *     // trigger gesture event
 *     inst.trigger(this.name, ev);
 *   }
 * }

 * @param   {String}    name
 * this should be the name of the gesture, lowercase
 * it is also being used to disable/enable the gesture per instance config.
 *
 * @param   {Number}    [index=1000]
 * the index of the gesture, where it is going to be in the stack of gestures detection
 * like when you build an gesture that depends on the drag gesture, it is a good
 * idea to place it after the index of the drag gesture.
 *
 * @param   {Object}    [defaults={}]
 * the default settings of the gesture. these are added to the instance settings,
 * and can be overruled per instance. you can also add the name of the gesture,
 * but this is also added by default (and set to true).
 *
 * @param   {Function}  handler
 * this handles the gesture detection of your custom gesture and receives the
 * following arguments:
 *
 *      @param  {Object}    eventData
 *      event data containing the following properties:
 *          timeStamp   {Number}        time the event occurred
 *          target      {HTMLElement}   target element
 *          touches     {Array}         touches (fingers, pointers, mouse) on the screen
 *          pointerType {String}        kind of pointer that was used. matches Hammer.POINTER_MOUSE|TOUCH
 *          center      {Object}        center position of the touches. contains pageX and pageY
 *          deltaTime   {Number}        the total time of the touches in the screen
 *          deltaX      {Number}        the delta on x axis we haved moved
 *          deltaY      {Number}        the delta on y axis we haved moved
 *          velocityX   {Number}        the velocity on the x
 *          velocityY   {Number}        the velocity on y
 *          angle       {Number}        the angle we are moving
 *          direction   {String}        the direction we are moving. matches Hammer.DIRECTION_UP|DOWN|LEFT|RIGHT
 *          distance    {Number}        the distance we haved moved
 *          scale       {Number}        scaling of the touches, needs 2 touches
 *          rotation    {Number}        rotation of the touches, needs 2 touches *
 *          eventType   {String}        matches Hammer.EVENT_START|MOVE|END
 *          srcEvent    {Object}        the source event, like TouchStart or MouseDown *
 *          startEvent  {Object}        contains the same properties as above,
 *                                      but from the first touch. this is used to calculate
 *                                      distances, deltaTime, scaling etc
 *
 *      @param  {Hammer.Instance}    inst
 *      the instance we are doing the detection for. you can get the options from
 *      the inst.options object and trigger the gesture event by calling inst.trigger
 *
 *
 * Handle gestures
 * --------------------
 * inside the handler you can get/set Hammer.detection.current. This is the current
 * detection session. It has the following properties
 *      @param  {String}    name
 *      contains the name of the gesture we have detected. it has not a real function,
 *      only to check in other gestures if something is detected.
 *      like in the drag gesture we set it to 'drag' and in the swipe gesture we can
 *      check if the current gesture is 'drag' by accessing Hammer.detection.current.name
 *
 *      @readonly
 *      @param  {Hammer.Instance}    inst
 *      the instance we do the detection for
 *
 *      @readonly
 *      @param  {Object}    startEvent
 *      contains the properties of the first gesture detection in this session.
 *      Used for calculations about timing, distance, etc.
 *
 *      @readonly
 *      @param  {Object}    lastEvent
 *      contains all the properties of the last gesture detect in this session.
 *
 * after the gesture detection session has been completed (user has released the screen)
 * the Hammer.detection.current object is copied into Hammer.detection.previous,
 * this is usefull for gestures like doubletap, where you need to know if the
 * previous gesture was a tap
 *
 * options that have been set by the instance can be received by calling inst.options
 *
 * You can trigger a gesture event by calling inst.trigger("mygesture", event).
 * The first param is the name of your gesture, the second the event argument
 *
 *
 * Register gestures
 * --------------------
 * When an gesture is added to the Hammer.gestures object, it is auto registered
 * at the setup of the first Hammer instance. You can also call Hammer.detection.register
 * manually and pass your gesture object as a param
 *
 */

/**
 * Hold
 * Touch stays at the same place for x time
 * @events  hold
 */
Hammer.gestures.Hold = {
    name: 'hold',
    index: 10,
    defaults: {
        hold_timeout	: 500,
        hold_threshold	: 1
    },
    timer: null,
    handler: function holdGesture(ev, inst) {
        switch(ev.eventType) {
            case Hammer.EVENT_START:
                // clear any running timers
                clearTimeout(this.timer);

                // set the gesture so we can check in the timeout if it still is
                Hammer.detection.current.name = this.name;

                // set timer and if after the timeout it still is hold,
                // we trigger the hold event
                this.timer = setTimeout(function() {
                    if(Hammer.detection.current.name == 'hold') {
                        inst.trigger('hold', ev);
                    }
                }, inst.options.hold_timeout);
                break;

            // when you move or end we clear the timer
            case Hammer.EVENT_MOVE:
                if(ev.distance > inst.options.hold_threshold) {
                    clearTimeout(this.timer);
                }
                break;

            case Hammer.EVENT_END:
                clearTimeout(this.timer);
                break;
        }
    }
};


/**
 * Tap/DoubleTap
 * Quick touch at a place or double at the same place
 * @events  tap, doubletap
 */
Hammer.gestures.Tap = {
    name: 'tap',
    index: 100,
    defaults: {
        tap_max_touchtime	: 250,
        tap_max_distance	: 10,
		tap_always			: true,
        doubletap_distance	: 20,
        doubletap_interval	: 300
    },
    handler: function tapGesture(ev, inst) {
        if(ev.eventType == Hammer.EVENT_END) {
            // previous gesture, for the double tap since these are two different gesture detections
            var prev = Hammer.detection.previous,
				did_doubletap = false;

            // when the touchtime is higher then the max touch time
            // or when the moving distance is too much
            if(ev.deltaTime > inst.options.tap_max_touchtime ||
                ev.distance > inst.options.tap_max_distance) {
                return;
            }

            // check if double tap
            if(prev && prev.name == 'tap' &&
                (ev.timeStamp - prev.lastEvent.timeStamp) < inst.options.doubletap_interval &&
                ev.distance < inst.options.doubletap_distance) {
				inst.trigger('doubletap', ev);
				did_doubletap = true;
            }

			// do a single tap
			if(!did_doubletap || inst.options.tap_always) {
				Hammer.detection.current.name = 'tap';
				inst.trigger(Hammer.detection.current.name, ev);
			}
        }
    }
};


/**
 * Swipe
 * triggers swipe events when the end velocity is above the threshold
 * @events  swipe, swipeleft, swiperight, swipeup, swipedown
 */
Hammer.gestures.Swipe = {
    name: 'swipe',
    index: 40,
    defaults: {
        // set 0 for unlimited, but this can conflict with transform
        swipe_max_touches  : 1,
        swipe_velocity     : 0.7
    },
    handler: function swipeGesture(ev, inst) {
        if(ev.eventType == Hammer.EVENT_END) {
            // max touches
            if(inst.options.swipe_max_touches > 0 &&
                ev.touches.length > inst.options.swipe_max_touches) {
                return;
            }

            // when the distance we moved is too small we skip this gesture
            // or we can be already in dragging
            if(ev.velocityX > inst.options.swipe_velocity ||
                ev.velocityY > inst.options.swipe_velocity) {
                // trigger swipe events
                inst.trigger(this.name, ev);
                inst.trigger(this.name + ev.direction, ev);
            }
        }
    }
};


/**
 * Drag
 * Move with x fingers (default 1) around on the page. Blocking the scrolling when
 * moving left and right is a good practice. When all the drag events are blocking
 * you disable scrolling on that area.
 * @events  drag, drapleft, dragright, dragup, dragdown
 */
Hammer.gestures.Drag = {
    name: 'drag',
    index: 50,
    defaults: {
        drag_min_distance : 10,
        // set 0 for unlimited, but this can conflict with transform
        drag_max_touches  : 1,
        // prevent default browser behavior when dragging occurs
        // be careful with it, it makes the element a blocking element
        // when you are using the drag gesture, it is a good practice to set this true
        drag_block_horizontal   : false,
        drag_block_vertical     : false,
        // drag_lock_to_axis keeps the drag gesture on the axis that it started on,
        // It disallows vertical directions if the initial direction was horizontal, and vice versa.
        drag_lock_to_axis       : false,
        // drag lock only kicks in when distance > drag_lock_min_distance
        // This way, locking occurs only when the distance has become large enough to reliably determine the direction
        drag_lock_min_distance : 25
    },
    triggered: false,
    handler: function dragGesture(ev, inst) {
        // current gesture isnt drag, but dragged is true
        // this means an other gesture is busy. now call dragend
        if(Hammer.detection.current.name != this.name && this.triggered) {
            inst.trigger(this.name +'end', ev);
            this.triggered = false;
            return;
        }

        // max touches
        if(inst.options.drag_max_touches > 0 &&
            ev.touches.length > inst.options.drag_max_touches) {
            return;
        }

        switch(ev.eventType) {
            case Hammer.EVENT_START:
                this.triggered = false;
                break;

            case Hammer.EVENT_MOVE:
                // when the distance we moved is too small we skip this gesture
                // or we can be already in dragging
                if(ev.distance < inst.options.drag_min_distance &&
                    Hammer.detection.current.name != this.name) {
                    return;
                }

                // we are dragging!
                Hammer.detection.current.name = this.name;

                // lock drag to axis?
                if(Hammer.detection.current.lastEvent.drag_locked_to_axis || (inst.options.drag_lock_to_axis && inst.options.drag_lock_min_distance<=ev.distance)) {
                    ev.drag_locked_to_axis = true;
                }
                var last_direction = Hammer.detection.current.lastEvent.direction;
                if(ev.drag_locked_to_axis && last_direction !== ev.direction) {
                    // keep direction on the axis that the drag gesture started on
                    if(Hammer.utils.isVertical(last_direction)) {
                        ev.direction = (ev.deltaY < 0) ? Hammer.DIRECTION_UP : Hammer.DIRECTION_DOWN;
                    }
                    else {
                        ev.direction = (ev.deltaX < 0) ? Hammer.DIRECTION_LEFT : Hammer.DIRECTION_RIGHT;
                    }
                }

                // first time, trigger dragstart event
                if(!this.triggered) {
                    inst.trigger(this.name +'start', ev);
                    this.triggered = true;
                }

                // trigger normal event
                inst.trigger(this.name, ev);

                // direction event, like dragdown
                inst.trigger(this.name + ev.direction, ev);

                // block the browser events
                if( (inst.options.drag_block_vertical && Hammer.utils.isVertical(ev.direction)) ||
                    (inst.options.drag_block_horizontal && !Hammer.utils.isVertical(ev.direction))) {
                    ev.preventDefault();
                }
                break;

            case Hammer.EVENT_END:
                // trigger dragend
                if(this.triggered) {
                    inst.trigger(this.name +'end', ev);
                }

                this.triggered = false;
                break;
        }
    }
};


/**
 * Transform
 * User want to scale or rotate with 2 fingers
 * @events  transform, pinch, pinchin, pinchout, rotate
 */
Hammer.gestures.Transform = {
    name: 'transform',
    index: 45,
    defaults: {
        // factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1
        transform_min_scale     : 0.01,
        // rotation in degrees
        transform_min_rotation  : 1,
        // prevent default browser behavior when two touches are on the screen
        // but it makes the element a blocking element
        // when you are using the transform gesture, it is a good practice to set this true
        transform_always_block  : false
    },
    triggered: false,
    handler: function transformGesture(ev, inst) {
        // current gesture isnt drag, but dragged is true
        // this means an other gesture is busy. now call dragend
        if(Hammer.detection.current.name != this.name && this.triggered) {
            inst.trigger(this.name +'end', ev);
            this.triggered = false;
            return;
        }

        // atleast multitouch
        if(ev.touches.length < 2) {
            return;
        }

        // prevent default when two fingers are on the screen
        if(inst.options.transform_always_block) {
            ev.preventDefault();
        }

        switch(ev.eventType) {
            case Hammer.EVENT_START:
                this.triggered = false;
                break;

            case Hammer.EVENT_MOVE:
                var scale_threshold = Math.abs(1-ev.scale);
                var rotation_threshold = Math.abs(ev.rotation);

                // when the distance we moved is too small we skip this gesture
                // or we can be already in dragging
                if(scale_threshold < inst.options.transform_min_scale &&
                    rotation_threshold < inst.options.transform_min_rotation) {
                    return;
                }

                // we are transforming!
                Hammer.detection.current.name = this.name;

                // first time, trigger dragstart event
                if(!this.triggered) {
                    inst.trigger(this.name +'start', ev);
                    this.triggered = true;
                }

                inst.trigger(this.name, ev); // basic transform event

                // trigger rotate event
                if(rotation_threshold > inst.options.transform_min_rotation) {
                    inst.trigger('rotate', ev);
                }

                // trigger pinch event
                if(scale_threshold > inst.options.transform_min_scale) {
                    inst.trigger('pinch', ev);
                    inst.trigger('pinch'+ ((ev.scale < 1) ? 'in' : 'out'), ev);
                }
                break;

            case Hammer.EVENT_END:
                // trigger dragend
                if(this.triggered) {
                    inst.trigger(this.name +'end', ev);
                }

                this.triggered = false;
                break;
        }
    }
};


/**
 * Touch
 * Called as first, tells the user has touched the screen
 * @events  touch
 */
Hammer.gestures.Touch = {
    name: 'touch',
    index: -Infinity,
    defaults: {
        // call preventDefault at touchstart, and makes the element blocking by
        // disabling the scrolling of the page, but it improves gestures like
        // transforming and dragging.
        // be careful with using this, it can be very annoying for users to be stuck
        // on the page
        prevent_default: false,

        // disable mouse events, so only touch (or pen!) input triggers events
        prevent_mouseevents: false
    },
    handler: function touchGesture(ev, inst) {
        if(inst.options.prevent_mouseevents && ev.pointerType == Hammer.POINTER_MOUSE) {
            ev.stopDetect();
            return;
        }

        if(inst.options.prevent_default) {
            ev.preventDefault();
        }

        if(ev.eventType ==  Hammer.EVENT_START) {
            inst.trigger(this.name, ev);
        }
    }
};


/**
 * Release
 * Called as last, tells the user has released the screen
 * @events  release
 */
Hammer.gestures.Release = {
    name: 'release',
    index: Infinity,
    handler: function releaseGesture(ev, inst) {
        if(ev.eventType ==  Hammer.EVENT_END) {
            inst.trigger(this.name, ev);
        }
    }
};

// node export
if(typeof module === 'object' && typeof module.exports === 'object'){
    module.exports = Hammer;
}
// just window export
else {
    window.Hammer = Hammer;

    // requireJS module definition
    if(typeof window.define === 'function' && window.define.amd) {
        window.define('hammer', [], function() {
            return Hammer;
        });
    }
}
})(this);// stats.js - http://github.com/mrdoob/stats.js
var Stats=function(){var l=Date.now(),m=l,g=0,n=Infinity,o=0,h=0,p=Infinity,q=0,r=0,s=0,f=document.createElement("div");f.id="stats";f.addEventListener("mousedown",function(b){b.preventDefault();t(++s%2)},!1);f.style.cssText="width:80px;opacity:0.9;cursor:pointer";var a=document.createElement("div");a.id="fps";a.style.cssText="padding:0 0 3px 3px;text-align:left;background-color:#002";f.appendChild(a);var i=document.createElement("div");i.id="fpsText";i.style.cssText="color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px";
i.innerHTML="FPS";a.appendChild(i);var c=document.createElement("div");c.id="fpsGraph";c.style.cssText="position:relative;width:74px;height:30px;background-color:#0ff";for(a.appendChild(c);74>c.children.length;){var j=document.createElement("span");j.style.cssText="width:1px;height:30px;float:left;background-color:#113";c.appendChild(j)}var d=document.createElement("div");d.id="ms";d.style.cssText="padding:0 0 3px 3px;text-align:left;background-color:#020;display:none";f.appendChild(d);var k=document.createElement("div");
k.id="msText";k.style.cssText="color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px";k.innerHTML="MS";d.appendChild(k);var e=document.createElement("div");e.id="msGraph";e.style.cssText="position:relative;width:74px;height:30px;background-color:#0f0";for(d.appendChild(e);74>e.children.length;)j=document.createElement("span"),j.style.cssText="width:1px;height:30px;float:left;background-color:#131",e.appendChild(j);var t=function(b){s=b;switch(s){case 0:a.style.display=
"block";d.style.display="none";break;case 1:a.style.display="none",d.style.display="block"}};return{REVISION:11,domElement:f,setMode:t,begin:function(){l=Date.now()},end:function(){var b=Date.now();g=b-l;n=Math.min(n,g);o=Math.max(o,g);k.textContent=g+" MS ("+n+"-"+o+")";var a=Math.min(30,30-30*(g/200));e.appendChild(e.firstChild).style.height=a+"px";r++;b>m+1E3&&(h=Math.round(1E3*r/(b-m)),p=Math.min(p,h),q=Math.max(q,h),i.textContent=h+" FPS ("+p+"-"+q+")",a=Math.min(30,30-30*(h/100)),c.appendChild(c.firstChild).style.height=
a+"px",m=b,r=0);return b},update:function(){l=this.end()}}};
